<title>DbQuery</title>

<div id=wikitoc>

<ul>
<li>[#overview|Overview]</li>
<ul>
<li>[#capi|Traditional Sqlite-C]</li>
<li>[#dbquery|The DbQuery Approach]</li>
<li>[#usingit|Usage]</li>
</ul>
<li>[#details|A Detailed Example]</li>
<li>[#tables|Tables]</li>
<ul>
<li>[#singlestruct|Single Struct]</li>
<li>[#arraystructs|3Arrays of Structs]</li>
<ul>
<li>[#staticarrays|Static Arrays]</li>
<li>[#staticptrs|Static Array of Pointers]</li>
<li>[#dynarray|Dynamic Array of Pointers]</li>
</ul>
<li>[#funcwrap|Function Wrappers]</li>
<li>[#multibind|Multi-Struct Bind]</li>
</ul>
<li>[#specfields|Spec Fields]</li>
<ul>
<li>[#supporttypes|Supported Types]</li>
<li>[#custom|Custom]</li>
<ul>
<li>[#custenum|Custom Enum]</li>
<li>[#custbit|Custom Bitset]</li>
</ul>
<li>[#fieldcolmap|Field/Column Mapping]</li>
<li>[#nullvalues|NULL Values]</li>
<li>[#dirtyfields|Dirty Field]</li>
<li>[#rowidfield|Rowid Field]</li>
</ul>
<li>[#javascript|Javascript]</li>
<ul>
<li>[#jsinit|Javascript Initialization]</li>
<li>[#cdata|The "Cdata" Command]</li>
<li>[#cdataquery|Queries With "Cdata"]</li>
<li>[#schemagen|Schema Generation]</li>
<li>[#schemacheck|Schema Checking]</li>
<li>[#config|Configuration]</li>
</ul>
<li>[#perf|Performance]</li>
<li>[#misc|Miscellaneous]</li>
<ul>
<li>[#begincommit|BEGIN/COMMIT]</li>
<li>[#errhandle|Error Handling]</li>
</ul>
<li>[#references|References]</li>
</ul>

</div>
  
<h2 id=overview>Overview</h2>

<b>DbQuery</b> is a query engine for loading and storing Sqlite data into C structs that:

  *  provides a high level of data type matching.
  *  is fast due to the compiled statement cache.
  *  reduces the amount of C-code required.
 
DbQuery provides the following features:

  *  Handles the following queries: <b>SELECT, INSERT, UPDATE, REPLACE, DELETE</b>
  *  Bindings using struct field <i>names</i>.
  *  Auto-generates list of bind-names via <b>"%s"</b>.
  *  Support for arrays (of structs).
  *  Establishes a <i>1-to-1</i> array/row mapping (via a <b>rowid</b> field).
  *  Stores modified-only array elements (via a <b>dirty</b> field).
  *  Very minimal use of the heap.
  *  Highly efficient string handling.
  *  A compiled statement cache (LRU).
  *  Cache bypass: queries starting with <b>";"</b> are passed directly to sqlite3_exec().
  *  And in case you need it, optional Javascript support.

And even if your application doesn't need it, the javascript support can be quite useful for testing.

<hr>

<h3 id=capi>Traditional Sqlite-C</h3>

The standard Sqlite C-API is both quick to learn and easy to use.
With it an application programmer simply moves data between a
database and program memory using two groups of functions:

  *  <b>sqlite3_bind_*()</b>
  *  <b>sqlite3_column_*()</b>

These are applied as in the following example:

    <nowiki><pre class=verbatim>
stmt = <b>sqlite3_prepare</b>(db, <i>"SELECT a,b FROM mytbl WHERE a=?1 AND b=?2",</i> ...)
<b>sqlite_bind_int</b>(stmt, 1, mydata.b);
<em>//...</em>
<b>sqlite3_step</b>(stmt);
mydata.a = <b>sqlite3_column_int</b>(stmt, 2);
</pre></nowiki>

While this approach is very manageable for small tables,
as database complexity increases code validation becomes challenging because:

  #  There is no simple <i>programmatic</i> way to enforce bind/column indexes will match a query.
  #  Type matches (between database and C variables) can easily occur.
  #  It is easy to mishandle a return code from one or more Sqlite functions.
  #  Generally the complexity of code will increase proportionly with the number of tables/columns/queries.

In the real world it is not unusual to manage tables with 20+ columns:

    <nowiki><pre class=verbatim>
stmt = <b>sqlite3_prepare</b>(db, <i>"INSERT INTO mytbl VALUES(?1,?2,?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?15,?16,?17,?18,?19,?20);"</i>);
</pre></nowiki>

<hr>

<h3 id=dbquery>The DbQuery Approach</h3>

The <b>Jsi_DbQuery()</b> function uses an abstraction layer based on the use of a <b>spec</b>:

    <nowiki><pre class=verbatim>
<b>static Jsi_OptionSpec</b> MyOptions[] = {
    <b>JSI_OPT(INT</b>,        MyData, id,     .help=<i>"Int id"</i>, <b>.userData</b>=<i>"DEFAULT 0 CHECK(id>0)"</i>),
    <b>JSI_OPT(DOUBLE</b>,     MyData, max,    .help=<i>"Max value"</i>),
    ...
    }
</pre></nowiki>

This spec describes a struct:

    <nowiki><pre class=verbatim>
typedef struct { int id; double max; ... };
</pre></nowiki>

And together these are supplied as inputs to the engine:

    <nowiki><pre class=verbatim>
int <b>Jsi_DbQuery</b>(Jsi_Db *jdb, Jsi_OptionSpec *spec, void *data, int numData, const char *query, int flags);
</pre></nowiki>

<b>Jsi_DbQuery()</b> compiles,
binds, executes and retrieve results for queries and in a single statement, transferring data to/from C structs:

    <nowiki><pre class=verbatim>
<b>Jsi_DbQuery</b>(jdb, spec, &mydata, 1, <i>"SELECT %s FROM mytbl WHERE id = :id"</i>, 0)
<b>Jsi_DbQuery</b>(jdb, spec, &mydata, 1, <i>"INSERT INTO mytbl %s"</i>, 0)
</pre></nowiki>

<hr>

<h3 id=usingit>Usage</h3>

Incorporating <b>DbQuery</b> into your application is quite simple: [./aquickstart.wiki|Download] Jsi, and then:

    <nowiki><pre class=verbatim>
#define HAVE_SQLITE 1
#include <sqlite3.h>
#include "jsi.c"

int main(int argc, char *argv) {
 // Start using it
  Jsi_DbQuery( ... );
  
}
</pre></nowiki>

For a simple but complete <b>DbQuery</b> example see the [../c-demos/litedemo.c|Jsi-Lite demo].

A complete working example is available here: [../c-demos/dbdemo.c]</i>.

<hr>
<h2 id=details>A Detailed Example</h2>

Given the following database-table:

    <nowiki><pre class=verbatim>
<b>CREATE TABLE</b> mytable (
    name,
    id <b>INT</b>,
    max <b>FLOAT</b>,
    myTime <b>TIMEINT</b>,
    mark,
    markSet,
    desc
);
</pre></nowiki>

and a corresponding struct definition:
    
    <nowiki><pre class=verbatim>
<b>typedef struct</b> {
    <b>char</b> name[16];
    <b>int</b> id;
    <b>double</b> max;
    <b>int64</b> myTime;
    <b>int</b> mark;
    <b>int</b> markSet;
    <b>Jsi_DString</b> desc;
    <b>int64</b> rowid;
    <b>char</b> dirty;
} MyData;
</pre></nowiki>

Define a descriptor array of type [./c-options.wiki|Jsi_OptionSpec]:

    <nowiki><pre class=verbatim>
<b>static const char</b> *markStrs[] = {<i>""</i>,<i>"A"</i>,<i>"B"</i>,<i>"C"</i>,<i>"D"</i>,<i>"F"</i>,NULL};

<b>static Jsi_OptionSpec</b> MyOptions[] = {
    <b>JSI_OPT(STRBUF</b>,     MyData, name,   .help=<i>"Fixed size char buf"</i>, <b>.userData</b>=<i>"DEFAULT ''"</i> ),
    <b>JSI_OPT(DSTRING</b>,    MyData, desc,   .help=<i>"Description field of arbitrary length"</i>),
    <b>JSI_OPT(INT</b>,        MyData, id,     .help=<i>"Int id"</i>, <b>.userData</b>=<i>"DEFAULT 0 CHECK(id>0)"</i>),
    <b>JSI_OPT(DOUBLE</b>,     MyData, max,    .help=<i>"Max value"</i>),
    <b>JSI_OPT(DATETIME</b>,   MyData, myTime, .help=<i>"A unix/javascript time field in milliseconds (64 bits)"</i>, <b>.userData</b>=<i>"DEFAULT"</i> ),
    <b>JSI_OPT(CUSTOM</b>,     MyData, mark,   .help=<i>"Marks"</i>, .custom=<b>Jsi_Opt_SwitchEnum</b>,   <b>.data</b>=markStrs ),
    <b>JSI_OPT(CUSTOM</b>,     MyData, markSet,.help=<i>"A set"</i>, .custom=<b>Jsi_Opt_SwitchBitset</b>, <b>.data</b>=markStrs ),
    <b>JSI_OPT(WIDE</b>,       MyData, rowid,  .help=<i>"DB rowid for update/insert; not stored in db"</i>, .flags=<b>JSI_OPT_DB_ROWID</b>),
    <b>JSI_OPT(BOOL</b>,       MyData, isdirty,.help=<i>"Dirty flag: not stored in db"</i>, .flags=<b>JSI_OPT_DB_DIRTY</b>),
    <b>JSI_OPT_END</b>(        MyData, .help=<i>"This is a struct for dbdemo"</i>)
};
</pre></nowiki>

Which we can then use to store/load data by calling <b>Jsi_DbQuery()</b>:

    <nowiki><pre class=verbatim>
<b>Jsi_Db</b> *jdb = <b>Jsi_DbNew</b>(<i>"~/mytables.db"</i>, 0);
MyData d = {<i>"myname"</i>, 99, 9.0};
<b>Jsi_DbQuery</b>(jdb, MyOptions, &d, 1, <i>"INSERT INTO mytable %s"</i>, 0);
<b>Jsi_DbQuery</b>(jdb, MyOptions, &d, 1, <i>"SELECT %s FROM mytable"</i>, 0);
<b>Jsi_DbQuery</b>(jdb, MyOptions, &d, 1, <i>"UPDATE mytable SET %s"</i>, 0);
<b>Jsi_DbQuery</b>(jdb, MyOptions, &d, 1, <i>"SELECT id,name FROM mytable WHERE rowid=:rowid"</i>, 0);
</pre></nowiki>

The return value is either the number of rows loaded, modified or stored, or:

  *  <b>-1</b> if an error occurs.
  *  <b>-2</b> if the database was locked.

Ideally, a function wrapper is used to improve readability and type-checking:

    <nowiki><pre class=verbatim>
int db_MyData(MyData *data, const char *query) {
    return <b>Jsi_DbQuery</b>(jdb, MyOptions, data, 1, query, 0);
}

db_MyData(&d, <i>"INSERT INTO mytable %s"</i>)
db_MyData(&d, <i>"UPDATE mytable SET %s"</i>)
</pre></nowiki>

<hr>
<h2 id=tables>Tables</h2>

The above example operated on a single row.
Multiple rows of data can be handled in a couple of ways.

<h3 id=singlestruct>Single Struct</h3>

The brute-force way to process a table of data is to iterate over a single struct:

    <nowiki><pre class=verbatim>
MyData mydata = {.id=99, .max=100.0, .mark=MARK_A, .markSet=6};
mydata.myTime = time(NULL)*1000LL;
strcpy(mydata.name, <i>"maryjane"</i>);
<b>Jsi_DSSet</b>(&mydata.desc, <i>"Some stuff"</i>);

<b>Jsi_DbQuery</b>(jdb, 0, 0, 0, <i>";BEGIN"</i>, 0);
for (i=0, n=1; i<10 && n==1; i++) {
    mydata.id++;
    mydata.max--;
    n = <b>Jsi_DbQuery</b>(jdb, MyOptions, &mydata, 1, <i>"INSERT INTO mytable %s"</i>, 0);
}
<b>Jsi_DbQuery</b>(jdb, 0, 0, 0, <i>";COMMIT"</i>, 0);
</pre></nowiki>

While this works, it requires more C-code than necessary. 

<h3 id=arraystructs>3Arrays of Structs</h3>

A simpler way to process a table is via an array of structs, with a single call.
Three forms of array are supported: 

<h4 id=staticarrays>Static Arrays</h4>

A <b>static array</b> has all storage pre-allocated by the user:

    <nowiki><pre class=verbatim>
MyData mydatas[10];
int cnt = <b>Jsi_DbQuery</b>(jdb, MyOptions, mydatas, 10, <i>"SELECT %s FROM mytable"</i>, 0);

for (i=0; i<cnt; i++)
    mydatas[i].id += i;
n = <b>Jsi_DbQuery</b>(jdb, MyOptions, mydatas, cnt, <i>"UPDATE mytable SET %s WHERE rowid = :rowid"</i>, 0);
</pre></nowiki>

This example simply uses:
  *  SELECT to load up to 10 rows into the array.
  *  UPDATE to iteratively stores the rows after modification.
  
Note that a <b>BEGIN/COMMIT</b> is implicitly performed for updates and inserts.


<h4 id=staticptrs>Static Array of Pointers</h4>

To use an array of pointers we pass
the <b>JSI_DB_PTRS</b> flag. 

    <nowiki><pre class=verbatim>
static MyData *mdPtr[10] = {};
n = <b>Jsi_DbQuery</b>(jdb, MyOptions, mdPtr, 10, <i>"SELECT %s FROM mytable"</i>, <b>JSI_DB_PTRS</b>);
</pre></nowiki>

In this mode, memory is allocated on demand (up to the maximum size).

Note the data argument is now an array of pointers to structs (<b>void **</b>).

<h4 id=dynarray>Dynamic Array of Pointers</h4>

For fully dynamic allocation, both of the array and the struct pointers,
we pass the <b>JSI_DB_PTR_PTRS</b> flag:

    <nowiki><pre class=verbatim>
MyData **dynPtr = NULL;
n = <b>Jsi_DbQuery</b>(jdb, MyOptions, &dynPtr, 0, <i>"SELECT %s FROM mytable WHERE rowid < 5"</i>, <b>JSI_DB_PTR_PTRS</b>);
n = <b>Jsi_DbQuery</b>(jdb, MyOptions, &dynPtr, n, <i>"SELECT %s FROM mytable LIMIT 1000"</i>, <b>JSI_DB_PTR_PTRS</b>);
</pre></nowiki>

This mode will manage an extra NULL pointer at the end of the array
to make the current length detectable
(ie. when the <b>num</b> parameter is 0). 

Note the data argument has changed again; it is now a pointer
to an array of pointers (<b>void***</b>).


<h3 id=funcwrap>Function Wrappers</h3>

The above examples have several drawbacks:

  #  the <b>data</b> argument is not type-checked.
  #  calls to <b>Jsi_DbQuery</b> takes a lot of arguments (6).
  
The first problem is easily demonstrated:

    <nowiki><pre class=verbatim>
<b>Jsi_DbQuery</b>(jdb, MyOptions, <i>"oops, not a struct"</i>, n, <i>"SELECT %s FROM mytable"</i>, 0);  <em>// Invalid, but no compiler warning!</em>
</pre></nowiki>

The simplest solution defines wrapper functions: 

    <nowiki><pre class=verbatim>
int My_Stat(MyData *data, int num, const char *query, int flags) {
    return <b>Jsi_DbQuery</b>(jdbPtr, MyOptions, data, num, query, flags);
}

int My_Semi(MyData **data, int num, const char *query, int flags) {
    return <b>Jsi_DbQuery</b>(jdbPtr, MyOptions, data, 0, query, JSI_DB_PTR|flags);
}

int My_Dyn(MyData ***data, int num, const char *query, int flags) {
    return <b>Jsi_DbQuery</b>(jdbPtr, MyOptions, data, 0, query, JSI_DB_PTR_PTRS|flags);
}

My_Stat(mydatas, n, <i>"SELECT %s FROM mytable;"</i>, 0);
My_Semi(mdPtr,   n, <i>"SELECT %s FROM mytable;"</i>, 0);
My_Dyn (&dynPtr, n, <i>"SELECT %s FROM mytable;"</i>, 0);
</pre></nowiki>

In addition to the adding type checking, the resulting code is simpler.

<h3 id=multibind>Multi-Struct Bind</h3>

Multiple structs can be bound to,
using a different bind character for each:

    <nowiki><pre class=verbatim>
int My_Bind(MyData *data1, int num, MyData *data2, const char *query)
{
    <b>Jsi_DbMultipleBind</b> binds[] = {
        { ':', MyOptions, data1, num }, <em>// Input/output array.</em>
        { '$', MyOptions, data2, 1 },   <em>// Input single struct.</em>
        {}
    };
    n = <b>Jsi_DbQuery</b>(jdb, NULL <em>/*multi-bind*/</em>, binds, 0, query, <b>JSI_DB_PTRS</b>);
}

mydata.max = -1;
n = My_Bind(mdPtr, num, mydata, <i>"SELECT %s FROM mytable WHERE rowid=:rowid AND max=$max"</i>);
</pre></nowiki>

This causes a single bind of <b>$max</b> to
<i>mydata</i>, then repeated array-binds to <b>:rowid</b>,
allowing us to avoid input/output data collisions.

<hr>
<h2 id=specfields>Spec Fields</h2>

A <b>spec</b> is an array used to describe all or part of an struct using [./c-options.wiki|options].

<h3 id=supporttypes>Supported Types</h3>

For database access, spec option types are limited to:

    <p><nowiki>
<table border='1' class='cmdstbl' ><tr ><th  >Name</th><th  >C-Type</th><th  >Description</th></tr>
<tr ><td >BOOL</td><td>int</td><td >Boolean (uses a "char" variable).</td></tr>
<tr ><td >INT</td><td>int</td><td >An integer.</td></tr>
<tr ><td >WIDE</td><td>Jsi_Wide</td><td >A 64-bit integer (Jsi_Wide).</td></tr>
<tr ><td >DOUBLE</td><td>Jsi_Number</td><td >Double floating point.</td></tr>
<tr ><td >DSTRING</td><td>Jsi_DString</td><td >A Jsi_DString value.</td></tr>
<tr ><td >STRKEY</td><td>char*</td><td >A char* string key.</td></tr>
<tr ><td >STRBUF</td><td>char[]</td><td >A fixed size char string buffer.</td></tr>
<tr ><td >STRING</td><td>Jsi_String</td><td >A Jsi_Value referring to a string (when not using JSI_LITE_ONLY)</td></tr>
<tr ><td >DATETIME</td><td>Jsi_Wide</td><td >A date variable, milliseconds since 1970 stored in a 64 bit integer.</td></tr>
<tr ><td >CUSTOM</td><td></td><td >Custom types, including Enum and Bitmap.</td></tr>
</table></nowiki>

<h3 id=custom>Custom</h3>
The custom type supports defining parametrized handlers using the <b>.custom</b> and <b>.data</b> fields.
Several predefined handlers are available:

<h4 id=custenum>Custom Enum</h4>

It is a common database practice to store numeric values in one table, and then use a foreign key to reference
the string value from another table.  This is certainly a useful abstraction, 
but it does add complexity to the schema.
It also typically results in overhead from the use of joins, views and sub-selects.

The alternative is to store the string in the table.  But this requires conversion code
when we wish to use an enum in C.

Now consider the <b>marks</b> field from above:

    <nowiki><pre class=verbatim>
<b>typedef enum</b> { MARK_NONE, MARK_A, MARK_B, MARK_C, MARK_D, MARK_F } MarkType;
...
<b>static const char</b> *markStrs[] = {<i>""</i>,<i>"A"</i>,<i>"B"</i>,<i>"C"</i>,<i>"D"</i>,<i>"F"</i>,NULL};
...
    <b>JSI_OPT(CUSTOM</b>,     MyData, mark,   .help=<i>"Marks"</i>, .custom=<b>Jsi_Opt_SwitchEnum</b>, <b>.data</b>=markStrs ),
...
</pre></nowiki>

The definition ensures that the <i>marks</i> value is stored as integer in memory, and as string
in the database:  No manual conversion is required.

The <b>JSI_OPT_NOCASE</b> flag can be used ignore case in the database string value.

<h4 id=custbit>Custom Bitset</h4>

The <b>Jsi_Opt_SwitchBitset</b> option provides access multiple bits in one integer field.
This works similar to the above enum, except that the C stored values are bits set in an integer:

    <nowiki><pre class=verbatim>
<b>JSI_OPT(CUSTOM</b>,     MyData, markSet,   .help=<i>"Marks set"</i>, .custom=<b>Jsi_Opt_SwitchBitset</b>, .<b>data</b>=markStrs ),
</pre></nowiki>

But in the database they are stored as a list of string attributes:

    <nowiki><pre class=verbatim>
# <b>SELECT markSet FROM mytable;</b>
<i>"A B"
"B C D"</i>
</pre></nowiki>

Like enum, Jsi automatically provides the translation to/from strings.

The <b>JSI_OPT_NOCASE</b> flag can be used ignore case in the database string value.

<h3 id=fieldcolmap>Field/Column Mapping</h3>

The <b>.extName</b> field is used to map a C field name to a different database column name:

   <nowiki><pre class=verbatim>
<b>JSI_OPT(STRBUF</b>,     MyData, name,   <b>.extName</b>=<i>"struct"</i> ),
</pre></nowiki>

ie. in this example, "struct" is a reserved word in C.

<h3 id=nullvalues>NULL Values</h3>

For SELECT, the following Sqlite C-API rules apply for NULL sqlite_column values:

  *  DSTRING and STRBUF: an empty string.
  *  STRKEY: a NULL pointer.
  *  Otherwise, the value is <b>0</b>.


<h3 id=dirtyfields>Dirty Field</h3>

A dirty field is used to limit which rows get stored, which is
substantially faster than updating every row in the table.
It is either a BOOL or INT field using the <b>JSI_OPT_DB_DIRTY</b> option flag.

    <nowiki><pre class=verbatim>
<b>JSI_OPT(BOOL</b>,       MyData, isdirty, .help=<i>"Dirty flag: not stored in db"</i>, .flags=<b>JSI_OPT_DB_DIRTY</b>),
</pre></nowiki>

The call must be made with the <b>JSI_DB_DIRTY_ONLY</b> flag:

    <nowiki><pre class=verbatim>
for (i=1; i<=3; i++) {
    mydatas[i].isdirty = 1;
    mydatas[i].id += 100*i;
}
n = QueryMyStat(mydatas, cnt, <i>"UPDATE mytable SET %s WHERE rowid = :rowid"</i>, <b>JSI_DB_DIRTY_ONLY</b>);
</pre></nowiki>

<b>Note:</b> unless an error occurs, dirty fields are cleared by the call.

<h3 id=rowidfield>Rowid Field</h3>

A field for storing the <b>rowid</b> is indicated by a <b>JSI_OPT_DB_ROWID</b> option flag.

    <nowiki><pre class=verbatim>
<b>JSI_OPT(WIDE</b>,       MyData, rowid,  .help=<i>"DB rowid for update/insert; not stored in db"</i>, .flags=<b>JSI_OPT_DB_ROWID</b>),
</pre></nowiki>

The field will not be stored back to the database, but will be loaded during a SELECT, for use
in query bindings to enforce a 1-1 mapping with the database, eg.

    <nowiki><pre class=verbatim>
QueryMyStat(mydatas, cnt, <i>"UPDATE mytable SET %s WHERE <b>rowid == :rowid</b>"</i>, 0);
</pre></nowiki>

<hr>
<h2 id=javascript>Javascript</h2>

Javascript is available when "jsi.c" is not compiled with <b>JSI_LITE_ONLY</b>,
and the appropriate initialization used.

<h3 id=jsinit>Javascript Initialization</h3>

The following shows how to initialize Jsi to have full access to Javascript and the
[./js-sqlite.wiki|database scripting API].

    <nowiki><pre class=verbatim>
<b>Jsi_EvalString</b>(interp, <i>"var mydb = <b>new Sqlite</b>('~/mytest.db');"</i>, 0);
<b>Jsi_Db</b> *jdb = <b>Jsi_UserObjDataFromVar</b>(interp, <i>"mydb"</i>);
<b>sqlite3</b> *db = <b>Jsi_DbHandle</b>(interp, jdb);
</pre></nowiki>

<h3 id=cdata>The "Cdata" Command</h3>

Javascript can access data arrays created in C-code using
the "Cdata" command.

The first step is to use <b>Jsi_CDataRegister()</b> making <b>mdPtr</b> available as "mydata".

    <nowiki><pre class=verbatim>
<b>Jsi_CDataRegister</b>(interp, <i>"mydata"</i>, MyOptions, mdPtr, num, <b>JSI_DB_PTRS</b>);
</pre></nowiki>

Then we can index data array elements from Javascript with:

    <nowiki><pre class=verbatim>
<b>Cdata.get</b>( <i>'mydata'</i>, 0, <i>'max'</i> ); 
<b>Cdata.set</b>( <i>'mydata'</i>, 1, {<i>'max'</i>:99} );
</pre></nowiki>

<h3 id=cdataquery>Queries With "Cdata"</h3>

Javascript queries can use <b>Cdata</b> targets to load and store data:

    <nowiki><pre class=verbatim>
db = <b>new Sqlite</b>(<i>'~/mytable.db'</i>);

size = <b>db.query</b>(<i>'SELECT %s FROM mytable'</i>, {<b>Cdata</b>:<i>'mydata'</i>});
for (i = 0; i<size; i++) {
    max = <b>Cdata.get</b>(<i>'mydata'</i>, i, <i>'max'</i>);
    max += i*100;
    <b>Cdata.set</b>(<i>'mydata'</i>, i, {max:max});
}
<b>db.query</b>(<i>'UPDATE %s FROM mytable'</i>, {<b>Cdata</b>:<i>'mydata'</i>});

<b>Cdata.get</b>(<i>'mydata'</i>, 0);
<b>Cdata.size</b>(<i>'mydata'</i>);      <em>// Get array allocated size.</em>
<b>Cdata.info</b>(<i>'mydata'</i>);      <em>// Struct info.</em>
</pre></nowiki>

<h3 id=schemagen>Schema Generation</h3>

The Javascript command <b>Cdata.schema()</b> returns the schema for a Cdata definition,
for example to create a table:

    <nowiki><pre class=verbatim>
<b>db.query</b>(<i>"CREATE TABLE newtable("</i> + <b>Cdata.schema</b>('mydata') + <i>")"</i>;
</pre></nowiki>

which can then be used to access data:

    <nowiki><pre class=verbatim>
<b>db.query</b>(<i>'INSERT %s INTO newtable'</i>, {<b>Cdata</b>:<i>'mydata'</i>});
<b>db.query</b>(<i>'SELECT %s FROM newtable'</i>, {<b>Cdata</b>:<i>'mydata'</i>});
</pre></nowiki>

The schema for the above would look something like:

    <nowiki><pre class=verbatim>
<b>CREATE TABLE</b> newtable(
</i>-- 'MyData': This is a struct for dbdemo</i>
  name <b>TEXT DEFAULT ''</b> <i>-- Fixed size char buf</i>
 ,desc <b>TEXT</b> <i>-- Description field of arbitrary length</i>
 ,id <b>INT DEFAULT 0 CHECK(id>0)</b> <i>-- Int id</i>
 ,max <b>FLOAT</b> <i>-- Max value</i>
 ,myTime <b>TIMEINT DEFAULT</b>(round((julianday('now') - 2440587.5)*86400.0)) <i>-- A unix/javascript time field in milliseconds (64 bits)</i>
 ,mark <b>TEXT</b> <i>-- Marks</i>
 ,markSet <b>TEXT</b> <i>-- A set</i>
<i>-- MD5: bc2a7cfc68725e60396dd2a2a4113f75</i>
);
</pre></nowiki>

The schema is generated by appending:

  *  The column name from the <b>extName</b> or the <b>name</b> field.
  *  The generated type.
  *  The <b>userData</b> field (eg. "DEFAULT 1 CHECK (id>0)")
  *  A DATETIME field with a .userData="DEFAULT" will init to the current time.
  *  Lastly, the <b>help</b> field as a comment (ie. after a "-- " string).

The schema is completed using fields from JSI_OPT_END:

  *  <b>help</b> is prepended as a comment.
  *  <b>userData</b> is appended (eg. ", FORIEGN KEY(id) REFERENCES tkey(tid)").
  *  And a calculated MD5-comment.

<h3 id=schemacheck>Schema Checking</h3>

One advantage of using generated schemas is that it provides a way to deal with data changes.

The calculated MD5 value (which ignores <b>.help</b> data) can be used in
tracking database compatibility as in the following example: 

    <nowiki><pre class=verbatim>
var md5 = <b>Cdata.schemaMd5</b>(<i>'mydata'</i>)
var schema = <b>db.onecolumn</b>(<i>"SELECT sql FROM sqlite_master WHERE name='newtable' AND type=='table'"</i>);
if (!schema.match(<i>'MD5: '</i>+md5))
    FixUpData(<i>'mydata','newtable'</i>); <em>// Fixup function: eg. export, recreate table and import data.</em>
</pre></nowiki>

<h3 id=config>Configuration</h3>

Option configuration is available thus:

    <nowiki><pre class=verbatim>
var mydb = <b>new Sqlite</b>(<i>'~/mytest.db'</i>, {maxStmts:100});
mydb.conf({maxStmts:1000});
</pre></nowiki>

<hr>
<h2 id=perf>Performance</h2>

Performance of Jsi_DbQuery() should be similar to that of hand generated C-code.
Heap memory requests are avoided where possible.
Except for Sqlite internal memory requests, heap allocation occurs only when:

  #  A JSI_DString field exceeds 200 bytes.
  #  A query string exceeds 2000 bytes (including generated argument lists).
  #  A query is first added to the cache.
  #  JSI_DB_PTR* flags are used.


Some overhead arises from using sqlite3_bind_parameter_name(),
and string concatenation which is used in binding list creation.
However, being stack orientated together with caching compiled queries
gives reasonably good performance.

Following is output from the million row benchmark included in the <b>dbdemo</b> program:

    <nowiki><pre class=verbatim>
user@host:~/src/jsi/jsi/c-demos$ <b>./dbdemo -benchmark</b>
-1.000000
TESTING 1000000 ROWS
INIT C:    0.198 secs
   6.704 sec,   149164 rows/sec    INSERT 1000000 ROWS
   2.883 sec,   346860 rows/sec    SELECT 1000000 ROWS 
  10.029 sec,    99710 rows/sec    UPDATE 1000000 ROWS, 1 FIELD
  10.754 sec,    92988 rows/sec    UPDATE 1000000 ROWS, ALL FIELDS
   4.381 sec,    22825 rows/sec    UPDATE 100000 DIRTY ROWS
   1.412 sec,      708 rows/sec    UPDATE 1000 DIRTY ROWS
   0.272 sec,       36 rows/sec    UPDATE 10 DIRTY ROWS
</pre></nowiki>

The last 3 use dirty row updates to demonstrate keeping a database in sync
with minimal overhead.

<hr>
<h2 id=misc>Miscellaneous</h2>

<h3 id=begincommit>BEGIN/COMMIT</h3>

Normally, any write query with size greater than one will implicilty add BEGIN/COMMITs.
The <i>JSI_DB_NO_BEGINCOMMIT</i> flag can be used to disable this behaviour.

Also, the "BEGIN" or "COMMIT" string can be overridden at compile time like so:

    <nowiki><pre class=verbatim>
#define <b>JSI_DBQUERY_BEGIN_STR</b> <i>"BEGIN TRANSACTION"</i>
#define <b>JSI_DBQUERY_COMMIT_STR</b> <i>"COMMIT"</i>
#include <i>"jsi.c"</i>
</pre></nowiki>

<h3 id=errhandle>Error Handling</h3>

A custom error handler can be invoked upon error using:

    <nowiki><pre class=verbatim>
#define <b>JSI_DBQUERY_ERRORCMD</b> MyErrHandler
#include <i>"jsi.c"</i>

int MyErrHandler(<b>Jsi_Db</b> *jdb, <b>Jsi_OptionSpec</b> *specs, void *data, int numData, const char *query, int flags, int rc) {
   printf(<i>"Error in query: %s\n"</i>, query);
   return rc;
}
</pre></nowiki>

<h2 id=references>References</h2>

The following related references are available:

  *  [./reference.wiki#Sqlite]
  *  [./js-sqlite.wiki|Javascript Sqlite API] 
  *  [./c-options.wiki|Jsi_OptionSpec]
  *  [./c-jsilite.wiki|Jsi-Lite]

<hr>
