#ifndef __JSI_H__
#define __JSI_H__

#define JSI_VERSION_MAJOR   2
#define JSI_VERSION_MINOR   0
#define JSI_VERSION_RELEASE 0

#define JSI_VERSION (JSI_VERSION_MAJOR + ((Jsi_Number)JSI_VERSION_MINOR/100.0) + ((Jsi_Number)JSI_VERSION_RELEASE/10000.0))

#ifndef EXTERN
#define EXTERN extern
#endif

#ifdef offsetof
#define Jsi_Offset(type, field) ((int) offsetof(type, field))
#else
#define Jsi_Offset(type, field) ((int) ((char *) &((type *) 0)->field))
#endif

#ifndef __GNUC__
#define __attribute__(X)
#endif

/* Optional compile-out commands/options string information. */
#ifdef JSI_WITHOUT_INFO
#define JSI_INFO(n) NULL
#endif
#ifndef JSI_INFO
#define JSI_INFO(n) n
#endif

/* JSI ENUMS */
typedef enum {
    
    /* Return codes. */
    JSI_OK=0, JSI_ERROR=1, JSI_RETURN=2, JSI_BREAK=3,
    JSI_CONTINUE=4, JSI_SIGNAL=5, JSI_EXIT=6, JSI_EVAL=7,
    
    /* General flags. */
    JSI_NONE=0, JSI_NO_ERRMSG=1, 
    JSI_CMP_NOCASE=1, JSI_CMP_CHARSET_SCAN=2,
    JSI_CMP_EXACT=0x4,
    JSI_EVAL_ARGV0=0x1, JSI_EVAL_GLOBAL=0x2, JSI_EVAL_NOSKIPBANG=0x4, JSI_EVAL_INDEX=0x8,
    JSI_EVAL_RETURN         =0x10, /* Return top of stack as result */

    /* Flags for Jsi_CmdProc */
    JSI_CALL_CONSTRUCTOR    =0x1,
    JSI_CALL_BUILTIN        =0x2,
    
    JSI_CMDSPEC_NOTOBJ      = 0x1,
    JSI_CMDSPEC_PROTO       = 0x2,
    JSI_CMDSPEC_NONTHIS     = 0x4,
    
    JSI_CMD_HAS_ATTR        = 0x100,
    JSI_CMD_IS_CONSTRUCTOR  = 0x200,
    JSI_CMD_IS_OBJ          = 0x400,
    JSI_CMD_MASK            = 0xffff,
    
    JSI_OM_READONLY         = 0x01,     /* ecma read-only */
    JSI_OM_DONTENUM         = 0x02,     /* ecma emumerable */
    JSI_OM_DONTDEL          = 0x04,     /* ecma configurable */
    JSI_OM_INNERSHARED      = 0x08,
    JSI_OM_ISARRAYLIST      = 0x10,
    JSI_OM_ISSTRKEY         = 0x20,
    JSI_OM_UNUSED           = 0x40,
    JSI_OM_ISSTATIC         = 0x80,
    
    JSI_LOG_FATAL= 0x1,  JSI_LOG_ERROR = 0x2,  JSI_LOG_WARN = 0x4, 
    JSI_LOG_INFO = 0x8,  JSI_LOG_DEBUG = 0x10, JSI_LOG_BUG  = 0x20, 
    JSI_LOG_TODO = 0x40, JSI_LOG_PARSE = 0x80,
    
    JSI_SORT_NOCASE = 0x1, JSI_SORT_DESCEND = 0x2, JSI_SORT_ASCII = 0x4,
    
    JSI_NAME_FUNCTIONS = 0x1, JSI_NAME_DATA = 0x2,
    
    JSI_TREE_INORDER=0, JSI_TREE_PREORDER=1, JSI_TREE_POSTORDER=2,
    JSI_TREE_LEVELORDER=3, JSI_TREE_ORDER_MASK=0x3,
    JSI_TREE_USERFLAG_MASK=0x7f,
    JSI_LIST_MUTEX=1,
    JSI_MUTEX_RECURSIVE=2,
    
    JSI_FS_NOCLOSE=0x1, JSI_FS_READONLY=0x2, JSI_FS_WRITEONLY=0x4, JSI_FS_APPEND=0x8,
    JSI_FS_COMPRESS=0x100,
    JSI_FSMODESIZE=15,
    JSI_FILE_TYPE_FILES=0x1, JSI_FILE_TYPE_DIRS=0x2,    JSI_FILE_TYPE_MOUNT=0x4,
    JSI_FILE_TYPE_LINK=0x8,  JSI_FILE_TYPE_PIPE=0x10,   JSI_FILE_TYPE_BLOCK=0x20,
    JSI_FILE_TYPE_CHAR=0x40, JSI_FILE_TYPE_SOCKET=0x80, JSI_FILE_TYPE_HIDDEN=0x100,
    
    JSI_OUTPUT_QUOTE = 0x1,
    JSI_OUTPUT_JSON = 0x2,
    JSI_OUTPUT_NEWLINES = 0x4,
    JSI_OUTPUT_STDERR = 0x8,
    JSI_JSON_STRICT   = 0x101, /* property names must be quoted. */
    JSI_STUBS_STRICT  = 0x1, JSI_STUBS_SIG = 0xdeadbee0,

    JSI_EVENT_TIMER=0, JSI_EVENT_SIGNAL=1, JSI_EVENT_ALWAYS=2,
    JSI_ZIP_MAIN=0x1,  JSI_ZIP_INDEX=0x2,
    
    JSI_DB_PTRS          =0x0100, /* Data is a fixed length array of pointers to (allocated) structs. */
    JSI_DB_PTR_PTRS      =0x0200, /* Address of data array is passed, and this is resized to fit results. */
    JSI_DB_MEMCLEAR     =0x0400, /* Before query previously used data items are reset to empty (eg. DStrings). */
    JSI_DB_MEMFREE      =0x0800, /* Reset as above, then free data items (query is normally empty). */
    JSI_DB_DIRTY_ONLY   =0x1000, /* Used by sqlite UPDATE/INSERT/REPLACE. */
    JSI_DB_NO_BEGINCOMMIT  =0x2000, /* Do not wrap multi-item UPDATE in BEGIN/COMMIT. */
    JSI_DB_NO_CACHE     =0x4000, /* Do not cache statement. */
    JSI_DB_NO_STATIC    =0x8000, /* Do not bind text with SQLITE_STATIC. */

    JSI_DBI_READONLY     =0x0001, /* Db is created readonly */
    JSI_DBI_NOCREATE     =0x0002, /* Db must already exist. */
    JSI_DBI_NO_MUTEX     =0x0004, /* Disable mutex. */
    JSI_DBI_FULL_MUTEX   =0x0008, /* Use full mutex. */
    
    JSI_MAX_NUMBER_STRING=50

} Jsi_Enums; /* We use enum as debugging is easier than #define. */

typedef enum {  JSI_MAP_HASH, JSI_MAP_TREE } Jsi_Map_Type;
typedef enum {
    JSI_KEYS_ONEWORD = 1, // A pointer
    JSI_KEYS_STRINGKEY = 2, // A pointer to strings in another hash, eg. Jsi_KeyLookup()
    JSI_KEYS_STRING = 3, // A string
    JSI_KEYS_STRUCT_MINSIZE = 4
} Jsi_Key_Type;
/* */


/* JSI TYPES */
typedef unsigned char Jsi_Bool;
typedef long long Jsi_Wide;
typedef unsigned long long Jsi_UWide;
#ifdef JSI_USE_LONG_DOUBLE
typedef long double Jsi_Number;
#define JSI_NUMLMOD "L"
#else
typedef double Jsi_Number;
#define JSI_NUMLMOD
#endif

#include <stdint.h>
#include <time.h>

typedef uint8_t  Jsi_BYTE;
typedef uint16_t Jsi_WORD;
typedef uint32_t Jsi_DWORD;
typedef uint64_t Jsi_QWORD;
typedef unsigned int uint;
#define JSI_NUMGFMT JSI_NUMLMOD "g"
#define JSI_NUMFFMT JSI_NUMLMOD "f"
#define JSI_NUMEFMT JSI_NUMLMOD "e"

typedef enum {
    JSI_OT_UNDEF,       /* Undefined */
    JSI_OT_BOOL,        /* Boolean object, use d.val */
    JSI_OT_NUMBER,      /* Number object, use d.num */
    JSI_OT_STRING,      /* String object, use d.str */
    JSI_OT_OBJECT,      /* common object, not use d */
    JSI_OT_ARRAY,       /* Actual in object is JSI_OT_OBJECT */
    JSI_OT_FUNCTION,    /* Function object, use d.fobj */
    JSI_OT_REGEXP,      /* RegExp object, use d.robj */
    JSI_OT_ITER,        /* Iter object, use d.iobj */
    JSI_OT_USEROBJ,     /* UserDefined object, use d.uobj */
    JSI_OT__MAX = JSI_OT_USEROBJ
} Jsi_otype;

typedef enum {          /* TYPE         CONSTRUCTOR JSI_VALUE-DATA  IMPLICIT-PROTOTYPE  */
    JSI_VT_UNDEF,       /* undefined    none        none            none                */
    JSI_VT_BOOL,        /* boolean      Boolean     d.val           none                */
    JSI_VT_NUMBER,      /* number       Number      d.num           Number.prototype    */
    JSI_VT_STRING,      /* string       String      d.str           String.prototype    */
    JSI_VT_OBJECT,      /* object       Jsi_Obj     d.obj           Jsi_Obj.prototype   */
    JSI_VT_NULL,        /* null         none        none            none                */
    JSI_VT_VARIABLE,    /* lvalue       none        d.lval          none                */
    JSI_VT__MAX = JSI_VT_VARIABLE
} Jsi_vtype;

typedef enum {
    JSI_TT_ANY      = (1<<JSI_OT_UNDEF),
    JSI_TT_BOOL     = (1<<JSI_OT_BOOL),
    JSI_TT_NUMBER   = (1<<JSI_OT_NUMBER),
    JSI_TT_STRING   = (1<<JSI_OT_STRING),
    JSI_TT_OBJECT   = (1<<JSI_OT_OBJECT),
    JSI_TT_ARRAY    = (1<<JSI_OT_ARRAY),
    JSI_TT_FUNCTION = (1<<JSI_OT_FUNCTION),
    JSI_TT_REGEXP   = (1<<JSI_OT_REGEXP),
    JSI_TT_NULL     = (1<<JSI_OT_ITER),
    JSI_TT_USEROBJ  = (1<<JSI_OT_USEROBJ),
    JSI_TT_VOID     = (1<<(JSI_OT_USEROBJ+1))
} Jsi_ttype;
/* */


struct Jsi_Interp_;
struct Jsi_Value_;
struct Jsi_Obj_;
struct Jsi_IterObj_;
struct Jsi_FuncObj_;
struct Jsi_Func_;
struct Jsi_UserObj_;
struct Jsi_UserObjReg_;
struct Jsi_HashEntry_;
struct Jsi_Hash_;
struct Jsi_HashSearch_;
struct Jsi_TreeEntry_;
struct Jsi_Tree_;
struct Jsi_TreeSearch_;
struct Jsi_Map_;
struct Jsi_MapSearch_;
struct Jsi_MapEntry_;
struct Jsi_List_;
struct Jsi_ListEntry_;
struct Jsi_CmdSpec_;
struct Jsi_OptionSpec_;
struct Jsi_Db_;
struct Jsi_Mutex_;

typedef struct Jsi_Interp_ Jsi_Interp;
typedef struct Jsi_Obj_ Jsi_Obj;
typedef struct Jsi_Value_ Jsi_Value;
typedef struct Jsi_Func_ Jsi_Func;
typedef struct Jsi_IterObj_ Jsi_IterObj;
typedef struct Jsi_FuncObj_ Jsi_FuncObj;
typedef struct Jsi_UserObjReg_ Jsi_UserObjReg;
typedef struct Jsi_UserObj_ Jsi_UserObj;
typedef struct Jsi_HashEntry_ Jsi_HashEntry;
typedef struct Jsi_Hash_ Jsi_Hash;
typedef struct Jsi_HashSearch_ Jsi_HashSearch;
typedef struct Jsi_TreeEntry_ Jsi_TreeEntry;
typedef struct Jsi_Tree_ Jsi_Tree;
typedef struct Jsi_TreeSearch_ Jsi_TreeSearch;
typedef struct Jsi_Map_ Jsi_Map;
typedef struct Jsi_MapEntry_ Jsi_MapEntry;
typedef struct Jsi_List_ Jsi_List;
typedef struct Jsi_ListEntry_ Jsi_ListEntry;
typedef struct Jsi_MapEntry_ Jsi_MapEntry;
typedef struct Jsi_Map_ Jsi_Map;
typedef struct Jsi_MapSearch_ Jsi_MapSearch;;
typedef struct Jsi_Regex_ Jsi_Regex;
typedef struct Jsi_OptionSpec_ Jsi_OptionSpec;
typedef struct Jsi_Db_ Jsi_Db;
typedef struct Jsi_Mutex_ Jsi_Mutex;

typedef int (Jsi_InitProc)(Jsi_Interp *interp);
typedef int (Jsi_DeleteProc)(Jsi_Interp *interp, void *data);
typedef int (Jsi_EventHandlerProc)(Jsi_Interp *interp, void *data);
typedef int (Jsi_HashDeleteProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);
typedef int (Jsi_ValueHandlerProc)(Jsi_Interp *interp, Jsi_Value *v);
typedef void (Jsi_DeleteVoidProc)(void *data);

/* INTERP */
EXTERN Jsi_Interp* Jsi_InterpNew(Jsi_Interp *parent, int argc, char **argv, Jsi_Value *opts); /*STUB = 1*/
EXTERN void Jsi_InterpDelete( Jsi_Interp* interp); /*STUB = 2*/
EXTERN void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr);  /*STUB = 3*/
EXTERN int Jsi_Interactive(Jsi_Interp* interp, int flags); /*STUB = 4*/
EXTERN int Jsi_InterpGone( Jsi_Interp* interp); /*STUB = 5*/
EXTERN Jsi_Value* Jsi_InterpResult(Jsi_Interp *interp); /*STUB = 6*/
EXTERN void* Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc); /*STUB = 7*/
EXTERN void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc *proc, void *data); /*STUB = 8*/
EXTERN void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key); /*STUB = 9*/
EXTERN int Jsi_InterpSafe(Jsi_Interp *interp); /*STUB = 308*/
EXTERN int Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* file, int toWrite); /*STUB = 290*/

/* CMD/FUNC/VAR */
typedef void (Jsi_DelCmdProc)(Jsi_Interp *interp, void *privData);
typedef int (Jsi_CmdProc)(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
#define Jsi_CmdProcDecl(name,...) int name(Jsi_Interp *interp, Jsi_Value *args, \
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, ##__VA_ARGS__)

typedef struct Jsi_CmdSpec_ {
    const char *name;             /* Cmd name */
    Jsi_CmdProc *proc;       /* Command handler */
    int minArgs;
    int maxArgs;            /* Max args or -1 */
    const char *argStr;           /* Argument description */
    int flags;              /* JSI_CMD_* flags. */
    const char *help;             /* Short help string. */
    const char *info;             /* Detailed description. Use JSI_DETAIL macro. */
    Jsi_otype retType;      /* Return type. */
    Jsi_OptionSpec *opts;  /* Options for arg, default is first. */
    Jsi_DelCmdProc *delProc;/* Callback to handle command delete. */
    void *udata1, *udata2, *udata3;  /* reserved for internal use. */
} Jsi_CmdSpec;

typedef struct {
    char *str;
    int len;
} Jsi_String;

EXTERN Jsi_Value* Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData); /*STUB = 10*/
EXTERN Jsi_Value* Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs, void *privData, int flags); /*STUB = 14*/
EXTERN int Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmd, const char *json, Jsi_Value **ret); /*STUB = 11*/
EXTERN int Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret); /*STUB = 12*/
EXTERN int Jsi_CommandDelete(Jsi_Interp *interp, const char *name); /*STUB = 13*/
EXTERN Jsi_CmdSpec* Jsi_FunctionGetSpecs(Jsi_Func *funcPtr); /*STUB = 15*/
EXTERN int Jsi_FunctionIsConstructor(Jsi_Func *funcPtr); /*STUB = 16*/
EXTERN int Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr); /*STUB = 17*/
EXTERN void* Jsi_FunctionPrivData(Jsi_Func *funcPtr); /*STUB = 293*/
EXTERN int Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr); /*STUB = 19*/
EXTERN int Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret); /*STUB = 20*/
EXTERN int Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this); /*STUB = 21*/
EXTERN int Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *tocall, const char *json, Jsi_Value **ret); /*STUB = 22*/
EXTERN int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg); /*STUB = 23*/
EXTERN Jsi_Value* Jsi_VarLookup(Jsi_Interp *interp, const char *varname); /*STUB = 24*/
EXTERN Jsi_Value* Jsi_NameLookup(Jsi_Interp *interp, const char *varname); /*STUB = 25*/
EXTERN int Jsi_PkgProvide(Jsi_Interp *interp, const char *name, const char *version); /*STUB = 26*/
EXTERN int Jsi_PkgRequire(Jsi_Interp *interp, const char *name, const char *version); /*STUB = 27*/


/* MEMORY */
EXTERN void* Jsi_Malloc(unsigned int size); /*STUB = 28*/
EXTERN void* Jsi_Calloc(unsigned int n, unsigned int size); /*STUB = 29*/
EXTERN void* Jsi_Realloc(void *m, unsigned int size); /*STUB = 30*/
EXTERN void  Jsi_Free(void *m); /*STUB = 31*/
EXTERN int Jsi_ObjIncrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 32*/
EXTERN int Jsi_ObjDecrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 33*/
EXTERN int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 34*/
EXTERN int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 35*/
EXTERN int Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 36*/


/* CHARACTER STRINGS */
EXTERN uint Jsi_Strlen(const char *str); /*STUB = 37*/
EXTERN uint Jsi_StrlenSet(const char *str, uint len); /*STUB = 38*/
EXTERN int Jsi_Strcmp(const char *str1, const char *str2); /*STUB = 39*/
EXTERN int Jsi_Strncmp(const char *str1, const char *str2, int n); /*STUB = 40*/
EXTERN int Jsi_Strncasecmp(const char *str1, const char *str2, int n); /*STUB = 41*/
EXTERN int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict); /*STUB = 42*/
EXTERN char* Jsi_Strcpy(char *dst, const char *src); /*STUB = 43*/
EXTERN char* Jsi_Strncpy(char *dst, const char *src, int len); /*STUB = 44*/
EXTERN char* Jsi_Strdup(const char *n); /*STUB = 45*/
EXTERN int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, int n); /*STUB = 46*/
EXTERN char* Jsi_Strchr(const char *str, int c); /*STUB = 48*/
EXTERN int Jsi_Strpos(const char *str, int start, const char *nid, int nocase); /*STUB = 49*/
EXTERN int Jsi_Strrpos(const char *str, int start, const char *nid, int nocase); /*STUB = 50*/
#define Jsi_Stzcpy(buf,src) Jsi_Strncpy(buf, src, sizeof(buf))

/* JSI_DSTRING : dynamic string support. */
#ifndef JSI_DSTRING_STATIC_SIZE
#define JSI_DSTRING_STATIC_SIZE 200
#endif

#define JSI_DSTRING_DECL(siz) \
struct { \
    char *str; \
    int len; \
    int spaceAvl; \
    int staticSize; \
    char staticSpace[siz]; \
}
#ifdef NO_JSI_DSTRING_HASH_DEF // This is just so the editor can find the struct def.
typedef struct { char *str; int len; int spaceAvl; int staticSize; char staticSpace[JSI_DSTRING_STATIC_SIZE]; } Jsi_DString;
#else
typedef JSI_DSTRING_DECL(JSI_DSTRING_STATIC_SIZE) Jsi_DString;
#endif

/* For declaring a custom Jsi_DString* variable with other than the default size... */
#define JSI_DSTRING_VAR(namPtr, siz) \
    JSI_DSTRING_DECL(siz) _STATIC_##namPtr; \
    Jsi_DString *namPtr = (Jsi_DString *)&_STATIC_##namPtr; \
    namPtr->staticSize = siz; namPtr->str=namPtr->staticSpace; \
    namPtr->staticSpace[0] = 0; namPtr->spaceAvl = namPtr->len = 0

EXTERN char*   Jsi_DSAppendLen(Jsi_DString *dsPtr,const char *bytes, int length);  /*STUB = 54*/
EXTERN char*   Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)  /*STUB = 55*/  __attribute__((sentinel));
EXTERN void    Jsi_DSFree(Jsi_DString *dsPtr);  /*STUB = 52*/
EXTERN char*   Jsi_DSFreeDup(Jsi_DString *dsPtr);  /*STUB = 57*/
EXTERN void    Jsi_DSInit(Jsi_DString *dsPtr);  /*STUB = 56*/
EXTERN int     Jsi_DSLength(Jsi_DString *dsPtr);  /*STUB = 59*/
EXTERN char*   Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)  /*STUB = 62*/ __attribute__((format (printf,2,3)));
EXTERN char*   Jsi_DSSet(Jsi_DString *dsPtr, const char *str);  /*STUB = 51*/
EXTERN int     Jsi_DSSetLength(Jsi_DString *dsPtr, int length);  /*STUB = 60*/
EXTERN char*   Jsi_DSValue(Jsi_DString *dsPtr);  /*STUB = 53*/
/* */


/* JSI_OBJ */
EXTERN Jsi_Obj* Jsi_ObjNew(Jsi_Interp* interp); /*STUB = 63*/
EXTERN Jsi_Obj* Jsi_ObjNewType(Jsi_Interp* interp, Jsi_otype type); /*STUB = 64*/
EXTERN void Jsi_ObjFree(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 65*/
EXTERN Jsi_Obj* Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count); /*STUB = 66*/
EXTERN Jsi_Obj* Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copy); /*STUB = 67*/

EXTERN int      Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o); /*STUB = 68*/
EXTERN void     Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, int len); /*STUB = 69*/
EXTERN int      Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 70*/
EXTERN const char* Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 71*/
EXTERN Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj); /*STUB = 72*/
EXTERN void     Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 73*/
EXTERN int      Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex); /*STUB = 74*/
EXTERN int      Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v); /*STUB = 75*/
EXTERN Jsi_TreeEntry* Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *nv, int flags); /*STUB = 76*/
EXTERN void    Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj);  /*STUB = 61*/
/* */


/* JSI_VALUE */
EXTERN Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp); /*STUB = 77*/
EXTERN Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp); /*STUB = 78*/
EXTERN void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v); /*STUB = 79*/

EXTERN Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp); /*STUB = 80*/
EXTERN Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval); /*STUB = 81*/
EXTERN Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n); /*STUB = 82*/
EXTERN Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, int len); /*STUB = 83*/
EXTERN Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len); /*STUB = 84*/
EXTERN Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s); /*STUB = 85*/
EXTERN Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s); /*STUB = 86*/
EXTERN Jsi_Value* Jsi_ValueNewArray(Jsi_Interp *interp, char **items, int count); /*STUB = 87*/

EXTERN int Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **s); /*STUB = 88*/
EXTERN int Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 89*/
EXTERN int Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 90*/
EXTERN int Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 91*/
EXTERN int Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n); /*STUB = 92*/
EXTERN int Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n); /*STUB = 93*/
EXTERN int Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 94*/
EXTERN int Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags); /*STUB = 95*/
EXTERN int Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Bool *val); /*STUB = 96*/
EXTERN int Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val); /*STUB = 97*/

EXTERN int Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype); /*STUB = 98*/
EXTERN int Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype); /*STUB = 99*/
EXTERN int Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 100*/
EXTERN int Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 101*/
EXTERN int Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 102*/
EXTERN int Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 103*/
EXTERN int Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 104*/
EXTERN int Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 105*/
EXTERN int Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 106*/
EXTERN int Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 107*/
EXTERN int Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 108*/

EXTERN Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 109*/
EXTERN Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 110*/
EXTERN Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **v, Jsi_Number n); /*STUB = 111*/
EXTERN Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **v, int b); /*STUB = 112*/
EXTERN Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 113*/
EXTERN Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 115*/
EXTERN Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **v, unsigned char *s, int len); /*STUB = 116*/
EXTERN Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 117*/
EXTERN Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 118*/
EXTERN Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_DString *dsPtr); /*STUB = 119*/
EXTERN int Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key); /*STUB = 120*/
#define Jsi_ValueMakeStringDup(interp, v, s) Jsi_ValueMakeString(interp, v, Jsi_Strdup(s))

EXTERN const char*  Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr); /*STUB = 121*/
EXTERN int          Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 122*/
EXTERN Jsi_Number   Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 123*/
EXTERN Jsi_Number   Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt); /*STUB = 124*/
EXTERN void         Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 125*/

EXTERN void     Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 126*/
EXTERN const char* Jsi_ValueGetDString(Jsi_Interp* interp, Jsi_Value* v, Jsi_DString *dStr, int quote); /*STUB = 127*/
EXTERN char*    Jsi_ValueString(Jsi_Interp* interp, Jsi_Value* v, int *lenPtr); /*STUB = 128*/
EXTERN unsigned char* Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr); /*STUB = 114*/
EXTERN char*    Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr); /*STUB = 129*/
EXTERN int      Jsi_ValueStrlen(Jsi_Value* v); /*STUB = 130*/
EXTERN void     Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret);  /*STUB = 58*/
EXTERN int      Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2); /*STUB = 131*/
EXTERN Jsi_Obj* Jsi_ValueGetObj(Jsi_Interp* interp, Jsi_Value* v); /*STUB = 132*/
EXTERN Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv); /*STUB = 133*/
EXTERN const char* Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 134*/
EXTERN int      Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int cmpFlags); /*STUB = 135*/
EXTERN int Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 136*/

EXTERN int Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int sortFlags); /*STUB = 137*/
EXTERN Jsi_Value * Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 138*/
EXTERN void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 139*/
EXTERN Jsi_Value* Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index); /*STUB = 142*/
EXTERN char* Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr); /*STUB = 143*/
#define Jsi_ValueArraySet(interp, dest, value, index) Jsi_ObjArraySet(interp, Jsi_ValueGetObj(interp, dest), value, index)

#define Jsi_ValueInsertFixed(i,t,k,v) Jsi_ValueInsert(i,t,k,v,JSI_OM_READONLY | JSI_OM_DONTDEL | JSI_OM_DONTENUM)
EXTERN void Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags); /*STUB = 140*/
EXTERN int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 141*/
EXTERN Jsi_Value* Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int iskeystr); /*STUB = 144*/
EXTERN int Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *k, int isstrkey); /*STUB = 145*/
EXTERN int Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret); /*STUB = 146*/

EXTERN void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ); /*STUB = 147*/
EXTERN void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from ); /*STUB = 148*/
EXTERN void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from); /*STUB = 47*/
EXTERN void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from); /*STUB = 278*/
EXTERN int  Jsi_ValueIsEqual(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2); /*STUB = 18*/
/* */


/* JSI_USEROBJ */
typedef int (Jsi_UserObjIsTrueProc)(void *data);
typedef int (Jsi_UserObjIsEquProc)(void *data1, void *data2);
typedef Jsi_Obj* (Jsi_UserGetObjProc)(Jsi_Interp *interp, void *data);

typedef struct Jsi_UserObjReg_ {
    const char *name;
    Jsi_CmdSpec *spec;
    Jsi_DeleteProc *freefun;
    Jsi_UserObjIsTrueProc *istrue;
    Jsi_UserObjIsEquProc *isequ;
} Jsi_UserObjReg;

EXTERN Jsi_Hash* Jsi_UserObjRegister    (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 149*/
EXTERN int Jsi_UserObjUnregister  (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 150*/
EXTERN int Jsi_UserObjNew    (Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data); /*STUB = 151*/
EXTERN void* Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr); /*STUB = 152*/
/* */


/* UTILITY */
#define JSI_NOTUSED(n) n=n /* Eliminate annoying compiler warning. */
EXTERN char* Jsi_NumberToString(Jsi_Number d, char *buf); /*STUB = 289*/
EXTERN Jsi_Number Jsi_Version(void); /*STUB = 153*/
EXTERN Jsi_Value* Jsi_ReturnValue(Jsi_Interp *interp); /*STUB = 154*/
EXTERN int Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret); /*STUB = 155*/
EXTERN Jsi_Value* Jsi_Executable(Jsi_Interp *interp); /*STUB = 156*/
EXTERN Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int flag); /*STUB = 157*/
EXTERN void Jsi_RegExpFree(Jsi_Regex* re); /*STUB = 158*/
EXTERN int Jsi_RegExpMatch( Jsi_Interp *interp,  Jsi_Value *pattern, const char *str, int *rc, Jsi_DString *dStr); /*STUB = 159*/
EXTERN int Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, Jsi_Value *ret); /*STUB = 160*/
EXTERN int Jsi_GlobMatch(const char *pattern, const char *string, int nocase); /*STUB = 161*/
EXTERN char* Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *path, char *newpath); /*STUB = 162*/
EXTERN char* Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newpath); /*STUB = 163*/
EXTERN char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr); /*STUB = 164*/
EXTERN char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *path, Jsi_DString *dStr); /*STUB = 165*/
EXTERN int Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags); /*STUB = 166*/
EXTERN int Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) /*STUB = 167*/ __attribute__((format (printf,3,4)));;
EXTERN char* Jsi_JSONQuote(Jsi_Interp *interp, const char *cp, int len, Jsi_DString *dStr); /*STUB = 168*/
EXTERN char* Jsi_Itoa(int n); /*STUB = 169*/
EXTERN int Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags); /*STUB = 170*/
EXTERN int Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags); /*STUB = 171*/
EXTERN int Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr); /*STUB = 172*/
EXTERN void Jsi_SetResultFormatted(Jsi_Interp *interp, const char *fmt, ...); /*STUB = 173*/
EXTERN int Jsi_DictionaryCompare(const char *left, const char *right); /*STUB = 174*/
EXTERN int Jsi_GetBool(Jsi_Interp* interp, const char *string, int *n); /*STUB = 175*/
EXTERN int Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base); /*STUB = 176*/
EXTERN int Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *n, int base); /*STUB = 177*/
EXTERN int Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n); /*STUB = 178*/
EXTERN int Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr); /*STUB = 179*/
EXTERN void Jsi_SplitStr(const char *str, int *argcPtr, char ***argvPtr,  const char *s, Jsi_DString *dStr); /*STUB = 180*/
EXTERN void Jsi_Puts(Jsi_Interp *interp, Jsi_Value *v, int quote); /*STUB = 181*/
EXTERN int Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim); /*STUB = 182*/
EXTERN void Jsi_Preserve(Jsi_Interp* interp, void *data); /*STUB = 183*/
EXTERN void Jsi_Release(Jsi_Interp* interp, void *data); /*STUB = 184*/
EXTERN void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc); /*STUB = 185*/
EXTERN void Jsi_ShiftArgs(Jsi_Interp *interp); /*STUB = 186*/
EXTERN Jsi_Value* Jsi_StringSplit(Jsi_Interp *interp, char *str, char *spliton); /*STUB = 187*/
EXTERN int Jsi_GetIndex( Jsi_Interp *interp, char *str, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 188*/
EXTERN void* Jsi_PrototypeGet(Jsi_Interp *interp, const char *key); /*STUB = 189*/
EXTERN int  Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *proto); /*STUB = 190*/
EXTERN int Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj); /*STUB = 191*/
EXTERN int Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value); /*STUB = 192*/
EXTERN void* Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this); /*STUB = 193*/
EXTERN int Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Obj *o, Jsi_DString *dStr); /*STUB = 282*/
EXTERN void* Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var); /*STUB = 295*/
EXTERN const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str); /*STUB = 296*/
EXTERN const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str); /*STUB = 312*/
EXTERN int Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number date, const char *fmt, int isUtc, Jsi_DString *dStr);  /*STUB = 297*/
EXTERN int Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr); /*STUB = 298*/
EXTERN Jsi_Number Jsi_DateTime(void); /*STUB = 304*/
#define JSI_DATE_JULIAN2UNIX(d)  (Jsi_Number)(((Jsi_Number)d - 2440587.5)*86400.0)
#define JSI_DATE_UNIX2JULIAN(d)  (Jsi_Number)((Jsi_Number)d/86400.0+2440587.5)

EXTERN void Jsi_Md5Str(Jsi_Interp *interp, char outbuf[33], const char *str, int len); /*STUB = 301*/
EXTERN void Jsi_Sha1Str(Jsi_Interp *interp, char outbuf[41], const char *str, int len); /*STUB = 309*/
EXTERN void Jsi_Sha256Str(Jsi_Interp *interp, char outbuf[65], const char *str, int len); /*STUB = 310*/
EXTERN int Jsi_EncryptBuf(Jsi_Interp *interp, const char *key, int *buf, int len, int decrypt); /*STUB = 311*/
  
/* JSI_HASH */
typedef struct Jsi_HashSearch_ {
    Jsi_Hash *tablePtr;
    unsigned long nextIndex; 
    Jsi_HashEntry *nextEntryPtr;
} Jsi_HashSearch;

EXTERN Jsi_Hash* Jsi_HashNew (Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 194*/
EXTERN void Jsi_HashDelete (Jsi_Hash *hashPtr); /*STUB = 195*/
EXTERN Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *hashPtr, void *key, void *value); /*STUB = 196*/
EXTERN void* Jsi_HashGet(Jsi_Hash *hashPtr, void *key); /*STUB = 197*/
EXTERN void* Jsi_HashKeyGet(Jsi_HashEntry *h); /*STUB = 198*/
EXTERN int Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *hashPtr, Jsi_Value **ret, int flags); /*STUB = 199*/
EXTERN void* Jsi_HashValueGet(Jsi_HashEntry *h); /*STUB = 200*/
EXTERN void Jsi_HashValueSet(Jsi_HashEntry *h, void *value); /*STUB = 201*/
EXTERN Jsi_HashEntry* Jsi_HashEntryFind (Jsi_Hash *hashPtr, const void *key); /*STUB = 202*/
EXTERN Jsi_HashEntry* Jsi_HashEntryNew (Jsi_Hash *hashPtr, const void *key, int *isNew); /*STUB = 203*/
EXTERN int Jsi_HashEntryDelete (Jsi_HashEntry *entryPtr); /*STUB = 204*/
EXTERN Jsi_HashEntry* Jsi_HashEntryFirst (Jsi_Hash *hashPtr, Jsi_HashSearch *searchPtr); /*STUB = 205*/
EXTERN Jsi_HashEntry* Jsi_HashEntryNext (Jsi_HashSearch *srchPtr); /*STUB = 206*/
EXTERN int Jsi_HashSize(Jsi_Hash *hashPtr); /*STUB = 286*/
/* */


/* JSI_TREE */
typedef int (Jsi_TreeWalkProc)(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data);
typedef int (Jsi_RBCompareProc)(Jsi_Tree *treePtr, const void *key1, const void *key2);
typedef Jsi_TreeEntry* (Jsi_RBCreateProc)(Jsi_Tree *treePtr, const void *key, int *newPtr);

typedef struct Jsi_TreeSearch_ {
    Jsi_Tree *treePtr;
    unsigned int top, max, left, epoch; 
    int flags;
    Jsi_TreeEntry *staticPtrs[200], *current;
    Jsi_TreeEntry **Ptrs;
} Jsi_TreeSearch;

EXTERN Jsi_Tree* Jsi_TreeNew(Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 207*/
EXTERN void Jsi_TreeDelete(Jsi_Tree *treePtr); /*STUB = 208*/
EXTERN Jsi_TreeEntry* Jsi_TreeObjSetValue(Jsi_Obj* obj, const char *key, Jsi_Value *val, int isstrkey); /*STUB = 209*/
EXTERN Jsi_Value*     Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey); /*STUB = 210*/
EXTERN void* Jsi_TreeValueGet(Jsi_TreeEntry *hPtr); /*STUB = 211*/
EXTERN void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value); /*STUB = 212*/
EXTERN void* Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr); /*STUB = 213*/
EXTERN Jsi_TreeEntry* Jsi_TreeEntryFind(Jsi_Tree *treePtr, const void *key); /*STUB = 214*/
EXTERN Jsi_TreeEntry* Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, int *isNew); /*STUB = 215*/
EXTERN int Jsi_TreeEntryDelete(Jsi_TreeEntry *entryPtr); /*STUB = 216*/
EXTERN Jsi_TreeEntry* Jsi_TreeEntryFirst(Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags); /*STUB = 217*/
EXTERN void Jsi_TreeSearchDone(Jsi_TreeSearch *srchPtr); /*STUB = 218*/
EXTERN Jsi_TreeEntry* Jsi_TreeEntryNext(Jsi_TreeSearch *searchPtr); /*STUB = 219*/
EXTERN int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags); /*STUB = 220*/
EXTERN Jsi_TreeEntry* Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value); /*STUB = 221*/
EXTERN void* Jsi_TreeGet(Jsi_Tree *treePtr, void *key); /*STUB = 222*/
EXTERN int Jsi_TreeSize(Jsi_Tree *treePtr); /*STUB = 288*/ 
EXTERN Jsi_Tree* Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 294*/
EXTERN int Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *hashPtr, Jsi_Value **ret, int flags); /*STUB = 287*/
/* */


/* MAP */
typedef struct Jsi_MapSearch_ {
    Jsi_Map_Type typ;
    union {
        Jsi_TreeSearch tree;
        Jsi_HashSearch hash;
    } v;
} Jsi_MapSearch;

EXTERN Jsi_Map* Jsi_MapNew (Jsi_Interp *interp, Jsi_Map_Type listType, Jsi_Key_Type keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 313*/
EXTERN void Jsi_MapDelete (Jsi_Map *listPtr); /*STUB = 314*/
EXTERN Jsi_MapEntry* Jsi_MapSet(Jsi_Map *listPtr, void *key, void *value); /*STUB = 315*/
EXTERN void* Jsi_MapGet(Jsi_Map *listPtr, void *key); /*STUB = 316*/
EXTERN void* Jsi_MapKeyGet(Jsi_MapEntry *h); /*STUB = 317*/
EXTERN int Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *listPtr, Jsi_Value **ret, int flags); /*STUB = 318*/
EXTERN void* Jsi_MapValueGet(Jsi_MapEntry *h); /*STUB = 319*/
EXTERN void Jsi_MapValueSet(Jsi_MapEntry *h, void *value); /*STUB = 320*/
EXTERN Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *listPtr, const void *key); /*STUB = 321*/
EXTERN Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *listPtr, const void *key, int *isNew); /*STUB = 322*/
EXTERN int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr); /*STUB = 323*/
EXTERN Jsi_MapEntry* Jsi_MapEntryFirst (Jsi_Map *listPtr, Jsi_MapSearch *searchPtr); /*STUB = 324*/
EXTERN Jsi_MapEntry* Jsi_MapEntryNext (Jsi_MapSearch *srchPtr); /*STUB = 325*/
EXTERN int Jsi_MapSize(Jsi_Map *listPtr); /*STUB = 326*/
/* */


/* JSI_LIST */
typedef void (Jsi_ListDeleteProc)(Jsi_List *list, Jsi_ListEntry *l);
typedef int (Jsi_ListLockProc)(Jsi_List *list, int lock);

typedef struct Jsi_ListAttr {
    void *data;
    int valueSpace; // Space to allocate for each ListEntry: value will be set to point to it.
    int useMutex;
    Jsi_ListDeleteProc* freeProc;
    Jsi_ListLockProc* lockProc;
    Jsi_Map* map;
}  Jsi_ListAttr;

EXTERN Jsi_List* Jsi_ListNew(Jsi_ListAttr *attr); /*STUB = 327*/
EXTERN void Jsi_ListDelete(Jsi_List *list); /*STUB = 328*/
EXTERN void Jsi_ListClear(Jsi_List *list); /*STUB = 331*/
EXTERN int Jsi_ListSize(Jsi_List *list); /*STUB = 338*/
EXTERN int Jsi_ListLock(Jsi_List *list, int lock); /*STUB = 242*/
EXTERN void* Jsi_ListGetAttr(Jsi_List *list, Jsi_ListAttr **attr); /*STUB = 347*/   /*LAST STUB*/

EXTERN Jsi_ListEntry* Jsi_ListEntryNew(Jsi_List *list); /*STUB = 329*/
EXTERN void Jsi_ListEntryDelete(Jsi_ListEntry *l); /*STUB = 330*/

EXTERN Jsi_ListEntry* Jsi_ListInsert(Jsi_List *list, Jsi_ListEntry *item, Jsi_ListEntry *at); /*STUB = 332*/
EXTERN Jsi_ListEntry* Jsi_ListRemove(Jsi_List *list, Jsi_ListEntry *item); /*STUB = 333*/

EXTERN void* Jsi_ListEntryGetValue(Jsi_ListEntry *l); /*STUB = 334*/
EXTERN void Jsi_ListEntrySetValue(Jsi_ListEntry *l, void *value); /*STUB = 335*/
EXTERN Jsi_ListEntry* Jsi_ListEntryPrev(Jsi_ListEntry *l); /*STUB = 336*/
EXTERN Jsi_ListEntry* Jsi_ListEntryNext(Jsi_ListEntry *l); /*STUB = 337*/

EXTERN Jsi_ListEntry* Jsi_ListGetFront(Jsi_List *list); /*STUB = 339*/
EXTERN Jsi_ListEntry* Jsi_ListGetBack(Jsi_List *list); /*STUB = 340*/
EXTERN Jsi_ListEntry* Jsi_ListPopFront(Jsi_List *list); /*STUB = 341*/
EXTERN Jsi_ListEntry* Jsi_ListPopBack(Jsi_List *list); /*STUB = 342*/
EXTERN Jsi_ListEntry* Jsi_ListPushFront(Jsi_List *list, Jsi_ListEntry *item); /*STUB = 343*/
EXTERN Jsi_ListEntry* Jsi_ListPushBack(Jsi_List *list, Jsi_ListEntry *item); /*STUB = 344*/
EXTERN Jsi_ListEntry* Jsi_ListPushFrontNew(Jsi_List *list, void *value); /*STUB = 345*/
EXTERN Jsi_ListEntry* Jsi_ListPushBackNew(Jsi_List *list, void *value); /*STUB = 346*/


/* JSI_OPTIONS */
typedef int (Jsi_OptionParseProc) (
    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value *value, const char *str, void *record);
typedef int (Jsi_OptionFormatProc) (
    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value **retValue, Jsi_DString *retStr, void *record);
typedef int (Jsi_OptionFormatStringProc) (
    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_DString **retValue, void *record);
typedef void (Jsi_OptionFreeProc) (Jsi_Interp *interp, Jsi_OptionSpec *spec, void *ptr);

typedef int (Jsi_OptionBitOp)(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);

typedef struct {
    const char *name;
    Jsi_OptionParseProc *parseProc;
    Jsi_OptionFormatProc *formatProc;
    Jsi_OptionFreeProc *freeProc;
    const char *help;
    const char *info;
    void* data;
} Jsi_OptionCustom;

typedef enum {
    JSI_OPTION_NONE, JSI_OPTION_BOOL, JSI_OPTION_INT, JSI_OPTION_WIDE,
    JSI_OPTION_BYTE, JSI_OPTION_WORD, JSI_OPTION_DWORD, JSI_OPTION_QWORD,
    JSI_OPTION_DOUBLE, JSI_OPTION_STRING, JSI_OPTION_DSTRING, JSI_OPTION_STRKEY, JSI_OPTION_STRBUF,
    JSI_OPTION_VALUE, JSI_OPTION_VAR, JSI_OPTION_OBJ, JSI_OPTION_ARRAY,  JSI_OPTION_FUNC,
    JSI_OPTION_DATETIME,/* Javascript timestamp: double milliseconds since Jan 1, 1970. */
    JSI_OPTION_DATE,      /* JS date only: double milliseconds. */
    JSI_OPTION_TIME,      /* JS time only: double milliseconds. */
    JSI_OPTION_TIMESTAMP, /* Unix timestamp: time_t seconds since Jan 1, 1970. */
    JSI_OPTION_CUSTOM,    /* Custom */
    JSI_OPTION_END
} Jsi_OptionTypes;

typedef char Jsi_Strbuf[];

struct Jsi_OptionSpec_ {
    Jsi_OptionTypes type;
    const char *name;         /* The field name. */
    int offset;         /* Jsi_Offset of field. */
    int size;           /* The sizeof() of field. */
    const char *help;         /* A short one-line help string, without newlines. */
    Jsi_OptionCustom *custom;
    int flags;          /* Lower 16 bytes: the JSI_OPT_* flags below. Upper 16 for custom/other. */
    void *data;         /* User data for custom options: eg. the bit for BOOLBIT. */
    Jsi_OptionBitOp *bitop; /* Special custom handler for bitfields. */
    const char *info;         /* Longer command description. Use JSI_DETAIL macro to allow compile-out.*/
    const char *init;   /* Initial string value for info.cmds to display. */
    const char *extName;      /* External name: used by the DB interface. */
    int value;          /* Extra field. */
    const char *userData;     /* User extension data. */
    union { /* Simple compile-time type checking for arg type: JSI_OPT() will assign, but field is unused. */
        Jsi_Bool       *ini_BOOL;
        int            *ini_INT;
        Jsi_BYTE       *ini_BYTE;
        Jsi_Wide       *ini_WIDE;
        Jsi_WORD       *ini_WORD;
        Jsi_DWORD      *ini_DWORD;
        Jsi_QWORD      *ini_QWORD;
        Jsi_Number     *ini_DOUBLE;
        Jsi_Value*     *ini_STRING;
        Jsi_DString    *ini_DSTRING;
        const char*    *ini_STRKEY;
        Jsi_Strbuf     *ini_STRBUF;
        Jsi_Value*     *ini_VALUE;
        Jsi_Value*     *ini_VAR;
        Jsi_Obj*       *ini_OBJ;
        Jsi_Value*     *ini_ARRAY;
        Jsi_Value*     *ini_FUNC;
        time_t         *ini_TIMESTAMP;
        Jsi_Number     *ini_DATETIME;
        Jsi_Number     *ini_DATE;
        Jsi_Number     *ini_TIME;
        void           *ini_CUSTOM;
    } iniVal;
};

/* JSI_OPT: a macro that simplifies defining options, eg:
 * 
 *      typedef struct { int debug; int bool; } MyStruct;
 *      Jsi_OptionSpec MyOptions[] = {
 *          JSI_OPT(BOOL,  MyStruct,  debug, .help="Debug flag"),
 *          JSI_OPT(INT,   MyStruct,  max,   .help="Max value"),
 *          JSI_OPT_END(   MyStruct )
 *      }
*/

#define JSI_OPTI(typ, strct, nam, ...) \
    { .type=JSI_OPTION_##typ, .name=#nam, ##__VA_ARGS__ }
#define JSI_OPT(typ, strct, nam, ...) \
    { .type=JSI_OPTION_##typ, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \
      .iniVal.ini_##typ=(&((strct *) 0)->nam), ##__VA_ARGS__ }
#define JSI_OPT_END(strct,...) { .type=JSI_OPTION_END, .name=#strct, .size=sizeof(strct), \
      .extName=__FILE__, .offset=__LINE__, ##__VA_ARGS__}

/* Custom options that are builtin. */
#define Jsi_Opt_SwitchEnum          (Jsi_OptionCustom*)0x1 /* Enum with .data=stringlist */
#define Jsi_Opt_SwitchBitset        (Jsi_OptionCustom*)0x2 /* Bits with .data=stringlist */
#define Jsi_Opt_SwitchSuboption     (Jsi_OptionCustom*)0x3 /* Sub-structs with .data=<sub-Option> */
#define Jsi_Opt_SwitchCBitField     (Jsi_OptionCustom*)0x4 /* C bitfields. */
#define Jsi_Opt_SwitchValueVerify   (Jsi_OptionCustom*)0x5 /* Provide callback to verify Jsi_Value* is correct. */

enum {
    /* Flags for Jsi_OptionsProcess, etc */
    JSI_OPTS_PREFIX         =   (1<<0), /* Allow matching unique prefix of object members. */
    JSI_OPTS_IS_UPDATE      =   (1<<1), /* This is an update/conf (do not reset the specified flags) */
    JSI_OPTS_IGNORE_EXTRA   =   (1<<2), /* Ignore extra members not found in spec. */
    JSI_OPTS_FORCE_STRICT   =   (1<<3), /* Complain about unknown options, even when noStrict is used. */
    JSI_OPTS_VERBOSE        =   (1<<4), /* Dump verbose options */

    /* Per option flags. */
    JSI_OPT_IS_SPECIFIED    =   (1<<0),  /* User set the option. */
    JSI_OPT_INIT_ONLY       =   (1<<1),  /* Allow set only at init, disallow update/conf. */
    JSI_OPT_READ_ONLY       =   (1<<2),  /* Value can never be set. */
    JSI_OPT_NO_DUPVALUE     =   (1<<3),  /* Values are not to be duped. */
    JSI_OPT_NO_CLEAR        =   (1<<4),  /* Values are not to be cleared: watch for memory leaks */
    JSI_OPT_DB_DIRTY        =   (1<<8),  /* Used to limit DB updates. */
    JSI_OPT_DB_IGNORE       =   (1<<9),  /* Field is not to be used for DB. */
    JSI_OPT_DB_ROWID        =   (1<<10),  /* Used by DB to store rowid. */
    JSI_OPT_CUST_NOCASE     =   (1<<11),  /* Ignore case (eg. for ENUM and BITSET). */
    JSI_OPT_FORCE_INT       =   (1<<12),  /* Force int instead of text for enum/bitset. */
    JSI_OPT_BITFIELD_BOOL   =   (1<<13),  /* Treat bitfield as bool. */
    JSI_OPT_RESERVE_FLAG3   =   (1<<14),  /* Reserved flags. */
    JSI_OPT_RESERVE_FLAG4   =   (1<<15),  /* Reserved flags. */
    
    JSI_OPTIONS_USER_FIRSTBIT  =   16,      /* User flags bit start: the lower 2 bytes are internal. */
};


EXTERN const char* Jsi_OptionTypeStr(Jsi_OptionTypes typ, int tname); /*STUB = 223*/
EXTERN int Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_Value *value, void *data, int flags); /*STUB = 224*/
EXTERN int Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_Value *value, void *data, Jsi_Value **ret, int flags); /*STUB = 225*/
EXTERN int Jsi_OptionsChanged (Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *pattern, ...) /*STUB = 226*/ __attribute__((sentinel));
EXTERN void Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, int flags); /*STUB = 227*/
EXTERN int Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, const char *option, Jsi_Value** valuePtr, int flags); /*STUB = 228*/
EXTERN int Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *option, void* data, Jsi_Value *value, int flags); /*STUB = 229*/
EXTERN int Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value** ret, int flags); /*STUB = 230*/
EXTERN int Jsi_OptionsValid(Jsi_Interp *interp,  Jsi_OptionSpec* spec);  /*STUB = 307*/
EXTERN Jsi_Value* Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *optionName, void *data, int offset); /*STUB = 231*/
EXTERN Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust); /*STUB = 299*/
/* Create a duplicate of static specs.   Use this for threaded access to Jsi_OptionsChanged(). */
EXTERN Jsi_OptionSpec* Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs); /*STUB = 232*/
/* */


/* JSI_DB */
/* Struct for array to bind a different Option/Data pair to each of the SQLite binding chars. */
typedef struct Jsi_DbMultipleBind {
    char prefix;            /* Char bind prefix. One of: '@' '$' ':' '?' or 0 for any */
    Jsi_OptionSpec *opts;   /* Option fields for the above struct. */
    void *data;             /* Struct data pointer/array */
    int numData;            /* Number of elements in data array: <= 0 means 1. */
    int flags;
    int (*callback)(Jsi_Interp *interp, struct Jsi_DbMultipleBind* obPtr, void *data); /* Select callback. */
} Jsi_DbMultipleBind;

EXTERN Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags); /*STUB = 305*/
EXTERN int Jsi_DbQuery(Jsi_Db *jdb, Jsi_OptionSpec *spec, void *data, int numData, const char *query, int flags); /*STUB = 300*/
EXTERN void* Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* db); /*STUB = 302*/
EXTERN int Jsi_CDataRegister(Jsi_Interp *interp, const char *name, Jsi_OptionSpec *spec, void *data, int numData, int flags); /*STUB = 303*/
EXTERN Jsi_DbMultipleBind* Jsi_CDataLookup(Jsi_Interp *interp, const char *name); /*STUB = 306*/
/* */


/* STACK */
typedef struct {
    int len;
    int maxlen;
    void **vector;
} Jsi_Stack;

EXTERN Jsi_Stack* Jsi_StackNew(void); /*STUB = 233*/
EXTERN void Jsi_StackFree(Jsi_Stack *stack); /*STUB = 234*/
EXTERN int Jsi_StackLen(Jsi_Stack *stack); /*STUB = 235*/
EXTERN void Jsi_StackPush(Jsi_Stack *stack, void *element); /*STUB = 236*/
EXTERN void* Jsi_StackPop(Jsi_Stack *stack); /*STUB = 237*/
EXTERN void* Jsi_StackPeek(Jsi_Stack *stack); /*STUB = 238*/
EXTERN void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeFunc); /*STUB = 239*/
/* */

/* THREADS/MUTEX */
EXTERN int Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 240*/
EXTERN void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 241*/
EXTERN void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 243*/
EXTERN Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags); /*STUB = 244*/
EXTERN void* Jsi_CurrentThread(void); /*STUB = 245*/
EXTERN void* Jsi_InterpThread(Jsi_Interp *interp); /*STUB = 246*/
/* */


/* LOG MESSAGES */
#if (defined(_JSI_LOG_PRINTF_) || defined(JSI_LITE_ONLY))
#define Jsi_LogFatal(fmt,...) fprintf(stderr, "FATAL: " fmt "\n", ##__VA_ARGS__)
#define Jsi_LogError(fmt,...) fprintf(stderr, "ERROR: " fmt "\n", ##__VA_ARGS__)
#define Jsi_LogParse(fmt,...) fprintf(stderr, "PARSE: " fmt "\n", ##__VA_ARGS__)
#define Jsi_LogWarn(fmt,...) fprintf(stderr, "WARN: " fmt "\n", ##__VA_ARGS__)
#define Jsi_LogInfo(fmt,...) printf(stderr, "INFO: " fmt "\n", ##__VA_ARGS__)
#define Jsi_LogBug(fmt,...) fprintf(stderr, "BUG: " fmt "\n", ##__VA_ARGS__)
#else
#define Jsi_LogFatal(fmt,...) Jsi_LogMsg(interp, JSI_LOG_FATAL, fmt, ##__VA_ARGS__)
#define Jsi_LogError(fmt,...) Jsi_LogMsg(interp, JSI_LOG_ERROR, fmt, ##__VA_ARGS__)
#define Jsi_LogParse(fmt,...) Jsi_LogMsg(interp, JSI_LOG_PARSE, fmt, ##__VA_ARGS__)
#define Jsi_LogWarn(fmt,...) Jsi_LogMsg(interp, JSI_LOG_WARN, fmt, ##__VA_ARGS__)
#define Jsi_LogInfo(fmt,...) Jsi_LogMsg(interp, JSI_LOG_INFO, fmt, ##__VA_ARGS__)
#define Jsi_LogBug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_BUG, fmt, ##__VA_ARGS__)
#endif
EXTERN void Jsi_LogMsg(Jsi_Interp *interp, int level, const char *format,...)  /*STUB = 247*/ __attribute__((format (printf,3,4)));


/* JSI_EVENT */
typedef struct {
    int sig;
    unsigned int id;
    int evType;                 /* Is signal handler. */
    int sigNum;
    int once;                   /* Execute once */
    long initialms;             /* initial relative timer value */
    long when_sec;              /* seconds */
    long when_ms;               /* milliseconds */
    unsigned int count;         /* Times executed */
    Jsi_HashEntry *hPtr;
    Jsi_Value *funcVal;         /* JS Function to call. */
    Jsi_EventHandlerProc *handler;  /* C-function handler. */
    void *data;
} Jsi_Event;

EXTERN Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data); /*STUB = 248*/
EXTERN void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event); /*STUB = 249*/
EXTERN int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents); /*STUB = 250*/
/* */


/* VFS - VIRTUAL FILESYSTEM */
#include <sys/stat.h>
#include <stdio.h> 
#include <dirent.h>

struct Jsi_Chan_;
struct Jsi_StatBuf_;
struct Jsi_LoadHandle_;
struct Jsi_Dirent_;

typedef struct Jsi_LoadHandle Jsi_LoadHandle;
typedef struct Jsi_Chan* Jsi_Channel;
typedef struct stat Jsi_StatBuf;
typedef struct dirent Jsi_Dirent;

typedef int (Jsi_FSStatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);
typedef int (Jsi_FSAccessProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);
typedef int (Jsi_FSChmodProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);
typedef Jsi_Channel (Jsi_FSOpenProc) (Jsi_Interp *interp, Jsi_Value* path, const char* modes);
typedef int (Jsi_FSLstatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);
typedef int (Jsi_FSCreateDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path);
typedef int (Jsi_FSRemoveProc) (Jsi_Interp *interp, Jsi_Value* path, int flags);
typedef int (Jsi_FSCopyDirectoryProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr, Jsi_Value **errorPtr);
typedef int (Jsi_FSCopyFileProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);
typedef int (Jsi_FSRemoveDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path, int recursive, Jsi_Value **errorPtr);
typedef int (Jsi_FSRenameProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);
typedef Jsi_Value * (Jsi_FSListVolumesProc) (Jsi_Interp *interp);
typedef char* (Jsi_FSRealPathProc) (Jsi_Interp *interp, Jsi_Value* path, char *newPath);
typedef int (Jsi_FSLinkProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType);
typedef int (Jsi_FSReadlinkProc)(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size);
typedef int (Jsi_FSReadProc)(Jsi_Channel chan, char *buf, int size);
typedef int (Jsi_FSGetcProc)(Jsi_Channel chan);
typedef int (Jsi_FSEofProc)(Jsi_Channel chan);
typedef int (Jsi_FSTruncateProc)(Jsi_Channel chan, unsigned int len);
typedef int (Jsi_FSUngetcProc)(Jsi_Channel chan, int ch);
typedef char *(Jsi_FSGetsProc)(Jsi_Channel chan, char *s, int size);
typedef int (Jsi_FSWriteProc)(Jsi_Channel chan, const char *buf, int size);
typedef int (Jsi_FSFlushProc)(Jsi_Channel chan);
typedef int (Jsi_FSSeekProc)(Jsi_Channel chan, Jsi_Wide offset, int mode);
typedef int (Jsi_FSTellProc)(Jsi_Channel chan);
typedef int (Jsi_FSCloseProc)(Jsi_Channel chan);
typedef int (Jsi_FSRewindProc)(Jsi_Channel chan);
typedef int (Jsi_FSPathInFilesystemProc) (Jsi_Interp *interp, Jsi_Value* path,void* *clientDataPtr);
typedef int (Jsi_FSScandirProc)(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,
  int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**));

typedef struct Jsi_Filesystem {
    const char *typeName;
    int structureLength;    
    int version;
    Jsi_FSPathInFilesystemProc *pathInFilesystemProc;
    Jsi_FSRealPathProc *realpathProc;
    Jsi_FSStatProc *statProc;
    Jsi_FSLstatProc *lstatProc;
    Jsi_FSAccessProc *accessProc;
    Jsi_FSChmodProc *chmodProc;
    Jsi_FSOpenProc *openProc;
    Jsi_FSScandirProc *scandirProc;
    Jsi_FSReadProc *readProc;
    Jsi_FSWriteProc *writeProc;
    Jsi_FSGetsProc *getsProc;
    Jsi_FSGetcProc *getcProc;
    Jsi_FSUngetcProc *ungetcProc;
    
    Jsi_FSFlushProc *flushProc;
    Jsi_FSSeekProc *seekProc;
    Jsi_FSTellProc *tellProc;
    Jsi_FSEofProc *eofProc;
    Jsi_FSTruncateProc *truncateProc;
    Jsi_FSRewindProc *rewindProc;
    Jsi_FSCloseProc *closeProc;
    Jsi_FSLinkProc *linkProc;
    Jsi_FSReadlinkProc *readlinkProc;
    Jsi_FSListVolumesProc *listVolumesProc;
    Jsi_FSCreateDirectoryProc *createDirectoryProc;
    Jsi_FSRemoveProc *removeProc;
    Jsi_FSRenameProc *renameProc;
} Jsi_Filesystem;

typedef struct Jsi_Chan {
    Jsi_Interp *interp;
    FILE *fp;
    const char *fname;  /* May be set by fs or by source */
    Jsi_Filesystem *fsPtr;
    int isNative;
    int flags;
    char modes[JSI_FSMODESIZE];
    void *data;
} Jsi_Chan;

EXTERN int Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data); /*STUB = 251*/
EXTERN int Jsi_FSUnregister(Jsi_Filesystem *fsPtr); /*STUB = 252*/
EXTERN Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name); /*STUB = 253*/
EXTERN char* Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr); /*STUB = 254*/
EXTERN int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 255*/
EXTERN int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 256*/
EXTERN int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 257*/
EXTERN int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags); /*STUB = 258*/
EXTERN int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst); /*STUB = 259*/
EXTERN int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 260*/
EXTERN Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString); /*STUB = 261*/
EXTERN int Jsi_Eof(Jsi_Channel chan); /*STUB = 262*/
EXTERN int Jsi_Close(Jsi_Channel chan); /*STUB = 263*/
EXTERN int Jsi_Read(Jsi_Channel chan, char *bufPtr, int toRead); /*STUB = 264*/
EXTERN int Jsi_Write(Jsi_Channel chan, const char *bufPtr, int slen); /*STUB = 265*/
EXTERN Jsi_Wide Jsi_Seek(Jsi_Channel chan, Jsi_Wide offset, int mode); /*STUB = 266*/
EXTERN Jsi_Wide Jsi_Tell(Jsi_Channel chan); /*STUB = 267*/
EXTERN int Jsi_Truncate(Jsi_Channel chan, unsigned int len); /*STUB = 268*/
EXTERN Jsi_Wide Jsi_Rewind(Jsi_Channel chan); /*STUB = 269*/
EXTERN int Jsi_Flush(Jsi_Channel chan); /*STUB = 270*/
EXTERN int Jsi_Getc(Jsi_Channel chan); /*STUB = 271*/
EXTERN int Jsi_Printf(Jsi_Channel chan, const char *fmt, ...) /*STUB = 272*/ __attribute__((format (printf,2,3))); 
EXTERN int Jsi_Ungetc(Jsi_Channel chan, int ch); /*STUB = 273*/
EXTERN char* Jsi_Gets(Jsi_Channel chan, char *s, int size); /*STUB = 274*/
typedef int (Jsi_ScandirFilter)(const Jsi_Dirent *);
typedef int (Jsi_ScandirCompare)(const Jsi_Dirent **, const Jsi_Dirent**);
EXTERN int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist, Jsi_ScandirFilter *filter, Jsi_ScandirCompare *compare ); /*STUB = 275*/
EXTERN int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName, const char *newValue); /*STUB = 276*/
EXTERN char* Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *path, char *newname); /*STUB = 277*/
EXTERN int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len); /*STUB = 279*/
EXTERN Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id); /*STUB = 280*/
EXTERN int Jsi_IsNative(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 281*/
EXTERN int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ); /*STUB = 291*/
EXTERN int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 292*/

EXTERN int Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr); /*STUB = 283*/
EXTERN int Jsi_AddIndexFiles(Jsi_Interp *interp, const char *dir);  /*STUB = 284*/
EXTERN int Jsi_ExecZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound); /*STUB = 285*/
#ifndef JSI_ZVFS_DIR
#define JSI_ZVFS_DIR "/zvfs"
#endif
/* */


#define JSI_STUBS_STRUCTSIZES (sizeof(Jsi_ListAttr)+sizeof(Jsi_MapSearch)+sizeof(Jsi_TreeSearch) \
    +sizeof(Jsi_HashSearch)+sizeof(Jsi_Filesystem)+sizeof(Jsi_Chan)+sizeof(Jsi_Event) \
    +sizeof(Jsi_DbMultipleBind)+sizeof(Jsi_Stack)+sizeof(Jsi_OptionSpec)+sizeof(Jsi_CmdSpec) \
    +sizeof(Jsi_UserObjReg)+sizeof(Jsi_String))

#ifdef JSI_USE_STUBS
#ifndef JSISTUBCALL
#define JSISTUBCALL(ptr,func) ptr->func
#endif
#include "jsiStubs.h"
#else
#define JSI_EXTENSION_INI
#define Jsi_StubsInit(i,f) JSI_OK
#endif



#endif /* __JSI_H__ */
#define JSI_AMALGAMATION
#ifdef __WIN32
/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Change History
     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major release with Zip64 support (almost there!):
       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug (thanks kahmyong.moon@hp.com) which could cause locate files to not find files. This bug
        would only have occured in earlier versions if you explicitly used this flag, OR if you used mz_zip_extract_archive_file_to_heap() or mz_zip_add_mem_to_archive_file_in_place()
        (which used this flag). If you can't switch to v1.15 but want to fix this bug, just remove the uses of this flag from both helper funcs (and of course don't use the flag).
       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when pUser_read_buf is not NULL and compressed size is > uncompressed size
       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract compressed data from directory entries, to account for weird zipfiles which contain zero-size compressed data on dir entries.
         Hopefully this fix won't cause any issues on weird zip archives, because it assumes the low 16-bits of zip external attributes are DOS attributes (which I believe they always are in practice).
       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the internal attributes, just the filename and external attributes
       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
       - Added cmake support for Linux builds which builds all the examples, tested with clang v3.3 and gcc v4.6.
       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
       - Merged MZ_FORCEINLINE fix from hdeanclark
       - Fix <time.h> include before config #ifdef, thanks emil.brink
       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping (super useful for OpenGL apps), and explicit control over the compression level (so you can
        set it to 1 for real-time compression).
       - Merged in some compiler fixes from paulharris's github repro.
       - Retested this build under Windows (VS 2010, including static analysis), tcc  0.9.26, gcc v4.6 and clang v3.3.
       - Added example6.c, which dumps an image of the mandelbrot set to a PNG file.
       - Modified example2 to help test the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix possible src file fclose() leak if alignment bytes+local header file write faiiled
         - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader(): Was pushing the wrong central dir header offset, appears harmless in this release, but it became a problem in the zip64 branch
     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).
     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
       - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and re-ran a randomized regression test on ~500k files.
       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly
        "Use of the comma-operator in a tested expression.." analysis warning, which I purposely use to work around a MSVC compiler warning).
       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.
       - Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.
       - Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.
       - Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)
       - Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).
     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.
      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.
     5/28/11 v1.11 - Added statement from unlicense.org
     5/27/11 v1.10 - Substantial compressor optimizations:
      - Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a
      - Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).
      - Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.
      - Refactored the compression code for better readability and maintainability.
      - Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large
       drop in throughput on some files).
     5/15/11 v1.09 - Initial stable release.

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/

#ifndef MINIZ_HEADER_INCLUDED
#define MINIZ_HEADER_INCLUDED

#include <stdlib.h>

// Defines to completely disable specific portions of miniz.c:
// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.

// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O.
//#define MINIZ_NO_STDIO

// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or
// get/set file times, and the C run-time funcs that get/set times won't be called.
// The current downside is the times written to your archives will be from 1979.
//#define MINIZ_NO_TIME

// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
//#define MINIZ_NO_ARCHIVE_APIS

// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive API's.
//#define MINIZ_NO_ARCHIVE_WRITING_APIS

// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's.
//#define MINIZ_NO_ZLIB_APIS

// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib.
//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES

// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.
//#define MINIZ_NO_MALLOC

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
  // TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux
  #define MINIZ_NO_TIME
#endif

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
  #include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
#define MINIZ_X86_OR_X64_CPU 1
#endif

#if (__BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
#define MINIZ_LITTLE_ENDIAN 1
#endif

#if MINIZ_X86_OR_X64_CPU
// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).
#define MINIZ_HAS_64BIT_REGISTERS 1
#endif

#ifdef __cplusplus
extern "C" {
#endif

// ------------------- zlib-style API Definitions.

// For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
typedef unsigned long mz_ulong;

// mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.
void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
// mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.
mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
// mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.
mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

// Compression strategies.
enum { MZ_DEFAULT_STRATEGY = 0, MZ_FILTERED = 1, MZ_HUFFMAN_ONLY = 2, MZ_RLE = 3, MZ_FIXED = 4 };

// Method
#define MZ_DEFLATED 8

#ifndef MINIZ_NO_ZLIB_APIS

// Heap allocation callbacks.
// Note that mz_alloc_func parameter types purpsosely differ from zlib's: items/size is size_t, not unsigned long.
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);

#define MZ_VERSION          "9.1.15"
#define MZ_VERNUM           0x91F0
#define MZ_VER_MAJOR        9
#define MZ_VER_MINOR        1
#define MZ_VER_REVISION     15
#define MZ_VER_SUBREVISION  0

// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs).
enum { MZ_NO_FLUSH = 0, MZ_PARTIAL_FLUSH = 1, MZ_SYNC_FLUSH = 2, MZ_FULL_FLUSH = 3, MZ_FINISH = 4, MZ_BLOCK = 5 };

// Return status codes. MZ_PARAM_ERROR is non-standard.
enum { MZ_OK = 0, MZ_STREAM_END = 1, MZ_NEED_DICT = 2, MZ_ERRNO = -1, MZ_STREAM_ERROR = -2, MZ_DATA_ERROR = -3, MZ_MEM_ERROR = -4, MZ_BUF_ERROR = -5, MZ_VERSION_ERROR = -6, MZ_PARAM_ERROR = -10000 };

// Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
enum { MZ_NO_COMPRESSION = 0, MZ_BEST_SPEED = 1, MZ_BEST_COMPRESSION = 9, MZ_UBER_COMPRESSION = 10, MZ_DEFAULT_LEVEL = 6, MZ_DEFAULT_COMPRESSION = -1 };

// Window bits
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

// Compression/decompression stream struct.
typedef struct mz_stream_s
{
  /*const*/ unsigned char *next_in;     // pointer to next byte to read
  unsigned int avail_in;            // number of bytes available at next_in
  mz_ulong total_in;                // total number of bytes consumed so far

  unsigned char *next_out;          // pointer to next byte to write
  unsigned int avail_out;           // number of bytes that can be written to next_out
  mz_ulong total_out;               // total number of bytes produced so far

  char *msg;                        // error msg (unused)
  struct mz_internal_state *state;  // internal state, allocated by zalloc/zfree

  mz_alloc_func zalloc;             // optional heap allocation function (defaults to malloc)
  mz_free_func zfree;               // optional heap free function (defaults to free)
  void *opaque;                     // heap alloc function user pointer

  int data_type;                    // data_type (unused)
  mz_ulong adler;                   // adler32 of the source or uncompressed data
  mz_ulong reserved;                // not used
} mz_stream;

typedef mz_stream *mz_streamp;

// Returns the version string of miniz.c.
const char *mz_version(void);

// mz_deflateInit() initializes a compressor with default options:
// Parameters:
//  pStream must point to an initialized mz_stream struct.
//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
//  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.
//  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
// Return values:
//  MZ_OK on success.
//  MZ_STREAM_ERROR if the stream is bogus.
//  MZ_PARAM_ERROR if the input parameters are bogus.
//  MZ_MEM_ERROR on out of memory.
int mz_deflateInit(mz_streamp pStream, int level);

// mz_deflateInit2() is like mz_deflate(), except with more control:
// Additional parameters:
//   method must be MZ_DEFLATED
//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)
//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

// Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
int mz_deflateReset(mz_streamp pStream);

// mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.
// Parameters:
//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH.
// Return values:
//   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).
//   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore.
//   MZ_STREAM_ERROR if the stream is bogus.
//   MZ_PARAM_ERROR if one of the parameters is invalid.
//   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)
int mz_deflate(mz_streamp pStream, int flush);

// mz_deflateEnd() deinitializes a compressor:
// Return values:
//  MZ_OK on success.
//  MZ_STREAM_ERROR if the stream is bogus.
int mz_deflateEnd(mz_streamp pStream);

// mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH.
mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

// Single-call compression functions mz_compress() and mz_compress2():
// Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure.
int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

// mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress().
mz_ulong mz_compressBound(mz_ulong source_len);

// Initializes a decompressor.
int mz_inflateInit(mz_streamp pStream);

// mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:
// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate).
int mz_inflateInit2(mz_streamp pStream, int window_bits);

// Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.
// Parameters:
//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
//   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).
//   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.
// Return values:
//   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.
//   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.
//   MZ_STREAM_ERROR if the stream is bogus.
//   MZ_DATA_ERROR if the deflate stream is invalid.
//   MZ_PARAM_ERROR if one of the parameters is invalid.
//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again
//   with more input data, or with more room in the output buffer (except when using single call decompression, described above).
int mz_inflate(mz_streamp pStream, int flush);

// Deinitializes a decompressor.
int mz_inflateEnd(mz_streamp pStream);

// Single-call decompression.
// Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure.
int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);

// Returns a string description of the specified error code, or NULL if the error code is invalid.
const char *mz_error(int err);

// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports.
// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
  typedef unsigned char Byte;
  typedef unsigned int uInt;
  typedef mz_ulong uLong;
  typedef Byte Bytef;
  typedef uInt uIntf;
  typedef char charf;
  typedef int intf;
  typedef void *voidpf;
  typedef uLong uLongf;
  typedef void *voidp;
  typedef void *const voidpc;
  #define Z_NULL                0
  #define Z_NO_FLUSH            MZ_NO_FLUSH
  #define Z_PARTIAL_FLUSH       MZ_PARTIAL_FLUSH
  #define Z_SYNC_FLUSH          MZ_SYNC_FLUSH
  #define Z_FULL_FLUSH          MZ_FULL_FLUSH
  #define Z_FINISH              MZ_FINISH
  #define Z_BLOCK               MZ_BLOCK
  #define Z_OK                  MZ_OK
  #define Z_STREAM_END          MZ_STREAM_END
  #define Z_NEED_DICT           MZ_NEED_DICT
  #define Z_ERRNO               MZ_ERRNO
  #define Z_STREAM_ERROR        MZ_STREAM_ERROR
  #define Z_DATA_ERROR          MZ_DATA_ERROR
  #define Z_MEM_ERROR           MZ_MEM_ERROR
  #define Z_BUF_ERROR           MZ_BUF_ERROR
  #define Z_VERSION_ERROR       MZ_VERSION_ERROR
  #define Z_PARAM_ERROR         MZ_PARAM_ERROR
  #define Z_NO_COMPRESSION      MZ_NO_COMPRESSION
  #define Z_BEST_SPEED          MZ_BEST_SPEED
  #define Z_BEST_COMPRESSION    MZ_BEST_COMPRESSION
  #define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
  #define Z_DEFAULT_STRATEGY    MZ_DEFAULT_STRATEGY
  #define Z_FILTERED            MZ_FILTERED
  #define Z_HUFFMAN_ONLY        MZ_HUFFMAN_ONLY
  #define Z_RLE                 MZ_RLE
  #define Z_FIXED               MZ_FIXED
  #define Z_DEFLATED            MZ_DEFLATED
  #define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
  #define alloc_func            mz_alloc_func
  #define free_func             mz_free_func
  #define internal_state        mz_internal_state
  #define z_stream              mz_stream
  #define deflateInit           mz_deflateInit
  #define deflateInit2          mz_deflateInit2
  #define deflateReset          mz_deflateReset
  #define deflate               mz_deflate
  #define deflateEnd            mz_deflateEnd
  #define deflateBound          mz_deflateBound
  #define compress              mz_compress
  #define compress2             mz_compress2
  #define compressBound         mz_compressBound
  #define inflateInit           mz_inflateInit
  #define inflateInit2          mz_inflateInit2
  #define inflate               mz_inflate
  #define inflateEnd            mz_inflateEnd
  #define uncompress            mz_uncompress
  #define crc32                 mz_crc32
  #define adler32               mz_adler32
  #define MAX_WBITS             15
  #define MAX_MEM_LEVEL         9
  #define zError                mz_error
  #define ZLIB_VERSION          MZ_VERSION
  #define ZLIB_VERNUM           MZ_VERNUM
  #define ZLIB_VER_MAJOR        MZ_VER_MAJOR
  #define ZLIB_VER_MINOR        MZ_VER_MINOR
  #define ZLIB_VER_REVISION     MZ_VER_REVISION
  #define ZLIB_VER_SUBREVISION  MZ_VER_SUBREVISION
  #define zlibVersion           mz_version
  #define zlib_version          mz_version()
#endif // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES

#endif // MINIZ_NO_ZLIB_APIS

// ------------------- Types and macros

typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef long long mz_int64;
typedef unsigned long long mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

// An attempt to work around MSVC's spammy "warning C4127: conditional expression is constant" message.
#ifdef _MSC_VER
   #define MZ_MACRO_END while (0, 0)
#else
   #define MZ_MACRO_END while (0)
#endif

// ------------------- ZIP archive reading/writing

#ifndef MINIZ_NO_ARCHIVE_APIS

enum
{
  MZ_ZIP_MAX_IO_BUF_SIZE = 64*1024,
  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
};

typedef struct
{
  mz_uint32 m_file_index;
  mz_uint32 m_central_dir_ofs;
  mz_uint16 m_version_made_by;
  mz_uint16 m_version_needed;
  mz_uint16 m_bit_flag;
  mz_uint16 m_method;
#ifndef MINIZ_NO_TIME
  time_t m_time;
#endif
  mz_uint32 m_crc32;
  mz_uint64 m_comp_size;
  mz_uint64 m_uncomp_size;
  mz_uint16 m_internal_attr;
  mz_uint32 m_external_attr;
  mz_uint64 m_local_header_ofs;
  mz_uint32 m_comment_size;
  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum
{
  MZ_ZIP_MODE_INVALID = 0,
  MZ_ZIP_MODE_READING = 1,
  MZ_ZIP_MODE_WRITING = 2,
  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef struct mz_zip_archive_tag
{
  mz_uint64 m_archive_size;
  mz_uint64 m_central_directory_file_ofs;
  mz_uint m_total_files;
  mz_zip_mode m_zip_mode;

  mz_uint m_file_offset_alignment;

  mz_alloc_func m_pAlloc;
  mz_free_func m_pFree;
  mz_realloc_func m_pRealloc;
  void *m_pAlloc_opaque;

  mz_file_read_func m_pRead;
  mz_file_write_func m_pWrite;
  void *m_pIO_opaque;

  mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef enum
{
  MZ_ZIP_FLAG_CASE_SENSITIVE                = 0x0100,
  MZ_ZIP_FLAG_IGNORE_PATH                   = 0x0200,
  MZ_ZIP_FLAG_COMPRESSED_DATA               = 0x0400,
  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
} mz_zip_flags;

// ZIP archive reading

// Inits a ZIP archive reader.
// These functions read and validate the archive's central directory.
mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags);
mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags);

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
#endif

// Returns the total number of files in the archive.
mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

// Returns detailed information about an archive file entry.
mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

// Determines if an archive file entry is a directory entry.
mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);
mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

// Retrieves the filename of an archive file entry.
// Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename.
mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

// Attempts to locates a file in the archive's central directory.
// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
// Returns -1 if the file cannot be found.
int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

// Extracts a archive file to a memory buffer using no memory allocation.
mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

// Extracts a archive file to a memory buffer.
mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

// Extracts a archive file to a dynamically allocated heap buffer.
void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

// Extracts a archive file using a callback function to output the file's data.
mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

#ifndef MINIZ_NO_STDIO
// Extracts a archive file to a disk file and sets its last accessed and modified times.
// This function only extracts files, not archive directory records.
mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);
#endif

// Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used.
mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

// ZIP archive writing

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

// Inits a ZIP archive writer.
mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
#endif

// Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.
// For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called.
// For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it).
// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL.
// Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before
// the archive is finalized the file's central directory will be hosed.
mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);

// Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive.
// To add a directory entry, call this method with an archive name ending in a forwardslash with empty buffer.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);
mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

#ifndef MINIZ_NO_STDIO
// Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
#endif

// Adds a file to an archive by fully cloning the data from another archive.
// This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data, and comment fields.
mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index);

// Finalizes the archive by writing the central directory records followed by the end of central directory record.
// After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end().
// An archive must be manually finalized by calling this function for it to be valid.
mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize);

// Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used.
// Note for the archive to be valid, it must have been finalized before ending.
mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

// Misc. high-level helper functions:

// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

// Reads a single file from an archive into a heap block.
// Returns NULL on failure.
void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint zip_flags);

#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

#endif // #ifndef MINIZ_NO_ARCHIVE_APIS

// ------------------- Low-level Decompression API Definitions

// Decompression flags used by tinfl_decompress().
// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.
// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.
// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).
// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.
enum
{
  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
  TINFL_FLAG_HAS_MORE_INPUT = 2,
  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
  TINFL_FLAG_COMPUTE_ADLER32 = 8
};

// High level decompression functions:
// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().
// On entry:
//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.
// On return:
//  Function returns a pointer to the decompressed data, or NULL on failure.
//  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.
//  The caller must call mz_free() on the returned block when it's no longer needed.
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.
// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

// tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.
// Returns 1 on success or 0 on failure.
typedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);
int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag; typedef struct tinfl_decompressor_tag tinfl_decompressor;

// Max size of LZ dictionary.
#define TINFL_LZ_DICT_SIZE 32768

// Return status.
typedef enum
{
  TINFL_STATUS_BAD_PARAM = -3,
  TINFL_STATUS_ADLER32_MISMATCH = -2,
  TINFL_STATUS_FAILED = -1,
  TINFL_STATUS_DONE = 0,
  TINFL_STATUS_NEEDS_MORE_INPUT = 1,
  TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

// Initializes the decompressor to its initial state.
#define tinfl_init(r) do { (r)->m_state = 0; } MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

// Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.
// This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.
tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

// Internal/private bits follow.
enum
{
  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,
  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

typedef struct
{
  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
} tinfl_huff_table;

#if MINIZ_HAS_64BIT_REGISTERS
  #define TINFL_USE_64BIT_BITBUF 1
#endif

#if TINFL_USE_64BIT_BITBUF
  typedef mz_uint64 tinfl_bit_buf_t;
  #define TINFL_BITBUF_SIZE (64)
#else
  typedef mz_uint32 tinfl_bit_buf_t;
  #define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag
{
  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
  tinfl_bit_buf_t m_bit_buf;
  size_t m_dist_from_out_buf_start;
  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

// ------------------- Low-level Compression API Definitions

// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).
#define TDEFL_LESS_MEMORY 0

// tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):
// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).
enum
{
  TDEFL_HUFFMAN_ONLY = 0, TDEFL_DEFAULT_MAX_PROBES = 128, TDEFL_MAX_PROBES_MASK = 0xFFF
};

// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.
// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).
// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.
// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).
// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
// The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK).
enum
{
  TDEFL_WRITE_ZLIB_HEADER             = 0x01000,
  TDEFL_COMPUTE_ADLER32               = 0x02000,
  TDEFL_GREEDY_PARSING_FLAG           = 0x04000,
  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
  TDEFL_RLE_MATCHES                   = 0x10000,
  TDEFL_FILTER_MATCHES                = 0x20000,
  TDEFL_FORCE_ALL_STATIC_BLOCKS       = 0x40000,
  TDEFL_FORCE_ALL_RAW_BLOCKS          = 0x80000
};

// High level compression functions:
// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().
// On entry:
//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
//  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.
// On return:
//  Function returns a pointer to the compressed data, or NULL on failure.
//  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.
//  The caller must free() the returned block when it's no longer needed.
void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

// tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.
// Returns 0 on failure.
size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

// Compresses an image to a compressed PNG file in memory.
// On entry:
//  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. 
//  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.
//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps).
// On return:
//  Function returns a pointer to the compressed data, or NULL on failure.
//  *pLen_out will be set to the size of the PNG image file.
//  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed.
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

// Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);

// tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.
mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

enum { TDEFL_MAX_HUFF_TABLES = 3, TDEFL_MAX_HUFF_SYMBOLS_0 = 288, TDEFL_MAX_HUFF_SYMBOLS_1 = 32, TDEFL_MAX_HUFF_SYMBOLS_2 = 19, TDEFL_LZ_DICT_SIZE = 32768, TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1, TDEFL_MIN_MATCH_LEN = 3, TDEFL_MAX_MATCH_LEN = 258 };

// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).
#if TDEFL_LESS_MEMORY
enum { TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 12, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };
#else
enum { TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };
#endif

// The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.
typedef enum
{
  TDEFL_STATUS_BAD_PARAM = -2,
  TDEFL_STATUS_PUT_BUF_FAILED = -1,
  TDEFL_STATUS_OKAY = 0,
  TDEFL_STATUS_DONE = 1,
} tdefl_status;

// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
typedef enum
{
  TDEFL_NO_FLUSH = 0,
  TDEFL_SYNC_FLUSH = 2,
  TDEFL_FULL_FLUSH = 3,
  TDEFL_FINISH = 4
} tdefl_flush;

// tdefl's compression state structure.
typedef struct
{
  tdefl_put_buf_func_ptr m_pPut_buf_func;
  void *m_pPut_buf_user;
  mz_uint m_flags, m_max_probes[2];
  int m_greedy_parsing;
  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
  tdefl_status m_prev_return_status;
  const void *m_pIn_buf;
  void *m_pOut_buf;
  size_t *m_pIn_buf_size, *m_pOut_buf_size;
  tdefl_flush m_flush;
  const mz_uint8 *m_pSrc;
  size_t m_src_buf_left, m_out_buf_ofs;
  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

// Initializes the compressor.
// There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.
// pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.
// If pBut_buf_func is NULL the user should always call the tdefl_compress() API.
// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)
tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

// Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.
tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.
// tdefl_compress_buffer() always consumes the entire input buffer.
tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't defined, because it uses some of its macros.
#ifndef MINIZ_NO_ZLIB_APIS
// Create tdefl_compress() flags given zlib-style compression parameters.
// level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files)
// window_bits may be -15 (raw deflate) or 15 (zlib)
// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);
#endif // #ifndef MINIZ_NO_ZLIB_APIS

#ifdef __cplusplus
}
#endif

#endif // MINIZ_HEADER_INCLUDED

// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)

#ifndef MINIZ_HEADER_FILE_ONLY

typedef unsigned char mz_validate_uint16[sizeof(mz_uint16)==2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32)==4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64)==8 ? 1 : -1];

#include <string.h>
#include <assert.h>

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
  #define MZ_MALLOC(x) NULL
  #define MZ_FREE(x) (void)x, ((void)0)
  #define MZ_REALLOC(p, x) NULL
#else
  #define MZ_MALLOC(x) malloc(x)
  #define MZ_FREE(x) free(x)
  #define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a,b) (((a)>(b))?(a):(b))
#define MZ_MIN(a,b) (((a)<(b))?(a):(b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  #define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
  #define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
  #define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
  #define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#ifdef _MSC_VER
  #define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
  #define MZ_FORCEINLINE inline __attribute__((__always_inline__))
#else
  #define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
  extern "C" {
#endif

// ------------------- zlib-style API's

mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
{
  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16); size_t block_len = buf_len % 5552;
  if (!ptr) return MZ_ADLER32_INIT;
  while (buf_len) {
    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
      s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
      s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
    }
    for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;
    s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
  }
  return (s2 << 16) + s1;
}

// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
{
  static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
  mz_uint32 crcu32 = (mz_uint32)crc;
  if (!ptr) return MZ_CRC32_INIT;
  crcu32 = ~crcu32; while (buf_len--) { mz_uint8 b = *ptr++; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)]; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)]; }
  return ~crcu32;
}

void mz_free(void *p)
{
  MZ_FREE(p);
}

#ifndef MINIZ_NO_ZLIB_APIS

static void *def_alloc_func(void *opaque, size_t items, size_t size) { (void)opaque, (void)items, (void)size; return MZ_MALLOC(items * size); }
static void def_free_func(void *opaque, void *address) { (void)opaque, (void)address; MZ_FREE(address); }
static void *def_realloc_func(void *opaque, void *address, size_t items, size_t size) { (void)opaque, (void)address, (void)items, (void)size; return MZ_REALLOC(address, items * size); }

const char *mz_version(void)
{
  return MZ_VERSION;
}

int mz_deflateInit(mz_streamp pStream, int level)
{
  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
}

int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
{
  tdefl_compressor *pComp;
  mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

  if (!pStream) return MZ_STREAM_ERROR;
  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))) return MZ_PARAM_ERROR;

  pStream->data_type = 0;
  pStream->adler = MZ_ADLER32_INIT;
  pStream->msg = NULL;
  pStream->reserved = 0;
  pStream->total_in = 0;
  pStream->total_out = 0;
  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
  if (!pStream->zfree) pStream->zfree = def_free_func;

  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
  if (!pComp)
    return MZ_MEM_ERROR;

  pStream->state = (struct mz_internal_state *)pComp;

  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
  {
    mz_deflateEnd(pStream);
    return MZ_PARAM_ERROR;
  }

  return MZ_OK;
}

int mz_deflateReset(mz_streamp pStream)
{
  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree)) return MZ_STREAM_ERROR;
  pStream->total_in = pStream->total_out = 0;
  tdefl_init((tdefl_compressor*)pStream->state, NULL, NULL, ((tdefl_compressor*)pStream->state)->m_flags);
  return MZ_OK;
}

int mz_deflate(mz_streamp pStream, int flush)
{
  size_t in_bytes, out_bytes;
  mz_ulong orig_total_in, orig_total_out;
  int mz_status = MZ_OK;

  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out)) return MZ_STREAM_ERROR;
  if (!pStream->avail_out) return MZ_BUF_ERROR;

  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;

  if (((tdefl_compressor*)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

  orig_total_in = pStream->total_in; orig_total_out = pStream->total_out;
  for ( ; ; )
  {
    tdefl_status defl_status;
    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;

    defl_status = tdefl_compress((tdefl_compressor*)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tdefl_get_adler32((tdefl_compressor*)pStream->state);

    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes;
    pStream->total_out += (mz_uint)out_bytes;

    if (defl_status < 0)
    {
      mz_status = MZ_STREAM_ERROR;
      break;
    }
    else if (defl_status == TDEFL_STATUS_DONE)
    {
      mz_status = MZ_STREAM_END;
      break;
    }
    else if (!pStream->avail_out)
      break;
    else if ((!pStream->avail_in) && (flush != MZ_FINISH))
    {
      if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
        break;
      return MZ_BUF_ERROR; // Can't make forward progress without some input.
    }
  }
  return mz_status;
}

int mz_deflateEnd(mz_streamp pStream)
{
  if (!pStream) return MZ_STREAM_ERROR;
  if (pStream->state)
  {
    pStream->zfree(pStream->opaque, pStream->state);
    pStream->state = NULL;
  }
  return MZ_OK;
}

mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
{
  (void)pStream;
  // This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.)
  return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
}

int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
{
  int status;
  mz_stream stream;
  memset(&stream, 0, sizeof(stream));

  // In case mz_ulong is 64-bits (argh I hate longs).
  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;

  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;

  status = mz_deflateInit(&stream, level);
  if (status != MZ_OK) return status;

  status = mz_deflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END)
  {
    mz_deflateEnd(&stream);
    return (status == MZ_OK) ? MZ_BUF_ERROR : status;
  }

  *pDest_len = stream.total_out;
  return mz_deflateEnd(&stream);
}

int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
  return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
}

mz_ulong mz_compressBound(mz_ulong source_len)
{
  return mz_deflateBound(NULL, source_len);
}

typedef struct
{
  tinfl_decompressor m_decomp;
  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed; int m_window_bits;
  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
  tinfl_status m_last_status;
} inflate_state;

int mz_inflateInit2(mz_streamp pStream, int window_bits)
{
  inflate_state *pDecomp;
  if (!pStream) return MZ_STREAM_ERROR;
  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)) return MZ_PARAM_ERROR;

  pStream->data_type = 0;
  pStream->adler = 0;
  pStream->msg = NULL;
  pStream->total_in = 0;
  pStream->total_out = 0;
  pStream->reserved = 0;
  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
  if (!pStream->zfree) pStream->zfree = def_free_func;

  pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
  if (!pDecomp) return MZ_MEM_ERROR;

  pStream->state = (struct mz_internal_state *)pDecomp;

  tinfl_init(&pDecomp->m_decomp);
  pDecomp->m_dict_ofs = 0;
  pDecomp->m_dict_avail = 0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = 1;
  pDecomp->m_has_flushed = 0;
  pDecomp->m_window_bits = window_bits;

  return MZ_OK;
}

int mz_inflateInit(mz_streamp pStream)
{
   return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
}

int mz_inflate(mz_streamp pStream, int flush)
{
  inflate_state* pState;
  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
  size_t in_bytes, out_bytes, orig_avail_in;
  tinfl_status status;

  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;

  pState = (inflate_state*)pStream->state;
  if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = pStream->avail_in;

  first_call = pState->m_first_call; pState->m_first_call = 0;
  if (pState->m_last_status < 0) return MZ_DATA_ERROR;

  if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
  pState->m_has_flushed |= (flush == MZ_FINISH);

  if ((flush == MZ_FINISH) && (first_call))
  {
    // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file.
    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;
    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
    pState->m_last_status = status;
    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes; pStream->total_in += (mz_uint)in_bytes;
    pStream->adler = tinfl_get_adler32(&pState->m_decomp);
    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes; pStream->total_out += (mz_uint)out_bytes;

    if (status < 0)
      return MZ_DATA_ERROR;
    else if (status != TINFL_STATUS_DONE)
    {
      pState->m_last_status = TINFL_STATUS_FAILED;
      return MZ_BUF_ERROR;
    }
    return MZ_STREAM_END;
  }
  // flush != MZ_FINISH then we must assume there's more input.
  if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

  if (pState->m_dict_avail)
  {
    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
    return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
  }

  for ( ; ; )
  {
    in_bytes = pStream->avail_in;
    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
    pState->m_last_status = status;

    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tinfl_get_adler32(&pState->m_decomp);

    pState->m_dict_avail = (mz_uint)out_bytes;

    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

    if (status < 0)
       return MZ_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).
    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
      return MZ_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH.
    else if (flush == MZ_FINISH)
    {
       // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
       if (status == TINFL_STATUS_DONE)
          return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
       // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong.
       else if (!pStream->avail_out)
          return MZ_BUF_ERROR;
    }
    else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
      break;
  }

  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
}

int mz_inflateEnd(mz_streamp pStream)
{
  if (!pStream)
    return MZ_STREAM_ERROR;
  if (pStream->state)
  {
    pStream->zfree(pStream->opaque, pStream->state);
    pStream->state = NULL;
  }
  return MZ_OK;
}

int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
  mz_stream stream;
  int status;
  memset(&stream, 0, sizeof(stream));

  // In case mz_ulong is 64-bits (argh I hate longs).
  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;

  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;

  status = mz_inflateInit(&stream);
  if (status != MZ_OK)
    return status;

  status = mz_inflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END)
  {
    mz_inflateEnd(&stream);
    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
  }
  *pDest_len = stream.total_out;

  return mz_inflateEnd(&stream);
}

const char *mz_error(int err)
{
  static struct { int m_err; const char *m_pDesc; } s_error_descs[] =
  {
    { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" },
    { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
  };
  mz_uint i; for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i) if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;
  return NULL;
}

#endif //MINIZ_NO_ZLIB_APIS

// ------------------- Low-level Decompression (completely independent from all compression API's)

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN switch(r->m_state) { case 0:
#define TINFL_CR_RETURN(state_index, result) do { status = result; r->m_state = state_index; goto common_exit; case state_index:; } MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result) do { for ( ; ; ) { TINFL_CR_RETURN(state_index, result); } } MZ_MACRO_END
#define TINFL_CR_FINISH }

// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never
// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.
#define TINFL_GET_BYTE(state_index, c) do { \
  if (pIn_buf_cur >= pIn_buf_end) { \
    for ( ; ; ) { \
      if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) { \
        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \
        if (pIn_buf_cur < pIn_buf_end) { \
          c = *pIn_buf_cur++; \
          break; \
        } \
      } else { \
        c = 0; \
        break; \
      } \
    } \
  } else c = *pIn_buf_cur++; } MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n) do { mz_uint c; TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } b = bit_buf & ((1 << (n)) - 1); bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END

// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.
// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a
// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the
// bit buffer contains >=15 bits (deflate's max. Huffman code size).
#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff) \
  do { \
    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \
    if (temp >= 0) { \
      code_len = temp >> 9; \
      if ((code_len) && (num_bits >= code_len)) \
      break; \
    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) { \
       code_len = TINFL_FAST_LOOKUP_BITS; \
       do { \
          temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \
       } while ((temp < 0) && (num_bits >= (code_len + 1))); if (temp >= 0) break; \
    } TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; \
  } while (num_bits < 15);

// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read
// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully
// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.
// The slow path is only executed at the very end of the input buffer.
#define TINFL_HUFF_DECODE(state_index, sym, pHuff) do { \
  int temp; mz_uint code_len, c; \
  if (num_bits < 15) { \
    if ((pIn_buf_end - pIn_buf_cur) < 2) { \
       TINFL_HUFF_BITBUF_FILL(state_index, pHuff); \
    } else { \
       bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); pIn_buf_cur += 2; num_bits += 16; \
    } \
  } \
  if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0) \
    code_len = temp >> 9, temp &= 511; \
  else { \
    code_len = TINFL_FAST_LOOKUP_BITS; do { temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; } while (temp < 0); \
  } sym = temp; bit_buf >>= code_len; num_bits -= code_len; } MZ_MACRO_END

tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
{
  static const int s_length_base[31] = { 3,4,5,6,7,8,9,10,11,13, 15,17,19,23,27,31,35,43,51,59, 67,83,99,115,131,163,195,227,258,0,0 };
  static const int s_length_extra[31]= { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
  static const int s_dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193, 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
  static const int s_dist_extra[32] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
  static const mz_uint8 s_length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
  static const int s_min_table_sizes[3] = { 257, 1, 4 };

  tinfl_status status = TINFL_STATUS_FAILED; mz_uint32 num_bits, dist, counter, num_extra; tinfl_bit_buf_t bit_buf;
  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
  size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;

  // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).
  if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) { *pIn_buf_size = *pOut_buf_size = 0; return TINFL_STATUS_BAD_PARAM; }

  num_bits = r->m_num_bits; bit_buf = r->m_bit_buf; dist = r->m_dist; counter = r->m_counter; num_extra = r->m_num_extra; dist_from_out_buf_start = r->m_dist_from_out_buf_start;
  TINFL_CR_BEGIN

  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0; r->m_z_adler32 = r->m_check_adler32 = 1;
  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
  {
    TINFL_GET_BYTE(1, r->m_zhdr0); TINFL_GET_BYTE(2, r->m_zhdr1);
    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
    if (counter) { TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED); }
  }

  do
  {
    TINFL_GET_BITS(3, r->m_final, 3); r->m_type = r->m_final >> 1;
    if (r->m_type == 0)
    {
      TINFL_SKIP_BITS(5, num_bits & 7);
      for (counter = 0; counter < 4; ++counter) { if (num_bits) TINFL_GET_BITS(6, r->m_raw_header[counter], 8); else TINFL_GET_BYTE(7, r->m_raw_header[counter]); }
      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) { TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED); }
      while ((counter) && (num_bits))
      {
        TINFL_GET_BITS(51, dist, 8);
        while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT); }
        *pOut_buf_cur++ = (mz_uint8)dist;
        counter--;
      }
      while (counter)
      {
        size_t n; while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT); }
        while (pIn_buf_cur >= pIn_buf_end)
        {
          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT)
          {
            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
          }
          else
          {
            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
          }
        }
        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n); pIn_buf_cur += n; pOut_buf_cur += n; counter -= (mz_uint)n;
      }
    }
    else if (r->m_type == 3)
    {
      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
    }
    else
    {
      if (r->m_type == 1)
      {
        mz_uint8 *p = r->m_tables[0].m_code_size; mz_uint i;
        r->m_table_sizes[0] = 288; r->m_table_sizes[1] = 32; TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
        for ( i = 0; i <= 143; ++i) *p++ = 8; for ( ; i <= 255; ++i) *p++ = 9; for ( ; i <= 279; ++i) *p++ = 7; for ( ; i <= 287; ++i) *p++ = 8;
      }
      else
      {
        for (counter = 0; counter < 3; counter++) { TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]); r->m_table_sizes[counter] += s_min_table_sizes[counter]; }
        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size); for (counter = 0; counter < r->m_table_sizes[2]; counter++) { mz_uint s; TINFL_GET_BITS(14, s, 3); r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s; }
        r->m_table_sizes[2] = 19;
      }
      for ( ; (int)r->m_type >= 0; r->m_type--)
      {
        int tree_next, tree_cur; tinfl_huff_table *pTable;
        mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16]; pTable = &r->m_tables[r->m_type]; MZ_CLEAR_OBJ(total_syms); MZ_CLEAR_OBJ(pTable->m_look_up); MZ_CLEAR_OBJ(pTable->m_tree);
        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i) total_syms[pTable->m_code_size[i]]++;
        used_syms = 0, total = 0; next_code[0] = next_code[1] = 0;
        for (i = 1; i <= 15; ++i) { used_syms += total_syms[i]; next_code[i + 1] = (total = ((total + total_syms[i]) << 1)); }
        if ((65536 != total) && (used_syms > 1))
        {
          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
        }
        for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
        {
          mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index]; if (!code_size) continue;
          cur_code = next_code[code_size]++; for (l = code_size; l > 0; l--, cur_code >>= 1) rev_code = (rev_code << 1) | (cur_code & 1);
          if (code_size <= TINFL_FAST_LOOKUP_BITS) { mz_int16 k = (mz_int16)((code_size << 9) | sym_index); while (rev_code < TINFL_FAST_LOOKUP_SIZE) { pTable->m_look_up[rev_code] = k; rev_code += (1 << code_size); } continue; }
          if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) { pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; }
          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
          {
            tree_cur -= ((rev_code >>= 1) & 1);
            if (!pTable->m_tree[-tree_cur - 1]) { pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; } else tree_cur = pTable->m_tree[-tree_cur - 1];
          }
          tree_cur -= ((rev_code >>= 1) & 1); pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
        }
        if (r->m_type == 2)
        {
          for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]); )
          {
            mz_uint s; TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]); if (dist < 16) { r->m_len_codes[counter++] = (mz_uint8)dist; continue; }
            if ((dist == 16) && (!counter))
            {
              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
            }
            num_extra = "\02\03\07"[dist - 16]; TINFL_GET_BITS(18, s, num_extra); s += "\03\03\013"[dist - 16];
            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s); counter += s;
          }
          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
          {
            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
          }
          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]); TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
        }
      }
      for ( ; ; )
      {
        mz_uint8 *pSrc;
        for ( ; ; )
        {
          if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
          {
            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
            if (counter >= 256)
              break;
            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT); }
            *pOut_buf_cur++ = (mz_uint8)counter;
          }
          else
          {
            int sym2; mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
            if (num_bits < 30) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits); pIn_buf_cur += 4; num_bits += 32; }
#else
            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }
#endif
            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
              code_len = sym2 >> 9;
            else
            {
              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);
            }
            counter = sym2; bit_buf >>= code_len; num_bits -= code_len;
            if (counter & 256)
              break;

#if !TINFL_USE_64BIT_BITBUF
            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }
#endif
            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
              code_len = sym2 >> 9;
            else
            {
              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);
            }
            bit_buf >>= code_len; num_bits -= code_len;

            pOut_buf_cur[0] = (mz_uint8)counter;
            if (sym2 & 256)
            {
              pOut_buf_cur++;
              counter = sym2;
              break;
            }
            pOut_buf_cur[1] = (mz_uint8)sym2;
            pOut_buf_cur += 2;
          }
        }
        if ((counter &= 511) == 256) break;

        num_extra = s_length_extra[counter - 257]; counter = s_length_base[counter - 257];
        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(25, extra_bits, num_extra); counter += extra_bits; }

        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
        num_extra = s_dist_extra[dist]; dist = s_dist_base[dist];
        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(27, extra_bits, num_extra); dist += extra_bits; }

        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
        if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
        {
          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
        }

        pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);

        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
        {
          while (counter--)
          {
            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT); }
            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
          }
          continue;
        }
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
        else if ((counter >= 9) && (counter <= dist))
        {
          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
          do
          {
            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
            pOut_buf_cur += 8;
          } while ((pSrc += 8) < pSrc_end);
          if ((counter &= 7) < 3)
          {
            if (counter)
            {
              pOut_buf_cur[0] = pSrc[0];
              if (counter > 1)
                pOut_buf_cur[1] = pSrc[1];
              pOut_buf_cur += counter;
            }
            continue;
          }
        }
#endif
        do
        {
          pOut_buf_cur[0] = pSrc[0];
          pOut_buf_cur[1] = pSrc[1];
          pOut_buf_cur[2] = pSrc[2];
          pOut_buf_cur += 3; pSrc += 3;
        } while ((int)(counter -= 3) > 2);
        if ((int)counter > 0)
        {
          pOut_buf_cur[0] = pSrc[0];
          if ((int)counter > 1)
            pOut_buf_cur[1] = pSrc[1];
          pOut_buf_cur += counter;
        }
      }
    }
  } while (!(r->m_final & 1));
  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
  {
    TINFL_SKIP_BITS(32, num_bits & 7); for (counter = 0; counter < 4; ++counter) { mz_uint s; if (num_bits) TINFL_GET_BITS(41, s, 8); else TINFL_GET_BYTE(42, s); r->m_z_adler32 = (r->m_z_adler32 << 8) | s; }
  }
  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
  TINFL_CR_FINISH

common_exit:
  r->m_num_bits = num_bits; r->m_bit_buf = bit_buf; r->m_dist = dist; r->m_counter = counter; r->m_num_extra = num_extra; r->m_dist_from_out_buf_start = dist_from_out_buf_start;
  *pIn_buf_size = pIn_buf_cur - pIn_buf_next; *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
  if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
  {
    const mz_uint8 *ptr = pOut_buf_next; size_t buf_len = *pOut_buf_size;
    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16; size_t block_len = buf_len % 5552;
    while (buf_len)
    {
      for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
      {
        s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
        s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
      }
      for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;
      s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
    }
    r->m_check_adler32 = (s2 << 16) + s1; if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32)) status = TINFL_STATUS_ADLER32_MISMATCH;
  }
  return status;
}

// Higher level helper functions.
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  tinfl_decompressor decomp; void *pBuf = NULL, *pNew_buf; size_t src_buf_ofs = 0, out_buf_capacity = 0;
  *pOut_len = 0;
  tinfl_init(&decomp);
  for ( ; ; )
  {
    size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf, pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,
      (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
    {
      MZ_FREE(pBuf); *pOut_len = 0; return NULL;
    }
    src_buf_ofs += src_buf_size;
    *pOut_len += dst_buf_size;
    if (status == TINFL_STATUS_DONE) break;
    new_out_buf_capacity = out_buf_capacity * 2; if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;
    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
    if (!pNew_buf)
    {
      MZ_FREE(pBuf); *pOut_len = 0; return NULL;
    }
    pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity;
  }
  return pBuf;
}

size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
  tinfl_decompressor decomp; tinfl_status status; tinfl_init(&decomp);
  status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
}

int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
  int result = 0;
  tinfl_decompressor decomp;
  mz_uint8 *pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE); size_t in_buf_ofs = 0, dict_ofs = 0;
  if (!pDict)
    return TINFL_STATUS_FAILED;
  tinfl_init(&decomp);
  for ( ; ; )
  {
    size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
      (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
    in_buf_ofs += in_buf_size;
    if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
      break;
    if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
    {
      result = (status == TINFL_STATUS_DONE);
      break;
    }
    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
  }
  MZ_FREE(pDict);
  *pIn_buf_size = in_buf_ofs;
  return result;
}

// ------------------- Low-level Compression (independent from all decompression API's)

// Purposely making these tables static for faster init and thread safety.
static const mz_uint16 s_tdefl_len_sym[256] = {
  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,
  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,
  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,
  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,
  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,
  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,
  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,
  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };

static const mz_uint8 s_tdefl_len_extra[256] = {
  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };

static const mz_uint8 s_tdefl_small_dist_sym[512] = {
  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,
  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };

static const mz_uint8 s_tdefl_small_dist_extra[512] = {
  0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7 };

static const mz_uint8 s_tdefl_large_dist_sym[128] = {
  0,0,18,19,20,20,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,
  26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
  28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29 };

static const mz_uint8 s_tdefl_large_dist_extra[128] = {
  0,0,8,8,9,9,9,9,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13 };

// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.
typedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;
static tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1)
{
  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2]; tdefl_sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1; MZ_CLEAR_OBJ(hist);
  for (i = 0; i < num_syms; i++) { mz_uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; }
  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;
  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
  {
    const mz_uint32* pHist = &hist[pass << 8];
    mz_uint offsets[256], cur_ofs = 0;
    for (i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }
    for (i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
    { tdefl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }
  }
  return pCur_syms;
}

// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
  int root, leaf, next, avbl, used, dpth;
  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }
  A[0].m_key += A[1].m_key; root = 0; leaf = 2;
  for (next=1; next < n-1; next++)
  {
    if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = (mz_uint16)next; } else A[next].m_key = A[leaf++].m_key;
    if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key); A[root++].m_key = (mz_uint16)next; } else A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
  }
  A[n-2].m_key = 0; for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;
  avbl = 1; used = dpth = 0; root = n-2; next = n-1;
  while (avbl>0)
  {
    while (root>=0 && (int)A[root].m_key==dpth) { used++; root--; }
    while (avbl>used) { A[next--].m_key = (mz_uint16)(dpth); avbl--; }
    avbl = 2*used; dpth++; used = 0;
  }
}

// Limits canonical Huffman code table's max code size.
enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };
static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
  int i; mz_uint32 total = 0; if (code_list_len <= 1) return;
  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];
  for (i = max_code_size; i > 0; i--) total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
  while (total != (1UL << max_code_size))
  {
    pNum_codes[max_code_size]--;
    for (i = max_code_size - 1; i > 0; i--) if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }
    total--;
  }
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)
{
  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE]; mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; MZ_CLEAR_OBJ(num_codes);
  if (static_table)
  {
    for (i = 0; i < table_len; i++) num_codes[d->m_huff_code_sizes[table_num][i]]++;
  }
  else
  {
    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
    int num_used_syms = 0;
    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
    for (i = 0; i < table_len; i++) if (pSym_count[i]) { syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (mz_uint16)i; }

    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1); tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;

    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]); MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
      for (l = num_codes[i]; l > 0; l--) d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
  }

  next_code[1] = 0; for (j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1);

  for (i = 0; i < table_len; i++)
  {
    mz_uint rev_code = 0, code, code_size; if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;
    code = next_code[code_size]++; for (l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1);
    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
  }
}

#define TDEFL_PUT_BITS(b, l) do { \
  mz_uint bits = b; mz_uint len = l; MZ_ASSERT(bits <= ((1U << len) - 1U)); \
  d->m_bit_buffer |= (bits << d->m_bits_in); d->m_bits_in += len; \
  while (d->m_bits_in >= 8) { \
    if (d->m_pOutput_buf < d->m_pOutput_buf_end) \
      *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
      d->m_bit_buffer >>= 8; \
      d->m_bits_in -= 8; \
  } \
} MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \
  if (rle_repeat_count < 3) { \
    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \
  } else { \
    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3); \
} rle_repeat_count = 0; } }

#define TDEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \
  if (rle_z_count < 3) { \
    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \
  } else if (rle_z_count <= 10) { \
    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3); \
  } else { \
    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
} rle_z_count = 0; } }

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
  int num_lit_codes, num_dist_codes, num_bit_lengths; mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

  d->m_huff_count[0][256] = 1;

  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--) if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--) if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;

  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
  total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;

  memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
  for (i = 0; i < total_code_sizes_to_pack; i++)
  {
    mz_uint8 code_size = code_sizes_to_pack[i];
    if (!code_size)
    {
      TDEFL_RLE_PREV_CODE_SIZE();
      if (++rle_z_count == 138) { TDEFL_RLE_ZERO_CODE_SIZE(); }
    }
    else
    {
      TDEFL_RLE_ZERO_CODE_SIZE();
      if (code_size != prev_code_size)
      {
        TDEFL_RLE_PREV_CODE_SIZE();
        d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;
      }
      else if (++rle_repeat_count == 6)
      {
        TDEFL_RLE_PREV_CODE_SIZE();
      }
    }
    prev_code_size = code_size;
  }
  if (rle_repeat_count) { TDEFL_RLE_PREV_CODE_SIZE(); } else { TDEFL_RLE_ZERO_CODE_SIZE(); }

  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

  TDEFL_PUT_BITS(2, 2);

  TDEFL_PUT_BITS(num_lit_codes - 257, 5);
  TDEFL_PUT_BITS(num_dist_codes - 1, 5);

  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--) if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;
  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1)); TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
  for (i = 0; (int)i < num_bit_lengths; i++) TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

  for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes; )
  {
    mz_uint code = packed_code_sizes[packed_code_sizes_index++]; MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
    if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
  }
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
  mz_uint i;
  mz_uint8 *p = &d->m_huff_code_sizes[0][0];

  for (i = 0; i <= 143; ++i) *p++ = 8;
  for ( ; i <= 255; ++i) *p++ = 9;
  for ( ; i <= 279; ++i) *p++ = 7;
  for ( ; i <= 287; ++i) *p++ = 8;

  memset(d->m_huff_code_sizes[1], 5, 32);

  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

  TDEFL_PUT_BITS(1, 2);
}

static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_uint flags;
  mz_uint8 *pLZ_codes;
  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
  mz_uint64 bit_buffer = d->m_bit_buffer;
  mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l) { bit_buffer |= (((mz_uint64)(b)) << bits_in); bits_in += (l); }

  flags = 1;
  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
  {
    if (flags == 1)
      flags = *pLZ_codes++ | 0x100;

    if (flags & 1)
    {
      mz_uint s0, s1, n0, n1, sym, num_extra_bits;
      mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16 *)(pLZ_codes + 1); pLZ_codes += 3;

      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

      // This sequence coaxes MSVC into using cmov's vs. jmp's.
      s0 = s_tdefl_small_dist_sym[match_dist & 511];
      n0 = s_tdefl_small_dist_extra[match_dist & 511];
      s1 = s_tdefl_large_dist_sym[match_dist >> 8];
      n1 = s_tdefl_large_dist_extra[match_dist >> 8];
      sym = (match_dist < 512) ? s0 : s1;
      num_extra_bits = (match_dist < 512) ? n0 : n1;

      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
    }
    else
    {
      mz_uint lit = *pLZ_codes++;
      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
      {
        flags >>= 1;
        lit = *pLZ_codes++;
        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
        {
          flags >>= 1;
          lit = *pLZ_codes++;
          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
        }
      }
    }

    if (pOutput_buf >= d->m_pOutput_buf_end)
      return MZ_FALSE;

    *(mz_uint64*)pOutput_buf = bit_buffer;
    pOutput_buf += (bits_in >> 3);
    bit_buffer >>= (bits_in & ~7);
    bits_in &= 7;
  }

#undef TDEFL_PUT_BITS_FAST

  d->m_pOutput_buf = pOutput_buf;
  d->m_bits_in = 0;
  d->m_bit_buffer = 0;

  while (bits_in)
  {
    mz_uint32 n = MZ_MIN(bits_in, 16);
    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
    bit_buffer >>= n;
    bits_in -= n;
  }

  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_uint flags;
  mz_uint8 *pLZ_codes;

  flags = 1;
  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
  {
    if (flags == 1)
      flags = *pLZ_codes++ | 0x100;
    if (flags & 1)
    {
      mz_uint sym, num_extra_bits;
      mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8)); pLZ_codes += 3;

      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

      if (match_dist < 512)
      {
        sym = s_tdefl_small_dist_sym[match_dist]; num_extra_bits = s_tdefl_small_dist_extra[match_dist];
      }
      else
      {
        sym = s_tdefl_large_dist_sym[match_dist >> 8]; num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
      }
      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
    }
    else
    {
      mz_uint lit = *pLZ_codes++;
      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
    }
  }

  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
  if (static_block)
    tdefl_start_static_block(d);
  else
    tdefl_start_dynamic_block(d);
  return tdefl_compress_lz_codes(d);
}

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
  mz_uint saved_bit_buf, saved_bits_in;
  mz_uint8 *pSaved_output_buf;
  mz_bool comp_block_succeeded = MZ_FALSE;
  int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
  mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;

  d->m_pOutput_buf = pOutput_buf_start;
  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

  MZ_ASSERT(!d->m_output_flush_remaining);
  d->m_output_flush_ofs = 0;
  d->m_output_flush_remaining = 0;

  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
  {
    TDEFL_PUT_BITS(0x78, 8); TDEFL_PUT_BITS(0x01, 8);
  }

  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

  pSaved_output_buf = d->m_pOutput_buf; saved_bit_buf = d->m_bit_buffer; saved_bits_in = d->m_bits_in;

  if (!use_raw_block)
    comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));

  // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.
  if ( ((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
       ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size) )
  {
    mz_uint i; d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
    TDEFL_PUT_BITS(0, 2);
    if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }
    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
    {
      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
    }
    for (i = 0; i < d->m_total_lz_bytes; ++i)
    {
      TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
    }
  }
  // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.
  else if (!comp_block_succeeded)
  {
    d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
    tdefl_compress_block(d, MZ_TRUE);
  }

  if (flush)
  {
    if (flush == TDEFL_FINISH)
    {
      if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }
      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) { mz_uint i, a = d->m_adler32; for (i = 0; i < 4; i++) { TDEFL_PUT_BITS((a >> 24) & 0xFF, 8); a <<= 8; } }
    }
    else
    {
      mz_uint i, z = 0; TDEFL_PUT_BITS(0, 3); if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); } for (i = 2; i; --i, z ^= 0xFFFF) { TDEFL_PUT_BITS(z & 0xFFFF, 16); }
    }
  }

  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8; d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes; d->m_total_lz_bytes = 0; d->m_block_index++;

  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
  {
    if (d->m_pPut_buf_func)
    {
      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
    }
    else if (pOutput_buf_start == d->m_output_buf)
    {
      int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
      d->m_out_buf_ofs += bytes_to_copy;
      if ((n -= bytes_to_copy) != 0)
      {
        d->m_output_flush_ofs = bytes_to_copy;
        d->m_output_flush_remaining = n;
      }
    }
    else
    {
      d->m_out_buf_ofs += n;
    }
  }

  return d->m_output_flush_remaining;
}

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
  const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;
  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);
  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;
  for ( ; ; )
  {
    for ( ; ; )
    {
      if (--num_probes_left == 0) return;
      #define TDEFL_PROBE \
        next_probe_pos = d->m_next[probe_pos]; \
        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \
        if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;
      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;
    }
    if (!dist) break; q = (const mz_uint16*)(d->m_dict + probe_pos); if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue; p = s; probe_len = 32;
    do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
                   (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );
    if (!probe_len)
    {
      *pMatch_dist = dist; *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN); break;
    }
    else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len)
    {
      *pMatch_dist = dist; if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;
      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
    }
  }
}
#else
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
  const mz_uint8 *s = d->m_dict + pos, *p, *q;
  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;
  for ( ; ; )
  {
    for ( ; ; )
    {
      if (--num_probes_left == 0) return;
      #define TDEFL_PROBE \
        next_probe_pos = d->m_next[probe_pos]; \
        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \
        if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;
      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;
    }
    if (!dist) break; p = s; q = d->m_dict + probe_pos; for (probe_len = 0; probe_len < max_match_len; probe_len++) if (*p++ != *q++) break;
    if (probe_len > match_len)
    {
      *pMatch_dist = dist; if ((*pMatch_len = match_len = probe_len) == max_match_len) return;
      c0 = d->m_dict[pos + match_len]; c1 = d->m_dict[pos + match_len - 1];
    }
  }
}
#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
  // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.
  mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
  {
    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
    mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
    d->m_src_buf_left -= num_bytes_to_process;
    lookahead_size += num_bytes_to_process;

    while (num_bytes_to_process)
    {
      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
      d->m_pSrc += n;
      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
      num_bytes_to_process -= n;
    }

    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;

    while (lookahead_size >= 4)
    {
      mz_uint cur_match_dist, cur_match_len = 1;
      mz_uint8 *pCur_dict = d->m_dict + cur_pos;
      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
      mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
      mz_uint probe_pos = d->m_hash[hash];
      d->m_hash[hash] = (mz_uint16)lookahead_pos;

      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
      {
        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
        mz_uint32 probe_len = 32;
        do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
          (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );
        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
        if (!probe_len)
          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)))
        {
          cur_match_len = 1;
          *pLZ_code_buf++ = (mz_uint8)first_trigram;
          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
          d->m_huff_count[0][(mz_uint8)first_trigram]++;
        }
        else
        {
          mz_uint32 s0, s1;
          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));

          cur_match_dist--;

          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
          pLZ_code_buf += 3;
          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
        }
      }
      else
      {
        *pLZ_code_buf++ = (mz_uint8)first_trigram;
        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
        d->m_huff_count[0][(mz_uint8)first_trigram]++;
      }

      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }

      total_lz_bytes += cur_match_len;
      lookahead_pos += cur_match_len;
      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
      MZ_ASSERT(lookahead_size >= cur_match_len);
      lookahead_size -= cur_match_len;

      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
      {
        int n;
        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
        if ((n = tdefl_flush_block(d, 0)) != 0)
          return (n < 0) ? MZ_FALSE : MZ_TRUE;
        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;
      }
    }

    while (lookahead_size)
    {
      mz_uint8 lit = d->m_dict[cur_pos];

      total_lz_bytes++;
      *pLZ_code_buf++ = lit;
      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }

      d->m_huff_count[0][lit]++;

      lookahead_pos++;
      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
      lookahead_size--;

      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
      {
        int n;
        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
        if ((n = tdefl_flush_block(d, 0)) != 0)
          return (n < 0) ? MZ_FALSE : MZ_TRUE;
        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;
      }
    }
  }

  d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;
  d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;
  return MZ_TRUE;
}
#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN

static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
{
  d->m_total_lz_bytes++;
  *d->m_pLZ_code_buf++ = lit;
  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }
  d->m_huff_count[0][lit]++;
}

static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
  mz_uint32 s0, s1;

  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));

  d->m_total_lz_bytes += match_len;

  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

  match_dist -= 1;
  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8); d->m_pLZ_code_buf += 3;

  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }

  s0 = s_tdefl_small_dist_sym[match_dist & 511]; s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;

  if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
  const mz_uint8 *pSrc = d->m_pSrc; size_t src_buf_left = d->m_src_buf_left;
  tdefl_flush flush = d->m_flush;

  while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
  {
    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
    // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.
    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
    {
      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;
      src_buf_left -= num_bytes_to_process;
      d->m_lookahead_size += num_bytes_to_process;
      while (pSrc != pSrc_end)
      {
        mz_uint8 c = *pSrc++; d->m_dict[dst_pos] = c; if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);
        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK; ins_pos++;
      }
    }
    else
    {
      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
      {
        mz_uint8 c = *pSrc++;
        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
        src_buf_left--;
        d->m_dict[dst_pos] = c;
        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
        {
          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);
        }
      }
    }
    d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
      break;

    // Simple lazy/greedy parsing state machine.
    len_to_move = 1; cur_match_dist = 0; cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1); cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
    {
      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
      {
        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
        cur_match_len = 0; while (cur_match_len < d->m_lookahead_size) { if (d->m_dict[cur_pos + cur_match_len] != c) break; cur_match_len++; }
        if (cur_match_len < TDEFL_MIN_MATCH_LEN) cur_match_len = 0; else cur_match_dist = 1;
      }
    }
    else
    {
      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
    }
    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
    {
      cur_match_dist = cur_match_len = 0;
    }
    if (d->m_saved_match_len)
    {
      if (cur_match_len > d->m_saved_match_len)
      {
        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
        if (cur_match_len >= 128)
        {
          tdefl_record_match(d, cur_match_len, cur_match_dist);
          d->m_saved_match_len = 0; len_to_move = cur_match_len;
        }
        else
        {
          d->m_saved_lit = d->m_dict[cur_pos]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;
        }
      }
      else
      {
        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
        len_to_move = d->m_saved_match_len - 1; d->m_saved_match_len = 0;
      }
    }
    else if (!cur_match_dist)
      tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
    {
      tdefl_record_match(d, cur_match_len, cur_match_dist);
      len_to_move = cur_match_len;
    }
    else
    {
      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;
    }
    // Move the lookahead forward by len_to_move bytes.
    d->m_lookahead_pos += len_to_move;
    MZ_ASSERT(d->m_lookahead_size >= len_to_move);
    d->m_lookahead_size -= len_to_move;
    d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);
    // Check if it's time to flush the current LZ codes to the internal output buffer.
    if ( (d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
         ( (d->m_total_lz_bytes > 31*1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) )
    {
      int n;
      d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;
      if ((n = tdefl_flush_block(d, 0)) != 0)
        return (n < 0) ? MZ_FALSE : MZ_TRUE;
    }
  }

  d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;
  return MZ_TRUE;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
  if (d->m_pIn_buf_size)
  {
    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
  }

  if (d->m_pOut_buf_size)
  {
    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
    d->m_output_flush_ofs += (mz_uint)n;
    d->m_output_flush_remaining -= (mz_uint)n;
    d->m_out_buf_ofs += n;

    *d->m_pOut_buf_size = d->m_out_buf_ofs;
  }

  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
  if (!d)
  {
    if (pIn_buf_size) *pIn_buf_size = 0;
    if (pOut_buf_size) *pOut_buf_size = 0;
    return TDEFL_STATUS_BAD_PARAM;
  }

  d->m_pIn_buf = pIn_buf; d->m_pIn_buf_size = pIn_buf_size;
  d->m_pOut_buf = pOut_buf; d->m_pOut_buf_size = pOut_buf_size;
  d->m_pSrc = (const mz_uint8 *)(pIn_buf); d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
  d->m_out_buf_ofs = 0;
  d->m_flush = flush;

  if ( ((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf) )
  {
    if (pIn_buf_size) *pIn_buf_size = 0;
    if (pOut_buf_size) *pOut_buf_size = 0;
    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
  }
  d->m_wants_to_finish |= (flush == TDEFL_FINISH);

  if ((d->m_output_flush_remaining) || (d->m_finished))
    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
  {
    if (!tdefl_compress_fast(d))
      return d->m_prev_return_status;
  }
  else
#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  {
    if (!tdefl_compress_normal(d))
      return d->m_prev_return_status;
  }

  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
    d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);

  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
  {
    if (tdefl_flush_block(d, flush) < 0)
      return d->m_prev_return_status;
    d->m_finished = (flush == TDEFL_FINISH);
    if (flush == TDEFL_FULL_FLUSH) { MZ_CLEAR_OBJ(d->m_hash); MZ_CLEAR_OBJ(d->m_next); d->m_dict_size = 0; }
  }

  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
}

tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
{
  MZ_ASSERT(d->m_pPut_buf_func); return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
}

tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
  d->m_pPut_buf_func = pPut_buf_func; d->m_pPut_buf_user = pPut_buf_user;
  d->m_flags = (mz_uint)(flags); d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3; d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);
  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8;
  d->m_pOutput_buf = d->m_output_buf; d->m_pOutput_buf_end = d->m_output_buf; d->m_prev_return_status = TDEFL_STATUS_OKAY;
  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0; d->m_adler32 = 1;
  d->m_pIn_buf = NULL; d->m_pOut_buf = NULL;
  d->m_pIn_buf_size = NULL; d->m_pOut_buf_size = NULL;
  d->m_flush = TDEFL_NO_FLUSH; d->m_pSrc = NULL; d->m_src_buf_left = 0; d->m_out_buf_ofs = 0;
  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
  return TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
{
  return d->m_prev_return_status;
}

mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
{
  return d->m_adler32;
}

mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
  tdefl_compressor *pComp; mz_bool succeeded; if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;
  pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor)); if (!pComp) return MZ_FALSE;
  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
  succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
  MZ_FREE(pComp); return succeeded;
}

typedef struct
{
  size_t m_size, m_capacity;
  mz_uint8 *m_pBuf;
  mz_bool m_expandable;
} tdefl_output_buffer;

static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
{
  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
  size_t new_size = p->m_size + len;
  if (new_size > p->m_capacity)
  {
    size_t new_capacity = p->m_capacity; mz_uint8 *pNew_buf; if (!p->m_expandable) return MZ_FALSE;
    do { new_capacity = MZ_MAX(128U, new_capacity << 1U); } while (new_size > new_capacity);
    pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity); if (!pNew_buf) return MZ_FALSE;
    p->m_pBuf = pNew_buf; p->m_capacity = new_capacity;
  }
  memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len); p->m_size = new_size;
  return MZ_TRUE;
}

void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);
  if (!pOut_len) return MZ_FALSE; else *pOut_len = 0;
  out_buf.m_expandable = MZ_TRUE;
  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;
  *pOut_len = out_buf.m_size; return out_buf.m_pBuf;
}

size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);
  if (!pOut_buf) return 0;
  out_buf.m_pBuf = (mz_uint8*)pOut_buf; out_buf.m_capacity = out_buf_len;
  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;
  return out_buf.m_size;
}

#ifndef MINIZ_NO_ZLIB_APIS
static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };

// level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files).
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
{
  mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
  if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

  if (!level) comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
  else if (strategy == MZ_FILTERED) comp_flags |= TDEFL_FILTER_MATCHES;
  else if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= ~TDEFL_MAX_PROBES_MASK;
  else if (strategy == MZ_FIXED) comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
  else if (strategy == MZ_RLE) comp_flags |= TDEFL_RLE_MATCHES;

  return comp_flags;
}
#endif //MINIZ_NO_ZLIB_APIS

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable:4204) // nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal)
#endif

// Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
// This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
{
  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.
  static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };
  tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor)); tdefl_output_buffer out_buf; int i, bpl = w * num_chans, y, z; mz_uint32 c; *pLen_out = 0;
  if (!pComp) return NULL;
  MZ_CLEAR_OBJ(out_buf); out_buf.m_expandable = MZ_TRUE; out_buf.m_capacity = 57+MZ_MAX(64, (1+bpl)*h); if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) { MZ_FREE(pComp); return NULL; }
  // write dummy header
  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);
  // compress image data
  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
  for (y = 0; y < h; ++y) { tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH); tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH); }
  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) { MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
  // write real header
  *pLen_out = out_buf.m_size-41;
  {
    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
    mz_uint8 pnghdr[41]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,
      0,0,(mz_uint8)(w>>8),(mz_uint8)w,0,0,(mz_uint8)(h>>8),(mz_uint8)h,8,chans[num_chans],0,0,0,0,0,0,0,
      (mz_uint8)(*pLen_out>>24),(mz_uint8)(*pLen_out>>16),(mz_uint8)(*pLen_out>>8),(mz_uint8)*pLen_out,0x49,0x44,0x41,0x54};
    c=(mz_uint32)mz_crc32(MZ_CRC32_INIT,pnghdr+12,17); for (i=0; i<4; ++i, c<<=8) ((mz_uint8*)(pnghdr+29))[i]=(mz_uint8)(c>>24);
    memcpy(out_buf.m_pBuf, pnghdr, 41);
  }
  // write footer (IDAT CRC-32, followed by IEND chunk)
  if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) { *pLen_out = 0; MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT,out_buf.m_pBuf+41-4, *pLen_out+4); for (i=0; i<4; ++i, c<<=8) (out_buf.m_pBuf+out_buf.m_size-16)[i] = (mz_uint8)(c >> 24);
  // compute final size of file, grab compressed data buffer and return
  *pLen_out += 57; MZ_FREE(pComp); return out_buf.m_pBuf;
}
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)
  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
}

#ifdef _MSC_VER
#pragma warning (pop)
#endif

// ------------------- .ZIP archive reading

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef MINIZ_NO_STDIO
  #define MZ_FILE void *
#else
  #include <stdio.h>
  #include <sys/stat.h>

  #if defined(_MSC_VER) || defined(__MINGW64__)
    static FILE *mz_fopen(const char *pFilename, const char *pMode)
    {
      FILE* pFile = NULL;
      fopen_s(&pFile, pFilename, pMode);
      return pFile;
    }
    static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
    {
      FILE* pFile = NULL;
      if (freopen_s(&pFile, pPath, pMode, pStream))
        return NULL;
      return pFile;
    }
    #ifndef MINIZ_NO_TIME
      #include <sys/utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN mz_fopen
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 _ftelli64
    #define MZ_FSEEK64 _fseeki64
    #define MZ_FILE_STAT_STRUCT _stat
    #define MZ_FILE_STAT _stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN mz_freopen
    #define MZ_DELETE_FILE remove
  #elif defined(__MINGW32__)
    #ifndef MINIZ_NO_TIME
      #include <sys/utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftello64
    #define MZ_FSEEK64 fseeko64
    #define MZ_FILE_STAT_STRUCT _stat
    #define MZ_FILE_STAT _stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
    #define MZ_DELETE_FILE remove
  #elif defined(__TINYC__)
    #ifndef MINIZ_NO_TIME
      #include <sys/utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftell
    #define MZ_FSEEK64 fseek
    #define MZ_FILE_STAT_STRUCT stat
    #define MZ_FILE_STAT stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
    #define MZ_DELETE_FILE remove
  #elif defined(__GNUC__) && _LARGEFILE64_SOURCE
    #ifndef MINIZ_NO_TIME
      #include <utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen64(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftello64
    #define MZ_FSEEK64 fseeko64
    #define MZ_FILE_STAT_STRUCT stat64
    #define MZ_FILE_STAT stat64
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
    #define MZ_DELETE_FILE remove
  #else
    #ifndef MINIZ_NO_TIME
      #include <utime.h>
    #endif
    #define MZ_FILE FILE
    #define MZ_FOPEN(f, m) fopen(f, m)
    #define MZ_FCLOSE fclose
    #define MZ_FREAD fread
    #define MZ_FWRITE fwrite
    #define MZ_FTELL64 ftello
    #define MZ_FSEEK64 fseeko
    #define MZ_FILE_STAT_STRUCT stat
    #define MZ_FILE_STAT stat
    #define MZ_FFLUSH fflush
    #define MZ_FREOPEN(f, m, s) freopen(f, m, s)
    #define MZ_DELETE_FILE remove
  #endif // #ifdef _MSC_VER
#endif // #ifdef MINIZ_NO_STDIO

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

// Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff.
enum
{
  // ZIP archive identifiers and record sizes
  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50, MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50, MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
  // Central directory header record offsets
  MZ_ZIP_CDH_SIG_OFS = 0, MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4, MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6, MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
  MZ_ZIP_CDH_METHOD_OFS = 10, MZ_ZIP_CDH_FILE_TIME_OFS = 12, MZ_ZIP_CDH_FILE_DATE_OFS = 14, MZ_ZIP_CDH_CRC32_OFS = 16,
  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20, MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24, MZ_ZIP_CDH_FILENAME_LEN_OFS = 28, MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32, MZ_ZIP_CDH_DISK_START_OFS = 34, MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36, MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38, MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
  // Local directory header offsets
  MZ_ZIP_LDH_SIG_OFS = 0, MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4, MZ_ZIP_LDH_BIT_FLAG_OFS = 6, MZ_ZIP_LDH_METHOD_OFS = 8, MZ_ZIP_LDH_FILE_TIME_OFS = 10,
  MZ_ZIP_LDH_FILE_DATE_OFS = 12, MZ_ZIP_LDH_CRC32_OFS = 14, MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18, MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26, MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
  // End of central directory offsets
  MZ_ZIP_ECDH_SIG_OFS = 0, MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4, MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6, MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10, MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12, MZ_ZIP_ECDH_CDIR_OFS_OFS = 16, MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
};

typedef struct
{
  void *m_p;
  size_t m_size, m_capacity;
  mz_uint m_element_size;
} mz_zip_array;

struct mz_zip_internal_state_tag
{
  mz_zip_array m_central_dir;
  mz_zip_array m_central_dir_offsets;
  mz_zip_array m_sorted_central_dir_offsets;
  MZ_FILE *m_pFile;
  void *m_pMem;
  size_t m_mem_size;
  size_t m_mem_capacity;
};

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]

static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
{
  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
  memset(pArray, 0, sizeof(mz_zip_array));
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
{
  void *pNew_p; size_t new_capacity = min_new_capacity; MZ_ASSERT(pArray->m_element_size); if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;
  if (growing) { new_capacity = MZ_MAX(1, pArray->m_capacity); while (new_capacity < min_new_capacity) new_capacity *= 2; }
  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity))) return MZ_FALSE;
  pArray->m_p = pNew_p; pArray->m_capacity = new_capacity;
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
{
  if (new_capacity > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing)) return MZ_FALSE; }
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
{
  if (new_size > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing)) return MZ_FALSE; }
  pArray->m_size = new_size;
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
{
  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
}

static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
{
  size_t orig_size = pArray->m_size; if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE)) return MZ_FALSE;
  memcpy((mz_uint8*)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
  return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date)
{
  struct tm tm;
  memset(&tm, 0, sizeof(tm)); tm.tm_isdst = -1;
  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900; tm.tm_mon = ((dos_date >> 5) & 15) - 1; tm.tm_mday = dos_date & 31;
  tm.tm_hour = (dos_time >> 11) & 31; tm.tm_min = (dos_time >> 5) & 63; tm.tm_sec = (dos_time << 1) & 62;
  return mktime(&tm);
}

static void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef _MSC_VER
  struct tm tm_struct;
  struct tm *tm = &tm_struct;
  errno_t err = localtime_s(tm, &time);
  if (err)
  {
    *pDOS_date = 0; *pDOS_time = 0;
    return;
  }
#else
  struct tm *tm = localtime(&time);
#endif
  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
}
#endif

#ifndef MINIZ_NO_STDIO
static mz_bool mz_zip_get_file_modified_time(const char *pFilename, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef MINIZ_NO_TIME
  (void)pFilename; *pDOS_date = *pDOS_time = 0;
#else
  struct MZ_FILE_STAT_STRUCT file_stat;
  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
  if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
    return MZ_FALSE;
  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
#endif // #ifdef MINIZ_NO_TIME
  return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time, time_t modified_time)
{
  struct utimbuf t; t.actime = access_time; t.modtime = modified_time;
  return !utime(pFilename, &t);
}
#endif // #ifndef MINIZ_NO_TIME
#endif // #ifndef MINIZ_NO_STDIO

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint32 flags)
{
  (void)flags;
  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
    return MZ_FALSE;

  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;

  pZip->m_zip_mode = MZ_ZIP_MODE_READING;
  pZip->m_archive_size = 0;
  pZip->m_central_directory_file_ofs = 0;
  pZip->m_total_files = 0;

  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
    return MZ_FALSE;
  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
{
  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
  const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  mz_uint8 l = 0, r = 0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE; pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pE = pL + MZ_MIN(l_len, r_len);
  while (pL < pE)
  {
    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
      break;
    pL++; pR++;
  }
  return (pL == pE) ? (l_len < r_len) : (l < r);
}

#define MZ_SWAP_UINT32(a, b) do { mz_uint32 t = a; a = b; b = t; } MZ_MACRO_END

// Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.)
static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
{
  mz_zip_internal_state *pState = pZip->m_pState;
  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
  const int size = pZip->m_total_files;
  int start = (size - 2) >> 1, end;
  while (start >= 0)
  {
    int child, root = start;
    for ( ; ; )
    {
      if ((child = (root << 1) + 1) >= size)
        break;
      child += (((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])));
      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
        break;
      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;
    }
    start--;
  }

  end = size - 1;
  while (end > 0)
  {
    int child, root = 0;
    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
    for ( ; ; )
    {
      if ((child = (root << 1) + 1) >= end)
        break;
      child += (((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]));
      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
        break;
      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;
    }
    end--;
  }
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint32 flags)
{
  mz_uint cdir_size, num_this_disk, cdir_disk_index;
  mz_uint64 cdir_ofs;
  mz_int64 cur_file_ofs;
  const mz_uint8 *p;
  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)]; mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
  mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
  // Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there.
  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  // Find the end of central directory record by scanning the file from the end towards the beginning.
  cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
  for ( ; ; )
  {
    int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
      return MZ_FALSE;
    for (i = n - 4; i >= 0; --i)
      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
        break;
    if (i >= 0)
    {
      cur_file_ofs += i;
      break;
    }
    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
      return MZ_FALSE;
    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
  }
  // Read and verify the end of central directory record.
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||
      ((pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) != MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
    return MZ_FALSE;

  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
  if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
    return MZ_FALSE;

  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
    return MZ_FALSE;

  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
    return MZ_FALSE;

  pZip->m_central_directory_file_ofs = cdir_ofs;

  if (pZip->m_total_files)
  {
     mz_uint i, n;

    // Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and another to hold the sorted indices.
    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
      return MZ_FALSE;

    if (sort_central_dir)
    {
      if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
        return MZ_FALSE;
    }

    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
      return MZ_FALSE;

    // Now create an index into the central directory file records, do some basic sanity checking on each record, and check for zip64 entries (which are not yet supported).
    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
    {
      mz_uint total_header_size, comp_size, decomp_size, disk_index;
      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
        return MZ_FALSE;
      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
      if (sort_central_dir)
        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) || (comp_size == 0xFFFFFFFF))
        return MZ_FALSE;
      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
      if ((disk_index != num_this_disk) && (disk_index != 1))
        return MZ_FALSE;
      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
        return MZ_FALSE;
      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
        return MZ_FALSE;
      n -= total_header_size; p += total_header_size;
    }
  }

  if (sort_central_dir)
    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

  return MZ_TRUE;
}

mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags)
{
  if ((!pZip) || (!pZip->m_pRead))
    return MZ_FALSE;
  if (!mz_zip_reader_init_internal(pZip, flags))
    return MZ_FALSE;
  pZip->m_archive_size = size;
  if (!mz_zip_reader_read_central_dir(pZip, flags))
  {
    mz_zip_reader_end(pZip);
    return MZ_FALSE;
  }
  return MZ_TRUE;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
  return s;
}

mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags)
{
  if (!mz_zip_reader_init_internal(pZip, flags))
    return MZ_FALSE;
  pZip->m_archive_size = size;
  pZip->m_pRead = mz_zip_mem_read_func;
  pZip->m_pIO_opaque = pZip;
#ifdef __cplusplus
  pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
  pZip->m_pState->m_pMem = (void *)pMem;
#endif
  pZip->m_pState->m_mem_size = size;
  if (!mz_zip_reader_read_central_dir(pZip, flags))
  {
    mz_zip_reader_end(pZip);
    return MZ_FALSE;
  }
  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    return 0;
  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
{
  mz_uint64 file_size;
  MZ_FILE *pFile = MZ_FOPEN(pFilename, "rb");
  if (!pFile)
    return MZ_FALSE;
  if (MZ_FSEEK64(pFile, 0, SEEK_END))
  {
    MZ_FCLOSE(pFile);
    return MZ_FALSE;
  }
  file_size = MZ_FTELL64(pFile);
  if (!mz_zip_reader_init_internal(pZip, flags))
  {
    MZ_FCLOSE(pFile);
    return MZ_FALSE;
  }
  pZip->m_pRead = mz_zip_file_read_func;
  pZip->m_pIO_opaque = pZip;
  pZip->m_pState->m_pFile = pFile;
  pZip->m_archive_size = file_size;
  if (!mz_zip_reader_read_central_dir(pZip, flags))
  {
    mz_zip_reader_end(pZip);
    return MZ_FALSE;
  }
  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
{
  return pZip ? pZip->m_total_files : 0;
}

static MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
{
  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return NULL;
  return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
}

mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_uint m_bit_flag;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p)
    return MZ_FALSE;
  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
  return (m_bit_flag & 1);
}

mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_uint filename_len, external_attr;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p)
    return MZ_FALSE;

  // First see if the filename ends with a '/' character.
  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  if (filename_len)
  {
    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
      return MZ_TRUE;
  }

  // Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct.
  // Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field.
  // FIXME: Remove this check? Is it necessary - we already check the filename.
  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
  if ((external_attr & 0x10) != 0)
    return MZ_TRUE;

  return MZ_FALSE;
}

mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
{
  mz_uint n;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if ((!p) || (!pStat))
    return MZ_FALSE;

  // Unpack the central directory record.
  pStat->m_file_index = file_index;
  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
  pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

  // Copy as much of the filename and comment as possible.
  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n); pStat->m_filename[n] = '\0';

  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
  pStat->m_comment_size = n;
  memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n); pStat->m_comment[n] = '\0';

  return MZ_TRUE;
}

mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
{
  mz_uint n;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p) { if (filename_buf_size) pFilename[0] = '\0'; return 0; }
  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  if (filename_buf_size)
  {
    n = MZ_MIN(n, filename_buf_size - 1);
    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pFilename[n] = '\0';
  }
  return n + 1;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
{
  mz_uint i;
  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
    return 0 == memcmp(pA, pB, len);
  for (i = 0; i < len; ++i)
    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
      return MZ_FALSE;
  return MZ_TRUE;
}

static MZ_FORCEINLINE int mz_zip_reader_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
{
  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  mz_uint8 l = 0, r = 0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pE = pL + MZ_MIN(l_len, r_len);
  while (pL < pE)
  {
    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
      break;
    pL++; pR++;
  }
  return (pL == pE) ? (int)(l_len - r_len) : (l - r);
}

static int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename)
{
  mz_zip_internal_state *pState = pZip->m_pState;
  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
  const int size = pZip->m_total_files;
  const mz_uint filename_len = (mz_uint)strlen(pFilename);
  int l = 0, h = size - 1;
  while (l <= h)
  {
    int m = (l + h) >> 1, file_index = pIndices[m], comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
    if (!comp)
      return file_index;
    else if (comp < 0)
      l = m + 1;
    else
      h = m - 1;
  }
  return -1;
}

int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
{
  mz_uint file_index; size_t name_len, comment_len;
  if ((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return -1;
  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
    return mz_zip_reader_locate_file_binary_search(pZip, pName);
  name_len = strlen(pName); if (name_len > 0xFFFF) return -1;
  comment_len = pComment ? strlen(pComment) : 0; if (comment_len > 0xFFFF) return -1;
  for (file_index = 0; file_index < pZip->m_total_files; file_index++)
  {
    const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    if (filename_len < name_len)
      continue;
    if (comment_len)
    {
      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
      const char *pFile_comment = pFilename + filename_len + file_extra_len;
      if ((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags)))
        continue;
    }
    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
    {
      int ofs = filename_len - 1;
      do
      {
        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
          break;
      } while (--ofs >= 0);
      ofs++;
      pFilename += ofs; filename_len -= ofs;
    }
    if ((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))
      return file_index;
  }
  return -1;
}

mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
  int status = TINFL_STATUS_DONE;
  mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf;
  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
  tinfl_decompressor inflator;

  if ((buf_size) && (!pBuf))
    return MZ_FALSE;

  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
    return MZ_FALSE;

  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
  if (!file_stat.m_comp_size)
    return MZ_TRUE;

  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
  // I'm torn how to handle this case - should it fail instead?
  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
    return MZ_TRUE;

  // Encryption and patch files are not supported.
  if (file_stat.m_bit_flag & (1 | 32))
    return MZ_FALSE;

  // This function only supports stored and deflate.
  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
    return MZ_FALSE;

  // Ensure supplied output buffer is large enough.
  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
  if (buf_size < needed_size)
    return MZ_FALSE;

  // Read and parse the local directory entry.
  cur_file_ofs = file_stat.m_local_header_ofs;
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    return MZ_FALSE;

  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
    return MZ_FALSE;

  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
  {
    // The file is stored or the caller has requested the compressed data.
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
      return MZ_FALSE;
    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
  }

  // Decompress the file either directly from memory or from a file input buffer.
  tinfl_init(&inflator);

  if (pZip->m_pState->m_pMem)
  {
    // Read directly from the archive in memory.
    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
    read_buf_size = read_buf_avail = file_stat.m_comp_size;
    comp_remaining = 0;
  }
  else if (pUser_read_buf)
  {
    // Use a user provided read buffer.
    if (!user_read_buf_size)
      return MZ_FALSE;
    pRead_buf = (mz_uint8 *)pUser_read_buf;
    read_buf_size = user_read_buf_size;
    read_buf_avail = 0;
    comp_remaining = file_stat.m_comp_size;
  }
  else
  {
    // Temporarily allocate a read buffer.
    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
#ifdef _MSC_VER
    if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
#else
    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
#endif
      return MZ_FALSE;
    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
      return MZ_FALSE;
    read_buf_avail = 0;
    comp_remaining = file_stat.m_comp_size;
  }

  do
  {
    size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
    {
      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
      {
        status = TINFL_STATUS_FAILED;
        break;
      }
      cur_file_ofs += read_buf_avail;
      comp_remaining -= read_buf_avail;
      read_buf_ofs = 0;
    }
    in_buf_size = (size_t)read_buf_avail;
    status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
    read_buf_avail -= in_buf_size;
    read_buf_ofs += in_buf_size;
    out_buf_ofs += out_buf_size;
  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

  if (status == TINFL_STATUS_DONE)
  {
    // Make sure the entire file was decompressed, and check its CRC.
    if ((out_buf_ofs != file_stat.m_uncomp_size) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
      status = TINFL_STATUS_FAILED;
  }

  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

  return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
    return MZ_FALSE;
  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
}

mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
{
  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
}

mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
{
  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
}

void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
{
  mz_uint64 comp_size, uncomp_size, alloc_size;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  void *pBuf;

  if (pSize)
    *pSize = 0;
  if (!p)
    return NULL;

  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);

  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
#ifdef _MSC_VER
  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
#else
  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
#endif
    return NULL;
  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
    return NULL;

  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags))
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
    return NULL;
  }

  if (pSize) *pSize = (size_t)alloc_size;
  return pBuf;
}

void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
{
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
  {
    if (pSize) *pSize = 0;
    return MZ_FALSE;
  }
  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
}

mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
  int status = TINFL_STATUS_DONE; mz_uint file_crc32 = MZ_CRC32_INIT;
  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf = NULL; void *pWrite_buf = NULL;
  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
    return MZ_FALSE;

  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
  if (!file_stat.m_comp_size)
    return MZ_TRUE;

  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
  // I'm torn how to handle this case - should it fail instead?
  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
    return MZ_TRUE;

  // Encryption and patch files are not supported.
  if (file_stat.m_bit_flag & (1 | 32))
    return MZ_FALSE;

  // This function only supports stored and deflate.
  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
    return MZ_FALSE;

  // Read and parse the local directory entry.
  cur_file_ofs = file_stat.m_local_header_ofs;
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    return MZ_FALSE;

  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
    return MZ_FALSE;

  // Decompress the file either directly from memory or from a file input buffer.
  if (pZip->m_pState->m_pMem)
  {
    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
    read_buf_size = read_buf_avail = file_stat.m_comp_size;
    comp_remaining = 0;
  }
  else
  {
    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
      return MZ_FALSE;
    read_buf_avail = 0;
    comp_remaining = file_stat.m_comp_size;
  }

  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
  {
    // The file is stored or the caller has requested the compressed data.
    if (pZip->m_pState->m_pMem)
    {
#ifdef _MSC_VER
      if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
#else
      if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
#endif
        return MZ_FALSE;
      if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
        status = TINFL_STATUS_FAILED;
      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
      cur_file_ofs += file_stat.m_comp_size;
      out_buf_ofs += file_stat.m_comp_size;
      comp_remaining = 0;
    }
    else
    {
      while (comp_remaining)
      {
        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
        {
          status = TINFL_STATUS_FAILED;
          break;
        }

        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
          file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);

        if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
        {
          status = TINFL_STATUS_FAILED;
          break;
        }
        cur_file_ofs += read_buf_avail;
        out_buf_ofs += read_buf_avail;
        comp_remaining -= read_buf_avail;
      }
    }
  }
  else
  {
    tinfl_decompressor inflator;
    tinfl_init(&inflator);

    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
      status = TINFL_STATUS_FAILED;
    else
    {
      do
      {
        mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
        size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
        {
          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
          {
            status = TINFL_STATUS_FAILED;
            break;
          }
          cur_file_ofs += read_buf_avail;
          comp_remaining -= read_buf_avail;
          read_buf_ofs = 0;
        }

        in_buf_size = (size_t)read_buf_avail;
        status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
        read_buf_avail -= in_buf_size;
        read_buf_ofs += in_buf_size;

        if (out_buf_size)
        {
          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
          {
            status = TINFL_STATUS_FAILED;
            break;
          }
          file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
          {
            status = TINFL_STATUS_FAILED;
            break;
          }
        }
      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
    }
  }

  if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
  {
    // Make sure the entire file was decompressed, and check its CRC.
    if ((out_buf_ofs != file_stat.m_uncomp_size) || (file_crc32 != file_stat.m_crc32))
      status = TINFL_STATUS_FAILED;
  }

  if (!pZip->m_pState->m_pMem)
    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
  if (pWrite_buf)
    pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

  return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
    return MZ_FALSE;
  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
{
  (void)ofs; return MZ_FWRITE(pBuf, 1, n, (MZ_FILE*)pOpaque);
}

mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
{
  mz_bool status;
  mz_zip_archive_file_stat file_stat;
  MZ_FILE *pFile;
  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
    return MZ_FALSE;
  pFile = MZ_FOPEN(pDst_filename, "wb");
  if (!pFile)
    return MZ_FALSE;
  status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
  if (MZ_FCLOSE(pFile) == EOF)
    return MZ_FALSE;
#ifndef MINIZ_NO_TIME
  if (status)
    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif
  return status;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
{
  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return MZ_FALSE;

  if (pZip->m_pState)
  {
    mz_zip_internal_state *pState = pZip->m_pState; pZip->m_pState = NULL;
    mz_zip_array_clear(pZip, &pState->m_central_dir);
    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
    if (pState->m_pFile)
    {
      MZ_FCLOSE(pState->m_pFile);
      pState->m_pFile = NULL;
    }
#endif // #ifndef MINIZ_NO_STDIO

    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
  }
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
{
  int file_index = mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
  if (file_index < 0)
    return MZ_FALSE;
  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
}
#endif

// ------------------- .ZIP archive writing

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

static void mz_write_le16(mz_uint8 *p, mz_uint16 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); }
static void mz_write_le32(mz_uint8 *p, mz_uint32 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); p[2] = (mz_uint8)(v >> 16); p[3] = (mz_uint8)(v >> 24); }
#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))

mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
{
  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
    return MZ_FALSE;

  if (pZip->m_file_offset_alignment)
  {
    // Ensure user specified file offset alignment is a power of 2.
    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
      return MZ_FALSE;
  }

  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;

  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  pZip->m_archive_size = existing_size;
  pZip->m_central_directory_file_ofs = 0;
  pZip->m_total_files = 0;

  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
    return MZ_FALSE;
  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
  return MZ_TRUE;
}

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
#ifdef _MSC_VER
  if ((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
#else
  if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
#endif
    return 0;
  if (new_size > pState->m_mem_capacity)
  {
    void *pNew_block;
    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity); while (new_capacity < new_size) new_capacity *= 2;
    if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
      return 0;
    pState->m_pMem = pNew_block; pState->m_mem_capacity = new_capacity;
  }
  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
  pState->m_mem_size = (size_t)new_size;
  return n;
}

mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
{
  pZip->m_pWrite = mz_zip_heap_write_func;
  pZip->m_pIO_opaque = pZip;
  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
    return MZ_FALSE;
  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
  {
    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
    {
      mz_zip_writer_end(pZip);
      return MZ_FALSE;
    }
    pZip->m_pState->m_mem_capacity = initial_allocation_size;
  }
  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    return 0;
  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
{
  MZ_FILE *pFile;
  pZip->m_pWrite = mz_zip_file_write_func;
  pZip->m_pIO_opaque = pZip;
  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
    return MZ_FALSE;
  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb")))
  {
    mz_zip_writer_end(pZip);
    return MZ_FALSE;
  }
  pZip->m_pState->m_pFile = pFile;
  if (size_to_reserve_at_beginning)
  {
    mz_uint64 cur_ofs = 0; char buf[4096]; MZ_CLEAR_OBJ(buf);
    do
    {
      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
      {
        mz_zip_writer_end(pZip);
        return MZ_FALSE;
      }
      cur_ofs += n; size_to_reserve_at_beginning -= n;
    } while (size_to_reserve_at_beginning);
  }
  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
{
  mz_zip_internal_state *pState;
  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    return MZ_FALSE;
  // No sense in trying to write to an archive that's already at the support max size
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
    return MZ_FALSE;

  pState = pZip->m_pState;

  if (pState->m_pFile)
  {
#ifdef MINIZ_NO_STDIO
    pFilename; return MZ_FALSE;
#else
    // Archive is being read from stdio - try to reopen as writable.
    if (pZip->m_pIO_opaque != pZip)
      return MZ_FALSE;
    if (!pFilename)
      return MZ_FALSE;
    pZip->m_pWrite = mz_zip_file_write_func;
    if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
    {
      // The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it.
      mz_zip_reader_end(pZip);
      return MZ_FALSE;
    }
#endif // #ifdef MINIZ_NO_STDIO
  }
  else if (pState->m_pMem)
  {
    // Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback.
    if (pZip->m_pIO_opaque != pZip)
      return MZ_FALSE;
    pState->m_mem_capacity = pState->m_mem_size;
    pZip->m_pWrite = mz_zip_heap_write_func;
  }
  // Archive is being read via a user provided read function - make sure the user has specified a write function too.
  else if (!pZip->m_pWrite)
    return MZ_FALSE;

  // Start writing new files at the archive's current central directory location.
  pZip->m_archive_size = pZip->m_central_directory_file_ofs;
  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  pZip->m_central_directory_file_ofs = 0;

  return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
{
  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
}

typedef struct
{
  mz_zip_archive *m_pZip;
  mz_uint64 m_cur_archive_file_ofs;
  mz_uint64 m_comp_size;
} mz_zip_writer_add_state;

static mz_bool mz_zip_writer_add_put_buf_callback(const void* pBuf, int len, void *pUser)
{
  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
    return MZ_FALSE;
  pState->m_cur_archive_file_ofs += len;
  pState->m_comp_size += len;
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
{
  (void)pZip;
  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
  (void)pZip;
  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size, const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
  size_t orig_central_dir_size = pState->m_central_dir.m_size;
  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

  // No zip64 support yet
  if ((local_header_ofs > 0xFFFFFFFF) || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size, comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
    return MZ_FALSE;

  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
  {
    // Try to push the central directory array back into its original state.
    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
    return MZ_FALSE;
  }

  return MZ_TRUE;
}

static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
{
  // Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes.
  if (*pArchive_name == '/')
    return MZ_FALSE;
  while (*pArchive_name)
  {
    if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
      return MZ_FALSE;
    pArchive_name++;
  }
  return MZ_TRUE;
}

static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
{
  mz_uint32 n;
  if (!pZip->m_file_offset_alignment)
    return 0;
  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
  return (pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1);
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
{
  char buf[4096];
  memset(buf, 0, MZ_MIN(sizeof(buf), n));
  while (n)
  {
    mz_uint32 s = MZ_MIN(sizeof(buf), n);
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
      return MZ_FALSE;
    cur_file_ofs += s; n -= s;
  }
  return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
{
  mz_uint16 method = 0, dos_time = 0, dos_date = 0;
  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  tdefl_compressor *pComp = NULL;
  mz_bool store_data_uncompressed;
  mz_zip_internal_state *pState;

  if ((int)level_and_flags < 0)
    level_and_flags = MZ_DEFAULT_LEVEL;
  level = level_and_flags & 0xF;
  store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
    return MZ_FALSE;

  pState = pZip->m_pState;

  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
    return MZ_FALSE;
  // No zip64 support yet
  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
    return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
    return MZ_FALSE;

#ifndef MINIZ_NO_TIME
  {
    time_t cur_time; time(&cur_time);
    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
  }
#endif // #ifndef MINIZ_NO_TIME

  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > 0xFFFF)
    return MZ_FALSE;

  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))
    return MZ_FALSE;

  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
  {
    // Set DOS Subdirectory attribute bit.
    ext_attributes |= 0x10;
    // Subdirectories cannot contain data.
    if ((buf_size) || (uncomp_size))
      return MZ_FALSE;
  }

  // Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.)
  if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
    return MZ_FALSE;

  if ((!store_data_uncompressed) && (buf_size))
  {
    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
      return MZ_FALSE;
  }

  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    return MZ_FALSE;
  }
  local_dir_header_ofs += num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);

  MZ_CLEAR_OBJ(local_dir_header);
  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    return MZ_FALSE;
  }
  cur_archive_file_ofs += archive_name_size;

  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
  {
    uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, buf_size);
    uncomp_size = buf_size;
    if (uncomp_size <= 3)
    {
      level = 0;
      store_data_uncompressed = MZ_TRUE;
    }
  }

  if (store_data_uncompressed)
  {
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
      return MZ_FALSE;
    }

    cur_archive_file_ofs += buf_size;
    comp_size = buf_size;

    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
      method = MZ_DEFLATED;
  }
  else if (buf_size)
  {
    mz_zip_writer_add_state state;

    state.m_pZip = pZip;
    state.m_cur_archive_file_ofs = cur_archive_file_ofs;
    state.m_comp_size = 0;

    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
      return MZ_FALSE;
    }

    comp_size = state.m_comp_size;
    cur_archive_file_ofs = state.m_cur_archive_file_ofs;

    method = MZ_DEFLATED;
  }

  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
  pComp = NULL;

  // no zip64 support yet
  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
    return MZ_FALSE;

  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
    return MZ_FALSE;

  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
    return MZ_FALSE;

  pZip->m_total_files++;
  pZip->m_archive_size = cur_archive_file_ofs;

  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  MZ_FILE *pSrc_file = NULL;

  if ((int)level_and_flags < 0)
    level_and_flags = MZ_DEFAULT_LEVEL;
  level = level_and_flags & 0xF;

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
    return MZ_FALSE;
  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
    return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
    return MZ_FALSE;

  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > 0xFFFF)
    return MZ_FALSE;

  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))
    return MZ_FALSE;
    
  pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
  if (!pSrc_file)
    return MZ_FALSE;
  MZ_FSEEK64(pSrc_file, 0, SEEK_END);
  uncomp_size = MZ_FTELL64(pSrc_file);
  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

  if (uncomp_size > 0xFFFFFFFF)
  {
    // No zip64 support yet
    MZ_FCLOSE(pSrc_file);
    return MZ_FALSE;
  }
  if (uncomp_size <= 3)
    level = 0;

  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))
  {
    MZ_FCLOSE(pSrc_file);
    return MZ_FALSE;
  }
  local_dir_header_ofs += num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }
  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);

  MZ_CLEAR_OBJ(local_dir_header);
  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
  {
    MZ_FCLOSE(pSrc_file);
    return MZ_FALSE;
  }
  cur_archive_file_ofs += archive_name_size;

  if (uncomp_size)
  {
    mz_uint64 uncomp_remaining = uncomp_size;
    void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
    if (!pRead_buf)
    {
      MZ_FCLOSE(pSrc_file);
      return MZ_FALSE;
    }

    if (!level)
    {
      while (uncomp_remaining)
      {
        mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n))
        {
          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
          MZ_FCLOSE(pSrc_file);
          return MZ_FALSE;
        }
        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
        uncomp_remaining -= n;
        cur_archive_file_ofs += n;
      }
      comp_size = uncomp_size;
    }
    else
    {
      mz_bool result = MZ_FALSE;
      mz_zip_writer_add_state state;
      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
      if (!pComp)
      {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        MZ_FCLOSE(pSrc_file);
        return MZ_FALSE;
      }

      state.m_pZip = pZip;
      state.m_cur_archive_file_ofs = cur_archive_file_ofs;
      state.m_comp_size = 0;

      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
      {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        MZ_FCLOSE(pSrc_file);
        return MZ_FALSE;
      }

      for ( ; ; )
      {
        size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);
        tdefl_status status;

        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
          break;

        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
        uncomp_remaining -= in_buf_size;

        status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);
        if (status == TDEFL_STATUS_DONE)
        {
          result = MZ_TRUE;
          break;
        }
        else if (status != TDEFL_STATUS_OKAY)
          break;
      }

      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

      if (!result)
      {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        MZ_FCLOSE(pSrc_file);
        return MZ_FALSE;
      }

      comp_size = state.m_comp_size;
      cur_archive_file_ofs = state.m_cur_archive_file_ofs;

      method = MZ_DEFLATED;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
  }

  MZ_FCLOSE(pSrc_file); pSrc_file = NULL;

  // no zip64 support yet
  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
    return MZ_FALSE;

  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
    return MZ_FALSE;

  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
    return MZ_FALSE;

  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
    return MZ_FALSE;

  pZip->m_total_files++;
  pZip->m_archive_size = cur_archive_file_ofs;

  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index)
{
  mz_uint n, bit_flags, num_alignment_padding_bytes;
  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
  size_t orig_central_dir_size;
  mz_zip_internal_state *pState;
  void *pBuf; const mz_uint8 *pSrc_central_header;

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
    return MZ_FALSE;
  if (NULL == (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))
    return MZ_FALSE;
  pState = pZip->m_pState;

  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
    return MZ_FALSE;

  cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
  cur_dst_file_ofs = pZip->m_archive_size;

  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    return MZ_FALSE;
  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
    return MZ_FALSE;
  cur_dst_file_ofs += num_alignment_padding_bytes;
  local_dir_header_ofs = cur_dst_file_ofs;
  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }

  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    return MZ_FALSE;
  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  comp_bytes_remaining = n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);

  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(sizeof(mz_uint32) * 4, MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)))))
    return MZ_FALSE;

  while (comp_bytes_remaining)
  {
    n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }
    cur_src_file_ofs += n;

    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }
    cur_dst_file_ofs += n;

    comp_bytes_remaining -= n;
  }

  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
  if (bit_flags & 8)
  {
    // Copy data descriptor
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }

    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
    {
      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
      return MZ_FALSE;
    }

    cur_src_file_ofs += n;
    cur_dst_file_ofs += n;
  }
  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

  // no zip64 support yet
  if (cur_dst_file_ofs > 0xFFFFFFFF)
    return MZ_FALSE;

  orig_central_dir_size = pState->m_central_dir.m_size;

  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
    return MZ_FALSE;

  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n))
  {
    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
    return MZ_FALSE;
  }

  if (pState->m_central_dir.m_size > 0xFFFFFFFF)
    return MZ_FALSE;
  n = (mz_uint32)orig_central_dir_size;
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
  {
    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
    return MZ_FALSE;
  }

  pZip->m_total_files++;
  pZip->m_archive_size = cur_dst_file_ofs;

  return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
{
  mz_zip_internal_state *pState;
  mz_uint64 central_dir_ofs, central_dir_size;
  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
    return MZ_FALSE;

  pState = pZip->m_pState;

  // no zip64 support yet
  if ((pZip->m_total_files > 0xFFFF) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
    return MZ_FALSE;

  central_dir_ofs = 0;
  central_dir_size = 0;
  if (pZip->m_total_files)
  {
    // Write central directory
    central_dir_ofs = pZip->m_archive_size;
    central_dir_size = pState->m_central_dir.m_size;
    pZip->m_central_directory_file_ofs = central_dir_ofs;
    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
      return MZ_FALSE;
    pZip->m_archive_size += central_dir_size;
  }

  // Write end of central directory record
  MZ_CLEAR_OBJ(hdr);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);

  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, sizeof(hdr)) != sizeof(hdr))
    return MZ_FALSE;
#ifndef MINIZ_NO_STDIO
  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
    return MZ_FALSE;
#endif // #ifndef MINIZ_NO_STDIO

  pZip->m_archive_size += sizeof(hdr);

  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
  return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize)
{
  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize))
    return MZ_FALSE;
  if (pZip->m_pWrite != mz_zip_heap_write_func)
    return MZ_FALSE;
  if (!mz_zip_writer_finalize_archive(pZip))
    return MZ_FALSE;

  *pBuf = pZip->m_pState->m_pMem;
  *pSize = pZip->m_pState->m_mem_size;
  pZip->m_pState->m_pMem = NULL;
  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
  return MZ_TRUE;
}

mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
{
  mz_zip_internal_state *pState;
  mz_bool status = MZ_TRUE;
  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
    return MZ_FALSE;

  pState = pZip->m_pState;
  pZip->m_pState = NULL;
  mz_zip_array_clear(pZip, &pState->m_central_dir);
  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
  if (pState->m_pFile)
  {
    MZ_FCLOSE(pState->m_pFile);
    pState->m_pFile = NULL;
  }
#endif // #ifndef MINIZ_NO_STDIO

  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
  {
    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
    pState->m_pMem = NULL;
  }

  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
  return status;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
  mz_bool status, created_new_archive = MZ_FALSE;
  mz_zip_archive zip_archive;
  struct MZ_FILE_STAT_STRUCT file_stat;
  MZ_CLEAR_OBJ(zip_archive);
  if ((int)level_and_flags < 0)
     level_and_flags = MZ_DEFAULT_LEVEL;
  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
    return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
    return MZ_FALSE;
  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
  {
    // Create a new archive.
    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))
      return MZ_FALSE;
    created_new_archive = MZ_TRUE;
  }
  else
  {
    // Append to an existing archive.
    if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
      return MZ_FALSE;
    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename))
    {
      mz_zip_reader_end(&zip_archive);
      return MZ_FALSE;
    }
  }
  status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
  // Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.)
  if (!mz_zip_writer_finalize_archive(&zip_archive))
    status = MZ_FALSE;
  if (!mz_zip_writer_end(&zip_archive))
    status = MZ_FALSE;
  if ((!status) && (created_new_archive))
  {
    // It's a new archive and something went wrong, so just delete it.
    int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
    (void)ignoredStatus;
  }
  return status;
}

void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
{
  int file_index;
  mz_zip_archive zip_archive;
  void *p = NULL;

  if (pSize)
    *pSize = 0;

  if ((!pZip_filename) || (!pArchive_name))
    return NULL;

  MZ_CLEAR_OBJ(zip_archive);
  if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
    return NULL;

  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL, flags)) >= 0)
    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);

  mz_zip_reader_end(&zip_archive);
  return p;
}

#endif // #ifndef MINIZ_NO_STDIO

#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

#endif // #ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
}
#endif

#endif // MINIZ_HEADER_FILE_ONLY

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/
#endif
#if defined(_WIN32) || defined(WIN32)
#ifndef JSI_WIN32COMPAT_H
#define JSI_WIN32COMPAT_H

typedef unsigned int uint;
/* TODO: bring in external regex ..
typedef struct { int n; } regex_t;
typedef struct { int n; } regmatch_t; */

enum {
    DT_UNKNOWN = 0, DT_FIFO = 1, DT_CHR = 2, DT_DIR = 4,
    DT_BLK = 6, DT_REG = 8, DT_LNK = 10, DT_SOCK = 12, DT_WHT = 14
};


/* Compatibility for Windows (mingw and msvc, not cygwin */

#include <time.h>
#include <dirent.h>
char * strptime(const char *buf, const char *fmt, struct tm *tm);

#define MAXNAMLEN FILENAME_MAX 
int scandir( const char *dirname, struct dirent ***namelist, int (*select)(const struct dirent *), 
     int (*compar)( const struct dirent **, const struct dirent ** ) 
);
int alphasort( const struct dirent **d1, const struct dirent **d2 ); 
int istrcmp( const char *s1, const char *s2 ); 

#define HAVE_DLOPEN
void *dlopen(const char *path, int mode);
int dlclose(void *handle);
void *dlsym(void *handle, const char *symbol);
char *dlerror(void);

/* MS CRT always uses three digits after 'e' */
#define JSI_SPRINTF_DOUBLE_NEEDS_FIX

#ifdef _MSC_VER
/* These are msvc vs gcc */

#if _MSC_VER >= 1000
    #pragma warning(disable:4146)
#endif

#include <limits.h>
#define jsi_wide _int64
#ifndef LLONG_MAX
    #define LLONG_MAX    9223372036854775807I64
#endif
#ifndef LLONG_MIN
    #define LLONG_MIN    (-LLONG_MAX - 1I64)
#endif
#define JSI_WIDE_MIN LLONG_MIN
#define JSI_WIDE_MAX LLONG_MAX
#define JSI_WIDE_MODIFIER "I64d"
#define strcasecmp _stricmp
#define strtoull _strtoui64
#define snprintf _snprintf

#include <io.h>

struct timeval {
    long tv_sec;
    long tv_usec;
};

int gettimeofday(struct timeval *tv, void *unused);

#define HAVE_OPENDIR
struct dirent {
    char *d_name;
};

typedef struct DIR {
    long                handle; /* -1 for failed rewind */
    struct _finddata_t  info;
    struct dirent       result; /* d_name null iff first time */
    char                *name;  /* null-terminated char string */
} DIR;

DIR *opendir(const char *name);
int closedir(DIR *dir);
struct dirent *readdir(DIR *dir);
#endif /* _MSC_VER */

#endif

#endif /* WIN32 */
#ifdef __WIN32
#ifndef JSIREGEXP_H
#define JSIREGEXP_H

#if defined(HAVE_REGCOMP) && !defined(JSI_REGEXP)
/* Use POSIX regex */
#include <regex.h>

#else

#include <stdlib.h>

/*
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 *
 * 11/04/02 (seiwald) - const-ing for string literals
 */

typedef struct {
    int rm_so;
    int rm_eo;
} regmatch_t;

/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart char that must begin a match; '\0' if none obvious
 * reganch  is the match anchored (at beginning-of-line only)?
 * regmust  string (pointer into program) that match must include, or NULL
 * regmlen  length of regmust string
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that regcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in regexec() needs it and regcomp() is computing
 * it anyway.
 */

typedef struct regexp {
    /* -- public -- */
    int re_nsub;        /* number of parenthesized subexpressions */

    /* -- private -- */
    int cflags;         /* Flags used when compiling */
    int err;            /* Any error which occurred during compile */
    int regstart;       /* Internal use only. */
    int reganch;        /* Internal use only. */
    int regmust;        /* Internal use only. */
    int regmlen;        /* Internal use only. */
    int *program;       /* Allocated */

    /* working state - compile */
    const char *regparse;       /* Input-scan pointer. */
    int p;              /* Current output pos in program */
    int proglen;        /* Allocated program size */

    /* working state - exec */
    int eflags;             /* Flags used when executing */
    const char *start;      /* Initial string pointer. */
    const char *reginput;   /* Current input pointer. */
    const char *regbol;     /* Beginning of input, for ^ check. */

    /* Input to regexec() */
    regmatch_t *pmatch;     /* submatches will be stored here */
    int nmatch;             /* size of pmatch[] */
} regexp;

typedef regexp regex_t;

#define REG_EXTENDED 0
#define REG_NEWLINE 1
#define REG_ICASE 2

#define REG_NOTBOL 16

enum {
    REG_NOERROR,      /* Success.  */
    REG_NOMATCH,      /* Didn't find a match (for regexec).  */
    REG_BADPAT,       /* >= REG_BADPAT is an error */
    REG_ERR_NULL_ARGUMENT,
    REG_ERR_UNKNOWN,
    REG_ERR_TOO_BIG,
    REG_ERR_NOMEM,
    REG_ERR_TOO_MANY_PAREN,
    REG_ERR_UNMATCHED_PAREN,
    REG_ERR_UNMATCHED_BRACES,
    REG_ERR_BAD_COUNT,
    REG_ERR_JUNK_ON_END,
    REG_ERR_OPERAND_COULD_BE_EMPTY,
    REG_ERR_NESTED_COUNT,
    REG_ERR_INTERNAL,
    REG_ERR_COUNT_FOLLOWS_NOTHING,
    REG_ERR_TRAILING_BACKSLASH,
    REG_ERR_CORRUPTED,
    REG_ERR_NULL_CHAR,
    REG_ERR_NUM
};

int regcomp(regex_t *preg, const char *regex, int cflags);
int regexec(regex_t  *preg,  const  char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
size_t regerror(int errcode, const regex_t *preg, char *errbuf,  size_t errbuf_size);
void regfree(regex_t *preg);

#endif
#endif
#endif
/* A Bison parser, made by GNU Bison 2.5.  */

/* Bison interface for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */


/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     STRING = 258,
     IDENTIFIER = 259,
     IF = 260,
     ELSE = 261,
     FOR = 262,
     IN = 263,
     WHILE = 264,
     DO = 265,
     CONTINUE = 266,
     SWITCH = 267,
     CASE = 268,
     DEFAULT = 269,
     BREAK = 270,
     FUNC = 271,
     RETURN = 272,
     LOCAL = 273,
     NEW = 274,
     DELETE = 275,
     TRY = 276,
     CATCH = 277,
     FINALLY = 278,
     THROW = 279,
     WITH = 280,
     UNDEF = 281,
     _TRUE = 282,
     _FALSE = 283,
     _THIS = 284,
     ARGUMENTS = 285,
     FNUMBER = 286,
     REGEXP = 287,
     TYPESTRING = 288,
     TYPENUMBER = 289,
     TYPENULL = 290,
     TYPEOBJECT = 291,
     TYPEBOOLEAN = 292,
     TYPEUSEROBJ = 293,
     TYPEREGEXP = 294,
     TYPEANY = 295,
     TYPEARRAY = 296,
     ELLIPSIS = 297,
     __DEBUG = 298,
     MIN_PRI = 299,
     ARGCOMMA = 300,
     DIVAS = 301,
     BXORAS = 302,
     BORAS = 303,
     BANDAS = 304,
     URSHFAS = 305,
     RSHFAS = 306,
     LSHFAS = 307,
     MODAS = 308,
     MULAS = 309,
     MNSAS = 310,
     ADDAS = 311,
     OR = 312,
     AND = 313,
     NNEQ = 314,
     EEQU = 315,
     NEQ = 316,
     EQU = 317,
     INSTANCEOF = 318,
     GEQ = 319,
     LEQ = 320,
     URSHF = 321,
     RSHF = 322,
     LSHF = 323,
     VOID = 324,
     TYPEOF = 325,
     DEC = 326,
     INC = 327,
     NEG = 328,
     MAX_PRI = 329
   };
#endif



#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif



#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
} YYLTYPE;
# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif



#ifndef __JSICODE_H__
#define __JSICODE_H__
#ifdef __WIN32
#include "win/regex.h"
#else
#include <regex.h>
#endif

/* stack change */
/* 0  nothing change */
/* +1 push */
/* -1 pop */
typedef enum {      /* SC   type of data    comment                             */
    OP_NOP,         /* 0 */
    OP_PUSHNUM,     /* +1   *double         number                              */
    OP_PUSHSTR,     /* +1   *char        string                              */
    OP_PUSHVAR,     /* +1   *FastVar        variable name                       */
    OP_PUSHUND,     /* +1   -               undefined                           */
    OP_PUSHBOO,     /* +1   int             bool                                */
    OP_PUSHFUN,     /* +1   *Jsi_Func           function                            */
    OP_PUSHREG,     /* +1   *regex_t        regex                               */
    OP_PUSHARG,     /* +1   -               push arguments(cur scope)           */
    OP_PUSHTHS,     /* +1   -               push this                           */
    OP_PUSHTOP,     /* +1   -               duplicate top                       */
    OP_PUSHTOP2,    /* +2   -               duplicate toq and top               */
    OP_UNREF,       /* 0    -               make top be right value             */
    OP_POP,         /* -n   int             pop n elements                      */
    OP_LOCAL,       /* 0    *char        add a var to current scope          */
    OP_NEG,         /* 0    -               make top = - top                    */
    OP_POS,         /* 0    -               make top = + top, (conv to number)  */
    OP_NOT,         /* 0    -               reserve top                         */
    OP_BNOT,        /* 0    -               bitwise not                         */
    OP_ADD,         /* -1   -               all math opr pop 2 elem from stack, */
    OP_SUB,         /* -1   -                calc and push back in to the stack */
    OP_MUL,         /* -1   -                                                   */
    OP_DIV,         /* -1   -                                                   */
    OP_MOD,         /* -1   -                                                   */
    OP_LESS,        /* -1   -               logical opr, same as math opr       */
    OP_GREATER,     /* -1   -                                                   */
    OP_LESSEQU,     /* -1   -                                                   */
    OP_GREATEREQU,  /* -1   -                                                   */
    OP_EQUAL,       /* -1   -                                                   */
    OP_NOTEQUAL,    /* -1   -                                                   */
    OP_STRICTEQU,   /* -1   -                                                   */
    OP_STRICTNEQ,   /* -1   -                                                   */
    OP_BAND,        /* -1   -               bitwise and                         */
    OP_BOR,         /* -1   -               bitwise or                          */
    OP_BXOR,        /* -1   -               bitwise xor                         */
    OP_SHF,         /* -1   int(right)      signed shift left or shift right    */
    OP_INSTANCEOF,  /* -1 */
    OP_ASSIGN,      /* -n   int             if n = 1, assign to lval,           */
                    /*                      n = 2, assign to object member      */
    OP_SUBSCRIPT,   /* -1   -               do subscript TOQ[TOP]               */
    OP_INC,         /* 0    int             data indicate prefix/postfix inc/dec                */
    OP_TYPEOF,      /* 0    obj                                                                 */
    OP_IN,          /* 0    obj                                                                 */
    OP_DEC,         /* 0    int                                                                 */
    OP_KEY,         /* +1   -               push an iter object that contain all key in top     */
    OP_NEXT,        /* -1   -               assign next key to top, make top be res of this opr */
    OP_JTRUE,       /* -1   int             jmp to offset if top is true,                       */
    OP_JFALSE,      /* -1   int             jmp to offset if top is false,                      */
    OP_JTRUE_NP,    /* 0    int             jtrue no pop version                                */
    OP_JFALSE_NP,   /* 0    int             jfalse no pop version                               */
    OP_JMP,         /* 0    int             jmp to offset                                       */
    OP_JMPPOP,      /* -n   *JmpPopInfo     jmp to offset with pop n                            */
    OP_FCALL,       /* -n+1 int             call func with n args, pop then, make ret to be top */
    OP_NEWFCALL,    /* -n+1 int             same as fcall, call as a constructor                */
    OP_RET,         /* -n   int             n = 0|1, return with arg                            */
    OP_DELETE,      /* -n   int             n = 1, delete var, n = 2, delete object member      */
    OP_CHTHIS,      /* 0,   -               make toq as new 'this'                              */
    OP_OBJECT,      /* -n*2+1   int         create object from stack, and push back in          */
    OP_ARRAY,       /* -n+1 int             create array object from stack, and push back in    */
    OP_EVAL,        /* -n+1 int             eval can not be assign to other var                 */
    OP_STRY,        /* 0    *TryInfo        push try statment poses Jsi_LogWarn to trylist             */
    OP_ETRY,        /* 0    -               end of try block, jmp to finally                    */
    OP_SCATCH,      /* 0    *char        create new scope, assign to current excption        */
    OP_ECATCH,      /* 0    -               jmp to finally                                      */
    OP_SFINAL,      /* 0    -               restore scope chain create by Scatch                */
    OP_EFINAL,      /* 0    -               end of finally, any unfinish code in catch, do it   */
    OP_THROW,       /* 0    -               make top be last exception, pop trylist till catched*/
    OP_WITH,        /* -1   -               make top be top of scopechain, add to trylist       */
    OP_EWITH,       /* 0    -               pop trylist                                         */
    OP_RESERVED,    /* 0    ReservedInfo*   reserved, be replaced by iterstat by jmp/jmppop     */
    OP_DEBUG,       /* 0    -               DEBUG OPCODE, output top                            */
    OP_LASTOP       /* 0    -               END OF OPCODE                                       */
} Eopcode;

#define RES_CONTINUE    1
#define RES_BREAK       2


typedef struct OpCode {
    Eopcode op;
    void *data;
    unsigned int line:24;
    unsigned char alloc;
    const char *fname;
} OpCode;

typedef struct OpCodes_ {
    OpCode *codes;
    int code_len;
    int code_size;
    
    int expr_counter;           /* context related expr count */
    int lvalue_flag;            /* left value count/flag */
    const char *lvalue_name; /* left value name */
#ifdef JSI_MEM_DEBUG
    Jsi_HashEntry *hPtr;
    int id;
#endif
} OpCodes;


typedef struct TryInfo {
    int trylen;
    int catchlen;
    int finallen;
} TryInfo;

typedef struct ReservedInfo {
    int type;
    const char *label;
    int topop;
} ReservedInfo;

typedef struct JmpPopInfo {
    int off;
    int topop;
} JmpPopInfo;

typedef struct YYLTYPE jsi_Pline;

//void jsi_codes_print(OpCodes *ops);
void jsi_code_decode(OpCode *op, int currentip, char *buf, int bsiz);

#endif /* __JSICODE_H__ */
#ifndef __JSIINT_H__
#define __JSIINT_H__

//#define HIDE_MEMLEAKS /* TODO: fix memory leaks and ref count bugs, ie Jsi_DecrRefCount */
#define JSI_DEBUG_MEMORY
#ifdef JSI_DEBUG_MEMORY
#define Assert(n) assert(n)
#else
#define Assert(n)
#endif
#ifndef JSI_OMIT_SIGNATURES
#define JSI_HAS_SIG
#define JSI_HAS_SIG_HASHENTRY 1
#define JSI_HAS_SIG_LISTENTRY 1
#endif
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#define __USE_GNU
#endif
#define VAL_REFCNT
#define VAL_REFCNT2

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <ctype.h>
#include <assert.h>

#ifdef __WIN32 /* TODO: support windows signal??? */
#define JSI_OMIT_SIGNAL
#endif

#ifndef JSI_AMALGAMATION

#ifdef __WIN32
#include "win/compat.h"
#include "win/regex.h"
#else
#define HAVE_REGCOMP
#include <sys/time.h>
#endif
#endif

#include <time.h>

#ifndef JSI_IS64BIT
#ifdef __GNUC__
#ifdef __X86_64__
#define JSI_IS64BIT 1
#endif
#else /* GCC */
#if _WIN64 || __amd64__
#define JSI_IS64BIT 1
#endif
#endif /* GCC */
#endif /* JSI_IS64BIT */

#ifndef JSI_IS64BIT
#define JSI_IS64BIT 0
#endif

#define JSMN_FREE(p) Jsi_Free(p)
#define JSMN_MALLOC(l) Jsi_Malloc(l)
#define JSMN_REALLOC(p,l) Jsi_Realloc(p,l)

#define JSI_HAS_SIG /* Signatures to help with debugging */
#ifdef JSI_HAS_SIG
#ifndef SIGASSERT
#define SIGASSERT(s,n) assert((s) && (s)->sig == (int)JSI_SIG_##n);
#endif
#define SIGINIT(s,n) (s)->sig = JSI_SIG_##n;
#define __VALSIG__ JSI_SIG_VALUE,
#else
#define SIGASSERT(s,n)
#define SIGINIT(s,n)
#define __VALSIG__
#endif

#define JSI_HAS___PROTO__ 1  // Support setting and getting prototypes. 1=set/get funcs, 2=__proto__ assign.

#ifndef uint
typedef unsigned int uint;
#endif
#ifndef uchar
typedef unsigned char uchar;
#endif

#ifndef JSI_AMALGAMATION
#include "jsi.h"
#endif

#define ALLOC_MOD_SIZE 16      /* Increase allocs by increments of 16. */
#define MAX_ARRAY_LIST 100000  /* Default Max size of an array convertable to list form */
#define MAX_LOOP_COUNT 10000000 /* Limit infinite loops */
#define JSI_MAX_ALLOC_BUF  100000000 /* Limit for dynamic memory allocation hunk */
#define JSI_MAX_SCOPE (BUFSIZ/2)
typedef enum {
    JSI_SIG_ITEROBJ=0xdeadbee1, JSI_SIG_FUNCOBJ, JSI_SIG_SCOPE, JSI_SIG_VALUE,
    JSI_SIG_OBJ, JSI_SIG_USERDATA, JSI_SIG_INTERP, JSI_SIG_PARSER,
    JSI_SIG_FILEOBJ, JSI_SIG_INTERPOBJ, JSI_SIG_FUNC, JSI_SIG_CMDSPECITEM, JSI_SIG_HASH,
    JSI_SIG_HASHENTRY, JSI_SIG_TREE, JSI_SIG_TREEENTRY, JSI_SIG_LIST, JSI_SIG_LISTENTRY,
    JSI_SIG_USER_REG, JSI_SIG_EVENT,
    JSI_SIG_ARGTYPE, JSI_SIG_FORINVAR, JSI_SIG_CASELIST, JSI_SIG_CASESTAT,
    JSI_SIG_FASTVAR, JSI_SIG_INTERPSTREVENT, JSI_SIG_ALIASCMD, JSI_SIG_SOCKET, JSI_SIG_SOCKETPSS
} jsi_Sig;

struct OpCode;

#ifdef  JSI_DEBUG_MEMORY
extern void jsi_VALCHK(Jsi_Value *v);
extern void jsi_OBJCHK(Jsi_Obj *o);
#define VALCHK(val) jsi_VALCHK(val)
#define OBJCHK(val) jsi_OBJCHK(val)
#else
#define VALCHK(val)
#define OBJCHK(val)
#endif

/* Scope chain */
typedef struct jsi_ScopeChain_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Value **chains;  /* values(objects) */
    int chains_cnt;         /* count */
} jsi_ScopeChain;

/* Function obj */
/* a Jsi_FuncObj is a raw function with own scope chain */
struct Jsi_FuncObj_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Func *func;
    jsi_ScopeChain *scope;
};

typedef int (Jsi_IterProc)(Jsi_IterObj *iterObj, Jsi_Value *val, Jsi_Value *var, int index);

/* Jsi_IterObj, use only in for-in statement */
struct Jsi_IterObj_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    const char **keys;
    int size; 
    int count;
    int iter;
    int isArrayList;            /* If an array list do not store keys. */
    Jsi_Obj *obj;
    int cur;                    /* Current array cursor. */
    int depth;                  /* Used to create list of keys. */
    Jsi_IterProc *iterCmd;
};

typedef struct UserObjReg_ { /* Per interp userobj registration. */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_UserObjReg *reg;
    Jsi_Hash* hashPtr;
    int idx;
} UserObjReg;

/* User defined object */
typedef struct Jsi_UserObj_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Hash *id;
    void *data;
    const char *prefix;
    Jsi_UserObjReg *reg;
    struct UserObjReg_ *ureg;
    uint idx;
    Jsi_HashEntry* hPtr;
} Jsi_UserObj;

typedef struct {
    int valueCnt;
    int objCnt;
    int valueAllocCnt;
    int objAllocCnt;
#ifdef JSI_MEM_DEBUG
    Jsi_Hash *valueDebugTbl;
    Jsi_Hash *objDebugTbl;
    int memDebugCallIdx;
#endif
} Jsi_InterpDebug;

#ifdef JSI_MEM_DEBUG
#ifndef JSI_AMALGAMATION
#include "jsiCode.h"
#endif
typedef struct 
{
    const char *fname;
    int line;
    const char *func;
    const char *label;
    const char *label2;
    const char *label3;
    uint Idx;
    uint flags;
    struct OpCode *ip;
    int ipLine;
    Eopcode ipOp;
    const char* ipFname;
    Jsi_HashEntry *hPtr;
    Jsi_Interp *interp;
} jsi_ValueDebug;
#endif

struct Jsi_Obj_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int refcnt;                 /* reference count */
    Jsi_otype ot:8;             /* object type */
    uint isarrlist:1;           /* Array type. */
    uint isstrkey:1;            /* Key string registered in interp->strKeyTbl (do not free) */
    uint isJSONstr:1;
    uint clearProto:1;          /* Prototype changed, clean it up at exit. */
    uint unused1:2;
    uint unused2:16;
    union {                     /* switched on by value of "ot" */
        int val;
        Jsi_Number num;
        Jsi_String s;
        Jsi_Regex *robj;
        Jsi_FuncObj *fobj;
        Jsi_IterObj *iobj;
        Jsi_UserObj *uobj;
    } d;
    uint arrMaxSize;                 /* Max allocated space for array. */
    uint arrCnt;                     /* Count of actually set keys. */
    Jsi_Value **arr;   /* Array values. */  
    Jsi_Tree *tree;                 /* Tree storage (should be union with array). */
    Jsi_Value *__proto__;           /* TODO: memory leaks when this is changed */
    struct Jsi_Obj_ *constructor;
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebug VD;
#endif
};

/*#pragma pack(1)*/


struct Jsi_Value_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int refCnt:24;
    Jsi_vtype vt:8;             /* value type */
    union {
        uint flag:8;
        struct vflagbit {
            uint readonly:1;
            uint dontenum:1;  /* Dont enumerate. */
            uint dontdel:1;
            uint innershared:1; /* All above used only for objkeys. */
            uint isarrlist:1;
            uint isstrkey:1;    /* Key string registered in interp->strKeyTbl (do not free) */
            uint unused:1;
            uint onstack:1;     /* Stack value. */  
        } bits;
    } f;
    union {                     /* see above */
        int val;
        Jsi_Number num;
        Jsi_String s;
        Jsi_Obj *obj;
        struct Jsi_Value_ *lval;
    } d;
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebug VD;
#endif
};

#ifndef JSI_SMALL_HASH_TABLE
#define JSI_SMALL_HASH_TABLE 10
#endif

typedef union jsi_HashKey_ {
    void *oneWordValue;
    unsigned long words[1];
    char string[4]; 
} jsi_HashKey;

typedef unsigned int jsi_Hash;

typedef struct Jsi_HashEntry_ {
#ifdef JSI_HAS_SIG_HASHENTRY
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_HASH
    struct Jsi_HashEntry_ *nextPtr;
    Jsi_Hash *tablePtr;
    jsi_Hash hval;
    void* clientData;
    jsi_HashKey key;
} Jsi_HashEntry;

typedef struct Jsi_Hash_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_HASH
    Jsi_HashEntry **buckets;
    Jsi_HashEntry *staticBuckets[JSI_SMALL_HASH_TABLE];
    int numBuckets;
    int numEntries;
    int rebuildSize;
    jsi_Hash mask;
    unsigned int downShift;
    int keyType;
    Jsi_HashEntry *(*createProc) (Jsi_Hash *tablePtr, const void *key, int *newPtr);
    Jsi_HashEntry *(*findProc) (Jsi_Hash *tablePtr, const void *key);
    Jsi_HashDeleteProc *freeProc;
    int (*lockProc) (Jsi_Hash *tablePtr, int lock);
    Jsi_Interp *interp;
} Jsi_Hash;

struct Jsi_Tree_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_TREE
    Jsi_Interp *interp;
    Jsi_TreeEntry *root;
    unsigned int numEntries, keyType, epoch;
    struct {
        unsigned int 
            inserting:1, destroyed:1,
            nonredblack:1,  /* Disable red/black handling on insert/delete. */
            internstr:1,    /* STRINGPTR keys are stored in strHash */
            valuesonly:1,   /* Values must be of type JSI_VALUE */
            unused:28;
    } flags;
    Jsi_Hash* strHash;  /* String hash table to use if INTERNSTR; setup on first Create if not defined. */
    Jsi_RBCreateProc *createProc;
    Jsi_RBCompareProc *compareProc;
    Jsi_DeleteProc *freeProc;
};

typedef union jsi_TreeKey_ {
    void *oneWordValue;
    char string[4];
    const char *stringKey;
} jsi_TreeKey;

typedef struct Jsi_TreeEntry_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int typ; // JSI_MAP_TREE
    Jsi_Tree *treePtr;
    struct Jsi_TreeEntry_* left;
    struct Jsi_TreeEntry_* right;
    struct Jsi_TreeEntry_* parent;
    union { /* FLAGS: bottom 16 bits for JSI, upper 16 bits for users. First 7 map to JSI_OM_ above. */
        struct { 
            unsigned int readonly:1, dontenum:1, dontdel:1, innershared:1, isarrlist:1, isstrkey:1, unused:1,
                color:1,
                reserve:8,
                user0:8,
                user1:1, user2:1, user3:1, user4:1, user5:1, user6:1, user7:1, user8:1;
        } bits;
        int flags;
    } f;
    void* value;
    jsi_TreeKey key;
} Jsi_TreeEntry;

typedef struct Jsi_List_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int numEntries;
    Jsi_ListEntry *head;
    Jsi_ListEntry *tail;
    Jsi_Mutex *mutex;
    Jsi_ListAttr attr;
    /*void *data;
    int dataSpace;
    int useMutex;
    Jsi_ListDeleteProc *freeProc; // Related lists share this field.
    Jsi_ListLockProc *lockProc; */
} Jsi_List;

typedef struct Jsi_ListEntry_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    struct Jsi_ListEntry_ *next;
    struct Jsi_ListEntry_ *prev;
    struct Jsi_List_ *list;
    void *value;
} Jsi_ListEntry;


// List is a slightly less efficent thin wrapper around Tree/Hash: abstracts ordered/unordered lists.
typedef struct Jsi_Map_ {
    Jsi_Map_Type typ;
    union {
        Jsi_Hash *hash;
        Jsi_Tree *tree;
    } v;
} Jsi_Map;


typedef struct jsi_ArgValue_ {
    char *name;
    int type;
    Jsi_Value *defValue;
} jsi_ArgValue;

typedef struct Jsi_ScopeStrs_ {
    jsi_ArgValue *args;
    int count;
    int _size;  // Used in allocation only.
    int varargs;
    int typeCnt;
    int firstDef;
    int argCnt;
} Jsi_ScopeStrs;

struct OpCodes_;
typedef struct OpCodes_ OpCodes;

/* Program/parse state(context) */
typedef struct jsi_Pstate_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int err_count;              /* Jsi_LogError count after parse */
    int eval_flag;              /* 1 if currently executing in an eval function */
    int funcDefs;               /* Count of functions defined. 0 means we can delete this cache (eventually). */
    OpCodes *opcodes;    /* Execution codes. */
    struct Lexer *lexer;        /* seq provider */

    int _context_id;            /* used in FastVar-locating */
    Jsi_Value *last_exception;
    Jsi_Interp *interp;
    Jsi_HashEntry *hPtr;
    Jsi_Hash *argsTbl;
    Jsi_Hash *strTbl;
    Jsi_Hash *fastVarTbl;
    int argType;                // Used during parsing to aggregate type.
} jsi_Pstate;

#ifndef JSI_AMALGAMATION
#include "jsiPstate.h"
#include "parser.h"
#include "jsiCode.h"
#include "jsiLexer.h"
#endif

typedef struct FastVar_ {
    jsi_Sig sig;
    int context_id:31;
    unsigned int isglob:1;
    jsi_Pstate *ps;
    struct {
        char *varname;
        struct Jsi_Value_ *lval;
    } var;
} FastVar;

typedef enum { FC_NORMAL, FC_BUILDIN } Jsi_Func_Type;

/* raw function data, with script function or system Jsi_CmdProc */
struct Jsi_Func_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Func_Type type;                         /* type */
    struct OpCodes_ *opcodes;    /* FC_NORMAL, codes of this function */
    Jsi_CmdProc *callback;            /* FC_BUILDIN, callback */

    Jsi_ScopeStrs *argnames;                 /* FC_NORMAL, argument names */
    Jsi_ScopeStrs *localnames;               /* FC_NORMAL, local var names */
    union {
        uint flags;
        struct {
            uint res:8, hasattr:1, isobj:1 , iscons:1, res2:4;
        } bits;
    } f;
    union {
        uint i;
        struct {
            uint addargs:1 , iscons:1, isdiscard:1, res:5;
        } bits;
    } callflags;
    int refCnt;
    void *privData;                 /* context data given in create. */
    Jsi_CmdSpec *cmdSpec;
    const char *name;  /* Name for non-anonymous function. */
    uint retType;  /* Type name: or of Jsi_otype*/
    int callCnt;
    Jsi_ScopeStrs *typeArgs;
    const char *script;  /* Script created in. */
    Jsi_Value *bindArgs;
    jsi_Pline bodyline; /* Body line info. */
    Jsi_HashEntry *hPtr;
};

typedef struct {
    char *origFile; /* Short file name. */
    char *fileName; /* Fully qualified name. */
    char *dirName;  /* Directory name. */
    int useCnt;
} jsi_FileInfo;

enum {
    STACK_INIT_SIZE=1024, STACK_INCR_SIZE=1024, STACK_MIN_PAD=100,
    JSI_MAX_CALLFRAME_DEPTH=1000, /* default max nesting depth for procs */
    JSI_MAX_EVAL_DEPTH=1000, /* default max nesting depth for eval */
    JSI_MAX_INCLUDE_DEPTH=50,  JSI_MAX_SUBINTERP_DEPTH=10
    /*,JSI_ON_STACK=0x80*/
};

typedef struct InterpStrEvent_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int rc, isExec, tryDepth, errLine;
    const char *errFile;
    Jsi_Value *objData;
    Jsi_DString func;
    Jsi_DString data;
    struct InterpStrEvent_ *next;
    void *mutex;
} InterpStrEvent;

typedef enum { jsi_TypeChk_Disable, jsi_TypeChk_Warn, jsi_TypeChk_Error, jsi_TypeChk_Static } jsi_TypeChk;
typedef void (*jsiCallTraceProc)(Jsi_Interp *interp, const char *funcName, const char *file, int line, Jsi_CmdSpec* spec, Jsi_Value* _this, Jsi_Value* args);

struct Jsi_Interp_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    uint deleting:1;
    uint destroying:1;
    uint hasEventHdl:1;
    uint indexLoaded:2;
    int exited;
    int exitCode;
    int refCount;
    int callTrace;
    int opTrace;
    int memDebug;
    Jsi_Bool nDebug; /* Disable asserts */
    Jsi_Bool isMain;
    Jsi_Bool compat;
    Jsi_Bool doUnlock;
    Jsi_Bool isSafe;
    Jsi_Bool noInherit;
    Jsi_Bool noUndef;
    Jsi_Bool fileStrict;  /* Error out on file not found, etc. */
    Jsi_Bool hasCallee;
    Jsi_Bool noreadline;
    Jsi_Bool nocacheOpCodes;
    Jsi_Bool noSubInterps;
    Jsi_Bool privKeys;
    Jsi_Bool subthread;
    Jsi_Bool logAllowDups;
    jsi_TypeChk typeCheck;
   // Jsi_Bool staticCheck;
    int flags;
    int evalFlags;
    Jsi_InterpDebug dbStatic;
    Jsi_InterpDebug *dbPtr;
    jsiCallTraceProc traceHook;
    int opCnt;  /* Count of instructions eval'ed */
    int maxOpCnt;
    int maxUserObjs;
    int userObjCnt;
    int funcCnt;
    int level;  /* Nesting level of eval/func/cmd calls. */
    int maxDepth;/* Max allowed eval recursion. */
    int maxIncDepth;
    int includeDepth;
    int maxInterpDepth;
    int interpDepth;
    int didReturn;
    uint codeCacheHit;
    uint funcCallCnt;
    uint cmdCallCnt;
    uint eventIdx;
#ifdef JSI_MEM_DEBUG
    uint valueDebugIdx;
    Jsi_Hash *codesTbl;
#endif
    jsi_ScopeChain *gsc;
    Jsi_Value *csc;
    struct Jsi_Interp_ *parent, *mainInterp;
    jsi_ScopeChain *ingsc;
    Jsi_Value *incsc;
    Jsi_Value *inthis;
    Jsi_Value *onComplete;
    Jsi_Value *onEval;
    Jsi_Value *onExit;
    Jsi_Value *safeReadDirs;
    Jsi_Value *safeWriteDirs;
    Jsi_Value *execZip;
    void (*logHook)(char *buf, va_list va);
    int (*evalHook)(struct Jsi_Interp_* interp, const char *curFile, int curLine);
    const char *name;

    int tryDepth, withDepth, inParse;
    Jsi_Value *retPtr;       /* Return value from eval */
    jsi_Pstate *ps;
    /*int argc;
    char **argv;*/
    Jsi_Value *argv0;
    Jsi_Value *args;
    Jsi_Value *console;
    Jsi_Value *scriptFile;  /* Start script returned by info.argv0(). */
    const char *scriptStr;
    const char *curFile;
    const char *homeDir;
    char *curDir;
    int asc;    /* "A constructor" used by IsConstructorCall(). */
    int Sp;
    int maxStack;

    Jsi_Hash *onDeleteTbl;  /* Cleanup funcs to call on interp delete. */
    Jsi_Hash *assocTbl;
    Jsi_Hash *cmdSpecTbl; /* Jsi_CmdSpecs registered. */
    Jsi_Hash *codeTbl; /* Scripts compiled table. */
    Jsi_Hash *eventTbl;
    Jsi_Hash *genValueTbl;
    Jsi_Hash *genObjTbl;
    Jsi_Hash *genDataTbl;
    Jsi_Hash *funcObjTbl;
    Jsi_Hash *funcsTbl;
    Jsi_Hash *bindTbl;
    Jsi_Hash *fileTbl;
    Jsi_Hash *lexkeyTbl;
    Jsi_Hash *protoTbl;
    Jsi_Hash *regexpTbl;    
    Jsi_Hash *strKeyTbl;  /* Global strings table. */
    Jsi_Hash *thisTbl;
    Jsi_Hash *userdataTbl;
    Jsi_Hash *varTbl;
    Jsi_Hash *preserveTbl;
    Jsi_Hash *loadTbl;
    Jsi_Hash *optionDataHash;
#ifdef VAL_REFCNT
    Jsi_Value **Stack;
    Jsi_Value **Obj_this;
#else
    Jsi_Value *Stack;
    Jsi_Value *Obj_this;
#endif
            
    Jsi_Value *Object_prototype;
    Jsi_Value *Function_prototype_prototype;
    Jsi_Value *Function_prototype;
    Jsi_Value *String_prototype;
    Jsi_Value *Number_prototype;
    Jsi_Value *Boolean_prototype;
    Jsi_Value *Array_prototype;
    Jsi_Value *RegExp_prototype;
    Jsi_Value *Date_prototype;
    
    Jsi_Value *NaNValue;
    Jsi_Value *InfValue;
    Jsi_Value *NullValue;
    Jsi_Value *nullFuncArg; /* Efficient call of no-arg func */
    Jsi_Value *nullFuncRet;
    Jsi_Value *indexFiles;
    Jsi_Obj* cleanObjs[4];

    const char *logCallback;
    const char *evalCallback;
    
    Jsi_Value *Top_object;
    Jsi_Func *lastFuncIndex;

    Jsi_Value* lastSubscriptFail;
    char* lastSubscriptFailStr;
    Jsi_Obj *lastBindSubscriptObj; /* Used for FUNC.bind() */

    Jsi_ScopeStrs *scopes[JSI_MAX_SCOPE];
    int cur_scope;
    int maxArrayList;
    int delRBCnt;
    Jsi_Func *activeFunc;  // Currently active function call.
    OpCode *curIp;  /* These 2 used for debug Log msgs. */
    char *lastPushStr; 
    char *lastPushVar;
    Jsi_Wide sigmask;
    char errMsgBuf[200];  /* Error message space for when in try. */
    int errLine;
    int errCol;
    const char *errFile;
    Jsi_Mutex* Mutex;
    Jsi_Mutex* QMutex; /* For threads queues */
    void* threadId;
    int threadCnt;
    int threadShrCnt;
    int lockTimeout; /* in milliseconds. */
    uint lockRefCnt;
    int psEpoch;
    Jsi_DString interpEvalQ;
    Jsi_DString interpMsgQ;
    InterpStrEvent *interpStrEvents;
    const char *recvCmd;
    uint threadErrCnt;  /* Count of bad thread event return codes. */
    uint threadEvalCnt;
    uint threadMsgCnt;
    void *sleepData;
    jsi_Pline *parseLine;
};


enum { JSI_REG_GLOB=0x1, JSI_REG_NEWLINE=0x2, JSI_REG_DOT_NEWLINE=0x4, JSI_REG_STATIC=0x100 };

struct Jsi_Regex_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    regex_t reg;
    int eflags;
    int flags;
    char *pattern;
};


/* Entries in interp->cmdSpecTbl. */
typedef struct Jsi_CmdSpecItem_ {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    const char *name;  /* Parent cmd. */
    Jsi_CmdSpec *spec;
    Jsi_Value *proto;
    int flags;
    void *privData;
    Jsi_HashEntry *hPtr;
    struct Jsi_CmdSpecItem_ *next; /* TODO: support user-added sub-commands. */
    const char *help;
    const char *info;
    int isCons;
} Jsi_CmdSpecItem;


/* SCOPE */
//typedef struct jsi_ScopeChain jsi_ScopeChain;

extern jsi_ScopeChain* jsi_ScopeChainNew(Jsi_Interp *interp, int cnt); /*STUB = 176*/
extern Jsi_Value* jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key); /*STUB = 177*/
extern jsi_ScopeChain* jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next); /*STUB = 178*/
extern void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc); /*STUB = 179*/

extern Jsi_Interp *jsiMainInterp; /* The main interp */
extern Jsi_Interp *jsiDelInterp; /* Interp being delete: Used by cleanup callbacks. */
extern void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr);
int jsi_global_eval(Jsi_Interp* interp, jsi_Pstate *ps, char *program,
        jsi_ScopeChain *scope, Jsi_Value *currentScope,
        Jsi_Value *_this, Jsi_Value **ret);

int jsi_FilesysInit(Jsi_Interp *interp);
int jsi_LexerInit(Jsi_Interp *interp);
int jsi_LoadInit(Jsi_Interp *interp);
int jsi_CmdsInit(Jsi_Interp *interp);
int jsi_InterpInit(Jsi_Interp *interp);
int jsi_FileCmdsInit(Jsi_Interp *interp);
int jsi_StringInit(Jsi_Interp *interp);
int jsi_ValueInit(Jsi_Interp *interp);
int jsi_NumberInit(Jsi_Interp *interp);
int jsi_ArrayInit(Jsi_Interp *interp);
int jsi_BooleanInit(Jsi_Interp *interp);
int jsi_MathInit(Jsi_Interp *interp);
int jsi_ProtoInit(Jsi_Interp *interp);
int jsi_RegexpInit(Jsi_Interp *interp);
int jsi_JSONInit(Jsi_Interp *interp);
int Jsi_InitSqlite(Jsi_Interp *interp);
int Jsi_InitMySql(Jsi_Interp *interp);
int jsi_TreeInit(Jsi_Interp *interp);
int Jsi_InitWebSocket(Jsi_Interp *interp);
int Jsi_InitSocket(Jsi_Interp *interp);
int jsi_SignalInit(Jsi_Interp *interp);
int jsi_execCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr, Jsi_DString *cStr, int *code);
int Jsi_InitZvfs(Jsi_Interp *interp);

void jsi_SignalClear(Jsi_Interp *interp, int sigNum);
int jsi_SignalIsSet(Jsi_Interp *interp, int sigNum);
/* excute opcodes
 * 1. ps, program execution context
 * 2. opcodes, codes to be executed
 * 3. scope, current scopechain, not include current scope
 * 4. currentScope, current scope
 * 5. _this, where 'this' indicated
 * 6. vret, return value
 */
extern int jsi_evalcode(jsi_Pstate *ps, OpCodes *opcodes, 
        jsi_ScopeChain *scope, Jsi_Value *currentScope,
        Jsi_Value *_this,
        Jsi_Value **vret);
        
typedef int (*Jsi_Constructor)(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, int flags, void *privData);
extern int jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc);
extern void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall);
extern int jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern int jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    
enum {StrKeyAny = 0, StrKeyFunc = 0x1, StrKeyCmd = 0x2, StrKeyVar = 0x2};

//char* jsi_KeyLookup(Jsi_Interp *interp, const char *str);
char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey);
void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who);
Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp);
void jsi_AddEventHandler(Jsi_Interp *interp);

extern const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp);
extern const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val);
extern int jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern int jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern int jsi_Md5File(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern int jsi_Sha1File(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern int jsi_Sha256File(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
extern int jsi_EncryptFile(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
     Jsi_Value **ret, Jsi_Func *funcPtr, int decrypt);

extern const char *jsi_GetHomeDir(Jsi_Interp *interp);
extern int jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret);
extern void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec);
extern Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, OpCodes *ops, jsi_Pline *line, char *name);
extern Jsi_Func *jsi_FuncNew(Jsi_Interp *interp);
extern void jsi_FreeOpcodes(OpCodes *ops);
extern void jsi_DelAssocData(Jsi_Interp *interp, void *data);

extern void jsi_UserObjFree (Jsi_Interp *interp, Jsi_UserObj *uobj);
extern int jsi_UserObjIsTrue (Jsi_Interp *interp, Jsi_UserObj *uobj);
extern int jsi_UserObjDump   (Jsi_Interp *interp, const char *argStr, Jsi_Obj *obj);
extern int jsi_UserObjDelete (Jsi_Interp *interp, void *data);
extern void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr);
extern Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name);

extern int Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret);
extern Jsi_Value* jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex);
extern void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey);
extern const char* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);
extern void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);
extern Jsi_Value* jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value *value, int flag);
extern void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret);
extern Jsi_Value* jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key);
extern void jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int index, Jsi_Value *val, int flags);
extern Jsi_Value* jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name);
extern Jsi_Value* jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent);
extern Jsi_Value* jsi_ObjValueNew(Jsi_Interp *interp);
extern Jsi_Value* Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v);
extern int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v);
extern int jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *handle);
extern Jsi_Value* jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name);
extern Jsi_Value* jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData);
extern int jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int islstat);
extern void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr);

extern Jsi_IterObj *jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterProc);
extern void jsi_IterObjFree(Jsi_IterObj *iobj);
extern Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func);
extern void jsi_FuncObjFree(Jsi_FuncObj *fobj);
extern int jsi_ArglistFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);
void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func);

extern int jsi_ieee_isnormal(Jsi_Number a);
extern int jsi_ieee_isnan(Jsi_Number a);
extern int jsi_ieee_infinity(Jsi_Number a);
extern int jsi_is_integer(Jsi_Number n);
extern int jsi_is_wide(Jsi_Number n);

extern Jsi_Number jsi_ieee_makeinf(int i);
extern Jsi_Number jsi_ieee_makenan(void);

extern void jsi_num_itoa10(int value, char* str);
extern void jsi_num_uitoa10(unsigned int value, char* str);
extern void jsi_num_dtoa2(Jsi_Number value, char* str, int prec);
extern int jsi_num_isNaN(Jsi_Number value);
extern int jsi_num_isFinite(Jsi_Number value);
extern int jsi_num_isEqual(Jsi_Number n1, Jsi_Number n2);

#ifndef MEMCLEAR
#ifndef JSI_MEM_DEBUG
#define MEMCLEAR(ptr)
#else
#define MEMCLEAR(ptr) memset(ptr, 0, sizeof(*ptr)) /* To aid debugging memory.*/
#endif
#endif

#define MAX_SUBREGEX    256
#define HAVE_LONG_LONG
#define UCHAR(s) (unsigned char)(s)
#define StrnCpy(d,s) strncpy(d,s,sizeof(d)), d[sizeof(d)-1] = 0
extern char* jsi_SubstrDup(const char *a, int start, int len);
extern int jsi_typeGet(Jsi_Interp *interp , const char *tname);
extern const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr);
extern int jsi_ArgTypeCheck(Jsi_Interp *interp, int typ, Jsi_Value *arg, const char *p1, const char *p2, int index, Jsi_Func *func);
extern void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, int isNew, const char *name, const char *namePre);
extern int jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line);
extern Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a);
extern Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue);
extern Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr);

#ifdef JSI_MEM_DEBUG
#define jsi_ValueDebugUpdate(interp, v, tbl, file, line, func) jsi_ValueDebugUpdate_(interp, &v->VD, v, interp->dbPtr->tbl, file, line, func)
#define jsi_ValueDebugLabel(v,l1,l2) jsi_ValueDebugLabel_(&v->VD,l1,l2)

#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ValueDup(interp,v) jsi_ValueDup(interp, v,__FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)

extern Jsi_Value *jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern Jsi_Value *jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern Jsi_Value *jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func);
extern Jsi_Obj *jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2);
extern void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func);
extern void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp);
extern void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp);

#define jsi_DebugValueCallIdx() ++interp->dbPtr->memDebugCallIdx
#define VALINIT { __VALSIG__ .vt=JSI_VT_UNDEF, .refCnt=1, .f={JSI_OM_ISSTATIC}, .VD={.fname=__FILE__, .line=__LINE__,.func=__PRETTY_FUNCTION__}  }
#else
#define VALINIT { __VALSIG__ .vt=JSI_VT_UNDEF, .refCnt=1, .f={JSI_OM_ISSTATIC}  }
#define jsi_ValueDebugUpdate(interp, vd, v, tbl, file, line, func)
#define jsi_ValueDebugLabel(v,l1,l2)
#define jsi_DebugValue(v,r,i,t)
#define jsi_DebugObj(o,r,i,t)
#define jsi_DebugValueCallIdx() 0
#define jsi_ValueDebugLabel_(v,l1,l2)
#endif

#define DECL_VALINIT(n) Jsi_Value n = VALINIT

extern void jsi_FilesysDone(Jsi_Interp *interp);
extern int Jsi_DoneZvfs(Jsi_Interp *interp);
void jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *func, OpCode *iPtr, Jsi_Value* args, Jsi_Value *scope);

struct Jsi_Stubs;
extern struct Jsi_Stubs *jsiStubsTblPtr;
extern char *jsi_execName;

#endif /* __JSIINT_H__ */
#ifndef __JSIPSTATE_H__
#define __JSIPSTATE_H__

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif


Jsi_ScopeStrs *jsi_ScopeStrsNew();
void jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType);
void jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss);
const char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i);

/* what lexical scope means:
 * --------------
 * var a;                       // this is first level of scope
 * function foo() {             // parsing function make lexical scope to push
 *     var b;                   // this is the second level
 *     var c = function() {     // push again
 *         var d;               // third level
 *     }                        // end of an function, pop scope
 * }                            // return to first scope
 * --------------
 */

void jsi_PstatePush(jsi_Pstate *ps);
void jsi_PstatePop(jsi_Pstate *ps);
void jsi_PstateAddVar(jsi_Pstate *ps, const char *str);
Jsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps);

void jsi_PstateFree(jsi_Pstate *ps);
jsi_Pstate *jsi_PstateNew(Jsi_Interp *interp);
void jsi_PstateClear(jsi_Pstate *ps);
const char * jsi_PstateGetFilename(jsi_Pstate *ps);
int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang);
int jsi_PstateSetString(jsi_Pstate *ps, const char *str);

extern int yyparse(jsi_Pstate *ps);




#endif /* __JSIPSTATE_H__ */
#ifndef __JSILEXER_H__
#define __JSILEXER_H__

#define YYSTYPE void *

#ifndef JSI_AMALGAMATION
#include "parser.h"
#include "jsiPstate.h"
#endif

typedef enum {
    LT_NONE,
    LT_FILE,            /* read from file */
    LT_STRING           /* read from a string */
} Jsi_Lexer_Type;

/* Lexer, where input seq provided */
typedef struct Lexer {
    Jsi_Lexer_Type ltype;
    union {
        Jsi_Channel fp;           /* LT_FILE, where to read */
        char *str;          /* LT_STRING */
    } d;
    int last_token;         /* last token returned */
    int ungot, unch[100];
    int cur;                /* LT_STRING, current char */
    int cur_line;           /* current line no. */
    int cur_char;           /* current column no. */
    jsi_Pstate *pstate;
} Lexer;

int yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate);
void yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg);

#endif /* __JSILEXER_H__ */

#ifndef __JSIUTF8_H__
#define __JSIUTF8_H__

int jsi_utf8_charlen(int c);
int jsi_utf8_index(const char *str, int charindex);
int jsi_utf8_lower(int uc);
int jsi_utf8_prev_len(const char *str, int len);
int jsi_utf8_strlen(const char *str);
int jsi_utf8_title(int uc);
int jsi_utf8_tounicode(const char *str, int *uc);
int jsi_utf8_upper(int uc);
int jsi_utf8_tounicode_case(const char *s, int *uc, int upper);
int jsi_utf8_fromunicode(char *p, unsigned uc);

#endif /* __JSIUTF8_H__ */
#ifndef __JSMN_H__
#define __JSMN_H__

#define JSMN_STATIC_DEFAULT 100

#define JSMN_DECLARE(p,token) \
    jsmn_parser p = {0}; \
    jsmntok_t tokens[JSMN_STATIC_DEFAULT]; \
    jsmn_init(&p, tokens, JSMN_STATIC_DEFAULT)

/**
 * JSON type identifier. Basic types are:
 *  o Object
 *  o Array
 *  o String
 *  o Other primitive: number, boolean (true/false) or null
 */
typedef enum {
    JSMN_PRIMITIVE = 0,
    JSMN_OBJECT = 1,
    JSMN_ARRAY = 2,
    JSMN_STRING = 3,
    JSMN_INVALID=-1
} jsmntype_t;

typedef enum {
    /* Not enough tokens were provided */
    JSMN_ERROR_NOMEM = -1,
    /* Invalid character inside JSON string */
    JSMN_ERROR_INVAL = -2,
    /* The string is not a full JSON packet, more bytes expected */
    JSMN_ERROR_PART = -3,
    /* Everything was fine */
    JSMN_SUCCESS = 0
} jsmnerr_t;

/**
 * JSON token description.
 * @param       type    type (object, array, string etc.)
 * @param       start   start position in JSON data string
 * @param       end     end position in JSON data string
 */
typedef struct {
    jsmntype_t type;
    int start;
    int end;
    uint size;
#ifdef JSMN_PARENT_LINKS
    int parent;
#endif
} jsmntok_t;

/**
 * JSON parser. Contains an array of token blocks available. Also stores
 * the string being parsed now and current position in that string
 */
typedef struct {
    uint pos; /* offset in the JSON string */
    uint toknext;    /* next token to allocate */
    int toksuper;   /* superior token node, e.g parent object or array */
    jsmntok_t *tokens, *static_tokens;
    unsigned int num_tokens;
    int no_malloc;  /* Disallow parser to dynamically grow tokens array. */
    unsigned char strict;   /* Strict parsing. */
    unsigned char flags;
    const char *errStr;
} jsmn_parser;

/**
 * Setup JSON parser with a static array of tokens and size.
 * If static_tokens is NULL, malloc array of size num_tokens (0 means use default of 100).
 */
void jsmn_init(jsmn_parser *parser, jsmntok_t *static_tokens, unsigned int num_tokens);

/**
 * Reset parser before another call to parse()
 */
void jsmn_reset(jsmn_parser *parser);

/**
 * Free allocated memory after parse.
 */
void jsmn_free(jsmn_parser *parser);

/**
 * Run JSON parser. It parses a JSON data string into and array of tokens, each describing
 * a single JSON object.  Called after jsmn_init().
 */
jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js);

/**
 * Helper functions.
 */
jsmntok_t *jsmn_token(jsmn_parser *parser, unsigned int index);
jsmntype_t jsmn_type(jsmn_parser *parser, unsigned int index);
int jsmn_toklen(jsmn_parser *parser, unsigned int index);
const char* jsmn_tokstr(jsmn_parser *parser, const char *js, unsigned int index, uint *len);
const char* jsmn_typename(int type);
const char* jsmn_errname(int code);
void jsmn_dump(jsmn_parser *parser, const char *js);

#endif /* __JSMN_H_ */
#ifndef JSI_LITE_ONLY
#ifndef _JSI_CODE_C_
#define _JSI_CODE_C_
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/* replace continue/break(coded as OP_RESERVED) jmp
 * |------------------| \
 * |                  | \\ where 'continue' jmp (jmp to step code)
 * |       ops        |  / 
 * |                  | / \
 * |------------------|    \ where 'break' jmp (jmp after step code)
 * |                  |    /
 * |       step       |   /
 * |                  |  /
 * |------------------| /
 * 1. break_only used only in switch
 * 2. desire_label, only replace if current iter statement has the same label with opcode
 * 3. topop, if not replace in current iter statment, make sure when jmp out of this loop/switch
 *    corrent stack elems poped(for in always has 2 elem, while switch has 1)
 */

static const char *op_names[OP_LASTOP] = {
    "NOP",
    "PUSHNUM",
    "PUSHSTR",
    "PUSHVAR",
    "PUSHUND",
    "PUSHBOO",
    "PUSHFUN",
    "PUSHREG",
    "PUSHARG",
    "PUSHTHS",
    "PUSHTOP",
    "PUSHTOP2",
    "UNREF",
    "POP",
    "LOCAL",
    "NEG",
    "POS",
    "NOT",
    "BNOT",
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MOD",
    "LESS",
    "GREATER",
    "LESSEQU",
    "GREATEREQU",
    "EQUAL",
    "NOTEQUAL",
    "STRICTEQU",
    "STRICTNEQ",
    "BAND",
    "BOR",
    "BXOR",
    "SHF",
    "INSTANCEOF",
    "ASSIGN",
    "SUBSCRIPT",
    "INC",
    "TYPEOF",
    "DEC",
    "IN",
    "KEY",
    "NEXT",
    "JTRUE",
    "JFALSE",
    "JTRUE_NP",
    "JFALSE_NP",
    "JMP",
    "JMPPOP",
    "FCALL",
    "NEWFCALL",
    "RET",
    "DELETE",
    "CHTHIS",
    "OBJECT",
    "ARRAY",
    "EVAL",
    "STRY",
    "ETRY",
    "SCATCH",
    "ECATCH",
    "SFINAL",
    "EFINAL",
    "THROW",
    "WITH",
    "EWITH",
    "RESERVED",
    "DEBUG"
};

static int jsiOpCodesCnt[3] = {0,0,0};

void jsi_FreeOpcodes(OpCodes *ops) {
    int i;
    for (i=0; i<ops->code_len; i++) {
        OpCode *op = ops->codes+i;
        if (op->data && op->alloc)
            Jsi_Free(op->data);
        MEMCLEAR(op);
    }
    jsiOpCodesCnt[1]++;
    jsiOpCodesCnt[2]--;
#ifdef JSI_MEM_DEBUG
    if (ops->hPtr)
        Jsi_HashEntryDelete(ops->hPtr);
#endif
    Jsi_Free(ops->codes);
    Jsi_Free(ops);
}

static OpCodes *codes_new(int size)
{
    OpCodes *ops = (OpCodes *)Jsi_Calloc(1, sizeof(*ops));
    jsiOpCodesCnt[0]++;
    jsiOpCodesCnt[2]++;
    ops->codes = (OpCode *)Jsi_Calloc(size, sizeof(OpCode));
    ops->code_size = size;
#ifdef JSI_MEM_DEBUG
    static int idNum = 0;
    ops->hPtr = Jsi_HashSet(jsiMainInterp->codesTbl, ops, ops);
    ops->id = idNum++;
#endif
    return ops;
}

static int codes_insert(OpCodes *c, Eopcode code, void *extra, int doalloc)
{
    if (c->code_size - c->code_len <= 0) {
        c->code_size += 100;
        c->codes = (OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(OpCode));
    }
    c->codes[c->code_len].op = code;
    c->codes[c->code_len].data = extra;
    c->codes[c->code_len].alloc = doalloc;
    c->code_len ++;
    return 0;
}

static int codes_insertln(OpCodes *c, Eopcode code, void *extra, jsi_Pstate *pstate, jsi_Pline *line, int doalloc)
{
    if (c->code_size - c->code_len <= 0) {
        c->code_size += 100;
        c->codes = (OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(OpCode));
    }
    c->codes[c->code_len].op = code;
    c->codes[c->code_len].data = extra;
    c->codes[c->code_len].line = (code == OP_FCALL ? line->first_line:line->first_line);
    c->codes[c->code_len].fname = jsi_PstateGetFilename(pstate);
    c->codes[c->code_len].alloc = doalloc;
    c->code_len ++;
    return 0;
}


static OpCodes *codes_join(OpCodes *a, OpCodes *b)
{
    OpCodes *ret = codes_new(a->code_len + b->code_len);
    memcpy(ret->codes, a->codes, a->code_len * sizeof(OpCode));
    memcpy(&ret->codes[a->code_len], b->codes, b->code_len * sizeof(OpCode));
    ret->code_size = a->code_len + b->code_len;
    ret->code_len = ret->code_size;
    ret->expr_counter = a->expr_counter + b->expr_counter;
#if 0
    a->code_len=0;
    jsi_FreeOpcodes(a);
    b->code_len=0;
    jsi_FreeOpcodes(b);
#else
    Jsi_Free(a->codes);
    Jsi_Free(b->codes);
#ifdef JSI_MEM_DEBUG
    if (a->hPtr)
        Jsi_HashEntryDelete(a->hPtr);
    if (b->hPtr)
        Jsi_HashEntryDelete(b->hPtr);
#endif
    Jsi_Free(a);
    Jsi_Free(b);
#endif
    jsiOpCodesCnt[1]++;
    jsiOpCodesCnt[2]-=2;
    return ret;
}

static OpCodes *codes_join3(OpCodes *a, OpCodes *b, OpCodes *c)
{
    return codes_join(codes_join(a, b), c);
}

static OpCodes *codes_join4(OpCodes *a, OpCodes *b, OpCodes *c, OpCodes *d)
{
    return codes_join(codes_join(a, b), codes_join(c, d));
}

#define NEW_CODES(doalloc,code, extra) do {                 \
        OpCodes *r = codes_new(3);                  \
        codes_insert(r, (code), (void *)(extra), doalloc);   \
        return r;                                   \
    } while(0)

#define NEW_CODESLN(doalloc,code, extra) do {                 \
        OpCodes *r = codes_new(3);                  \
        codes_insertln(r, (code), (void *)(extra), p, line, doalloc);   \
        return r;                                   \
    } while(0)

static OpCodes *code_push_undef() { NEW_CODES(0,OP_PUSHUND, 0); }
static OpCodes *code_push_bool(int v) { NEW_CODES(0,OP_PUSHBOO, v); }
static OpCodes *code_push_num(Jsi_Number *v) { NEW_CODES(1,OP_PUSHNUM, v); }
static OpCodes *code_push_string(jsi_Pstate *p, jsi_Pline *line, const char *str) {
    if (*str == 'c' && !strcmp(str,"callee"))
        p->interp->hasCallee = 1;
    NEW_CODESLN(0,OP_PUSHSTR, str);
}

static OpCodes *code_push_index(jsi_Pstate *p, jsi_Pline *line, char *varname)
{
    FastVar *n = (FastVar*)Jsi_Calloc(1,sizeof(*n)); /* TODO: free when opcodes are freed. */
    n->sig = JSI_SIG_FASTVAR;
    n->ps = p;
    n->context_id = -1;
    n->var.varname = (char*)Jsi_KeyAdd(p->interp, varname);
    Jsi_HashSet(p->fastVarTbl, n, n);
    NEW_CODESLN(1,OP_PUSHVAR, n);
}

static OpCodes *code_push_this(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_PUSHTHS, 0); }
static OpCodes *code_push_top() { NEW_CODES(0,OP_PUSHTOP, 0); }
static OpCodes *code_push_top2() { NEW_CODES(0,OP_PUSHTOP2, 0); }
static OpCodes *code_unref() { NEW_CODES(0,OP_UNREF, 0); }
static OpCodes *code_push_args() { NEW_CODES(0,OP_PUSHARG, 0); }
static OpCodes *code_push_func(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) { p->funcDefs++; NEW_CODESLN(0,OP_PUSHFUN, fun); }
static OpCodes *code_push_regex(jsi_Pstate *p, jsi_Pline *line, Jsi_Regex *reg) { NEW_CODESLN(0,OP_PUSHREG, reg); }

static OpCodes *code_local(jsi_Pstate *p, jsi_Pline *line, const char *varname) { NEW_CODESLN(0,OP_LOCAL, varname); }

static OpCodes *code_nop() { NEW_CODES(0,OP_NOP, 0); }
static OpCodes *code_neg() { NEW_CODES(0,OP_NEG, 0); }
static OpCodes *code_pos() { NEW_CODES(0,OP_POS, 0); }
static OpCodes *code_bnot() { NEW_CODES(0,OP_BNOT, 0); }
static OpCodes *code_not() { NEW_CODES(0,OP_NOT, 0); }
static OpCodes *code_mul() { NEW_CODES(0,OP_MUL, 0); }
static OpCodes *code_div() { NEW_CODES(0,OP_DIV, 0); }
static OpCodes *code_mod() { NEW_CODES(0,OP_MOD, 0); }
static OpCodes *code_add() { NEW_CODES(0,OP_ADD, 0); }
static OpCodes *code_sub() { NEW_CODES(0,OP_SUB, 0); }
static OpCodes *code_in() { NEW_CODES(0,OP_IN, 0); }
static OpCodes *code_less() { NEW_CODES(0,OP_LESS, 0); }
static OpCodes *code_greater() { NEW_CODES(0,OP_GREATER, 0); }
static OpCodes *code_lessequ() { NEW_CODES(0,OP_LESSEQU, 0); }
static OpCodes *code_greaterequ() { NEW_CODES(0,OP_GREATEREQU, 0); }
static OpCodes *code_equal() { NEW_CODES(0,OP_EQUAL, 0); } 
static OpCodes *code_notequal() { NEW_CODES(0,OP_NOTEQUAL, 0); }
static OpCodes *code_eequ() { NEW_CODES(0,OP_STRICTEQU, 0); }
static OpCodes *code_nneq() { NEW_CODES(0,OP_STRICTNEQ, 0); }
static OpCodes *code_band() { NEW_CODES(0,OP_BAND, 0); }
static OpCodes *code_bor() { NEW_CODES(0,OP_BOR, 0); }
static OpCodes *code_bxor() { NEW_CODES(0,OP_BXOR, 0); }
static OpCodes *code_shf(int right) { NEW_CODES(0,OP_SHF, right); }
static OpCodes *code_instanceof() { NEW_CODES(0,OP_INSTANCEOF, 0); }
static OpCodes *code_assign(jsi_Pstate *p, jsi_Pline *line, int h) { NEW_CODESLN(0,OP_ASSIGN, h); }
static OpCodes *code_subscript(jsi_Pstate *p, jsi_Pline *line, int right_val) { NEW_CODESLN(0,OP_SUBSCRIPT, right_val); }
static OpCodes *code_inc(jsi_Pstate *p, jsi_Pline *line, int e) { NEW_CODESLN(0,OP_INC, e); }
static OpCodes *code_dec(jsi_Pstate *p, jsi_Pline *line, int e) { NEW_CODESLN(0,OP_DEC, e); }
static OpCodes *code_typeof(jsi_Pstate *p, jsi_Pline *line, int e) { NEW_CODESLN(0,OP_TYPEOF, e); }

static OpCodes *code_fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre) { jsi_FuncCallCheck(p,line,argc,1, name, namePre);NEW_CODESLN(0,OP_FCALL, argc); }
static OpCodes *code_newfcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name) { jsi_FuncCallCheck(p,line,argc,1, name, NULL); NEW_CODESLN(0,OP_NEWFCALL, argc); }
static OpCodes *code_ret(jsi_Pstate *p, jsi_Pline *line, int n) { NEW_CODESLN(0,OP_RET, n); }
static OpCodes *code_delete(int n) { NEW_CODES(0,OP_DELETE, n); }
static OpCodes *code_chthis(int n) { NEW_CODES(0,OP_CHTHIS, n); }
static OpCodes *code_pop(int n) { NEW_CODES(0,OP_POP, n); }
static OpCodes *code_jfalse(int off) { NEW_CODES(0,OP_JFALSE, off); }
static OpCodes *code_jtrue(int off) { NEW_CODES(0,OP_JTRUE, off); }
static OpCodes *code_jfalse_np(int off) { NEW_CODES(0,OP_JFALSE_NP, off); }
static OpCodes *code_jtrue_np(int off) { NEW_CODES(0,OP_JTRUE_NP, off); }
static OpCodes *code_jmp(int off) { NEW_CODES(0,OP_JMP, off); }
static OpCodes *code_object(jsi_Pstate *p, jsi_Pline *line, int c) { NEW_CODESLN(0,OP_OBJECT, c); }
static OpCodes *code_array(jsi_Pstate *p, jsi_Pline *line, int c) { NEW_CODESLN(0,OP_ARRAY, c); }
static OpCodes *code_key() { NEW_CODES(0,OP_KEY, 0); }
static OpCodes *code_next() { NEW_CODES(0,OP_NEXT, 0); }

static OpCodes *code_eval(jsi_Pstate *p, jsi_Pline *line, int argc, OpCodes *c) {
    jsi_FreeOpcodes(c); // Eliminate leak of unused opcodes.
    NEW_CODESLN(0,OP_EVAL, argc);
}

static OpCodes *code_stry(jsi_Pstate *p, jsi_Pline *line, int trylen, int catchlen, int finlen)
{ 
    TryInfo *ti = (TryInfo *)Jsi_Calloc(1,sizeof(*ti));
    ti->trylen = trylen;
    ti->catchlen = catchlen;
    ti->finallen = finlen;
    NEW_CODESLN(1,OP_STRY, ti); 
}
static OpCodes *code_etry(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_ETRY, 0); }
static OpCodes *code_scatch(jsi_Pstate *p, jsi_Pline *line, const char *var) { NEW_CODESLN(0,OP_SCATCH, var); }
static OpCodes *code_ecatch(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_ECATCH, 0); }
static OpCodes *code_sfinal(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_SFINAL, 0); }
static OpCodes *code_efinal(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_EFINAL, 0); }
static OpCodes *code_throw(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_THROW, 0); }
static OpCodes *code_with(jsi_Pstate *p, jsi_Pline *line, int withlen) { NEW_CODESLN(0,OP_WITH, withlen); }
static OpCodes *code_ewith(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_EWITH, 0); }

static OpCodes *code_debug(jsi_Pstate *p, jsi_Pline *line) { NEW_CODESLN(0,OP_DEBUG, 0); }
static OpCodes *code_reserved(jsi_Pstate *p, jsi_Pline *line, int type, char *id)
{
    ReservedInfo *ri = (ReservedInfo*)Jsi_Calloc(1, sizeof(*ri));
    ri->type = type;
    ri->label = id;
    ri->topop = 0;
    NEW_CODESLN(1,OP_RESERVED, ri);
}

static JmpPopInfo *jpinfo_new(int off, int topop)
{
    JmpPopInfo *r = (JmpPopInfo *)Jsi_Calloc(1, sizeof(*r));
    r->off = off;
    r->topop = topop;
    return r;
}

static void code_reserved_replace(OpCodes *ops, int step_len, int break_only,
                           const char *desire_label, int topop)
{
    int i;
    for (i = 0; i < ops->code_len; ++i) {
        if (ops->codes[i].op != OP_RESERVED) continue;
        ReservedInfo *ri = (ReservedInfo *)ops->codes[i].data;

        if (ri->label) {
            if (!desire_label || Jsi_Strcmp(ri->label, desire_label) != 0) {
                ri->topop += topop;
                continue;
            }
        }
        
        if (ri->type == RES_CONTINUE) {
            if (break_only) {
                ri->topop += topop;
                continue;
            } else {
                int topop = ri->topop;
                Jsi_Free(ri);       /* kill reserved Warn, replace with other opcode */
 /*               if (ops->codes[i].data && ops->codes[i].alloc) //TODO: memory leak?
                    Jsi_Free(ops->codes[i].data);*/
                if (topop) {
                    ops->codes[i].data = jpinfo_new(ops->code_len - i, topop);
                    ops->codes[i].op = OP_JMPPOP;
                    ops->codes[i].alloc = 1;
                } else {
                    ops->codes[i].data = (void *)(ops->code_len - i);
                    ops->codes[i].op = OP_JMP;
                    ops->codes[i].alloc = 0;
                }
            }
        } else if (ri->type == RES_BREAK) {
            int topop = ri->topop;
            Jsi_Free(ri);
/*           if (ops->codes[i].data && ops->codes[i].alloc)
                Jsi_Free(ops->codes[i].data); */
            if (topop) {
                ops->codes[i].data = jpinfo_new(step_len + ops->code_len - i, topop);
                ops->codes[i].op = OP_JMPPOP;
                ops->codes[i].alloc = 1;
            } else {
                ops->codes[i].data = (void *)(step_len + ops->code_len - i);
                ops->codes[i].op = OP_JMP;
                ops->codes[i].alloc = 0;
            }
        }
    }
}

void jsi_code_decode(OpCode *op, int currentip, char *buf, int bsiz)
{
    if (op->op < 0 || op->op >= OP_LASTOP) {
        snprintf(buf, bsiz, "Bad opcode[%d] at %d", op->op, currentip);
    }
    char nbuf[100];
    sprintf(nbuf, "%d#%d", currentip, op->line);
    snprintf(buf, bsiz, "%-8s %s ", nbuf, op_names[op->op]);

    int sl = strlen(buf);
    char *bp = buf + sl;
    bsiz -= sl;
    if (op->op == OP_PUSHBOO || op->op == OP_FCALL || op->op == OP_EVAL ||
        op->op == OP_POP || op->op == OP_ASSIGN ||
        op->op == OP_RET || op->op == OP_NEWFCALL ||
        op->op == OP_DELETE || op->op == OP_CHTHIS ||
        op->op == OP_OBJECT || op->op == OP_ARRAY ||
        op->op == OP_SHF ||
        op->op == OP_INC || op->op == OP_DEC) snprintf(bp, bsiz, "%d", (int)op->data);
    else if (op->op == OP_PUSHNUM) snprintf(bp, bsiz, "%" JSI_NUMGFMT "", *((Jsi_Number *)op->data));
    else if (op->op == OP_PUSHSTR || op->op == OP_LOCAL ||
             op->op == OP_SCATCH) snprintf(bp, bsiz, "\"%s\"", op->data ? (char*)op->data:"(NoCatch)");
    else if (op->op == OP_PUSHVAR) snprintf(bp, bsiz, "var: \"%s\"", ((FastVar *)op->data)->var.varname);
    else if (op->op == OP_PUSHFUN) snprintf(bp, bsiz, "func: 0x%x", (int)op->data);
    else if (op->op == OP_JTRUE || op->op == OP_JFALSE ||
             op->op == OP_JTRUE_NP || op->op == OP_JFALSE_NP ||
             op->op == OP_JMP) snprintf(bp, bsiz, "{%d}\t#%d", (int)op->data, currentip + (int)op->data);
    else if (op->op == OP_JMPPOP) {
        JmpPopInfo *jp = (JmpPopInfo*)op->data;
        snprintf(bp, bsiz, "{%d},%d\t#%d", jp->off, jp->topop, currentip + jp->off);
    }
    else if (op->op == OP_STRY) {
        TryInfo *t = (TryInfo *)op->data;
        snprintf(bp, bsiz, "{try:%d, catch:%d, final:%d}", t->trylen, t->catchlen, t->finallen);
    }
}

/*
void jsi_codes_print(OpCodes *ops)
{
    int i = 0;
    OpCode *opcodes = ops->codes;
    int opcodesi = ops->code_len;
    
    fprintf(stderr, "opcodes count = %d\n", opcodesi);
    
    while(i < opcodesi) {
        jsi_code_decode(&opcodes[i], i);
        i++;
    }
}*/
#endif
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#define COMMENT (-128)

static int lexer_getchar(Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    int c = 0;
    if (!lex) Jsi_LogBug("No lexer init");
    if (lex->ltype == LT_FILE) {
        c = Jsi_Getc(lex->d.fp);
        if (c == EOF) c = 0;
    } else {
        if (lex->ungot) {
            c = lex->unch[--lex->ungot];
        } else {
            c = lex->d.str[lex->cur];
            if (c != 0) lex->cur++;
        }
    }
    //printf("%c", c);
    if (c == '\n') {
        //printf("!!!!!!!!!!\n");
        lex->cur_line++;
        lex->cur_char = 0;
    }
    lex->cur_char++;
    //printf("<%2x\n",c);
    return c;
}

static void lexer_ungetc(int c, Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    if (!lex) Jsi_LogBug("No lexer init");
    if (!c) return;
    if (c == '\n') {
        lex->cur_line--;
    }

    //printf("^<%c>", c);
    if (lex->ltype == LT_FILE) {
        Jsi_Ungetc(lex->d.fp, c);
    } else if (lex->ungot<=0 && lex->cur>0 && c == lex->d.str[lex->cur-1]) {
        lex->cur--;
    } else if ((lex->ungot+2)<(int)sizeof(lex->unch)) {
        lex->unch[lex->ungot++] = c;
    }
    //printf(">%2x\n",c);
}

int jsi_LexerInit(Jsi_Interp *interp)
{
    static struct st_kw {
        const char *name;
        int value;
    } keywords[] = {
        { "if", IF },
        { "else", ELSE },
        { "for", FOR },
        { "in", IN },
        { "while", WHILE },
        { "do", DO },
        { "continue", CONTINUE },
        { "switch", SWITCH },
        { "case", CASE },
        { "default", DEFAULT },
        { "break", BREAK },
        { "function", FUNC },
        { "return", RETURN },
        { "var", LOCAL },
        { "new", NEW },
        { "delete", DELETE },
        { "try", TRY },
        { "catch", CATCH },
        { "throw", THROW },
        { "finally", FINALLY },
        { "with", WITH },
        { "undefined", UNDEF },
        { "true", _TRUE },
        { "false", _FALSE },
        { "this", _THIS },
        { "arguments", ARGUMENTS },
        { "void", VOID },
        { "typeof", TYPEOF },
        { "instanceof", INSTANCEOF },
        { "string", TYPESTRING },
        { "number", TYPENUMBER },
        { "regexp", TYPEREGEXP },
        { "any", TYPEANY },
        { "userobj", TYPEUSEROBJ },
        { "boolean", TYPEBOOLEAN },
        { "array", TYPEARRAY },
        { "...", ELLIPSIS },
        { "__debug", __DEBUG }
    };
    uint i;
    Jsi_HashEntry *hPtr;
    if (!interp->lexkeyTbl->numEntries) {
        int isNew;
        for (i = 0; i < sizeof(keywords) / sizeof(struct st_kw); ++i) {
            hPtr = Jsi_HashEntryNew(interp->lexkeyTbl, keywords[i].name, &isNew);
            assert(hPtr);
            if (hPtr)
                Jsi_HashValueSet(hPtr, (void*)keywords[i].value);
        }
    }
    return JSI_OK;
}

static int iskey(const char *word, Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->lexkeyTbl, word);
    if (hPtr)
        return (int)Jsi_HashValueGet(hPtr);
    return 0;
}

static char *do_string(Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    int n, c = lexer_getchar(lex);
    int endchar = c;
    
    int bufi = 0, bsiz, done = 0;
    char unibuf[bsiz=BUFSIZ], *buf = unibuf, *ret;
    
    while (!done) {
        if (bufi >= (bsiz-5)) {
            int nsiz = bsiz+=BUFSIZ;
            if (buf!=unibuf) 
                buf = (char*)Jsi_Realloc(buf, nsiz);
            else {
                buf = (char*)Jsi_Malloc(nsiz);
                memcpy(buf, unibuf, sizeof(unibuf));
            }
            bsiz = nsiz;
        }
        c = lexer_getchar(lex);
        if (c == EOF || c == 0) {
            goto saw_eof;
        }
        if (c == '\\') {
            n = lexer_getchar(lex);
            switch(n) {
                case 'b': buf[bufi++] = '\b'; break;
                case 'f': buf[bufi++] = '\f'; break;
                case 'n': buf[bufi++] = '\n'; break;
                case 'r': buf[bufi++] = '\r'; break;
                case 't': buf[bufi++] = '\t'; break;
                case EOF: 
                case 0:
saw_eof:
                    Jsi_LogError("Unexpected EOF parsing string.");
                    buf[bufi++] = 0;
                    done = 1;
                    break;
                default: buf[bufi++] = n;
            }
        } else {
            buf[bufi++] = c;
        }
        if (c == endchar) {
            bufi --;
            break;
        }
    }
    buf[bufi] = 0;
    Jsi_HashEntry *hPtr = Jsi_HashSet(lex->pstate->strTbl, buf, NULL);
    ret = (char*)Jsi_HashKeyGet(hPtr);
    if (buf != unibuf)
        Jsi_Free(buf);
    return ret;
}

static char *do_regex(Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;

    int n, bufi = 0, bsiz;
    char unibuf[bsiz=BUFSIZ], *buf = unibuf, *ret = NULL;
    
    buf[bufi++] = lexer_getchar(lex);     /* first '/'*/
    while (1) {
        if (bufi >= (bsiz-5)) {
            int nsiz = bsiz+=BUFSIZ;
            if (buf!=unibuf) 
                buf = (char*)Jsi_Realloc(buf, nsiz);
            else {
                buf = (char*)Jsi_Malloc(nsiz);
                memcpy(buf, unibuf, sizeof(unibuf));
            }
            bsiz = nsiz;
        }
        int c = lexer_getchar(lex);
        if (c == EOF || c == 0) {
            goto saw_eof;
        }
        if (c == '\\') {
            n = lexer_getchar(lex);
            if (n == EOF || c == 0) {
saw_eof:
                Jsi_LogError("Unexpected EOF parsing regular expression.\n");
                buf[bufi++] = 0;
                break;
            }
            
            buf[bufi++] = c;
            buf[bufi++] = n;
        } else if (c == '/') {
            buf[bufi++] = '/';
            while (1) {
                buf[bufi++] = c = lexer_getchar(lex);
                if (!isalnum(c)) break;
            }
            buf[bufi-1] = 0;
            lexer_ungetc(c, lex);
            break;
        } else {
            buf[bufi++] = c;
        }
    }
    Jsi_HashEntry *hPtr = Jsi_HashSet(lex->pstate->strTbl, buf, NULL);
    ret = (char*)Jsi_HashKeyGet(hPtr);
    ret = Jsi_Strdup(buf);
    if (buf != unibuf)
        Jsi_Free(buf);
    return ret;
}

static int do_sign(Lexer *lex)
{
    static struct st_sn {
        const char *name;
        int len;
        int value;
    } signs[] = {
        { ">>>=", 4, URSHFAS },
        { "<<=", 3, LSHFAS },
        { ">>=", 3, RSHFAS },
        { "===", 3, EEQU },
        { "!==", 3, NNEQ },
        { ">>>", 3, URSHF },
        { "==", 2, EQU },
        { "!=", 2, NEQ },
        { "<=", 2, LEQ },
        { ">=", 2, GEQ },
        { "++", 2, INC },
        { "--", 2, DEC },
        { "&&", 2, AND },
        { "||", 2, OR },
        { "+=", 2, ADDAS },
        { "-=", 2, MNSAS },
        { "*=", 2, MULAS },
        { "/=", 2, DIVAS },
        { "%=", 2, MODAS },
        { "&=", 2, BANDAS },
        { "|=", 2, BORAS },
        { "^=", 2, BXORAS },
        { "<<", 2, LSHF },
        { ">>", 2, RSHF }
    };

    int bufi;
    char buf[4];
    uint i;
    for (bufi = 0; bufi < 4; ++bufi) {
        int c = lexer_getchar(lex);
        if (c == 0 || c == '\n') break;
        buf[bufi] = c;
    }
    if (!bufi) return 0;
    
    for (i = 0; i < sizeof(signs)/sizeof(struct st_sn); ++i) {
        if (bufi < signs[i].len) continue;
        if (strncmp(buf, signs[i].name, signs[i].len) == 0) {
            int j;
            for (j = bufi - 1; j >= signs[i].len; --j)
                lexer_ungetc(buf[j], lex);

            return signs[i].value;
        }
    }
    
    for (i = bufi - 1; i >= 1; --i)
        lexer_ungetc(buf[i], lex);
    
    return buf[0];
}

#define LOCATION_START(loc, lex) do {       \
    (loc)->first_line = (lex)->cur_line;    \
    (loc)->first_column = (lex)->cur_char;  \
    } while(0)
#define LOCATION_END(loc, lex) do {         \
    (loc)->last_line = (lex)->cur_line;     \
    (loc)->last_column = (lex)->cur_char;   \
    } while(0)

static void eat_comment(Lexer *lex)
{
    Jsi_Interp *interp = lex->pstate->interp;
    int c;
    while((c = lexer_getchar(lex))) {
        if (c == '*') {
            c = lexer_getchar(lex);
            if (c == '/') return;
            lexer_ungetc(c, lex);
        }
    }
    Jsi_LogError("Comment reach end of file");
}

static int _yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, Lexer *lex)
{
    int c, c2;
    Jsi_Interp *interp = lex->pstate->interp;
    
    char word[BUFSIZ];
    int wi = 0;

    LOCATION_START(yyllocp, lex);
    while ((c = lexer_getchar(lex)) == ' ' || c == '\t' || c == '\n' || c == '\r');
    
    if (c=='.') {
        c2 = lexer_getchar(lex);
        if (!isdigit(c2)) {
            lexer_ungetc(c2, lex);
        } else {
            word[wi++] = c;
            c = c2;
        }
    }
            
    if (isdigit(c)) {
        int base = 10, digCnt = 1, isdig, cpre=0;
        Jsi_Number fval;
        char *eptr = NULL;
        word[wi++] = c;
        while (wi < 1020) {
            c = lexer_getchar(lex);
            isdig = isxdigit(c);
            if (isdig)
                digCnt++;
            if (isdig || c == '.' || toupper(c)=='P' || toupper(c)=='E'
                || (toupper(c)=='X' && wi==1 && word[0] == '0')
                || ((c == '-' || c == '+') && toupper(cpre)=='E')
                || (base == 16 && isxdigit(c))) {
                if (toupper(c)=='X')
                    base = 16;
                word[wi++] = c;
                cpre = c;
                continue;
            }
            lexer_ungetc(c, lex);
            break;
        }
        word[wi] = 0;

        if (word[0] == '0' && (digCnt+(base==16)) == wi)
            fval = (Jsi_Number)strtoll(word, &eptr, base);
        else
            fval = (Jsi_Number)strtod(word, &eptr);
        LOCATION_END(yyllocp, lex);
        if (eptr == NULL || *eptr)
            Jsi_LogError("invalid number: %s", word); 
        Jsi_Number *db = (Jsi_Number *)Jsi_Malloc(sizeof(Jsi_Number));
        *db = fval;
        *yylvalp = db;
        return FNUMBER;
    } else if (c == '"' || c == '\'') {
        lexer_ungetc(c, lex);
        *yylvalp = do_string(lex);
        LOCATION_END(yyllocp, lex);
        return STRING;
    } else if (isalpha(c) || c == '_' || c == '$') {
        lexer_ungetc(c, lex);
        while (wi < 1020) {
            c = lexer_getchar(lex);
            if (!isalnum(c) && c != '_' && c != '$') break;
            word[wi++] = c;
        }
        lexer_ungetc(c, lex);
        
        word[wi] = 0;
        int r = iskey(word, lex);
        if (r) return r;
        *yylvalp = (char*)Jsi_KeyAdd(interp,word); /*Jsi_Strdup(word);*/
        LOCATION_END(yyllocp, lex);
        return IDENTIFIER;
    } else if (c == '/') {
        int d = lexer_getchar(lex);
        if (d == '/') {
            while ((d = lexer_getchar(lex)) != '\r' && d != '\n' && d != 0);
            return COMMENT;
        } else if (d == '*') {
            eat_comment(lex);
            return COMMENT;
        } else lexer_ungetc(d, lex);
        
        if (lex->last_token == '=' || lex->last_token == '(' || lex->last_token == ':'
            || lex->last_token == '?' || lex->last_token == ','
            || lex->last_token == '[' || lex->last_token == '{')
        {
            lexer_ungetc(c, lex);
            
            char *regtxt = do_regex(lex);
            Jsi_Regex *re = Jsi_RegExpNew(interp, regtxt, JSI_REG_STATIC);
            if (!(*yylvalp = re)) {
                 Jsi_Free(regtxt);
                 return -1;
            }
            Jsi_Free(regtxt);
            return REGEXP;
        }
    }
    
    lexer_ungetc(c, lex);
    
    int r = do_sign(lex);
    LOCATION_END(yyllocp, lex);
    return r;
}

int yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate)
{
    int ret;
    do {
        ret = _yylex(yylvalp, yyllocp, pstate->lexer);
    } while (ret == COMMENT);
/*
    if (ret < 128 && ret > 0) printf("%c\n", ret);
    else printf("%d\n", ret);
*/
    pstate->lexer->last_token = ret;
    return ret;
}

void yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg)
{
    Jsi_Interp *interp = ps->interp;
    interp->errLine = yylloc->first_line;
    interp->errCol = yylloc->first_column;
    Jsi_LogParse("%s:%d.%d: error: %s\n", interp->curFile?interp->curFile:"@", yylloc->first_line, 
        yylloc->first_column, msg);
    /*if (interp->curFile)
        fprintf(stderr, "%s:%d.%d: %s\n",  interp->curFile, yylloc->first_line, yylloc->first_column, msg);
    else
        fprintf(stderr, "@%d.%d: %s\n", yylloc->first_line, yylloc->first_column, msg);*/
    ps->err_count++;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/* Return value from call to function will is not used. */
int Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr) {
    return funcPtr->callflags.bits.isdiscard;
}

int Jsi_FunctionIsConstructor(Jsi_Func *funcPtr)
{
    return (funcPtr->f.bits.iscons);
}

Jsi_CmdSpec *Jsi_FunctionGetSpecs(Jsi_Func *funcPtr)
{
    return funcPtr->cmdSpec;
}

void *Jsi_FunctionPrivData(Jsi_Func *funcPtr)
{
    return funcPtr->privData;
}

const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp)
{
    switch (otyp) {
        case JSI_OT_NUMBER:     return "number"; 
        case JSI_OT_STRING:     return "string"; 
        case JSI_OT_BOOL:       return "boolean"; 
        case JSI_OT_ARRAY:      return "array"; 
        case JSI_OT_FUNCTION:   return "function"; 
        case JSI_OT_OBJECT:     return "object"; 
        case JSI_OT_REGEXP:     return "regexp"; 
        case JSI_OT_ITER:       return "iter"; 
        case JSI_OT_USEROBJ:    return "userobj"; 
        case JSI_OT_UNDEF:      return "any"; break;
    }
    return "undefined";
}

const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val)
{
    switch (val->vt) {
        case JSI_VT_NUMBER:     return "number"; 
        case JSI_VT_STRING:     return "string"; 
        case JSI_VT_BOOL:       return "boolean"; 
        case JSI_VT_OBJECT:     return jsi_ObjectTypeName(interp, val->d.obj->ot); 
        case JSI_VT_VARIABLE:   return "variable"; 
        case JSI_VT_NULL:       return "null"; 
        case JSI_VT_UNDEF:      break;
    }
    return "undefined";
}

int jsi_typeGet(Jsi_Interp *interp, const char *tname) {
    if (!tname)
        return 0;
    if (strchr(tname, '|')) {
        int argc, i, rc, val = 0;
        char **argv;
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        Jsi_SplitStr(tname, &argc, &argv, "|", &dStr);
        for (i=0; i<argc; i++) {
            rc = jsi_typeGet(interp, argv[i]);
            if (rc < 0)
                break;
            val |= rc;
        }
        Jsi_DSFree(&dStr);
        if (i<argc)
            return -1;
        return val;
    }
    switch (tname[0]) {
        case 'b': if (Jsi_Strcmp(tname, "boolean")==0) return JSI_TT_BOOL; break;
        case 's': if (Jsi_Strcmp(tname, "string")==0) return JSI_TT_STRING; break;
        case 'n': if (Jsi_Strcmp(tname, "null")==0) return JSI_TT_NULL;
                  if (Jsi_Strcmp(tname, "number")==0) return JSI_TT_NUMBER; break;
        case 'o': if (Jsi_Strcmp(tname, "object")==0) return JSI_TT_OBJECT; break;
        case 'r': if (Jsi_Strcmp(tname, "regexp")==0) return JSI_TT_REGEXP; break;
        case 'f': if (Jsi_Strcmp(tname, "function")==0) return JSI_TT_FUNCTION; break;
        case 'u': if (Jsi_Strcmp(tname, "userobj")==0) return JSI_TT_USEROBJ; break;
        case 'a': if (Jsi_Strcmp(tname, "array")==0) return JSI_TT_ARRAY;
                  if (Jsi_Strcmp(tname, "any")==0) return 0; break;
    }
    Jsi_LogWarn("Type \"%s\" is not one of boolean, string, number, function, array, object, regexp, userobj, null, or any", tname);
    return 0;
}

const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr) {
    if (typ<=0 || (typ&JSI_TT_ANY)) {
        Jsi_DSAppend(dStr, "any", NULL);
        return Jsi_DSValue(dStr);
    }
    int i = 0;
    if (typ&JSI_TT_NUMBER) Jsi_DSAppend(dStr, (i++?"|":""), "number", NULL);
    if (typ&JSI_TT_STRING) Jsi_DSAppend(dStr, (i++?"|":""), "string", NULL);
    if (typ&JSI_TT_BOOL)  Jsi_DSAppend(dStr, (i++?"|":""), "boolean", NULL);
    if (typ&JSI_TT_ARRAY)   Jsi_DSAppend(dStr, (i++?"|":""), "array", NULL);
    if (typ&JSI_TT_FUNCTION) Jsi_DSAppend(dStr, (i++?"|":""), "function", NULL);
    if (typ&JSI_TT_OBJECT) Jsi_DSAppend(dStr, (i++?"|":""), "object", NULL);
    if (typ&JSI_TT_REGEXP) Jsi_DSAppend(dStr, (i++?"|":""), "regexp", NULL);
    if (typ&JSI_TT_USEROBJ) Jsi_DSAppend(dStr, (i++?"|":""), "userobj", NULL);
    if (typ&JSI_TT_NULL) Jsi_DSAppend(dStr, (i++?"|":""), "null", NULL);
    if (typ&JSI_TT_VOID) Jsi_DSAppend(dStr, (i++?"|":""), "void", NULL);
    return Jsi_DSValue(dStr);
}

int jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1, const char *p2, int index, Jsi_Func *func) {
    int rc;
    if (typ <= 0 || (interp->typeCheck <= jsi_TypeChk_Disable))
        return JSI_OK;
    if (index == 0 && func && func->type == FC_BUILDIN && interp->typeCheck < jsi_TypeChk_Static)
        return JSI_OK; // Normally do not check return types for builtins.
    if ((typ&JSI_TT_ANY)) return JSI_OK;
    if (index == 0 && (typ&JSI_TT_VOID)) {
        if (arg->vt != JSI_VT_UNDEF)
            goto done;
        return JSI_OK;
    }
    if (arg->vt == JSI_VT_UNDEF)
        return JSI_OK;
    rc = JSI_OK;
    if (typ&JSI_TT_NUMBER && Jsi_ValueIsNumber(interp, arg)) return rc;
    if (typ&JSI_TT_STRING && Jsi_ValueIsString(interp, arg)) return rc;
    if (typ&JSI_TT_BOOL && Jsi_ValueIsBoolean(interp, arg))  return rc;
    if (typ&JSI_TT_ARRAY && Jsi_ValueIsArray(interp, arg))   return rc;
    if (typ&JSI_TT_FUNCTION && Jsi_ValueIsFunction(interp, arg)) return rc;
    if (typ&JSI_TT_OBJECT && Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) return rc;
    if (typ&JSI_TT_REGEXP && Jsi_ValueIsObjType(interp, arg, JSI_OT_REGEXP)) return rc;
    if (typ&JSI_TT_USEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_USEROBJ)) return rc;
    if (typ&JSI_TT_NULL && Jsi_ValueIsNull(interp, arg)) return rc;
done:
    {
        Jsi_DString dStr = {};
        const char *exp = jsi_typeName(interp, typ, &dStr);
        const char *vtyp = jsi_ValueTypeName(interp, arg);
        char idxBuf[200];
        idxBuf[0] = 0;
        if (index>0)
            sprintf(idxBuf, " %d", index);
        int ltyp = JSI_LOG_WARN;
        if (interp->typeCheck >= jsi_TypeChk_Error) {
            ltyp = JSI_LOG_ERROR;
            rc = JSI_ERROR;
        }
        Jsi_LogMsg(interp, ltyp, "type mismatch %s%s: \"%s\" is \"%s\" not a \"%s\"", p1, idxBuf, p2, vtyp, exp);
        Jsi_DSFree(&dStr);
    }
    return rc;
}

int jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line)
{
    int rc = JSI_OK;
    if (interp->typeCheck <= jsi_TypeChk_Disable)
        return JSI_OK;
    Jsi_CmdSpec *spec = func->cmdSpec;
    Jsi_ScopeStrs *ss = func->argnames;
    if (ss==NULL && spec == NULL)
        return JSI_OK;
    int minArgs, maxArgs, mis = 0, varargs = 0;
    char nbuf[100];
    if (func->type == FC_BUILDIN) {
        varargs =  (spec->maxArgs<0);
        maxArgs = spec->maxArgs + func->callflags.bits.addargs;
        minArgs = spec->minArgs + func->callflags.bits.addargs;
    } else {
        varargs = ss->varargs;
        minArgs = (ss->firstDef>0 ? ss->firstDef-1 : ss->count);
        maxArgs = ss->count;
        mis = (argc != ss->count);
        if (func->retType == 0 && ss && ss->typeCnt == 0)
            return JSI_OK;
    }
    if (varargs) {
        if (argc >= minArgs)
            return JSI_OK;
        mis = (argc<minArgs);
    } else 
        mis = (argc<minArgs || argc>maxArgs);
    if (mis) {
        if (varargs)
            snprintf(nbuf, sizeof(nbuf), "%d or more", minArgs);
        else if (maxArgs > minArgs)
            snprintf(nbuf, sizeof(nbuf), "%d-%d", minArgs, maxArgs);
        else
            snprintf(nbuf, sizeof(nbuf), "%d", maxArgs);
        if (line)
            interp->parseLine = line;
        int ltyp = JSI_LOG_WARN;
        if (interp->typeCheck >= jsi_TypeChk_Error) {
            ltyp = JSI_LOG_ERROR;
            rc = JSI_ERROR;
        }
        Jsi_LogMsg(interp, ltyp, "incorrect arg count in function call \"%s(%s)\": got %d args, but expected %s",
            name, (spec&&spec->argStr)?spec->argStr:"", argc, nbuf);
        if (line)
            interp->parseLine = NULL;
        return rc;
    }
    return rc;
}

// Parse time function call checker.
void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, int isNew, const char *name, const char *namePre)
{
    Jsi_Interp *interp = p->interp;
    if (interp->typeCheck<jsi_TypeChk_Static || name == NULL)
        return;
    Jsi_Value *val;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    if (namePre) {
        Jsi_DSAppend(&dStr, namePre, ".", name, NULL);
        name = Jsi_DSValue(&dStr);
    }
    val = Jsi_NameLookup(interp, name);
    if (val != NULL && Jsi_ValueIsFunction(interp, val))
        jsi_RunFuncCallCheck(interp, val->d.obj->d.fobj->func, argc, name, line);
    Jsi_DSFree(&dStr);
}

/* TODO: if not in a file (an eval) save copy of body string from pstate->lexer??? */
Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, OpCodes *ops, jsi_Pline* line, char *name)
{
    Jsi_Interp *interp = pstate->interp;
    Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);
    Jsi_Func *f = jsi_FuncNew(interp);
    f->type = FC_NORMAL;
    f->opcodes = ops;
    f->argnames = args;
    f->localnames = localvar;
    f->script = interp->curFile;
    f->bodyline = *line;
    if (name)
        f->name = Jsi_KeyAdd(interp, name);
    f->retType = (Jsi_otype)pstate->argType;
    pstate->argType = 0;
    return f;
}

int Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr)
{
    Jsi_FuncObj *funcPtr;
    Jsi_Func *f;
    if (!Jsi_ValueIsFunction(interp, func))
        return JSI_ERROR;
    funcPtr = func->d.obj->d.fobj;
    f = funcPtr->func;
    SIGASSERT(f, FUNC);
    *argcPtr = f->argnames->count;
    return JSI_OK;
}

void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who)
{
    SIGASSERT(who, FUNC);
    if (who->localnames) {
        int i;
        for (i = 0; i < who->localnames->count; ++i) {
            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);
            if (argkey) {
                DECL_VALINIT(key);// = VALINIT;
                Jsi_Value *v, *kPtr = &key; // Note: a string key so no reset needed.
                Jsi_ValueMakeStringKey(interp, &kPtr, argkey);
                v = jsi_ValueObjKeyAssign(interp, arguments, kPtr, NULL, JSI_OM_DONTENUM);
                jsi_ValueDebugLabel(v, "locals", who->name);
                v = v; // Compiler warning.
            }
        }
    }
}

int Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Obj *o, Jsi_DString *dStr)
{
    if (o->ot != JSI_OT_FUNCTION)
        return JSI_ERROR;
    Jsi_Func *f = o->d.fobj->func;
    if (f->type == FC_NORMAL) {
        Jsi_DSAppend(dStr, "function ", f->name?f->name:"", "(", NULL);
        int i;
        for (i = 0; i < f->argnames->count; ++i) {
            if (i) Jsi_DSAppend(dStr, ",", NULL);
            Jsi_DSAppend(dStr,  jsi_ScopeStrsGet(f->argnames, i), NULL);
        }
        Jsi_DSAppend(dStr, ") {...}", NULL);
    } else {
        Jsi_DSAppend(dStr, "function ", f->name?f->name:"", "() { [native code] }", NULL);
    }
    return JSI_OK;
}

Jsi_Value *jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name)
{
    Jsi_Obj *o = Jsi_ObjNew(interp);
    Jsi_Func *f = jsi_FuncNew(interp);
    Jsi_ObjIncrRefCount(interp, o);
    o->ot = JSI_OT_FUNCTION;
    f->type = FC_BUILDIN;
    f->callback = callback;
    f->privData = NULL;
    o->d.fobj = jsi_FuncObjNew(interp, f);
    f->cmdSpec = (Jsi_CmdSpec*)Jsi_Calloc(1,sizeof(Jsi_CmdSpec));
    Jsi_HashSet(interp->genDataTbl, f->cmdSpec, f->cmdSpec);
    f->cmdSpec->maxArgs = -1;
    if (name)
        f->cmdSpec->name = (char*)Jsi_KeyAdd(interp, name);
    f->script = interp->curFile;
    f->callback = callback;
    return Jsi_ValueMakeObject(interp,NULL, o);
}

Jsi_Value *jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData)
{
    Jsi_Obj *o = Jsi_ObjNew(interp);
    Jsi_Func *f = jsi_FuncNew(interp);
    o->ot = JSI_OT_FUNCTION;
    f->type = FC_BUILDIN;
    f->cmdSpec = cmdSpec;
    f->callback = cmdSpec->proc;
    f->privData = privData;
    f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);
    f->script = interp->curFile;
    o->d.fobj = jsi_FuncObjNew(interp, f);
    return Jsi_ValueMakeObject(interp, NULL, o);
}


/* Call a function with args: args and/or ret can be NULL. */
int Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)
{
    if (interp->deleting)
        return JSI_ERROR;
    if (!Jsi_ValueIsFunction(interp, func)) {
        Jsi_LogError("can not execute expression, expression is not a function\n");
        return JSI_ERROR;
    }
    if (!func->d.obj->d.fobj) {   /* empty function */
        return JSI_OK;
    }
    if (!ret) {
        if (!interp->nullFuncRet) {
            interp->nullFuncRet = Jsi_ValueNew(interp);
            Jsi_IncrRefCount(interp, interp->nullFuncRet);
        }
        *ret = interp->nullFuncRet;
        Jsi_ValueMakeUndef(interp, ret);
    }
    if (!args) {
        if (!interp->nullFuncArg) {
            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
            Jsi_IncrRefCount(interp, interp->nullFuncArg);
        }
        args = interp->nullFuncArg;
    }
    /* func to call */
    Jsi_Func *fstatic = func->d.obj->d.fobj->func;
    SIGASSERT(fstatic, FUNC);
    
    /* prepare args */
    if (args->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, args->d.obj)) {
        Jsi_LogError("argument must be an array\n");
        return JSI_ERROR;
    }
    /* new this */
    Jsi_Value *ntPtr = Jsi_ValueDup(interp, _this ? _this : func);
    Jsi_Func *prevActive = interp->activeFunc;
    int res = jsi_SharedArgs(interp, args, fstatic, 1);
    if (res == JSI_OK) {
        jsi_InitLocalVar(interp, args, fstatic);
        jsi_SetCallee(interp, args, func);
    
        Jsi_IncrRefCount(interp, args);
        
        if (interp->callTrace && fstatic->name)
            jsi_TraceFuncCall(interp, fstatic, NULL, args, ntPtr);
    
        interp->activeFunc = fstatic;
        if (fstatic->type == FC_NORMAL) {
            res = jsi_evalcode(interp->ps, fstatic->opcodes, func->d.obj->d.fobj->scope, 
                args, ntPtr, ret);
        } else {
            res = fstatic->callback(interp, args, ntPtr, ret, fstatic);
        }
        fstatic->callCnt++;
    }
    if (res == JSI_OK && fstatic->retType)
        res = jsi_ArgTypeCheck(interp, fstatic->retType, *ret, "returned from", fstatic->name, 0, fstatic);
    interp->activeFunc = prevActive;
    jsi_SharedArgs(interp, args, fstatic, 0);
    Jsi_DecrRefCount(interp, args);
    Jsi_DecrRefCount(interp, ntPtr);
    return res;
}

/* Special case: Call function with a single argument.  Return 1 if returns true. */
int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg)
{
    if (interp->deleting)
        return JSI_ERROR;
    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);
    int rc, bres = 0;
    if (!arg) {
        if (!interp->nullFuncArg) {
            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
            Jsi_IncrRefCount(interp, interp->nullFuncArg);
        }
        vpargs = interp->nullFuncArg;
    } else {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));
    }
    Jsi_IncrRefCount(interp, vpargs);
    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (rc == JSI_OK)
        bres = Jsi_ValueIsTrue(interp, frPtr);
    else
        Jsi_LogError("function call failed");
    Jsi_DecrRefCount(interp, frPtr);
    return bres;
}
       

Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func)
{
    Jsi_FuncObj *f = (Jsi_FuncObj*)Jsi_Calloc(1,sizeof(Jsi_FuncObj));
    f->interp = interp;
    SIGINIT(f,FUNCOBJ);
    f->func = func;
    func->refCnt++;
    return f;
}

void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func)
{
    if (--func->refCnt > 0)
        return;
    if (func->opcodes)
        jsi_FreeOpcodes(func->opcodes);
    if (func->hPtr)
        Jsi_HashEntryDelete(func->hPtr);
    if (func->localnames)
        jsi_ScopeStrsFree(interp, func->localnames);
    if (func->argnames)
        jsi_ScopeStrsFree(interp, func->argnames);
    MEMCLEAR(func);
    Jsi_Free(func);
    interp->funcCnt--;
}

Jsi_Func *jsi_FuncNew(Jsi_Interp *interp)
{
     Jsi_Func *func = (Jsi_Func*)Jsi_Calloc(1, sizeof(Jsi_Func));
     SIGINIT(func, FUNC);
     func->hPtr = Jsi_HashSet(interp->funcsTbl, func, func);
     func->refCnt = 1;
     interp->funcCnt++;
     return func;
}

void jsi_FuncObjFree(Jsi_FuncObj *fobj)
{
    if (fobj->scope)
        jsi_ScopeChainFree(fobj->interp, fobj->scope);
    if (fobj->func->bindArgs)
        Jsi_DecrRefCount(fobj->interp, fobj->func->bindArgs);
    if (fobj->func)
        jsi_FuncFree(fobj->interp, fobj->func);
    MEMCLEAR(fobj);
    Jsi_Free(fobj);
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define JSIVAL_GET_STR(pv) (pv->vt == JSI_VT_STRING ? &pv->d.s : \
  ((pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING) ? &pv->d.obj->d.s : NULL))

#define bits_set(who, mask)     ((who) |= (mask))
#define bits_unset(who, mask)   ((who) &= (~(mask)))
#define bits_get(who, mask)     ((who) & (mask))

static void IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth);

#ifdef  JSI_DEBUG_MEMORY
void jsi_VALCHK(Jsi_Value *val) {
    SIGASSERT(val,VALUE);
    assert(val->vt >= 0 && val->vt <= JSI_VT__MAX);
    if (val->vt == JSI_VT_OBJECT)
        OBJCHK(val->d.obj);
}

void jsi_OBJCHK(Jsi_Obj *obj) {
    SIGASSERT(obj,OBJ);
    assert(obj->ot >= 0 && obj->ot <= JSI_OT__MAX);
}
#endif

/*********************************************/

int Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v)
{
    SIGASSERT(v,VALUE);
    return (v->refCnt > 1);
}

int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v)
{
    SIGASSERT(v,VALUE);
    assert(v->refCnt>=0);
    jsi_DebugValue(v,"Incr", jsi_DebugValueCallIdx(), interp);
    return ++(v->refCnt);
}

int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v) {
    SIGASSERT(v,VALUE);
    if (v->refCnt<0)
        return -2;
    int ref;
    jsi_DebugValue(v,"Decr", jsi_DebugValueCallIdx(), interp);
    if ((ref = --(v->refCnt)) <= 0) {
        v->refCnt = -1;
        Jsi_ValueFree(interp, v);
    }
    return ref;
}

static Jsi_Value *ValueNew(Jsi_Interp *interp)
{
    interp->dbPtr->valueCnt++;
    interp->dbPtr->valueAllocCnt++;
    Jsi_Value *v = (Jsi_Value *)Jsi_Calloc(1,sizeof(*v));
    SIGINIT(v,VALUE)
    v->vt = JSI_VT_UNDEF;
    jsi_DebugValue(v,"New", jsi_DebugValueCallIdx(), interp);
    return v;
}

static Jsi_Value *ValueNew1(Jsi_Interp *interp)
{
    Jsi_Value *v = ValueNew(interp);
    Jsi_IncrRefCount(interp, v);
    return v;
}

static Jsi_Value *ValueDup(Jsi_Interp *interp, Jsi_Value *v)
{
    Jsi_Value *r = ValueNew1(interp);
    Jsi_ValueCopy(interp,r, v);
#ifdef JSI_MEM_DEBUG
    r->VD.label2 = "ValueDup";
#endif
    return r;
}
#ifndef JSI_MEM_DEBUG
Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {
    return ValueNew(interp);
}
Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp) {
    return ValueNew1(interp);
}
Jsi_Value *Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v) {
    return ValueDup(interp, v);
}
#else
// Debugging functions: set breakpoint with "cond B v == 0xNNN"
void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp)
{
    return;
}
void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp)
{
    return;
}
void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func)
{
    vd->fname = fname;
    vd->line = line;
    vd->func = func;
    if (!vd->Idx)
        vd->Idx = interp->dbPtr->memDebugCallIdx;
    vd->hPtr = Jsi_HashSet(tbl, v, 0);
    vd->ip = interp->curIp;
    if (vd->ip) {
        vd->ipLine = vd->ip->line;
        vd->ipOp = vd->ip->op;
        vd->ipFname = vd->ip->fname;
    }
    vd->interp = interp;
}

void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2)
{
    if (l1)
        vd->label = l1;
    if (l2)
        vd->label2 = l2;
}


Jsi_Value * jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {
    Jsi_Value *v = ValueNew(interp);
    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);
    return v;
}

Jsi_Value * jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func) {
    Jsi_Value *v = ValueNew1(interp);
    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);
    return v;
}
Jsi_Value * jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func) {
    Jsi_Value *v = ValueDup(interp, ov);
    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);
    return v;
}

#ifndef JSI_OMIT_STUBS
#undef Jsi_ValueNew
#undef Jsi_ValueNew1
Jsi_Value *Jsi_ValueNew(Jsi_Interp *interp) { return ValueNew(interp); }
Jsi_Value *Jsi_ValueNew1(Jsi_Interp *interp) { return NULL; ValueNew1(interp); }
#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#endif

#endif

Jsi_Hash *strDebug = NULL;

static void ValueFree(Jsi_Interp *interp, Jsi_Value* v)
{
    SIGASSERT(v,VALUE);
    //printf("FREE: %d\n", interp->valueCnt);
    switch (v->vt) {
        case JSI_VT_OBJECT:
            Jsi_ObjDecrRefCount(interp, v->d.obj);
            break;
        case JSI_VT_VARIABLE:
            assert(v->d.lval != v);
            Jsi_DecrRefCount(interp, v->d.lval);
            break;
        case JSI_VT_STRING:
            if (v->d.s.str && !v->f.bits.isstrkey) {
                Jsi_Free(v->d.s.str);
                /*Jsi_HashEntry *hPtr;
                if ((hPtr = Jsi_HashEntryFind(strDebug, v->d.s.str)))
                    Jsi_HashEntryDelete(hPtr);*/
            }
            break;
    }
    v->vt = JSI_VT_UNDEF;
}

void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v)
{
    interp->dbPtr->valueCnt--;
    jsi_DebugValue(v, "Free", jsi_DebugValueCallIdx(), interp);
    ValueFree(interp, v);
#ifdef JSI_MEM_DEBUG
   // if (v->VD.interp != interp)
    //    Jsi_LogWarn("cross interp delete: %p", v);
    if (v->VD.hPtr) {
        if (!Jsi_HashEntryDelete(v->VD.hPtr))
            fprintf(stderr, "Value not in hash\n");
    }
#endif
    MEMCLEAR(v);
    Jsi_Free(v);
}

/* Reset a value back to undefined, releasing string/obj if necessary. */
void Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **vPtr) {
    Jsi_Value *v = *vPtr;
    SIGASSERT(v,VALUE);
    Assert(v->vt >= 0 && v->vt <= JSI_VT__MAX);
    jsi_DebugValue(v, "Reset", jsi_DebugValueCallIdx(), interp);
    Assert(v->refCnt>=0);
    if (v->vt == JSI_VT_UNDEF)
        return;
    ValueFree(interp, v);
    v->f.flag = 0;
}

// Assign value ptrs (to=from). Decr old to, and Incr from ref count.
void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )  {
    VALCHK(from);
    if( *to == from) return;
    if (*to)
        Jsi_DecrRefCount(interp, *to);
    *to = from;
    if (from)
        Jsi_IncrRefCount(interp, from);
}


static void jsi_ValueCopyMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from, int isCopy )  {
    if (!from) {
        Jsi_ValueMakeUndef(interp, &to);
        return;
    }
    VALCHK(from);
    if( to == from) return;
    int ocnt = to->refCnt;
    Jsi_Value *ovt = NULL;
    assert(ocnt>0);
    int toVt = to->vt;
    if (toVt == JSI_VT_VARIABLE) {
        ovt = to->d.lval;
        Jsi_IncrRefCount(interp, ovt);
    }
    Jsi_ValueMakeUndef(interp, &to);
#ifdef JSI_MEM_DEBUG
    memcpy(to, from, sizeof(*to)-sizeof(to->VD));
    to->VD.label3 = from->VD.func;
#else
    *to = *from;
#endif
    if (isCopy) {
        if (to->refCnt) {
            switch (to->vt) {
                case JSI_VT_STRING:
                    if (!to->f.bits.isstrkey) {
                        to->d.s.str = Jsi_Strdup(to->d.s.str);
                        to->d.s.len = Jsi_Strlen(to->d.s.str);
                    }
                    break;
                case JSI_VT_OBJECT:
                    Jsi_ObjIncrRefCount(interp,to->d.obj);
                    break;
                case JSI_VT_VARIABLE:
                    Jsi_IncrRefCount(interp,to->d.lval);
                    break;
            }
        }
        to->refCnt = ocnt;
        if (ovt)
            Jsi_DecrRefCount(interp, ovt);
    } else {
        to->refCnt = ocnt;
        if (ovt)
            Jsi_DecrRefCount(interp, ovt);
        ocnt = from->refCnt;
#ifdef JSI_MEM_DEBUG
        memset(from, 0, sizeof(*to)-sizeof(to->VD));
#else
        memset(from, 0, sizeof(*to));
#endif
        SIGINIT(from, VALUE);
        from->refCnt = ocnt;
    }
}

void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from )  {
    return jsi_ValueCopyMove(interp, to, from, 0);
}

void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ) {
    return jsi_ValueCopyMove(interp, to, from, 1);
}

void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )
{
    if (!*to)
        *to = Jsi_ValueNew1(interp);
#ifdef JSI_MEM_DEBUG
    (*to)->VD.label3 = "ValueDup2";
#endif
    return Jsi_ValueCopy(interp, *to, from);
}

Jsi_Value *Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)
{
    Jsi_Obj *obj;
    Jsi_Value *v = NULL;
    if (interp->noInherit && key) {
        if (key[0] == 'p' && Jsi_Strcmp(key, "prototype")==0) {
            Jsi_LogError("inheritance is disabled in interp");
            return NULL;
        }
    }
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogWarn("Target is not object: %d\n", target->vt);
        return NULL;
    }
    obj = target->d.obj;
    
#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)
    if (*key == '_' && strcmp(key, "__proto__")==0 && interp->noInherit==0)
        return obj->__proto__;
#endif

    if (*key == 't' && strcmp(key, "this")==0)
        return interp->inthis;
    if (obj->arr)
        v = jsi_ObjArrayLookup(interp, obj, key);
    if (!v)
        v= Jsi_TreeObjGetValue(obj, key, isstrkey);
    return v;  /* TODO: redo with copy */
}

Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)
{
    char unibuf[12];
    Jsi_Obj *obj = args->d.obj;
    Jsi_Value *v;
    assert(args->vt == JSI_VT_OBJECT);
    if (obj->isarrlist && obj->arr) {
        if (index < 0 || index >= obj->arrCnt) {
            return NULL;
        }
        v = obj->arr[index];
        assert(v != args);
        return v;
    } else {
        jsi_num_itoa10(index, unibuf);
        v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);
    } /* TODO: redo with copy */
    return v;
}

/**************************************************/

int Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Bool *val)
{
    if (!pv) return JSI_ERROR;
    if (pv->vt == JSI_VT_BOOL)
        *val = pv->d.val;
    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL)
        *val = pv->d.obj->d.val;
    else 
        return JSI_ERROR;
    return JSI_OK;
}

int Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v)  {
    return (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT && v->d.obj->isarrlist);
}

int Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_BOOL || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL));
}

int Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_NULL);
}

int Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_UNDEF);
}

int Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val)
{
    if (!pv) return JSI_ERROR;
    if (pv->vt == JSI_VT_NUMBER)
        *val = pv->d.num;
    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)
        *val = pv->d.obj->d.num;
    else 
        return JSI_ERROR;
    return JSI_OK;
}
int Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER));
}

int Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key)
{
    if (key->vt == JSI_VT_STRING && key->f.bits.isstrkey)
        return 1;
    if (key->vt == JSI_VT_OBJECT && key->d.obj->ot == JSI_OT_STRING && key->d.obj->isstrkey)
        return 1;
    return 0;
}

int Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv)
{
    return (pv->vt == JSI_VT_STRING || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING));
}

int Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *v)
{
    return (v!=NULL && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && interp == v->d.obj->d.fobj->interp);
}

int Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype) {
    if (!pv) return 0;
    return pv->vt == vtype;
}

Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv) { return pv->vt; }


int Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)
{
    return (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == otype);
}

char* Jsi_NumberToString(Jsi_Number d, char *buf)
{
     if (jsi_is_integer(d)) {
        jsi_num_itoa10((int)d, buf);
    } else if (jsi_ieee_isnormal(d)) {
        jsi_num_dtoa2(d, buf, 10);
    } else if (jsi_ieee_isnan(d)) {
        Jsi_Strcpy(buf, "NaN");
    } else {
        int s = jsi_ieee_infinity(d);
        if (s > 0) Jsi_Strcpy(buf,  "Infinity");
        else if (s < 0) Jsi_Strcpy(buf, "-Infinity");
        else {
            buf[0] = 0;
        }
    }
    return buf;
}

/* Return the string value.  Coerce value to a string type. */
const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)
{
    Jsi_Number d;
    const char *ntxt = "undefined";
    if (!v) return ntxt;
    char unibuf[200];
    int kflag = 1;
    switch(v->vt) {
        case JSI_VT_STRING:
            if (lenPtr) *lenPtr = v->d.s.len;
            return v->d.s.str;
        case JSI_VT_UNDEF:
            break;
        case JSI_VT_BOOL:
            ntxt = v->d.val ? "true":"false";
            break;
        case JSI_VT_NULL:
            ntxt = "null";
            break;
        case JSI_VT_NUMBER: {
            d = v->d.num;
fmtnum:
            if (jsi_is_integer(d)) {
                jsi_num_itoa10((int)d, unibuf);
                kflag = 0;
                ntxt = unibuf;
            } else if (jsi_ieee_isnormal(d)) {
                jsi_num_dtoa2(d, unibuf, 10);
                kflag = 0;
                ntxt = unibuf;
            } else if (jsi_ieee_isnan(v->d.num)) {
                ntxt = "NaN";
            } else {
                int s = jsi_ieee_infinity(d);
                if (s > 0) ntxt = "Infinity";
                else if (s < 0) ntxt = "-Infinity";
                else Jsi_LogBug("Ieee function got problem");
            }
            break;
        }
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_STRING:
                    return obj->d.s.str;
                    break;
                case JSI_OT_BOOL:
                    ntxt = obj->d.val ? "true":"false";
                    break;
                case JSI_OT_NUMBER:
                    d = obj->d.num;
                    goto fmtnum;
                    break;
                default:
                    ntxt = "[object Object]";
                    break;
            }
            break;
        }
        default:
            Jsi_LogBug("Convert a unknown type: 0x%x to string\n", v->vt);
            break;
    }
    Jsi_ValueReset(interp, &v);
    if (kflag) {
        int isKey = 0;
        char *key = jsi_KeyFind(interp, ntxt, kflag, &isKey);
        if (isKey)
            Jsi_ValueMakeStringKey(interp, &v, key);
        else
            Jsi_ValueMakeString(interp, &v, key);
        return v->d.s.str;
    }
    Jsi_ValueMakeStringDup(interp, &v, ntxt);
    return Jsi_ValueString(interp, v, NULL);
}

Jsi_Number Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt)
{
    char *endPtr = NULL;
    Jsi_Number a = 0;
    switch(v->vt) {
        case JSI_VT_BOOL:
            a = (Jsi_Number)(v->d.val ? 1.0: 0);
            break;
        case JSI_VT_NULL:
            a = 0;
            break;
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_BOOL:
                    a = (Jsi_Number)(obj->d.val ? 1.0: 0);
                    break;
                case JSI_OT_NUMBER:
                    a = obj->d.num;
                    break;
                case JSI_OT_STRING:
                    if (!isInt)
                        a = strtod(obj->d.s.str, &endPtr);
                    else
                        a = (Jsi_Number)strtol(obj->d.s.str, &endPtr, 0);
                    if (endPtr && *endPtr)
                        a = interp->NaNValue->d.num;
                    break;
                default:
                    a = 0;
                break;
            }
            break;
        }
        case JSI_VT_UNDEF:
            a = jsi_ieee_makenan();
            break;
        case JSI_VT_NUMBER:
            a = v->d.num;
            break;
        case JSI_VT_STRING:
            if (!isInt) {
                a = strtod(v->d.s.str, &endPtr);
                if (endPtr && *endPtr)
                    a = interp->NaNValue->d.num;
            } else {
                a = (Jsi_Number)strtol(v->d.s.str, &endPtr, 0);
                if (!isdigit(v->d.s.str[0]))
                    a = interp->NaNValue->d.num;
            }
            break;
        default:
            Jsi_LogBug("Convert a unknown type: 0x%x to number\n", v->vt);
            break;
    }
    return a;
}

Jsi_Number Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt == JSI_VT_NUMBER) return v->d.num;
    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0);
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeNumber(interp,&v, a);
    return a;
}

int Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v)
{
    int a = 0;
    switch(v->vt) {
        case JSI_VT_BOOL:
            return v->d.val;
            break;
        case JSI_VT_NULL:
            a = 0;
            break;
        case JSI_VT_UNDEF:
            a = 0;
            break;
        case JSI_VT_NUMBER:
            a = (v->d.num ? 1: 0);
            break;
        case JSI_VT_STRING:     /* TODO: NaN, and accept true/false string? */
            a = atoi(v->d.s.str);
            a = (a ? 1 : 0);
            break;
        case JSI_VT_OBJECT: {
            Jsi_Obj *obj = v->d.obj;
            switch(obj->ot) {
                case JSI_OT_BOOL:
                    a = (obj->d.val ? 1.0: 0);
                    break;
                case JSI_OT_NUMBER:
                    a = obj->d.num;
                    a = (a ? 1 : 0);
                    break;
                case JSI_OT_STRING:
                    a = atoi(obj->d.s.str);
                    a = (a ? 1 : 0);
                    break;
                default:
                    a = 0;
                break;
            }
            break;
        }
        default:
            Jsi_LogBug("Convert a unknown type: 0x%x to number\n", v->vt);
            break;
    }
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeBool(interp, &v, a);
    return a;
}

int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v)
{
    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 1);
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeNumber(interp, &v, a);
    return (int)a;
}

void Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt == JSI_VT_OBJECT) return;
    Jsi_Obj *o = Jsi_ObjNew(interp);
    switch(v->vt) {
        case JSI_VT_UNDEF:
        case JSI_VT_NULL:
            Jsi_LogError("Can not convert a undefined/null value to object\n");
            o->d.num = 0;
            o->ot = JSI_OT_NUMBER;
            o->__proto__ = interp->Number_prototype;
            break;
        case JSI_VT_BOOL: {
            o->d.val = v->d.val;
            o->ot = JSI_OT_BOOL;
            o->__proto__ = interp->Boolean_prototype;
            break;
        }
        case JSI_VT_NUMBER: {
            o->d.num = v->d.num;
            o->ot = JSI_OT_NUMBER;
            o->__proto__ = interp->Number_prototype;
            break;
        }
        case JSI_VT_STRING: {
            o->d.s = v->d.s;
            if (!v->f.bits.isstrkey)
                o->d.s.str = (char*)Jsi_KeyAdd(interp, v->d.s.str);
            o->isstrkey = 1;
            o->ot = JSI_OT_STRING;
            o->__proto__ = interp->String_prototype;
            break;
        }
        default:
            Jsi_LogBug("toobject, not suppose to reach here\n");
    }
    Jsi_ValueReset(interp,&v);
    Jsi_ValueMakeObject(interp, &v, o);
}

/* also toBoolean here, in ecma */
int Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v)
{
    switch(v->vt) {
        case JSI_VT_UNDEF:
        case JSI_VT_NULL:   return 0;
        case JSI_VT_BOOL:   return v->d.val ? 1:0;
        case JSI_VT_NUMBER: 
            if (v->d.num == 0.0 || jsi_ieee_isnan(v->d.num)) return 0;
            return 1;
        case JSI_VT_STRING: return Jsi_ValueStrlen(v) ? 1 : 0;
        case JSI_VT_OBJECT: {
            Jsi_Obj *o = v->d.obj;
            if (o->ot == JSI_OT_USEROBJ && o->d.uobj->interp == interp) {
                return jsi_UserObjIsTrue(interp, o->d.uobj);
            }
            return 1;
        }
        default: Jsi_LogBug("TOP is type incorrect: %d\n", v->vt);
    }
    return 0;
}

int Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt == JSI_VT_BOOL)  return v->d.val ? 0:1;
    return 0;
}

int Jsi_ValueIsEqual(Jsi_Interp* interp, Jsi_Value* v1, Jsi_Value* v2)
{
    int eq = 0;
    if (v1->vt == JSI_VT_OBJECT && v2->vt == JSI_VT_OBJECT && v1->d.obj == v2->d.obj)
        eq = 1;
    else if (Jsi_ValueIsNull(interp, v1) && Jsi_ValueIsNull(interp, v2))
        eq = 1;
    else if (Jsi_ValueIsUndef(interp, v1) && Jsi_ValueIsUndef(interp, v2))
        eq = 1;
    else if (Jsi_ValueIsBoolean(interp, v1) && Jsi_ValueIsBoolean(interp, v2)) {
        int b1, b2;
        eq = (Jsi_GetBoolFromValue(interp, v1, &b1) == JSI_OK
            && Jsi_GetBoolFromValue(interp, v2, &b2) == JSI_OK
            && b1 == b2);
    } else if (Jsi_ValueIsNumber(interp, v1) && Jsi_ValueIsNumber(interp, v2)) {
        Jsi_Number n1, n2;
        eq = (Jsi_GetNumberFromValue(interp, v1, &n1) == JSI_OK
            && Jsi_GetNumberFromValue(interp, v2, &n2) == JSI_OK
            && n1 == n2);
    } else if (Jsi_ValueIsString(interp, v1) && Jsi_ValueIsString(interp, v2)) {
        const char *s1, *s2;
        int l1, l2;
        eq = (((s1=Jsi_ValueString(interp, v1, &l1)) && ((s2=Jsi_ValueString(interp, v2, &l2)))
            && l1 == l2 && Jsi_Strcmp(s1, s2)==0));
    }
    return eq;
}

void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr)
{
    Jsi_Value *v = *vPtr;
    if (v->vt != JSI_VT_OBJECT)
        return;
    DECL_VALINIT(res);
    Jsi_Value *rPtr = &res;
    Jsi_Obj *obj = v->d.obj;
    //rPtr = v;
    switch(obj->ot) {
        case JSI_OT_BOOL:
            Jsi_ValueMakeBool(interp,&rPtr, obj->d.val);
            break;
        case JSI_OT_NUMBER:
            Jsi_ValueMakeNumber(interp,&rPtr, obj->d.num);
            break;
        case JSI_OT_STRING:
            if (obj->isstrkey) {
                res.d.s = obj->d.s;
                res.f.bits.isstrkey = 1;
                obj->d.s.str = NULL;
            } else {
                if (obj->d.s.len >= 0) 
                {
                    Jsi_ValueMakeBlob(interp, &rPtr, (unsigned char*)obj->d.s.str, obj->d.s.len);
                } else if (obj->refcnt==1) {
                    Jsi_ValueMakeString(interp, &rPtr, obj->d.s.str);
                    res.d.s = obj->d.s;
                    obj->d.s.str = NULL;
                } else
                    Jsi_ValueMakeString(interp, &rPtr, Jsi_Strdup(obj->d.s.str));
            }
            break;
        case JSI_OT_FUNCTION: {
            Jsi_DString dStr;
            Jsi_DSInit(&dStr);
            Jsi_FuncObjToString(interp, obj, &dStr);
            Jsi_ValueMakeString(interp, &rPtr, Jsi_Strdup(Jsi_DSValue(&dStr)));
            Jsi_DSFree(&dStr);
            break;
        }
        case JSI_OT_USEROBJ: {
            Jsi_DString dStr;
            Jsi_DSInit(&dStr);
            jsi_UserObjToName(interp, obj->d.uobj, &dStr);
            Jsi_ValueMakeString(interp, &rPtr, Jsi_Strdup(Jsi_DSValue(&dStr)));
            Jsi_DSFree(&dStr);
            break;
        }
        default:
            Jsi_ValueMakeStringKey(interp,&rPtr, "[object Object]");
            break;
    }
    Jsi_ValueReset(interp, vPtr);
    res.refCnt = v->refCnt;
#ifdef JSI_MEM_DEBUG
    memcpy(v, &res, sizeof(res)-sizeof(res.VD));
#else
    *v = res;
#endif
}

static void jsi_ValueToPrimitiveRes(Jsi_Interp *interp, Jsi_Value *v, Jsi_Value *rPtr)
{
    if (v->vt != JSI_VT_OBJECT) {
#ifdef JSI_MEM_DEBUG
    memcpy(rPtr, v, sizeof(*v)-sizeof(v->VD));
#else
    *rPtr = *v; //TODO: usde only by ValueCompare, so refCnt doesn't matter?
#endif
        return;
    }
    Jsi_Obj *obj = v->d.obj;
    switch(obj->ot) {
        case JSI_OT_BOOL:
            Jsi_ValueMakeBool(interp, &rPtr, obj->d.val);
            break;
        case JSI_OT_NUMBER:
            Jsi_ValueMakeNumber(interp, &rPtr, obj->d.num);
            break;
        case JSI_OT_STRING:
            rPtr->vt = JSI_VT_STRING;
            rPtr->d.s = obj->d.s;
            rPtr->f.bits.isstrkey = 1;
            break;
        default:
            break;
    }
}

int Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int flags)
{
    DECL_VALINIT(res1);
    DECL_VALINIT(res2);
    int r = 1;
    int nocase = (flags&JSI_SORT_NOCASE), dict = ((flags & JSI_SORT_ASCII)==0);
    if (v1 == v2)
        return 1;
    if (v1->vt != v2->vt) {
        jsi_ValueToPrimitiveRes(interp, v1, &res1);
        jsi_ValueToPrimitiveRes(interp, v2, &res2);
        v1 = &res1;
        v2 = &res2;
    }
    if (v1->vt != v2->vt) {
        if ((flags&JSI_CMP_EXACT))
            return 1;
        if ((v1->vt == JSI_VT_UNDEF || v1->vt == JSI_VT_NULL) && 
            (v2->vt == JSI_VT_UNDEF || v2->vt == JSI_VT_NULL)) {
            r = 0;
        } else {
            Jsi_Number n1 = Jsi_ValueToNumberInt(interp, v1, 0);
            Jsi_Number n2 = Jsi_ValueToNumberInt(interp, v2, 0);
            r = (n2 - n1);
        }
    } else {
        switch (v1->vt) {
            case JSI_VT_NUMBER:
                r = (v2->d.num - v1->d.num);
                break;
            case JSI_VT_BOOL:
                r = (v2->d.val - v1->d.val);
                break;
            case JSI_VT_STRING:
                r = (Jsi_StrcmpDict(v2->d.s.str, v1->d.s.str, nocase, dict));
                break;
            case JSI_VT_OBJECT:
                /* TODO: refer to objects joined to each other */
                if (v1->d.obj->ot == JSI_OT_STRING)
                    r = (Jsi_StrcmpDict(v2->d.obj->d.s.str, v1->d.obj->d.s.str, nocase, dict));
                else
                    r = (v2->d.obj - v1->d.obj);
                break;
            case JSI_VT_UNDEF:
            case JSI_VT_NULL:
                r = 0;
                break;
            default:
                Jsi_LogBug("Unexpected value type\n");
        }
    }
    return r;
}

/**
 * @brief Split a string.
 * @param interp 
 * @param str - input string to split
 * @param split - to split on
 * @returns an array of string values
 * 
 * 
 */
Jsi_Value *Jsi_StringSplit(Jsi_Interp *interp, char *str, char *spliton)
{
    char **argv; int argc;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_SplitStr(str, &argc, &argv, spliton, &dStr);
    Jsi_Value *nret = Jsi_ValueNewArray(interp, NULL, 0);
    Jsi_Obj *obj = nret->d.obj;
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, argv[i]), i);
    }
    Jsi_ObjSetLength(interp, obj, argc);
    Jsi_ValueMakeArrayObject(interp, &nret, obj);
    Jsi_DSFree(&dStr);
    return nret;
}

void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey)
{
    Jsi_TreeEntry *hPtr;
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogWarn("Target is not object: %d\n", target->vt);
        return;
    }
    hPtr = Jsi_ObjInsert(interp, target->d.obj, key, value, (isstrkey?JSI_OM_ISSTRKEY:0));
    if (!hPtr)
        return;
    hPtr->f.flags |= (flags&JSI_TREE_USERFLAG_MASK);
}

Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)
{
    int arrayindex = -1;

    if (keyval->vt == JSI_VT_NUMBER && jsi_is_integer(keyval->d.num) && keyval->d.num >= 0) {
        arrayindex = (int)keyval->d.num;
    }
    /* TODO: array["1"] also extern the length of array */
    
    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&
        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {
        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);
    }
    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);
    
#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)
    if (strcmp(kstr, "__proto__")==0) {
        Jsi_Obj *obj = target->d.obj;
        obj->__proto__ = Jsi_ValueDup(interp, value);
        //obj->clearProto = 1;
        return obj->__proto__;
    }
#endif

    Jsi_Value *v;
    if (value)
        Jsi_ValueCopy(interp,v = Jsi_ValueNew1(interp), value);
    else
        value = (v = Jsi_ValueNew1(interp));

    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));
    Jsi_DecrRefCount(interp, v);
    return v;
}

const char *jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val)
{
    const char *keyStr = Jsi_ValueToString(interp, key, NULL);
    if (!target) {
        Jsi_ValueMakeUndef(interp, ret);
        return keyStr;
    }
    
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("subscript operand is not object\n");
    }

    Jsi_Value *r = Jsi_ValueObjLookup(interp, target, (char*)keyStr,
        ((key->vt == JSI_VT_STRING && key->f.bits.isstrkey)? 1 : 0));
    if (!r) {
        /* query from prototype, always no right_val */
        if (target->d.obj->__proto__) {
            jsi_ValueSubscript(interp, target->d.obj->__proto__, key, ret, 1);
        }
        if (right_val == 0) {       /* need a lvalue */
            Jsi_Value *n = Jsi_ValueNew(interp);
            Jsi_ValueCopy(interp,n, *ret);   /* copy from prototype */
            
            jsi_ValueObjKeyAssign(interp, target, key, n, 0);
            jsi_ValueDebugLabel(n, "subscript", keyStr);
            Jsi_ValueReset(interp, ret);
           (*ret)->vt = JSI_VT_VARIABLE;
            (*ret)->d.lval = n;
            SIGASSERT(n, VALUE);
        }
    } else {
        if (right_val || r->f.bits.readonly) {
            Jsi_ValueCopy(interp, *ret, r);
        } else {
            (*ret)->vt = JSI_VT_VARIABLE;
            (*ret)->d.lval = r;
            SIGASSERT(r, VALUE);
        }
    }
    return keyStr;
}

/* Like above, but handle "length", "constructor", "String", etc specially. */
void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key,
                           Jsi_Value **ret, int right_val)
{
    int len;
    const char *keyStr = jsi_ValueSubscript(interp, target, key, ret, right_val);
    if ((*ret)->vt != JSI_VT_UNDEF || key->vt != JSI_VT_STRING) {
        /* TODO: generalize this so that eval knows who is the parent object of a lookup. */
        if (Jsi_ValueIsFunction(interp, target) && key->vt == JSI_VT_STRING && !strcmp(keyStr, "bind"))
            interp->lastBindSubscriptObj = target->d.obj;
        return;
    }
    if (Jsi_Strcmp(keyStr,"length")==0) {
        if (Jsi_ValueIsString(interp, target)) {
            len = Jsi_ValueStrlen(target);
        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist /*&& target->d.obj->arr*/) {
            /* && target->d.obj->ot == JSI_OT_ARRAY   ??? */
            len = target->d.obj->arrCnt;
        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {
            if (target->d.obj->d.fobj->func->type == FC_NORMAL)
                len = target->d.obj->d.fobj->func->argnames->count;
            else
                len = target->d.obj->d.fobj->func->cmdSpec->maxArgs;
        } else {
            return;
        }
        (*ret)->vt = JSI_VT_NUMBER;
        (*ret)->d.num = (Jsi_Number)len;
        return;
    }

    if (target->vt == JSI_VT_OBJECT && (interp->noInherit==0 && Jsi_Strcmp(keyStr,"constructor")==0)) {
        const char *cp;
        Jsi_Obj *o = target->d.obj->constructor;
        if (o) {
            if (o->ot == JSI_OT_FUNCTION) {
                Jsi_Value *proto = Jsi_TreeObjGetValue(o, "prototype", 0);
                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {
                    o = proto->d.obj->constructor;
                }
            }
        } else {
            switch(target->d.obj->ot) {
                case JSI_OT_NUMBER:
                    cp = "Number";
                    break;
                case JSI_OT_BOOL:
                    cp = "Boolean";
                    break;
                case JSI_OT_STRING:
                    cp = "String";
                    break;
                default:
                    Jsi_ValueMakeUndef(interp, ret);
                    return;
            }
            Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);
            if (v==NULL || v->vt != JSI_VT_OBJECT)
                return;
            o = target->d.obj->constructor = v->d.obj;
        }
        Jsi_ValueMakeObject(interp, ret, o);
        return;
    }

    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {
        /* Looking up something like "String.substr('abc',1)" */
        Jsi_Func* func = target->d.obj->d.fobj->func;
        if (func->type == FC_BUILDIN) {
            if (func->f.bits.iscons && func->name) {
                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);
                if (v && ((v = Jsi_ValueObjLookup(interp, v, "prototype", 0)))
                        && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {
                    if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && strcmp(func->name,"Interp")) {
                        Jsi_Func* sfunc = v->d.obj->d.fobj->func;
                        sfunc->callflags.bits.addargs = 1;
                    }
                    Jsi_ValueCopy(interp, *ret, v);
                    return;
                }
            }
            if (Jsi_ValueIsString(interp, key)) {
                char *kstr = Jsi_ValueString(interp, key, NULL);
                if (0==strcmp(kstr,"call") || 0==strcmp(kstr,"apply")) {
                    char fbuf[100];
                    strcpy(fbuf, "Function.");
                    strcat(fbuf,kstr);
                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);
                    if (vv) {
                        //Jsi_ValueReplace(interp, ret, vv);
                        Jsi_ValueCopy(interp, *ret, vv);
                        Jsi_ValueInsertFixed(interp, target, kstr, vv);
                        Jsi_DecrRefCount(interp, vv);
                        return;
                    }
                }
            }
            /* Lookup failed, save cmdSpec in case a function call */
            interp->lastFuncIndex = func;
        }
        return;
    }

}

int Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)
{
    SIGASSERT(interp,INTERP);
    //SIGASSERT(target,VALUE);
    if (Jsi_TreeObjGetValue(target->d.obj, key, isstrkey))
        return 1;
    if (target->d.obj->__proto__ == NULL || target->d.obj->__proto__ == target)
        return 0;
    return Jsi_ValueKeyPresent(interp, target->d.obj->__proto__, key, isstrkey);
}

void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)
{
    Jsi_IterObj *io = jsi_IterObjNew(interp, NULL);
    Jsi_Obj *to = target->d.obj;
    
    if (target->vt != JSI_VT_UNDEF && target->vt != JSI_VT_NULL) {

        if (target->vt == JSI_VT_OBJECT && to->arr) {
            io->isArrayList = 1;
            io->count = to->arrCnt;
        } else {
            IterGetKeys(interp, target, io, 0);
        }
    }
    io->obj = to;
    Jsi_Obj *r = Jsi_ObjNew(interp);
    r->ot = JSI_OT_ITER;
    r->d.iobj = io;
    Jsi_ValueMakeObject(interp, &ret, r);
}

int Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)
{
    int i, n = 0;
    Jsi_IterObj *io;
    if (target->vt != JSI_VT_OBJECT)
        return JSI_ERROR;
    Jsi_Obj *to = target->d.obj;
    Jsi_Obj *r = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    Jsi_ValueMakeArrayObject(interp, &ret, r);
    if (to->arr) {
        for (i=0; i<to->arrCnt; i++)
            if (to->arr[i]) n++;
        if (Jsi_ObjArraySizer(interp, r, n) <= 0) {
            Jsi_LogError("too long");
            Jsi_ValueMakeUndef(interp, &ret);
            return JSI_ERROR;
        }
        for (i=0, n=0; i<to->arrCnt; i++) {
            if (to->arr[i]) {
                r->arr[n] = Jsi_ValueNewNumber(interp, (Jsi_Number)i);
                Jsi_IncrRefCount(interp, r->arr[n]);
                n++;
            }
        }
        r->arrCnt = n;
        return JSI_OK;
    }
    io = jsi_IterObjNew(interp, NULL);
    IterGetKeys(interp, target, io, 0);
    if (Jsi_ObjArraySizer(interp, r, io->count) <= 0) {
        Jsi_LogError("too long");
        Jsi_ValueMakeUndef(interp, &ret);
        return JSI_ERROR;
    }
    for (i=0; i<io->count; i++) {
        r->arr[i] = (io->keys[i] ? Jsi_ValueNewStringKey(interp, io->keys[i]) : NULL);
        Jsi_IncrRefCount(interp, r->arr[i]);
    }
    io->count = 0;
    r->arrCnt = i;
    jsi_IterObjFree(io);
    return JSI_OK;
}

jsi_ScopeChain *jsi_ScopeChainNew(Jsi_Interp *interp, int cnt)
{
    jsi_ScopeChain *r = (jsi_ScopeChain *)Jsi_Calloc(1, sizeof(*r));
    r->interp = interp;
    SIGINIT(r,SCOPE);
    r->chains = (Jsi_Value **)Jsi_Calloc(cnt, sizeof(r->chains[0]));
    r->chains_cnt = cnt;
    return r;
}

Jsi_Value *jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key)
{
    int i;
    Jsi_Value *ret;
    for (i = sc->chains_cnt - 1; i >= 0; --i) {
        if ((ret = Jsi_ValueObjLookup(sc->interp, sc->chains[i], key, 0))) {
            return ret;
        }
    }
    return NULL;
}

jsi_ScopeChain *jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next)
{
    if (!sc) {
        jsi_ScopeChain *nr = jsi_ScopeChainNew(interp, 1);
        nr->chains[0] = next;
        Jsi_IncrRefCount(interp, next);
        nr->chains_cnt = 1;
        return nr;
    }
    jsi_ScopeChain *r = jsi_ScopeChainNew(interp, sc->chains_cnt + 1);
    int i;
    for (i = 0; i < sc->chains_cnt; ++i) {
        r->chains[i] = sc->chains[i];
        Jsi_IncrRefCount(interp, sc->chains[i]);
    }
    r->chains[i] =  next;
    Jsi_IncrRefCount(interp, next);
    r->chains_cnt = i + 1;
    return r;
}

void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc)
{
    int i;
    for (i = 0; i < sc->chains_cnt; ++i) {
        Jsi_DecrRefCount(interp, sc->chains[i]);
    }
    Jsi_Free(sc->chains);
    MEMCLEAR(sc);
    Jsi_Free(sc);
}


int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v)
{
    if (!v) return JSI_ERROR;
    if (v->vt != JSI_VT_OBJECT)
        return 0;
    
    return Jsi_ObjGetLength(interp, v->d.obj);
}

char *Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, index);
    if (!arg)
        return NULL;
    char *res = Jsi_ValueString(interp, arg, lenPtr);
    if (res)
        return res;
    res = (char*)Jsi_ValueToString(interp, arg, NULL);
    if (res && lenPtr)
        *lenPtr = Jsi_Strlen(res);
    return res;
}

void Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags)
{
    if (target == NULL)
        target = interp->csc;
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogWarn("Target is not object\n");
        return ;
    }
    target->f.flag |= flags;
    Jsi_ObjInsert(interp, target->d.obj, key, val, flags);
}

void jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)
{
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogWarn("Target is not object\n");
        return;
    }
    Jsi_Obj *obj = target->d.obj;
    
    if (obj->isarrlist) {
        if (key >= 0 && key < interp->maxArrayList) {
            Jsi_ObjArraySet(interp, obj, val, key);
            return;
        }
    }
    char unibuf[12];
    jsi_num_itoa10(key, unibuf);
    Jsi_ObjInsert(interp, obj, unibuf, val, flags);
}

/* OBJ INTERFACE TO BTREE */

static void IterObjInsert(Jsi_IterObj *io, Jsi_TreeEntry *hPtr)
{
    const char *key = (const char*)Jsi_TreeKeyGet(hPtr);
    assert(!io->isArrayList);
    if (io->depth) {
        int i;
        for (i=0; i<io->count; i++) {
            if (!strcmp(key, io->keys[i]))
                return;
        }
    }

    if (io->count >= io->size) {
        io->size += 10;
        io->keys = (const char**)Jsi_Realloc(io->keys, io->size * sizeof(io->keys[0]));
    }
    io->keys[io->count] = (const char*)Jsi_TreeKeyGet(hPtr);
    io->count++;
}

Jsi_TreeEntry * Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *val, int flags)
{
    Jsi_TreeEntry *hPtr;
    /*if (val)
        Jsi_IncrRefCount(interp, val);*/
    hPtr = Jsi_TreeObjSetValue(obj, key, val, (flags&JSI_OM_ISSTRKEY));
    if ((flags&JSI_OM_DONTDEL)) hPtr->f.bits.dontdel = 1;
    if ((flags&JSI_OM_READONLY))  hPtr->f.bits.readonly = 1;
    if ((flags&JSI_OM_DONTENUM))  hPtr->f.bits.dontenum = 1;
    return hPtr;
}

static int IterGetKeysCallback(Jsi_Tree* tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_IterObj *io = (Jsi_IterObj *)data;
    if (!hPtr->f.bits.dontenum) {
        IterObjInsert(io, hPtr);
    }
    return JSI_OK;
}

static void IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth)
{
    if (!target) return;
    if (target->vt != JSI_VT_OBJECT) {
        Jsi_LogWarn("operand is not a object\n");
        return;
    }
    iterobj->depth = depth;
    Jsi_TreeWalk(target->d.obj->tree, IterGetKeysCallback, iterobj, 0);
    if (target->d.obj->__proto__ && target != target->d.obj->__proto__)
        IterGetKeys(interp, target->d.obj->__proto__, iterobj, depth+1);
    iterobj->depth = depth;
}

Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_DString *dsPtr)  {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    Jsi_Obj *obj;
    if (!v)
        v = Jsi_ValueNew(interp);
    else {
        assert(v->vt >= 0 && v->vt <= JSI_VT__MAX);
        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING
            && v->d.obj->refcnt == 1
        ) {
            Jsi_ObjFromDS(dsPtr, v->d.obj);
            return v;
        }
        Jsi_ValueReset(interp, &v);
    }
    obj = Jsi_ObjNewType(interp, JSI_OT_STRING);
    Jsi_ObjFromDS(dsPtr, obj);
    Jsi_ValueMakeObject(interp, &v, obj);
    return v;
}

Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (v && v->vt == JSI_VT_OBJECT && o == v->d.obj)
        return v;
    if (v)
        Jsi_ValueReset(interp, vPtr);
    else
        v = Jsi_ValueNew(interp);
    //Jsi_IncrRefCount(interp, v);
    if (!o)
        o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    v->vt = JSI_VT_OBJECT;
    v->d.obj = o;
    Jsi_ObjIncrRefCount(interp,v->d.obj);
    return v;
}

Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!o)
        o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    if (!v)
        v = Jsi_ValueNew(interp);
    else {
       if (v->vt == JSI_VT_OBJECT && o == v->d.obj) {
            if (!o->isarrlist) {
                if (o->tree)
                    Jsi_TreeDelete( o->tree);
                o->tree = NULL;
                o->__proto__ = interp->Array_prototype;
                o->isarrlist = 1;
            }
            return v;
        }
        Jsi_ValueReset(interp, vPtr);
    }
    v->vt = JSI_VT_OBJECT;
    v->d.obj = o;
    o->ot = JSI_OT_OBJECT;
    o->__proto__ = interp->Array_prototype;
    o->isarrlist = 1;
    Jsi_ObjArraySizer(interp, o, 0);
    Jsi_ObjIncrRefCount(interp,v->d.obj);
    return v;
}

Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Number n) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_NUMBER;
    v->d.num = n;
    return v;
}

Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **vPtr, int b) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_BOOL;
    v->d.val = b;
    return v;
}

Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);
    Jsi_ValueMakeObject(interp, &v, obj);
    obj->d.s.str = (char*)s;
    obj->d.s.len = len;
    return v;
}


Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {
    return Jsi_ValueMakeBlob(interp, vPtr, (unsigned char *)s, Jsi_Strlen(s));
}

Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_STRING;
    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);
    v->d.s.len = Jsi_Strlen(s);
    v->f.bits.isstrkey = 1;
    return v;
}

Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **vPtr) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else
        Jsi_ValueReset(interp, vPtr);
    v->vt = JSI_VT_NULL;
    return v;
}

Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **vPtr) {
    Jsi_Value *v = (vPtr?*vPtr:NULL);
    if (!v)
        v = Jsi_ValueNew(interp);
    else {
        if (v->vt == JSI_VT_UNDEF) return v;
        Jsi_ValueReset(interp, vPtr);
    }
    return v;
}

Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_NUMBER;
    v->d.num = n;
    return v;
}


Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);
    Jsi_ValueMakeObject(interp, &v, obj);
    obj->d.s.str = (char*)s;
    obj->d.s.len = (len<0?Jsi_Strlen(s):len);
    return v;
}

Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s) {
    return Jsi_ValueNewString(interp, Jsi_Strdup(s), -1);
}

Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_STRING;
    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);
    v->d.s.len = Jsi_Strlen(s);
    v->f.bits.isstrkey = 1;
    return v;
}

Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, int len) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_STRING;
    v->d.s.str = (char*)Jsi_Malloc(len+1);
    memcpy(v->d.s.str, (char*)s, len);
    v->d.s.str[len] = 0;
    v->d.s.len = len;
    return v;
}

Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_BOOL;
    v->d.val = bval;
    return v;
}

Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp) {
    Jsi_Value *v = Jsi_ValueNew(interp);
    v->vt = JSI_VT_NULL;
    return v;
}

Jsi_Value *Jsi_ValueNewArray(Jsi_Interp *interp, char **items, int count)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    int i = 0;
    if (count<0) {
        count = 0;
        while (items[count])
            count++;
    }
    if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {
        Jsi_ObjFree(interp, obj);
        return NULL;
    }
    for (i = 0; i < count; ++i) {
        obj->arr[i] = Jsi_ValueNewStringDup(interp, items[i]);
        Jsi_IncrRefCount(interp, obj->arr[i]);
    }
    obj->arrCnt = count;
    assert(obj->arrCnt<=obj->arrMaxSize);
    return Jsi_ValueMakeArrayObject(interp, NULL, obj);
}

Jsi_Obj *Jsi_ValueGetObj(Jsi_Interp *interp, Jsi_Value* v)
{
    if (v->vt == JSI_VT_OBJECT) {
        return v->d.obj;
    }
    return NULL;
}

int Jsi_ValueStrlen(Jsi_Value* v) {
    Jsi_String *s = JSIVAL_GET_STR(v);
    if (s == 0 || s->str == 0)
        return 0;
    return (s->len>=0 ? s->len : Jsi_Strlen(s->str));
}

char *Jsi_ValueString(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)
{
    if (!v) return NULL;
    Jsi_String *s = JSIVAL_GET_STR(v);
    if (s) {
        if (lenPtr)
            *lenPtr = (s->len<0 ? Jsi_Strlen(s->str) : s->len);
        return s->str;
    }
    if (lenPtr)
        *lenPtr = 0;
    return NULL;
}

unsigned char *Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)
{
    return (unsigned char*)Jsi_ValueString(interp, v, lenPtr);
}

char* Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr)
{
    if (!pv)
        return NULL;
    Jsi_String *s = JSIVAL_GET_STR(pv);
    if (!s)
        return NULL;
    if (lenPtr)
        *lenPtr = (s->len<0 ? Jsi_Strlen(s->str) : s->len);
    return s->str;
}

int Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2)
{
    Jsi_Value *proto, *sproto;
    if (v1->vt != JSI_VT_OBJECT || v2->vt != JSI_VT_OBJECT  || v2->d.obj->ot != JSI_OT_FUNCTION)
        return 0;
    proto = Jsi_ValueObjLookup(interp, v2, "prototype", 0);
    if (!proto)
        return 0;
    sproto = v1->d.obj->__proto__ ;
    while (sproto) {
        if (sproto == proto)
            return 1;
        if (sproto->vt != JSI_VT_OBJECT)
            return 0;
        sproto = sproto->d.obj->__proto__;
    }
    return 0;
}


int jsi_ValueInit(Jsi_Interp *interp)
{
    return JSI_OK;
}

void  Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret)
{
    char *cp;
    if (dsPtr->str != dsPtr->staticSpace) {
        cp = dsPtr->str;
        dsPtr->str = dsPtr->staticSpace;
    } else {
        cp = Jsi_Strdup(dsPtr->str);
    }
    dsPtr->len = 0;
    dsPtr->spaceAvl = dsPtr->staticSize;
    dsPtr->staticSpace[0] = 0;
    if (cp)
        Jsi_ValueMakeString(interp, ret, cp);
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
/* TODO: handle delete */

#define ChkRegexp(_this, funcPtr, dest) \
    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \
       _this->d.obj->__proto__ == interp->RegExp_prototype->d.obj->__proto__ ) { \
        skip = 1; \
        dest = Jsi_ValueArrayIndex(interp, args, 0); \
    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_REGEXP) { \
        Jsi_LogError("apply Regexp.%s to a non-regex object\n", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    } else  { \
        dest = _this; \
    }

void Jsi_RegExpFree(Jsi_Regex* re) {
    regfree(&re->reg);
    Jsi_Free(re);
}

Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int eflag)
{
    int isNew;
    Jsi_HashEntry *hPtr;
    int flag = REG_EXTENDED;
    char c, *cm, *ce;
    const char *cp;
    Jsi_Regex *re;
    eflag |= JSI_REG_STATIC;
    if (!regtxt[0])
        return NULL;
    hPtr = Jsi_HashEntryFind(interp->regexpTbl, regtxt);
    if (hPtr) {
        re = (Jsi_Regex*)Jsi_HashValueGet(hPtr);
        if (JSI_REG_STATIC & eflag)
            re->eflags |= JSI_REG_STATIC;
        return re;
    }
    cp = regtxt+1;
    if (regtxt[0] != '/')
        return NULL;
    ce = strrchr(cp, '/');
    if (ce == cp || !ce)
        return NULL;
    cm = ce + 1;    
    while (*cm) {
        c = *cm++;
        if (c == 'i') flag |= REG_ICASE;
        else if (c == 'g') eflag |= JSI_REG_GLOB;
        else if (c == 'm') { /* PERL NON-STANDARD */
            eflag |= JSI_REG_NEWLINE;
            flag |= REG_NEWLINE;
        }
#ifdef RE_DOT_NEWLINE
        else if (c == 's') { /* PERL NON-STANDARD */
            eflag |= JSI_REG_DOT_NEWLINE;
            flag |= RE_DOT_NEWLINE;
        }
#endif
    }
    *ce = 0;
    regex_t reg;
    if (regcomp(&reg, cp, flag)) {
        *ce++ = '/';
        Jsi_LogError("Invalid regex string '%s'", cp);
        return NULL;
    }
    *ce++ = '/';
    re = (Jsi_Regex*)Jsi_Calloc(1, sizeof(Jsi_Regex));
    assert (re);
    re->reg = reg;
    re->eflags = eflag;
    re->flags = flag;
    hPtr = Jsi_HashEntryNew(interp->regexpTbl, regtxt, &isNew);
    assert(hPtr);
    Jsi_HashValueSet(hPtr, re);
    re->pattern = (char*)Jsi_HashKeyGet(hPtr);
    return re;

}

int jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret)
{
    
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, "/", regtxt, "/", NULL);
    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);
    Jsi_DSFree(&dStr);
    if (re == NULL)
        return JSI_ERROR;
    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);
    Jsi_ValueMakeObject(interp, &ret, o);
    ret->d.obj->d.robj = re;
    ret->d.obj->ot = JSI_OT_REGEXP;
    return JSI_OK;
}


static int RegExp_constructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *target;
    
    if (Jsi_FunctionIsConstructor(funcPtr))
        target = _this;
    else {
        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);
        Jsi_ValueMakeObject(interp, ret, o);
        target = *ret;
    }
    
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    const char *regtxt = "";
    const char *mods = NULL;
    if (v) {
        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_REGEXP) {
            Jsi_ValueCopy(interp,target, v);
            return JSI_OK;
        } else if (!(regtxt = Jsi_ValueString(interp, v, NULL))) {
            return JSI_ERROR;
        }
    }
    Jsi_Value *f = Jsi_ValueArrayIndex(interp, args, 1);
    if (f)
        mods = Jsi_ValueString(interp, f, NULL);
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, "/", regtxt, "/", mods, NULL);
    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);
    Jsi_DSFree(&dStr);
    if (re == NULL)
        return JSI_ERROR;
    target->d.obj->d.robj = re;
    target->d.obj->ot = JSI_OT_REGEXP;
    return JSI_OK;
}


int Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)
{
    Jsi_Regex *re;
    int regexec_flags = 0;
    if (rc)
        *rc = 0;
    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_LogError("expected pattern");
        return JSI_ERROR;
    }
    re = pattern->d.obj->d.robj;
    regex_t *reg = &re->reg;
    
    regmatch_t pos;
    memset(&pos, 0,  sizeof(regmatch_t));
    if (dStr)
        Jsi_DSInit(dStr);
        
    int r  = regexec(reg, v, 1, &pos, regexec_flags);

    if (r >= REG_BADPAT) {
        char buf[100];

        regerror(r, reg, buf, sizeof(buf));
        Jsi_LogError("error while matching pattern: %s", buf);
        return JSI_ERROR;
    }
    if (r != REG_NOMATCH) {
        if (rc) *rc = 1;
        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)
            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);
    }
    
    return JSI_OK;
}



int Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, Jsi_Value *ret)
{
    Jsi_Regex *re;
    int regexec_flags = 0;
    Jsi_Value *seq = pattern;

    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_ValueMakeNull(interp, &ret);
        return JSI_OK;
    }
    re = seq->d.obj->d.robj;
    regex_t *reg = &re->reg;
    
    regmatch_t pos[MAX_SUBREGEX];
    memset(&pos, 0, MAX_SUBREGEX * sizeof(regmatch_t));
    int num_matches = 0, r, n = strlen(v);
    Jsi_Obj *obj;
    
    do {
        r = regexec(reg, v, MAX_SUBREGEX, pos, regexec_flags);

        if (r >= REG_BADPAT) {
            char buf[BUFSIZ];

            regerror(r, reg, buf, sizeof(buf));
            Jsi_LogError("error while matching pattern: %s", buf);
            return JSI_ERROR;
        }
        if (r == REG_NOMATCH) {
            if (num_matches == 0) {
                Jsi_ValueMakeNull(interp, &ret);
                return JSI_OK;
            }
            break;
        }

        if (num_matches == 0) {
            obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
            obj->__proto__ = interp->Array_prototype;
            Jsi_ValueMakeObject(interp, &ret, obj);
            Jsi_ObjSetLength(interp, ret->d.obj, 0);
        }
    
        int i;
        for (i = 0; i < MAX_SUBREGEX; ++i) {
            if (pos[i].rm_so <= 0 && pos[i].rm_eo <= 0)
                break;
            if (i && pos[i].rm_so == pos[i-1].rm_so && pos[i].rm_eo == pos[i-1].rm_eo)
                continue;
    
            Jsi_Value *val = Jsi_ValueMakeString(interp, NULL, 
                jsi_SubstrDup(v, pos[i].rm_so, pos[i].rm_eo - pos[i].rm_so));
            jsi_ValueInsertArray(interp, ret, num_matches, val, 0);
            num_matches++;
        }
        if (num_matches == 1 && (!(re->eflags&JSI_REG_GLOB)))
            break;
        
        v += pos[0].rm_eo;
        n -= pos[0].rm_eo;

        regexec_flags |= REG_NOTBOL;
    } while (n && pos[0].rm_eo>0);
    
    return JSI_OK;
}

#define FN_regexec JSI_INFO("\
Perform regexp match checking.  Returns the array of matches.\
Incompatibility note: does not set properties such as global, lastIndex, etc.")
static int RegexpExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    Jsi_Value *v;
    ChkRegexp(_this, funcPtr, v);
    /* TODO: add lastIndex support. */
    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), NULL);
    if (!str) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    return Jsi_RegExpMatches(interp, v, str, *ret);
}

static int RegexpTestCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0, rc = 0;
    Jsi_Value *v;
    ChkRegexp(_this, funcPtr, v);
    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), NULL);
    if (!str) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    if (Jsi_RegExpMatch(interp, v, str, &rc, NULL) != JSI_OK)
        return JSI_ERROR;
    Jsi_ValueMakeBool(interp, ret, rc != 0);
    return JSI_OK;
}

static Jsi_CmdSpec regexpCmds[] = {
    { "RegExp",  RegExp_constructor,    1, 1, "val:regexp|string", JSI_CMD_IS_CONSTRUCTOR, .help="Create a regexp object", .retType=(uint)JSI_TT_REGEXP },
    { "exec",    RegexpExecCmd,         1, 1, "val:string", .help="return matching string", .info=FN_regexec, .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NULL },
    { "test",    RegexpTestCmd,         1, 1, "val:string", .help="test if a string matches", .retType=(uint)JSI_TT_BOOL },
    { NULL,.help="Commands for managing reqular expression objects" }
};

int jsi_RegexpInit(Jsi_Interp *interp)
{
    interp->RegExp_prototype = Jsi_CommandCreateSpecs(interp, "RegExp", regexpCmds, NULL, 0);
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

// SCOPESTRS

Jsi_ScopeStrs *jsi_ScopeStrsNew()
{
    Jsi_ScopeStrs *ret = (Jsi_ScopeStrs *)Jsi_Calloc(1, sizeof(*ret));
    return ret;
}

void jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss)
{
    if (!ss) return;
    int i;
    for (i=0; i<ss->count; i++)
        if (ss->args[i].defValue)
            Jsi_DecrRefCount(interp, ss->args[i].defValue);
    if (ss->args)
        Jsi_Free(ss->args);
    Jsi_Free(ss);
}

void jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType)
{
    if (ss->count >= ss->_size) {
        int osz = ss->_size, isold = (ss->args!=NULL);
        ss->_size += ALLOC_MOD_SIZE;
        if (!isold)
            ss->args = (jsi_ArgValue*)Jsi_Calloc(ss->_size,  sizeof(ss->args[0]));
        else {
            ss->args = (jsi_ArgValue*)Jsi_Realloc(ss->args, (ss->_size) * sizeof(ss->args[0]));
            memset(ss->args+osz, 0, (ss->_size-osz)* sizeof(ss->args[0]));
        }
    }
    ss->args[ss->count].name = (char*)Jsi_KeyAdd(interp, string);
    ss->args[ss->count].type = argType;
    if (argType)
        ss->typeCnt++;
    ss->count++;
}

static Jsi_ScopeStrs *jsi_ScopeStrsDup(jsi_Pstate *ps, Jsi_ScopeStrs *ss)
{
    Jsi_ScopeStrs *n = jsi_ScopeStrsNew();
    int i;
    if (!ss) return n;
    *n = *ss;
    if (!ss->args) return n;
    n->args = (jsi_ArgValue*)Jsi_Malloc(n->count *  sizeof(ss->args[0]));
    n->_size = n->count;
    memcpy(n->args, ss->args, (n->count *  sizeof(ss->args[0])));
    for (i = 0; i < ss->count; ++i) {
        if (ss->args[i].defValue)
            Jsi_IncrRefCount(ps->interp, ss->args[i].defValue);
    }
    return n;
}

const char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i)
{
    if (i < 0 || i >= ss->count)
        return NULL;
    return ss->args[i].name;
}

Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a)
{
    jsi_PstatePush(pstate);
    return a;
}

Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue)
{
    Jsi_Interp *interp = pstate->interp;
    if (!a)
        a = jsi_ScopeStrsNew();
    int atyp = pstate->argType;
    jsi_ScopeStrsPush(interp, a, name, atyp);
    pstate->argType = 0;
    a->args[a->count-1].defValue = defValue;
    a->argCnt++;
    if (defValue) {
        Jsi_IncrRefCount(interp, defValue);
        if (a->firstDef==0)
            a->firstDef = a->argCnt;
            if (atyp)
                jsi_ArgTypeCheck(interp, atyp, defValue, "default value", name, a->argCnt, NULL);
    } else {
        if (a->firstDef && interp->typeCheck > jsi_TypeChk_Disable)
            Jsi_LogWarn("expected default value in argument list: \"%s\"", name);
    }
    return a;
}


// PSTATE 

void jsi_PstatePush(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    if (interp->cur_scope >= JSI_MAX_SCOPE - 1) {
        Jsi_LogBug("Scope chain too short");
        return;
    }
    interp->cur_scope++;
}

void jsi_PstatePop(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    if (interp->cur_scope <= 0) {
        Jsi_LogBug("No more scope to pop");
        return;
    }
    jsi_ScopeStrsFree(interp, interp->scopes[interp->cur_scope]);
    interp->scopes[interp->cur_scope] = NULL;
    interp->cur_scope--;
}

void jsi_PstateAddVar(jsi_Pstate *ps, const char *str)
{
    Jsi_Interp *interp = ps->interp;
    int i;
    if (interp->scopes[interp->cur_scope] == NULL)
        interp->scopes[interp->cur_scope] = (Jsi_ScopeStrs *)jsi_ScopeStrsNew();
    
    for (i = 0; i < interp->scopes[interp->cur_scope]->count; ++i) {
        if (Jsi_Strcmp(str, interp->scopes[interp->cur_scope]->args[i].name) == 0) return;
    }
    jsi_ScopeStrsPush(ps->interp, interp->scopes[interp->cur_scope], str, JSI_VT_UNDEF);
}

Jsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    return jsi_ScopeStrsDup(ps, interp->scopes[interp->cur_scope]);
}

#if 0
static int fastVarFree(Jsi_Interp *interp, void *ptr) {
    FastVar *fv = ptr;
    Jsi_Value *v = fv->var.lval;
    if (v) {
        //printf("FV FREE: %p (%d/%d)\n", fv, v->refCnt, v->vt == JSI_VT_OBJECT?v->d.obj->refcnt:-99);
        //Jsi_DecrRefCount(interp, v);
    }
    return JSI_OK;
}
#endif

jsi_Pstate *jsi_PstateNew(Jsi_Interp *interp)
{
    jsi_Pstate *ps = (jsi_Pstate *)Jsi_Calloc(1,sizeof(*ps));
    SIGINIT(ps,PARSER);
    ps->lexer = (Lexer*)Jsi_Calloc(1,sizeof(*ps->lexer));
    ps->lexer->pstate = ps;
    ps->interp = interp;
   // ps->argsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_ArglistFree);
    ps->fastVarTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL /*fastVarFree*/);
    ps->strTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    return ps;
}

const char *jsi_PstateGetFilename(jsi_Pstate *ps)
{
    Jsi_Interp *interp = ps->interp;
    return interp->curFile;
}

void jsi_PstateClear(jsi_Pstate *ps)
{
    Lexer* l = ps->lexer;
    if (l->ltype == LT_FILE)
    {
        if (l->d.fp)
            Jsi_Close(l->d.fp);
        l->d.fp = NULL;
    }
    if (l->ltype == LT_STRING)
    {
        l->d.str = NULL;
    }
    l->ltype = LT_NONE;
    l->last_token = 0;
    l->cur_line = 1;
    l->cur_char = 0;
    l->cur = 0;
    ps->err_count = 0;
}

int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)
{
    Lexer *l = ps->lexer;
    jsi_PstateClear(ps);
    l->ltype = LT_FILE;
    l->d.fp = fp;
    Jsi_Rewind(fp);
    if (skipbang) {
        char buf[1000];
        if (Jsi_Gets(fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {
            Jsi_Rewind(fp);
        }
    }
            
    return JSI_OK;
}


int jsi_PstateSetString(jsi_Pstate *ps, const char *str)
{
    Jsi_Interp *interp = ps->interp;
    Lexer *l = ps->lexer;
    jsi_PstateClear(ps);
    l->ltype = LT_STRING;
    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)str, NULL);
    assert(hPtr);
    l->d.str = (char*)Jsi_HashKeyGet(hPtr);
    return JSI_OK;
}

void jsi_PstateFree(jsi_Pstate *ps)
{
    /* TODO: when do we free opcodes */
    jsi_PstateClear(ps);
    Jsi_Free(ps->lexer);
    if (ps->opcodes)
        jsi_FreeOpcodes(ps->opcodes);
    if (ps->hPtr)
        Jsi_HashEntryDelete(ps->hPtr);
    Jsi_HashDelete(ps->argsTbl);
    Jsi_HashDelete(ps->strTbl);
    Jsi_HashDelete(ps->fastVarTbl);
    if (ps->last_exception)
        Jsi_DecrRefCount(ps->interp, ps->last_exception);
    MEMCLEAR(ps);
    Jsi_Free(ps);
}

#endif
#ifndef JSI_LITE_ONLY
#define __JSIINT_C__
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

#ifdef __WIN32
#include <windows.h>
#include <shlwapi.h>
#ifndef JSI_OMIT_THREADS
#include <process.h>
#endif
#else
#ifndef JSI_OMIT_THREADS
#include <pthread.h>
#endif
#endif

static int jsi_is_init = 0;
Jsi_Interp *jsiMainInterp = NULL;
Jsi_Interp *jsiDelInterp = NULL;
static Jsi_Hash *interpsTbl;

const char *jsi_TypeChkStrs[] = { "disable", "warn", "error", "static", NULL };
#define IIOF .flags=JSI_OPT_INIT_ONLY

static Jsi_OptionSpec InterpOptions[] = {
    JSI_OPT(ARRAY, Jsi_Interp, args,        .help="The console.arguments for interp", IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, doUnlock,    .help="Unlock our mutex when evaling in other interps", IIOF, .init="true"),
    JSI_OPT(BOOL,  Jsi_Interp, noUndef,     .help="Suppress printing undefined value result when in interactive mode"),
    JSI_OPT(INT,   Jsi_Interp, callTrace,  .help="Echo method call/return value"),
    JSI_OPT(STRKEY,Jsi_Interp, evalCallback,.help="String name of callback function in parent to handle eval stepping", IIOF ),
    JSI_OPT(VALUE, Jsi_Interp, indexFiles,  .help="File(s) to source for loading index for unknown commands"),
    JSI_OPT(BOOL,  Jsi_Interp, noInherit,   .help="Disallow access to __proto__, prototype, constructor, etc"),
    JSI_OPT(BOOL,  Jsi_Interp, isSafe,      .help="Interp is safe (ie. no file access)", IIOF),
    JSI_OPT(INT,   Jsi_Interp, lockTimeout, .help="Timeout for mutex lock-acquire (milliseconds)" ),
    JSI_OPT(STRKEY,Jsi_Interp, logCallback, .help="String name of callback function in parent to handle logging", IIOF ),
    JSI_OPT(BOOL,  Jsi_Interp, logAllowDups,.help="Disable log duplicate filtering"),
    JSI_OPT(INT,   Jsi_Interp, maxDepth,    .help="Recursion call depth limit", .init="1000"),
    JSI_OPT(INT,   Jsi_Interp, maxIncDepth, .help="Max file include nesting limit", .init="50" ),
    JSI_OPT(INT,   Jsi_Interp, maxInterpDepth,.help="Max nested subinterp create limit", .init="10" ),
    JSI_OPT(INT,   Jsi_Interp, maxUserObjs, .help="Cap on number of 'new' object calls (eg. File, Regexp, etc)" ),
    JSI_OPT(INT,   Jsi_Interp, maxOpCnt,    .help="Execution cap on opcodes evaluated" ),
    JSI_OPT(INT,   Jsi_Interp, memDebug,    .help="Set memory debugging level 1=summary, 2=detail", .flags=JSI_OPT_NO_CLEAR),
    JSI_OPT(BOOL,  Jsi_Interp, nDebug,      .help="Make assert statements have no effect"),
    JSI_OPT(STRKEY,Jsi_Interp, name, .help="Name of interp", IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, noreadline,  .help="Do not use readline in interactive mode", IIOF),
    JSI_OPT(FUNC,  Jsi_Interp, onComplete,  .help="Command return command completions" ),
    JSI_OPT(FUNC,  Jsi_Interp, onEval,      .help="Interactive eval" ),
    JSI_OPT(FUNC,  Jsi_Interp, onExit,      .help="Command to call in parent on exit (which returns true to continue)", IIOF ),
    JSI_OPT(INT,   Jsi_Interp, opTrace,     .help="Set debugging level"),
    JSI_OPT(BOOL,  Jsi_Interp, noSubInterps,.help="Disallow sub-interp creation", IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, privKeys,    .help="Disable string key sharing with other interps", IIOF, .init="true"),
    JSI_OPT(STRKEY,Jsi_Interp, recvCmd,     .help="Name of function to recv 'send' msgs"),
    JSI_OPT(ARRAY, Jsi_Interp, safeReadDirs,.help="In safe mode, directories to allow reads from", IIOF),
    JSI_OPT(ARRAY, Jsi_Interp, safeWriteDirs,.help="In safe mode, directories to allow writes to", IIOF),
    JSI_OPT(STRKEY,Jsi_Interp, scriptStr,   .help="Startup script string", IIOF),
    JSI_OPT(VALUE, Jsi_Interp, scriptFile,  .help="Startup script file name", IIOF),
    JSI_OPT(BOOL,  Jsi_Interp, compat,      .help="If set to true, option parses ignore unknown options" ),
    JSI_OPT(BOOL,  Jsi_Interp, subthread,   .help="Create thread for interp", IIOF),
    JSI_OPT(CUSTOM,Jsi_Interp, typeCheck,   .help="Type-checking control", .custom=Jsi_Opt_SwitchEnum, .data=jsi_TypeChkStrs),
    JSI_OPT_END(Jsi_Interp)
};

/* Object for each interp created. */
typedef struct InterpObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *subinterp;
    Jsi_Interp *parent;
    Jsi_Hash *aliases;
    //char *interpname;
    char *mode;
    Jsi_Obj *fobj;
    int objId;
    int deleting;
} InterpObj;

/* Global state of interps. */

typedef struct {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    int refCount;
    const char *cmdName;
    Jsi_Value *args;
    Jsi_Value *func;
    Jsi_Value *cmdVal;
    InterpObj *intobj;
    Jsi_Interp *interp;
} AliasCmd;


static void interpObjErase(InterpObj *fo);
static int interpObjFree(Jsi_Interp *interp, void *data);
static int interpObjIsTrue(void *data);
static int interpObjEqual(void *data1, void *data2);

static void ConvertReturn(Jsi_Interp *interp, Jsi_Interp *inInterp, Jsi_Value **ret)
{
    Jsi_DString dStr = {};

    switch ((*ret)->vt) {
        case JSI_VT_UNDEF:
        case JSI_VT_BOOL:
        case JSI_VT_NUMBER:
        case JSI_VT_NULL:
            break;
        default:
            Jsi_DSInit(&dStr);
            char *cp = (char*)Jsi_ValueGetDString(inInterp, *ret, &dStr, JSI_OUTPUT_JSON);
            Jsi_JSONParse(interp, cp, ret, 0);
            Jsi_DSFree(&dStr);
    }
}

/* Call a command with JSON args.  Returned value is converted to JSON. */
int Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr)
{
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)
        return JSI_ERROR;
    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);
    int rc = Jsi_CommandInvokeJSON(interp, cmd, jsonArgs, &nrPtr);
    Jsi_DSInit(dStr);
    Jsi_ValueGetDString(interp, nrPtr, dStr, JSI_OUTPUT_JSON);
    Jsi_DecrRefCount(interp, nrPtr);
    Jsi_MutexUnlock(interp, interp->Mutex);
    return rc;
}

/* Call a function with JSON args.  Return a primative. */
int Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *func, const char *json, Jsi_Value **ret)
{
    int rc;
    Jsi_Value *aPtr = Jsi_ValueNew1(interp);
    rc = Jsi_JSONParse(interp, json, &aPtr, 0);
    if (rc == JSI_OK) {
        rc = Jsi_FunctionInvoke(interp, func, aPtr, ret, NULL);
    }
    Jsi_DecrRefCount(interp, aPtr);
    return rc;
}
/* Lookup cmd from cmdstr and invoke with JSON args. */
/*
 *   Jsi_CommandInvokeJSON(interp, "info.cmds", "[\"*\",true]", ret);
 */
int Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmdstr, const char *json, Jsi_Value **ret)
{
    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);
    if (func)
        return Jsi_FunctionInvokeJSON(interp, func, json, ret);
    Jsi_LogError("can not find cmd: %s", cmdstr);
    return JSI_ERROR;
}

static int NeedClean(Jsi_Interp *interp, Jsi_Value *arg)
{
    switch (arg->vt) {
        case JSI_VT_BOOL: return 0;
        case JSI_VT_NULL: return 0;
        case JSI_VT_NUMBER: return 0;
        case JSI_VT_STRING: return (interp->privKeys || arg->f.bits.isstrkey);
        case JSI_VT_UNDEF: return 0;
        //case JSI_VT_VARIABLE: return 1;
        case JSI_VT_OBJECT: {
            Jsi_Obj *o = arg->d.obj;
            switch (o->ot) {
                case JSI_OT_NUMBER: return 0;
                case JSI_OT_BOOL: return 0;
                case JSI_OT_STRING: return (interp->privKeys || arg->d.obj->isstrkey);
                case JSI_OT_FUNCTION: return 1;
                case JSI_OT_REGEXP: return 1;
                case JSI_OT_USEROBJ: return 1;
                case JSI_OT_ITER: return 1;     
                case JSI_OT_OBJECT:
                case JSI_OT_ARRAY:
                    if (o->isarrlist && o->arr)
                    {
                        int i;
                        for (i = 0; i < o->arrCnt; ++i) {
                            if (o->arr[i] && NeedClean(interp, o->arr[i]))
                                return 1;
                        }
                    } else if (o->tree) {
                        int trc = 0;
                        Jsi_TreeEntry *tPtr;
                        Jsi_TreeSearch search;
                        for (tPtr = Jsi_TreeEntryFirst(o->tree, &search, 0);
                            tPtr; tPtr = Jsi_TreeEntryNext(&search)) {
                            Jsi_Value *v = (Jsi_Value *)Jsi_TreeValueGet(tPtr);
                            if (v && (trc = NeedClean(interp, v)))
                                break;
                        }
                        Jsi_TreeSearchDone(&search);
                        return trc;
                    } else {
                        return 1;
                    }
                    return 0;
                default:
                    return 1;
            }
        }
    }
    return 1;
}

static  int Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *args, Jsi_Value **ret)
{
    if (tointerp->threadId == interp->threadId && !NeedClean(interp, args)) {
        Jsi_ValueCopy(tointerp, *ret, args);
        return JSI_OK;
    }
    /* Cleanse input args by convert to JSON and back. */
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    const char *cp = Jsi_ValueGetDString(interp, args, &dStr, JSI_OUTPUT_JSON);
    if (Jsi_JSONParse(tointerp, cp, ret, 0) != JSI_OK) {
        Jsi_DSFree(&dStr);
        Jsi_LogError("bad subinterp parse");
        return JSI_ERROR;
    }
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static int AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Interp *pinterp = interp->parent;
    if (!pinterp)
        return JSI_ERROR;
    AliasCmd *ac = (AliasCmd *)funcPtr->cmdSpec->udata3;
    Jsi_Value *nargs = NULL;
    int argc = Jsi_ValueGetLength(interp, args);
    if (!ac) {
        Jsi_LogBug("BAD ALIAS INVOKE OF DELETED");
        return JSI_ERROR;
    }
    SIGASSERT(ac,ALIASCMD);
    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);
    if (argc == 0 && ac->args)
        nargs = ac->args;
    else if (argc) {
        if (Jsi_CleanValue(interp, pinterp, args, &nrPtr) != JSI_OK)
            return JSI_ERROR;
        if (ac->args) {
            nargs = Jsi_ValueArrayConcat(pinterp, ac->args, nrPtr);
        } else {
            nargs = nrPtr;
        }
    }
    if (interp->doUnlock) Jsi_MutexUnlock(interp, interp->Mutex);
    if (Jsi_MutexLock(interp, pinterp->Mutex) != JSI_OK) {
        if (interp->doUnlock) Jsi_MutexLock(interp, interp->Mutex);
        return JSI_ERROR;
    }
    ac->refCount++;
    if (nargs && nargs != nrPtr)
        Jsi_IncrRefCount(interp, nargs);
    int oref = nargs->d.obj->refcnt;
    int rc = Jsi_FunctionInvoke(pinterp, ac->func, nargs, ret, NULL);
    if (oref != nargs->d.obj->refcnt && strcmp(ac->func->d.obj->d.fobj->func->name,"include") == 0) {
        // TODO: a hack to reduce a mem-leak, probably due to use of "arguments[n]" in JS.
        //fprintf(stderr, "REF CHG: %d\n", oref - nargs->d.obj->refcnt);
        Jsi_ObjDecrRefCount(interp, nargs->d.obj); 
    }
    ac->refCount--;
    Jsi_MutexUnlock(interp, pinterp->Mutex);
    if (interp->doUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        return JSI_ERROR;
    }
    Jsi_DecrRefCount(interp, nrPtr);
    if (nargs && nargs != nrPtr)
        Jsi_DecrRefCount(interp, nargs);
    ConvertReturn(pinterp, interp, ret);
    return rc;
}


static int AliasFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data) {
    /* TODO: deal with other copies of func may be floating around (refCount). */
    AliasCmd *ac = (AliasCmd *)data;
    SIGASSERT(ac,ALIASCMD);
    if (ac->func)
        Jsi_DecrRefCount(ac->interp, ac->func);
    if (ac->args)
        Jsi_DecrRefCount(ac->interp, ac->args);
    if (!ac->cmdVal)
        return JSI_OK;
    Jsi_Func *fobj = ac->cmdVal->d.obj->d.fobj->func;
    fobj->cmdSpec->udata3 = NULL;
    fobj->cmdSpec->proc = NULL;
    if (ac->intobj->subinterp) {
        Jsi_CommandDelete(ac->intobj->subinterp, ac->cmdName);
        if (strchr(ac->cmdName, '.'))
            Jsi_LogBug("alias free with X.Y dot name leaks memory: %s", ac->cmdName);
    } else
        Jsi_DecrRefCount(ac->interp, ac->cmdVal);
    MEMCLEAR(ac);
    Jsi_Free(ac);
    return JSI_OK;
}

static int InterpAliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!udf) {
        Jsi_LogError("Apply Interp.eval in a non-interp object");
        return JSI_ERROR;
    }
    if (!udf->aliases) {
        Jsi_LogError("Sub-interp gone");
        return JSI_ERROR;
    }
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc == 0) {
        return Jsi_HashKeysDump(interp, udf->aliases, ret, 0);
    }
    Jsi_HashEntry *hPtr;
    char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (!key) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    AliasCmd* ac;
    if (argc == 1) {
        hPtr = Jsi_HashEntryFind(udf->aliases, (void*)key);
        if (!hPtr)
            return JSI_OK;
        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);
        SIGASSERT(ac,ALIASCMD);
        Jsi_ValueDup2(interp, ret, ac->func);
        return JSI_OK;
    }
    Jsi_Value *afunc = Jsi_ValueArrayIndex(interp, args, 1);
    if (argc == 2) {
        hPtr = Jsi_HashEntryFind(udf->aliases, (void*)key);
        if (!hPtr)
            return JSI_OK;
        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);
        if (!Jsi_ValueIsFunction(interp, afunc)) {
            Jsi_LogError("arg 2: expected function");
            return JSI_ERROR;
        }
        Jsi_ValueDup2(interp, ret, ac->args);
        return JSI_OK;
    }
    if (argc == 3) {
        int isNew;
        Jsi_Value *aargs = Jsi_ValueArrayIndex(interp, args, 2);
        if (Jsi_ValueIsNull(interp, afunc) && Jsi_ValueIsNull(interp, aargs)) {
            hPtr = Jsi_HashEntryFind(udf->aliases, (void*)key);
            if (hPtr == NULL)
                return JSI_OK;
            AliasCmd *ac = (AliasCmd*)Jsi_HashValueGet(hPtr);
            if (0 && ac->cmdVal)
                Jsi_DecrRefCount(interp, ac->cmdVal);
            AliasFree(interp, NULL, ac);
            Jsi_HashEntryDelete(hPtr);
            return JSI_OK;
        }
        hPtr = Jsi_HashEntryNew(udf->aliases, (void*)key, &isNew);
        if (!hPtr) {
            Jsi_LogError("create failed: %s", key);
            return JSI_ERROR;
        }
        if (!Jsi_ValueIsFunction(interp, afunc)) {
            Jsi_LogError("arg 2: expected function");
            return JSI_ERROR;
        }
        if (Jsi_ValueIsNull(interp, aargs) == 0 && Jsi_ValueIsArray(interp, aargs) == 0) {
            Jsi_LogError("arg 3: expected array or null");
            return JSI_ERROR;
        }
        AliasCmd *ac;
        if (!isNew) {
            AliasFree(interp, NULL, Jsi_HashValueGet(hPtr));
        }
        ac = (AliasCmd*)Jsi_Calloc(1, sizeof(AliasCmd));
        SIGINIT(ac, ALIASCMD);
        ac->cmdName = (const char*)Jsi_HashKeyGet(hPtr);
        ac->func = afunc;
        Jsi_IncrRefCount(interp, afunc);
        if (!Jsi_ValueIsNull(interp, aargs)) {
            ac->args = aargs;
            Jsi_IncrRefCount(interp, aargs);
        }
        ac->intobj = udf;
        ac->interp = interp;
        Jsi_HashValueSet(hPtr, ac);
        Jsi_Value *cmd = Jsi_CommandCreate(udf->subinterp, key, AliasInvoke, NULL);
        if (!cmd) {
            Jsi_LogError("command create failure");
            return JSI_ERROR;
        }
        ac->cmdVal = cmd;
        Jsi_Func *fobj = cmd->d.obj->d.fobj->func;
        fobj->cmdSpec->udata3 = ac;
    }
    return JSI_OK;
}

static int freeCodeTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    jsi_Pstate *ps = (jsi_Pstate *)ptr;
    if (!ps) return JSI_OK;
    ps->hPtr = NULL;
    jsi_PstateFree(ps);
    return JSI_OK;
}

static int freeOnDeleteTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    Jsi_DeleteProc *proc = (Jsi_DeleteProc *)ptr;
    proc(interp, NULL);
    return JSI_OK;
}

static int freeAssocTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    jsi_DelAssocData(interp, ptr);
    return JSI_OK;
}

static int freeEventTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Event *event = (Jsi_Event *)ptr;
    SIGASSERT(event,EVENT);
    if (!ptr) return JSI_OK;
    event->hPtr = NULL;
    Jsi_EventFree(interp, event);
    return JSI_OK;
}
static int jsiFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Free(ptr);
    return JSI_OK;
}

static int regExpFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_RegExpFree((Jsi_Regex*)ptr);
    return JSI_OK;
}

static int freeCmdSpecTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    jsi_CmdSpecDelete(interp, ptr);
    return JSI_OK;
}

static int freeGenObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Obj *obj = (Jsi_Obj *)ptr;
    SIGASSERT(obj,OBJ);
    if (!obj) return JSI_OK;
    Jsi_ObjDecrRefCount(interp, obj);
    return JSI_OK;
}


static int freeFuncsTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Func *func = (Jsi_Func *)ptr;
    if (!func) return JSI_OK;
    SIGASSERT(func,FUNC);
    func->hPtr = NULL;
    jsi_FuncFree(interp, func);
    return JSI_OK;
}

static int freeFuncObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Obj *v = (Jsi_Obj *)ptr;
    if (!v) return JSI_OK;
    SIGASSERT(v,OBJ);
    if (v->d.fobj) {
        if (v->d.fobj->scope) {
            jsi_ScopeChain *scope = v->d.fobj->scope;
            v->d.fobj->scope = NULL;
            jsi_ScopeChainFree(interp, scope);
        }
    }
    Jsi_ObjDecrRefCount(interp, v);
    return JSI_OK;
}

static int freeBindObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Obj *v = (Jsi_Obj *)ptr;
    if (!v) return JSI_OK;
    SIGASSERT(v,OBJ);
    if (v->d.fobj && v->d.fobj->scope) {
        v->d.fobj->scope = NULL;
    }
    Jsi_ObjDecrRefCount(interp, v);
    return JSI_OK;
}

/* TODO: incr ref before add then just decr till done. */
static int freeValueTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    Jsi_Value *val = (Jsi_Value *)ptr;
    SIGASSERT(val,VALUE);
    if (!val) return JSI_OK;
    //printf("GEN: %p\n", val);
   /* if (val->refCnt>1)
        Jsi_DecrRefCount(interp, val);*/
    Jsi_DecrRefCount(interp, val);
    return JSI_OK;
}

static int freeUserdataTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (ptr) 
        jsi_UserObjDelete(interp, ptr);
    return JSI_OK;
}

void Jsi_ShiftArgs(Jsi_Interp *interp) {
    Jsi_Value *v = interp->args; //Jsi_NameLookup(interp, "console.args");
    if (v==NULL || v->vt != JSI_VT_OBJECT || v->d.obj->arr == NULL || v->d.obj->arrCnt <= 0)
        return;
    Jsi_Obj *obj = v->d.obj;
    int n = v->d.obj->arrCnt;
    n--;
    v = obj->arr[0];
    if (n>0)
        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));
    obj->arr[n] = NULL;
    Jsi_ObjSetLength(interp, obj, n);    
}

char *jsi_execName = NULL;
static Jsi_Value *jsi_execValue = NULL;

Jsi_Value *Jsi_Executable(Jsi_Interp *interp)
{
    return jsi_execValue;
}

static int KeyLocker(Jsi_Hash* tbl, int lock)
{
    if (!lock)
        Jsi_MutexUnlock(jsiMainInterp, jsiMainInterp->Mutex);
    else
        return Jsi_MutexLock(jsiMainInterp, jsiMainInterp->Mutex);
    return JSI_OK;
}

Jsi_Interp* Jsi_InterpNew(Jsi_Interp *parent, int argc, char **argv, Jsi_Value *opts)
{
    Jsi_Interp* interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp));
    char buf[BUFSIZ];
    if (jsiMainInterp == NULL && parent == NULL)
        jsiMainInterp = interp;
    interp->parent = parent;
    interp->mainInterp = jsiMainInterp;
    if (parent) {
        interp->dbPtr = parent->dbPtr;
    } else {
        interp->dbPtr = &interp->dbStatic;
    }
#ifdef JSI_MEM_DEBUG
    if (!interp->dbPtr->valueDebugTbl) {
        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
    }
#endif    
    if (!parent)
        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;
    else {
        if (parent->noSubInterps) {
            Jsi_Free(interp);
            interp = parent;
            Jsi_LogError("subinterps disallowed");
            return NULL;
        }
        interp->maxInterpDepth = parent->maxInterpDepth;
        interp->interpDepth = parent->interpDepth+1;
        if (interp->interpDepth > interp->maxInterpDepth) {
            Jsi_Free(interp);
            interp = parent;
            Jsi_LogError("exceeded max subinterp depth");
            return NULL;
        }
    }
#ifdef JSI_USE_COMPAT
    interp->compat = JSI_USE_COMPAT;
#endif
    const char *ocp = NULL;
    const char *ocp2;
    if (ocp && ((ocp2=strstr(ocp,"memDebug:"))))
        interp->memDebug=strtol(ocp+sizeof("memDebug:"), NULL, 0);
    if (ocp && ((ocp2=strstr(ocp,"compat:"))))
        interp->compat=(ocp[sizeof("compat:")]=='t');
    interp->maxDepth = JSI_MAX_EVAL_DEPTH;
    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;
    SIGINIT(interp,INTERP);
    interp->NullValue = Jsi_ValueNewNull(interp);
    Jsi_IncrRefCount(interp, interp->NullValue);
    interp->curDir = Jsi_Strdup(getcwd(buf, sizeof(buf)));   
    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);
    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);
    interp->cmdSpecTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCmdSpecTbl);
    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);
    interp->genDataTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsiFree);
    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsiFree);
    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);
    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);
    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);
    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);
    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);
    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsiFree);
    interp->loadTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle);
    interp->optionDataHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsiFree);
    interp->lockTimeout = -1;
#ifdef JSI_LOCK_TIMEOUT
    interp->lockTimeout JSI_LOCK_TIMEOUT;
#endif
#ifndef JSI_DO_UNLOCK
#define JSI_DO_UNLOCK 1
#endif
    interp->doUnlock = JSI_DO_UNLOCK;

    if (interp == jsiMainInterp || interp->threadId != jsiMainInterp->threadId) {
        interp->strKeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
        interp->privKeys = 1;
    }
    if (!interp->strKeyTbl)
        interp->strKeyTbl = jsiMainInterp->strKeyTbl;
    if (opts && opts->vt != JSI_VT_NULL && Jsi_OptionsProcess(interp, InterpOptions, opts, interp, 0) < 0) {
        Jsi_InterpDelete(interp);
        return NULL;
    }
    if (interp == jsiMainInterp) {
        interp->subthread = 0;
    } else {
        if (interp->privKeys && interp->strKeyTbl == jsiMainInterp->strKeyTbl) {
            //Jsi_HashDelete(interp->strKeyTbl);
            Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */
            interp->strKeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
            if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, opts, interp, 0);
        } else if (interp->privKeys == 0 && interp->strKeyTbl != jsiMainInterp->strKeyTbl) {
            Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */
            Jsi_HashDelete(interp->strKeyTbl);
            interp->strKeyTbl = jsiMainInterp->strKeyTbl;
            if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, opts, interp, 0);
        }
        if (interp->subthread)
            jsiMainInterp->threadCnt++;
        if (interp->subthread && interp->strKeyTbl == jsiMainInterp->strKeyTbl)
            jsiMainInterp->threadShrCnt++;
        if (jsiMainInterp->threadShrCnt)
            jsiMainInterp->strKeyTbl->lockProc = KeyLocker;
    }
    if (parent && parent->isSafe)
        interp->isSafe = 1;
    Jsi_DString oStr = {};
#ifdef JSI_INTERP_OPTS  /* eg. "nonStrict: true, maxOpCnt:1000000" */
    if (ocp && *ocp)
        Jsi_DSAppend(&oStr, "{", JSI_INTERP_OPTS, ", ", ocp+1, NULL);
    else
        Jsi_DSAppend(&oStr, "{", JSI_INTERP_OPTS, "}", NULL);
#else
    Jsi_DSAppend(&oStr, ocp, NULL);
#endif
    ocp = Jsi_DSValue(&oStr);
    if (interp == jsiMainInterp  && *ocp) {
        Jsi_Value *popts = Jsi_ValueNew1(interp);
        if (Jsi_JSONParse(interp, ocp, &popts, 0) != JSI_OK ||
            Jsi_OptionsProcess(interp, InterpOptions, popts, interp, JSI_OPTS_IS_UPDATE) < 0) {
            Jsi_InterpDelete(interp);
            Jsi_DSFree(&oStr);
            return NULL;
        }
        Jsi_DecrRefCount(interp, popts);
    }
    Jsi_DSFree(&oStr);
#ifndef JSI_MEM_DEBUG
    static int warnNoDebug = 0;
    if (interp->memDebug && warnNoDebug == 0) {
        Jsi_LogWarn("ignoring memDebug as jsi was compiled without memory debugging");
        warnNoDebug = 1;
    }
#endif
    interp->threadId = Jsi_CurrentThread();
    if (interp == jsiMainInterp)
        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    else
        interp->lexkeyTbl = jsiMainInterp->lexkeyTbl;
    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);
    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);
    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);
    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);
    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);
#ifdef JSI_MEM_DEBUG
    interp->codesTbl = (interp == jsiMainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiMainInterp->codesTbl);
#endif
    interp->maxArrayList = MAX_ARRAY_LIST;
    if (!jsi_is_init) {
        jsi_is_init = 1;
        jsi_ValueInit(interp);
        interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);
    }
    

    /* current scope, also global */
    interp->csc = Jsi_ValueNew1(interp);
    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));
    interp->incsc = interp->csc;
    
    /* initial scope chain, nothing */
    interp->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);
    
    interp->ps = jsi_PstateNew(interp); /* Default parser. */

    if (interp->args && argc) {
        Jsi_LogFatal("args may not be specified both as options and parameter");
        Jsi_InterpDelete(interp);
        return NULL;
    }
    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)
        interp->maxDepth = JSI_MAX_EVAL_DEPTH;

#define JSIDOINIT(nam) if (jsi_##nam##Init(interp) != JSI_OK) { Jsi_LogFatal("Init failure in %s", #nam); }
#define JSIDOINIT2(nam) if (Jsi_##Init##nam(interp) != JSI_OK) { Jsi_LogFatal("Init failure in %s", #nam); }

    JSIDOINIT(Proto);

    if (argc >= 0) {
        Jsi_Value *iargs = Jsi_ValueNew1(interp);
        iargs->f.bits.dontdel = 1;
        iargs->f.bits.readonly = 1;
        Jsi_Obj *iobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);
        int msiz = (argc?argc-1:0);
        Jsi_ObjArraySizer(interp, iobj, msiz);
        iobj->arrMaxSize = msiz;
        iobj->arrCnt = argc;
        int i;
        for (i = 1; i < argc; ++i) {
            iobj->arr[i-1] = Jsi_ValueNewStringDup(interp, argv[i]);
            Jsi_IncrRefCount(interp, iobj->arr[i-1]);
            if (i==1)
                Jsi_HashSet(interp->genValueTbl, iobj->arr[i-1], iobj->arr[i-1]);
            jsi_ValueDebugLabel(iobj->arr[i-1], "InterpCreate", "args");
        }
        Jsi_ObjSetLength(interp, iobj, msiz);
        interp->args = iargs;
    }

    JSIDOINIT(Cmds);
    JSIDOINIT(Interp);
    JSIDOINIT(JSON);

    interp->retPtr = Jsi_ValueNew1(interp);
    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);
    if (1 || interp->subthread) {
        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);
        Jsi_DSInit(&interp->interpEvalQ);
        Jsi_DSInit(&interp->interpMsgQ);
    }
    JSIDOINIT(Lexer);
    if (interp != jsiMainInterp && !parent)
        Jsi_HashSet(interpsTbl, interp, NULL);
        
    if (!interp->isSafe) {
        JSIDOINIT(Load);
#ifndef JSI_OMIT_SIGNAL
        JSIDOINIT(Signal);
#endif
    }
    if (interp->isSafe == 0 || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {
#ifndef JSI_OMIT_FILESYS
        JSIDOINIT(FileCmds);
        JSIDOINIT(Filesys);
#endif
#ifndef JSI_OMIT_SOCKET
    JSIDOINIT2(Socket);
#endif
#ifdef HAVE_SQLITE
        JSIDOINIT2(Sqlite);
#endif
#ifdef HAVE_MYSQL
        JSIDOINIT2(MySql);
#endif
    }
#ifdef HAVE_WEBSOCKET
    JSIDOINIT2(WebSocket);
#endif

    if (argc > 0) {
        char *ss = argv[0];
        char epath[PATH_MAX] = "";
#ifdef __WIN32
  
        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)
            ss = epath;
#else
#ifndef PROC_SELF_DIR
#define PROC_SELF_DIR "/proc/self/exe"
#endif
        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath))) {
            ss = epath;
        }
#endif
        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);
        Jsi_IncrRefCount(interp, src);
        jsi_execName = Jsi_Realpath(interp, src, NULL);
        Jsi_DecrRefCount(interp, src);
        jsi_execValue = Jsi_ValueNewString(interp, jsi_execName, -1);
        Jsi_IncrRefCount(interp, jsi_execValue);
        Jsi_HashSet(interp->genValueTbl, jsi_execValue, jsi_execValue);
    }
    
    //interp->nocacheOpCodes = 1;
    return interp;
}

int Jsi_InterpGone( Jsi_Interp* interp)
{
    return (interp == NULL || interp->deleting || interp->destroying || interp->exited);
}

static void DeleteAllInterps() { /* Delete toplevel interps. */
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    if (!interpsTbl)
        return;
    for (hPtr = Jsi_HashEntryFirst(interpsTbl, &search); hPtr; hPtr = Jsi_HashEntryNext(&search)) {
        Jsi_Interp *interp = (Jsi_Interp *)Jsi_HashKeyGet(hPtr);
        Jsi_HashEntryDelete(hPtr);
        interp->destroying = 1;
        Jsi_InterpDelete(interp);
    }
    Jsi_HashDelete(interpsTbl);
    interpsTbl = NULL;
    jsi_is_init = 0;
}

#ifdef JSI_MEM_DEBUG

typedef enum { MDB_INOBJ=1, MDB_VISITED=2 } jsi_MDB;

void jsiFlagDebugValues(Jsi_Interp *interp, Jsi_Obj *obj)
{
    Jsi_Value *v;
    int oflags;
    if (obj->ot != JSI_OT_OBJECT && obj->ot != JSI_OT_ARRAY)
        return;
    if (obj->tree) {
        Jsi_TreeEntry *hPtr;
        Jsi_TreeSearch srch;
        for (hPtr=Jsi_TreeEntryFirst(obj->tree, &srch,  JSI_TREE_INORDER); hPtr;
            hPtr=Jsi_TreeEntryNext(&srch)) {
            v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;
            oflags = v->VD.flags;
            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);
            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)
                continue;
            jsiFlagDebugValues(interp, v->d.obj);
        }
    }
    if (obj->arr) {
        int i;
        for (i=0; i<obj->arrCnt; i++) {
            v = obj->arr[i];
            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;
            oflags = v->VD.flags;
            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);
            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)
                continue;
            jsiFlagDebugValues(interp, v->d.obj);
        }
    }
}

void jsi_DebugDumpValues(Jsi_Interp *interp)
{
    if (jsiMainInterp != interp) return;
    int vdLev = interp->memDebug;
    int have = (interp->dbPtr->valueDebugTbl->numEntries || interp->dbPtr->objDebugTbl->numEntries);
    if ((have && vdLev>0) || vdLev>=3) {
        // First traverse all Object trees/arrays and mark all values contained therein.
        Jsi_HashSearch search;
        Jsi_HashEntry *hPtr;
        for (hPtr = Jsi_HashEntryFirst(interp->dbPtr->objDebugTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);
            if (vp!=NULL && vp->sig == JSI_SIG_OBJ) {
                jsiFlagDebugValues(interp, vp);
            }
        }
        if (interp->dbPtr->valueDebugTbl->numEntries != interp->dbPtr->valueCnt)
            fprintf(stderr, "\n\nValues table/alloc mismatch: table=%d, alloc=%d\n",
                interp->dbPtr->valueDebugTbl->numEntries, interp->dbPtr->valueCnt);
        // Dump unfreed values and objs.
        int refSum=0, refsum=0;
        int bcnt[4] = {};
        if (vdLev>1 && interp->dbPtr->valueDebugTbl->numEntries)
            fprintf(stderr, "\n\nUNFREED VALUES \"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\"\n");
        for (hPtr = Jsi_HashEntryFirst(interp->dbPtr->valueDebugTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
            Jsi_Value *vp = (Jsi_Value *)Jsi_HashKeyGet(hPtr);
            if (vp==NULL || vp->sig != JSI_SIG_VALUE) {
                bcnt[0]++;
                if (vdLev>1)
                    fprintf(stderr, "BAD VALUE: %p\n", vp);
            } else {
                bcnt[1]++;
                refSum += vp->refCnt;
                if (vdLev>1) {
                    char ebuf[BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];
                    ebuf[0] = 0;
                    if (vp->vt==JSI_VT_OBJECT)
                        sprintf(ebuf, " {obj=%p, otype=%s}", vp->d.obj, Jsi_ObjTypeStr(interp, vp->d.obj));
                    else if (vp->vt==JSI_VT_NUMBER)
                        sprintf(ebuf, " {num=%s}", Jsi_NumberToString(vp->d.num, ebuf2));
                    else if (vp->vt==JSI_VT_BOOL)
                        sprintf(ebuf, " {bool=%s}", vp->d.val?"true":"false");
                    else if (vp->vt==JSI_VT_STRING) {
                        const char *sbuf = ((vp->d.s.str && strlen(vp->d.s.str)>40)?"...":"");
                        sprintf(ebuf, " {string=\"%.40s%s\"}", (vp->d.s.str?vp->d.s.str:""), sbuf);
                    }
                    const char *pfx = "";
                    if (!(vp->VD.flags&MDB_INOBJ))
                        pfx = "!"; // Value is not contained in an object.
                    fprintf(stderr, "[%s*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s()%s\n", pfx,
                        vp, vp->refCnt, Jsi_ValueTypeStr(interp, vp), vp->VD.Idx,
                        (vp->VD.label?vp->VD.label:""), (vp->VD.label2?":":""),
                        (vp->VD.label2?vp->VD.label2:""), vp->VD.interp==jsiMainInterp?"":"!",
                        vp->VD.fname, vp->VD.line, vp->VD.func, ebuf);
                }
            }
        }
        if (interp->dbPtr->objDebugTbl->numEntries != interp->dbPtr->objCnt)
            fprintf(stderr, "\n\nObject table/alloc mismatch: table=%d, alloc=%d\n",
                interp->dbPtr->objDebugTbl->numEntries, interp->dbPtr->objCnt);
        if (vdLev>1 && interp->dbPtr->objDebugTbl->numEntries)
            fprintf(stderr, "\n\nUNFREED OBJECTS \"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\"\n");
        for (hPtr = Jsi_HashEntryFirst(interp->dbPtr->objDebugTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);
            if (vp==NULL || vp->sig != JSI_SIG_OBJ) {
                bcnt[2]++;
                fprintf(stderr, "BAD OBJ: %p\n", vp);
            } else {
                bcnt[3]++;
                refsum += vp->refcnt;
                if (vdLev>1) {
                    char ebuf[BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];
                    ebuf[0] = 0;
                    if (vp->ot==JSI_OT_OBJECT) {
                        if (vp->isarrlist)
                            sprintf(ebuf, "tree#%d, array#%d", (vp->tree?vp->tree->numEntries:0), vp->arrCnt);
                        else
                            sprintf(ebuf, "tree#%d", (vp->tree?vp->tree->numEntries:0));
                    } else if (vp->ot==JSI_OT_NUMBER)
                        sprintf(ebuf, "num=%s", Jsi_NumberToString(vp->d.num, ebuf2));
                    else if (vp->ot==JSI_OT_BOOL)
                        sprintf(ebuf, "bool=%s", vp->d.val?"true":"false");
                    else if (vp->ot==JSI_OT_STRING) {
                        const char *sbuf = ((vp->d.s.str && strlen(vp->d.s.str)>40)?"...":"");
                        sprintf(ebuf, "string=\"%.40s%s\"", (vp->d.s.str?vp->d.s.str:""), sbuf);
                    }
                    fprintf(stderr, "[*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s() {%s}\n",
                        vp, vp->refcnt, Jsi_ObjTypeStr(interp, vp), vp->VD.Idx, vp->VD.label?vp->VD.label:"",
                        vp->VD.label2?":":"",vp->VD.label2?vp->VD.label2:"", vp->VD.interp==jsiMainInterp?"":"!",
                        vp->VD.fname, vp->VD.line,
                        vp->VD.func, ebuf);
                }
            }
        }
        fprintf(stderr, "\nVALUES: bad=%d,unfreed=%d,allocs=%d,refsum=%d  | OBJECTS: bad=%d,unfreed=%d,allocs=%d,refsum=%d\n",
            bcnt[0], bcnt[1], interp->dbPtr->valueAllocCnt, refSum, bcnt[2], bcnt[3], interp->dbPtr->objAllocCnt, refsum);

        if (interp->codesTbl)
            for (hPtr = Jsi_HashEntryFirst(interp->codesTbl, &search);
                hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
                OpCodes *vp = (OpCodes *)Jsi_HashKeyGet(hPtr);
                fprintf(stderr, "unfreed opcodes: %d\n", vp->id);
            }
    }
    Jsi_HashDelete(interp->dbPtr->valueDebugTbl);
    Jsi_HashDelete(interp->dbPtr->objDebugTbl);
    Jsi_HashDelete(interp->codesTbl);
}
#endif

static int jsiInterpDelete(Jsi_Interp* interp, void *unused)
{
    SIGASSERT(interp,INTERP);
    if (interp == jsiMainInterp)
        DeleteAllInterps();

    jsiDelInterp = interp;
    if (interp->gsc) jsi_ScopeChainFree(interp, interp->gsc);
    //if (interp->csc->d.obj->refcnt>1) /* TODO: This is a hack to release global. */
       // Jsi_ObjDecrRefCount(interp, interp->csc->d.obj);
    if (interp->csc) Jsi_DecrRefCount(interp, interp->csc);
    if (interp->ps) jsi_PstateFree(interp->ps);
    int i;
    for (i=0; i<interp->maxStack; i++) {
        if (interp->Stack[i]) Jsi_DecrRefCount(interp, interp->Stack[i]);
        if (interp->Obj_this[i]) Jsi_DecrRefCount(interp, interp->Obj_this[i]);
    }
    Jsi_Free(interp->Stack);
    Jsi_Free(interp->Obj_this);

    Jsi_HashDelete(interp->assocTbl);
    Jsi_HashDelete(interp->codeTbl);
    Jsi_HashDelete(interp->cmdSpecTbl);
    Jsi_HashDelete(interp->fileTbl);
    Jsi_HashDelete(interp->funcObjTbl);
    Jsi_HashDelete(interp->funcsTbl);
    if (interp == jsiMainInterp)
        Jsi_HashDelete(interp->lexkeyTbl);
    Jsi_HashDelete(interp->protoTbl);
    Jsi_HashDelete(interp->regexpTbl);
    if (interp->subthread)
        jsiMainInterp->threadCnt--;
    if (interp->subthread && interp->strKeyTbl == jsiMainInterp->strKeyTbl)
        jsiMainInterp->threadShrCnt--;
    if (!jsiMainInterp->threadShrCnt)
        jsiMainInterp->strKeyTbl->lockProc = NULL;
    //Jsi_ValueMakeUndef(interp, &interp->ret);
    Jsi_HashDelete(interp->thisTbl);
    Jsi_HashDelete(interp->userdataTbl);
    Jsi_HashDelete(interp->eventTbl);
    Jsi_HashDelete(interp->varTbl);
    Jsi_HashDelete(interp->genValueTbl);
    Jsi_HashDelete(interp->genObjTbl);
    Jsi_HashDelete(interp->genDataTbl);
    Jsi_HashDelete(interp->loadTbl);
    Jsi_HashDelete(interp->optionDataHash);
    if (interp->preserveTbl->numEntries!=0)
        Jsi_LogBug("Preserves unbalanced");
    Jsi_HashDelete(interp->preserveTbl);
    if (interp->argv0)
        Jsi_DecrRefCount(interp, interp->argv0);
    if (interp->console)
        Jsi_DecrRefCount(interp, interp->console);
    if (interp->lastSubscriptFail)
        Jsi_DecrRefCount(interp, interp->lastSubscriptFail);
    if (interp->curDir)
        Jsi_Free(interp->curDir);
    if (interp == jsiMainInterp) {
        jsi_FilesysDone(interp);
    }
    if (interp->Mutex)
        Jsi_MutexDelete(interp, interp->Mutex);
    if (interp->QMutex) {
        Jsi_MutexDelete(interp, interp->QMutex);
        Jsi_DSFree(&interp->interpEvalQ);
        Jsi_DSFree(&interp->interpMsgQ);
    }
    if (interp->nullFuncArg)
        Jsi_DecrRefCount(interp, interp->nullFuncArg);
    if (interp->NullValue)
        Jsi_DecrRefCount(interp, interp->NullValue);
    if (interp->Function_prototype_prototype) {
        if (interp->Function_prototype_prototype->refCnt>1)
            Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);
        Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);
    }
    if (interp->Object_prototype) {
        Jsi_DecrRefCount(interp, interp->Object_prototype);
    }
    if (interp->retPtr)
        Jsi_DecrRefCount(interp, interp->retPtr);
    if (interp->args) {
        //Jsi_DecrRefCount(interp, interp->args);
    }
    Jsi_OptionsFree(interp, InterpOptions, interp, 0);

    for (i=0; interp->cleanObjs[i]; i++) {
        //Jsi_Free(interp->cleanObjs[i]->tree);
        //interp->cleanObjs[i]->tree = NULL;
        interp->cleanObjs[i]->tree->freeProc = 0;
        Jsi_ObjFree(interp, interp->cleanObjs[i]);
    }
    Jsi_HashDelete(interp->bindTbl);
    for (i = 0; i <= interp->cur_scope; i++)
        jsi_ScopeStrsFree(interp, interp->scopes[i]);

#ifdef JSI_MEM_DEBUG
    jsi_DebugDumpValues(interp);
#endif
    if (interp == jsiMainInterp || interp->strKeyTbl != jsiMainInterp->strKeyTbl)
        Jsi_HashDelete(interp->strKeyTbl);
    if (interp == jsiMainInterp)
        jsiMainInterp = NULL;
    SIGASSERT(interp,INTERP);
    MEMCLEAR(interp);
    jsiDelInterp = NULL;
    Jsi_Free(interp);
    return JSI_OK;
}

void Jsi_InterpDelete(Jsi_Interp* interp)
{
    if (interp->deleting || interp->level > 0)
        return;
    Jsi_HashDelete(interp->onDeleteTbl);
    interp->deleting = 1;
    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);
}

typedef struct {
    void *data;
    Jsi_Interp *interp;
    int refCnt;
    Jsi_DeleteProc* proc;
} PreserveData;

void Jsi_Preserve(Jsi_Interp* interp, void *data) {
    int isNew;
    PreserveData *ptr;
    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->preserveTbl, data, &isNew);
    assert(hPtr);
    if (!isNew) {
        ptr = (PreserveData*)Jsi_HashValueGet(hPtr);
        assert(interp == ptr->interp);
        ptr->refCnt++;
    } else {
        ptr = (PreserveData*)Jsi_Calloc(1,sizeof(*ptr));
        Jsi_HashValueSet(hPtr, ptr);
        ptr->interp = interp;
        ptr->data = data;
        ptr->refCnt = 1;
    }
}

void Jsi_Release(Jsi_Interp* interp, void *data) {
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);
    if (!hPtr) return;
    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);
    assert(ptr->interp == interp);
    if (--ptr->refCnt > 0) return;
    if (ptr->proc)
        (*ptr->proc)(interp, data);
    Jsi_Free(ptr);
    Jsi_HashEntryDelete(hPtr);
}

void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc) {
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);
    if (!hPtr) {
        (*proc)(interp, data);
        return;
    }
    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);
    assert(ptr && ptr->interp == interp);
    Jsi_HashEntryDelete(hPtr);
}

void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr)
{
    Jsi_HashSet(interp->onDeleteTbl, ptr?ptr:(void*)freeProc, (void*)freeProc);
}

static void interpObjErase(InterpObj *fo)
{
    SIGASSERT(fo,INTERPOBJ);
    if (fo->subinterp) {
        Jsi_Interp *interp = fo->subinterp;        
        fo->subinterp = NULL;
        Jsi_HashDelete(fo->aliases);
        Jsi_InterpDelete(interp);
        /*fclose(fo->fp);
        Jsi_Free(fo->interpname);
        Jsi_Free(fo->mode);*/
    }
    fo->subinterp = NULL;
}

static int interpObjFree(Jsi_Interp *interp, void *data)
{
    InterpObj *fo = (InterpObj *)data;
    SIGASSERT(fo,INTERPOBJ);
    if (fo->deleting) return JSI_OK;
    fo->deleting = 1;
    interpObjErase(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static int interpObjIsTrue(void *data)
{
    InterpObj *fo = (InterpObj *)data;
    SIGASSERT(fo,INTERPOBJ);
    if (!fo->subinterp) return 0;
    else return 1;
}

static int interpObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}


#define FN_eval JSI_INFO("\
Unless an 'async' parameter of true is given, we wait until the sub-interp is idle, \
make the call, and return the result.  Otherwise the call is acyncronous (threaded only)")

/* TODO: support async func-callback.  Same for call/send. */
static int InterpEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int async = 0, rc = JSI_OK, isthrd;
    Jsi_ValueMakeUndef(interp, ret);
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!udf) {
        Jsi_LogError("Apply Interp.eval in a non-interp object");
        return JSI_ERROR;
    }
    Jsi_Interp *sinterp = udf->subinterp;
    if (Jsi_InterpGone(interp)) {
        Jsi_LogError("Sub-interp gone");
        return JSI_ERROR;
    }
    isthrd = (interp->threadId != sinterp->threadId);
    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);
    if (nw && Jsi_GetBoolFromValue(interp, nw, &async))
        return JSI_ERROR;
    char *cp = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (cp==NULL || *cp == 0)
        return JSI_OK;
    if (async && isthrd) {
        /* Post to thread event in sub-interps queue. TODO: could just use event like below... */
        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
            return JSI_ERROR;
        Jsi_DSAppend(&sinterp->interpEvalQ, Jsi_Strlen(Jsi_DSValue(&sinterp->interpEvalQ))?";":"", cp, NULL);
        Jsi_MutexUnlock(interp, sinterp->QMutex);
        return JSI_OK;
    }
    if (interp->doUnlock) Jsi_MutexUnlock(interp, interp->Mutex);
    if (!isthrd) {
        sinterp->level++;
        if (interp->tryDepth)
            sinterp->tryDepth++;
        rc = Jsi_EvalString(sinterp, cp, 0);
        if (interp->tryDepth) {
            sinterp->tryDepth--;
            if (rc != JSI_OK) {
                strcpy(interp->errMsgBuf, sinterp->errMsgBuf);
                interp->errLine = sinterp->errLine;
                interp->errFile = sinterp->errFile;
            }
        }
        sinterp->level--;
    } else {
        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
            return JSI_ERROR;
        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));
        SIGINIT(s,INTERPSTREVENT);
        s->isExec = 1;
        s->tryDepth = interp->tryDepth;
        Jsi_DSInit(&s->data);
        Jsi_DSAppend(&s->data, cp, NULL);
        Jsi_DSInit(&s->func);
        //s->mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);
        //Jsi_MutexLock(s->mutex);
        se = sinterp->interpStrEvents;
        if (!se)
            sinterp->interpStrEvents = s;
        else {
            while (se->next)
                se = se->next;
            se->next = s;
        }
    
        Jsi_MutexUnlock(interp, sinterp->QMutex);
        while (s->isExec)      /* Wait until done. TODO: timeout??? */
            Jsi_Sleep(interp, 1);
        rc = s->rc;
        if (rc != JSI_OK)
            Jsi_LogError("eval failed: %s", Jsi_DSValue(&s->data));
        Jsi_DSFree(&s->func);
        Jsi_DSFree(&s->data);
        Jsi_Free(s);
    }

    if (interp->doUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        return JSI_ERROR;
    }

    if (Jsi_InterpGone(sinterp))
    {
        /* TODO: should exit() be able to delete??? */
        //Jsi_InterpDelete(sinterp);
        return JSI_OK;
    }
    if (rc != JSI_OK && !async)
        return rc;
    if (sinterp->retPtr->vt != JSI_VT_UNDEF) {
        Jsi_CleanValue(sinterp, interp, sinterp->retPtr, ret);
    }
    return JSI_OK;
}

static int InterpInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Interp *subinterp = interp;
    if (udf) {
        if (!udf->subinterp) {
            Jsi_LogError("Sub-interp gone");
            return JSI_ERROR;
        }
        subinterp = udf->subinterp;
    }
    return jsi_InterpInfo(subinterp, args, _this, ret, funcPtr);
}

int jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Interp *sinterp = interp;
    Jsi_DString dStr = {}, cStr = {};
    char tbuf[1024];
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    tbuf[0] = 0;
    if (v) {
        InterpObj *udf = NULL;
        if (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_USEROBJ)
            udf = (InterpObj *)v->d.obj->d.uobj->data;
        if (udf && udf->subinterp) {
            SIGASSERT(udf, INTERPOBJ);
            sinterp = udf->subinterp;
        } else {
            Jsi_LogError("unknown interp");
            return JSI_ERROR;
        }
    }
    if (sinterp->subthread)
        sprintf(tbuf, ", thread:{errorCnt:%u, evalCnt:%u, msgCnt:%u }",
            sinterp->threadErrCnt, sinterp->threadEvalCnt, sinterp->threadMsgCnt );
    Jsi_DSPrintf(&dStr, "{curLevel:%d, hasExited:%d, opCnt:%d, isSafe:%s, codeCacheHits: %d, "
        "funcCallCnt:%d, cmdCallCnt:%d, cwd:\"%s\", lockTimeout: %d, name, \"%s\", parent: %p %s%s};",
        sinterp->level, sinterp->exited, sinterp->opCnt, sinterp->isSafe?"true":"false", sinterp->codeCacheHit,
        sinterp->funcCallCnt, sinterp->cmdCallCnt,
        (sinterp->curDir?sinterp->curDir:Jsi_GetCwd(sinterp,&cStr)),
        sinterp->lockTimeout, sinterp->name?sinterp->name:"", sinterp->parent, tbuf[0]?",":"", tbuf);
    int rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&cStr);
    return rc;
}

static int SubInterpEvalCallback(Jsi_Interp *interp, void* data)
{
    int rc = JSI_OK;
    Jsi_DString dStr = {};
    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
        return JSI_ERROR;
    char *cp = Jsi_DSValue(&interp->interpEvalQ);
    if (*cp) {
        Jsi_DSAppend(&dStr, cp, NULL);
        Jsi_DSSetLength(&interp->interpEvalQ, 0);
        interp->threadEvalCnt++;
        Jsi_MutexUnlock(interp, interp->QMutex);
        if (Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0) != JSI_OK)
            rc = JSI_ERROR;
        Jsi_DSSetLength(&dStr, 0);
        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
            return JSI_ERROR;
    }
    cp = Jsi_DSValue(&interp->interpMsgQ);
    if (*cp) {
        //if (!interp->parent) printf("RECIEVING: %s\n", cp);
        Jsi_DSAppend(&dStr, cp, NULL);
        Jsi_DSSetLength(&interp->interpEvalQ, 0);
        interp->threadMsgCnt++;
        Jsi_MutexUnlock(interp, interp->QMutex);
        if (Jsi_CommandInvokeJSON(interp, interp->recvCmd, Jsi_DSValue(&dStr), NULL) != JSI_OK)
            rc = JSI_ERROR;
        Jsi_DSSetLength(&interp->interpMsgQ, 0);
    } else
        Jsi_MutexUnlock(interp, interp->QMutex);
    Jsi_DSFree(&dStr);
    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
        return JSI_ERROR;
        
    /* Process subevents. */
    InterpStrEvent *oldse, *se = interp->interpStrEvents;
    Jsi_MutexUnlock(interp, interp->QMutex);
    while (se) {
        oldse = se;
        int isExec = se->isExec;
        if (isExec) {
            if (se->tryDepth)
                interp->tryDepth++;
            se->rc = Jsi_EvalString(interp, Jsi_DSValue(&se->data), 0);
            Jsi_DSSetLength(&se->data, 0);
            if (se->rc != JSI_OK && se->tryDepth) {
                Jsi_DSAppend(&se->data, interp->errMsgBuf, NULL);
                se->errLine = interp->errLine;
                se->errFile = interp->errFile;
            } else {
                Jsi_ValueGetDString(interp, interp->retPtr, &se->data, JSI_OUTPUT_JSON);
            }
            if (se->tryDepth)
                interp->tryDepth--;
                
        /* Otherwise, async calls. */
        } else if (se->objData) {
            if (JSI_OK != Jsi_CommandInvoke(interp, Jsi_DSValue(&se->func), se->objData, NULL))
                rc = JSI_ERROR;
        } else {
            if (JSI_OK != Jsi_CommandInvokeJSON(interp, Jsi_DSValue(&se->func), Jsi_DSValue(&se->data), NULL))
                rc = JSI_ERROR;
        }
        if (!isExec) {
            Jsi_DSFree(&se->func);
            Jsi_DSFree(&se->data);
        }
        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)
            return JSI_ERROR;
        interp->interpStrEvents = se->next;
        if (!isExec) Jsi_Free(se);
        se = interp->interpStrEvents;
        Jsi_MutexUnlock(interp, interp->QMutex);
        if (isExec)
            oldse->isExec = 0;
    }

    return rc;
}


static int ThreadEvalCallback(Jsi_Interp *interp, void* data) {
    int rc;

    if ((rc=SubInterpEvalCallback(interp, data)) != JSI_OK)
        interp->threadErrCnt++;
    return rc;
}

/* Create an event handler in interp to handle call/eval/send asyncronously via 'Sys.update()'. */
void jsi_AddEventHandler(Jsi_Interp *interp)
{
    Jsi_Event *ev;
    while (!interp->hasEventHdl) { /* Find an empty event slot. */
        int isNew, id;
        id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));
        SIGINIT(ev,EVENT);
        ev->id = id;
        ev->handler = ThreadEvalCallback;
        ev->hPtr = hPtr;
        ev->evType = JSI_EVENT_ALWAYS;
        Jsi_HashValueSet(hPtr, ev);
        interp->hasEventHdl = 1;
    }
}

#define FN_call JSI_INFO("\
Invoke function in sub-interp with arguments.  Since interps are not allowed to share objects, \
data is automatically cleansed by encoding/decoding \
to/from JSON if required.  Unless an 'async' parameter of true is given, we wait until the sub-interp is idle, \
make the call, and return the result.  Otherwise the call is acyncronous.")

static int InterpCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    int isthrd;
    Jsi_Interp *sinterp;
    if (udf)
        sinterp = udf->subinterp;
    else {
        Jsi_LogError("Apply Interp.call in a non-subinterp");
        return JSI_ERROR;
    }
    if (Jsi_InterpGone(sinterp)) {
        Jsi_LogError("Sub-interp gone");
        return JSI_ERROR;
    }
    isthrd = (interp->threadId != sinterp->threadId);
    
    Jsi_Value *func = NULL;
    char *fname = NULL; 
    func = Jsi_ValueArrayIndex(interp, args, 0);   
    fname = Jsi_ValueString(interp, func, NULL);
    if (!fname) {
        Jsi_LogError("function name must be a string");
        return JSI_ERROR;
    }
    if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)
        return JSI_ERROR;
    Jsi_Value *namLU = Jsi_NameLookup(sinterp, fname);
    Jsi_MutexUnlock(interp, sinterp->Mutex);
    if (namLU == NULL) {
        Jsi_LogError("unknown function: %s", fname);
        return JSI_ERROR;
    }
    
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    char *cp = Jsi_ValueString(interp, arg, NULL);

    if (cp == NULL && !Jsi_ValueIsArray(interp, arg)) {
        Jsi_LogError("expected string or array");
        return JSI_ERROR;
    }

    Jsi_Value *vasync = Jsi_ValueArrayIndex(interp, args, 2);
    int rc = JSI_OK, async = 0;
    if (vasync && Jsi_GetBoolFromValue(interp, vasync, &async))
        return JSI_ERROR;
    
    if (!async) {
        Jsi_DString dStr = {};
        if (cp == NULL)
            cp = (char*)Jsi_ValueGetDString(interp, arg, &dStr, JSI_OUTPUT_JSON);
        if (interp->doUnlock) Jsi_MutexUnlock(interp, interp->Mutex);
        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK) {
            if (interp->doUnlock) Jsi_MutexLock(interp, interp->Mutex);
            return JSI_ERROR;
        }
        Jsi_Value *srPtr = Jsi_ValueNew1(interp);
        /* TODO: call from this interp may not be safe if threaded. 
         * Could instead use async code below then wait for unlock on se->mutex. */
        rc = Jsi_CommandInvokeJSON(sinterp, fname, cp, &srPtr);
        Jsi_DSSetLength(&dStr, 0);
        ConvertReturn(interp, sinterp, &srPtr);
        Jsi_ValueCopy(interp, *ret, srPtr);
        Jsi_DecrRefCount(interp, srPtr);
        Jsi_DSFree(&dStr);
        Jsi_MutexUnlock(interp, sinterp->Mutex);
        if (interp->doUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
            Jsi_LogBug("mutex re-get failed");
            return JSI_ERROR;
        }
        return rc;
    }
    
    /* Post to thread event in sub-interps queue. */
    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
        return JSI_ERROR;
        
    /* Is an async call. */
    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));
    // TODO: is s->data inited?
    if (!cp) {
        Jsi_ValueGetDString(interp, arg, &s->data, JSI_OUTPUT_JSON);
    }
    Jsi_DSInit(&s->data);
    Jsi_DSAppend(&s->data, cp, NULL);
    Jsi_DSInit(&s->func);
    Jsi_DSAppend(&s->func, fname, NULL);
    se = sinterp->interpStrEvents;
    if (!se)
        sinterp->interpStrEvents = s;
    else {
        while (se->next)
            se = se->next;
        se->next = s;
    }

    Jsi_MutexUnlock(interp, sinterp->QMutex);
    if (!isthrd) {
        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)
            sinterp->threadErrCnt++;
    }
    return JSI_OK;
}

int Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)
{
#ifdef JSI_OMIT_ZVFS
    return JSI_ERROR;
#else
    return Zvfs_Mount(interp, archive, mount, ret);
#endif
}

int Jsi_AddIndexFiles(Jsi_Interp *interp, const char *dir) {
    /* Look for jsiIndex.js to setup. */
    Jsi_DString dStr = {};
    Jsi_StatBuf stat;
    int i, cnt = 0;
    for (i=0; i<2; i++) {
        Jsi_DSAppend(&dStr, dir, (i==0?"/lib":""),"/jsiIndex.jsi", NULL);
        Jsi_Value *v = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));
        if (Jsi_Stat(interp, v, &stat) != 0)
            Jsi_ValueFree(interp, v);
        else {
            if (!interp->indexFiles) {
                interp->indexFiles = Jsi_ValueNewArray(interp, 0, 0);
                Jsi_IncrRefCount(interp, interp->indexFiles);
            }
            Jsi_ObjArrayAdd(interp, interp->indexFiles->d.obj, v);
            cnt++;
            interp->indexLoaded = 0;
        }
        Jsi_DSSetLength(&dStr, 0);
    }
    Jsi_DSFree(&dStr);
    return cnt;
}

int Jsi_ExecZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound)
{
#ifndef JSI_OMIT_ZVFS
    Jsi_StatBuf stat;
    Jsi_Value *vinit, *vmnt = NULL;
    Jsi_Value *vexe = Jsi_ValueNewStringKey(interp, exeFile);
    Jsi_Value *ret = NULL;
    int rc;
    const char *omntDir = mntDir;
    Jsi_IncrRefCount(interp, vexe);
    Jsi_HashSet(interp->genValueTbl, vexe, vexe);
    if (jsFound)
        *jsFound = 0;
    if (!mntDir)
        ret = Jsi_ValueNew(interp);
    else {
        vmnt = Jsi_ValueNewStringKey(interp, mntDir);
        Jsi_IncrRefCount(interp, vmnt);
        Jsi_HashSet(interp->genValueTbl, vmnt, vmnt);
    }
    rc =Jsi_Mount(interp, vexe, vmnt, &ret);
    if (rc != JSI_OK)
        return -1;
    Jsi_DString dStr = {};
    if (!mntDir)
        mntDir = Jsi_ValueString(interp, ret, NULL);
    Jsi_DSAppend(&dStr, mntDir, "/main.jsi", NULL);
    vinit = Jsi_ValueNewStringKey(interp,  Jsi_DSValue(&dStr));
    Jsi_IncrRefCount(interp, vinit);
    Jsi_HashSet(interp->genValueTbl, vinit, vinit);
    Jsi_DSFree(&dStr);
    if (Jsi_Stat(interp, vinit, &stat) == 0) {
        if (jsFound)
            *jsFound |= JSI_ZIP_MAIN;
        interp->execZip = vexe;
        return Jsi_EvalFile(interp, vinit, JSI_EVAL_ARGV0|JSI_EVAL_INDEX);
    } else {
        if (Jsi_AddIndexFiles(interp, mntDir) && omntDir)
            *jsFound = JSI_ZIP_INDEX;
    }
#endif
    return JSI_OK;
}

#define FN_send JSI_INFO("\
Add messages to queue to be processed by the 'recvCmd' interp option.")

static int InterpSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    //return SendCmd(interp, args, _this, ret, funcPtr, 1);
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Interp *sinterp = NULL;
    int isthrd;
    if (udf) {
        sinterp = udf->subinterp;
    } else {
        sinterp = interp->parent;
        if (!sinterp) {
            Jsi_LogError("Apply Interp.send in a non-subinterp");
            return JSI_ERROR;
        }
    }

    if (Jsi_InterpGone(sinterp)) {
        Jsi_LogError("Sub-interp gone");
        return JSI_ERROR;
    }
    isthrd = (interp->threadId != sinterp->threadId);
    if (!sinterp->recvCmd) {
        Jsi_LogError("interp was not created with 'recvCmd' option");
        return JSI_ERROR;
    }

    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    char *cp = Jsi_ValueString(interp, arg, NULL);

    /* Post to thread event in sub-interps queue. */
    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)
        return JSI_ERROR;
        
    int slen = Jsi_Strlen(Jsi_DSValue(&sinterp->interpMsgQ));
    Jsi_DString eStr = {};
    if (!cp) {
        cp = (char*)Jsi_ValueGetDString(interp, arg, &eStr, JSI_OUTPUT_JSON);
    }
    if (!slen)
        Jsi_DSAppend(&sinterp->interpMsgQ, "[", cp, "]", NULL);
    else {
        Jsi_DSSetLength(&sinterp->interpMsgQ, slen-1);
        Jsi_DSAppend(&sinterp->interpMsgQ, ", ", cp, "]", NULL);
    }
    // if (interp->parent) printf("SENDING: %s\n", Jsi_DSValue(&sinterp->interpMsgQ));
    Jsi_DSFree(&eStr);

    Jsi_MutexUnlock(interp, sinterp->QMutex);
    if (!isthrd) {
        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)
            sinterp->threadErrCnt++;
    }
    return JSI_OK;

}

#ifndef JSI_OMIT_THREADS

#ifdef __WIN32
#define JSITHREADRET void
#else
#define JSITHREADRET void*
#endif

static JSITHREADRET NewInterpThread(void* iPtr)
{
    int rc = JSI_OK;
    InterpObj *udf = (InterpObj *)iPtr;
    Jsi_Interp *interp = udf->subinterp;
    interp->threadId = Jsi_CurrentThread();
   if (interp->scriptStr)
        rc = Jsi_EvalString(interp, interp->scriptStr, 0);
    else if (interp->scriptStr)
        rc = Jsi_EvalFile(interp, interp->scriptFile, 0);
    else {
        jsi_AddEventHandler(interp); 
        int mrc = Jsi_MutexLock(interp, interp->Mutex);      
        while (mrc == JSI_OK) {
            if (Jsi_EventProcess(interp, -1)<0)
                break;
            Jsi_Sleep(interp, 1);
        }
    }
    if (rc != JSI_OK) {
        Jsi_LogError("eval failure");
        interp->threadErrCnt++;
    }
    interpObjErase(udf);
#ifndef __WIN32
    /* TODO: should we wait/notify parent??? */
    pthread_detach(pthread_self());
    return NULL;
#endif
}
#endif


#define FN_interp JSI_INFO("\
The new interp may optionally be threaded.")
static int InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
static int InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    
static Jsi_CmdSpec interpCmds[] = {
    { "Interp", InterpConstructor,0,  1,  "options:object=void", JSI_CMD_IS_CONSTRUCTOR, .help="Create a new interp", .info=FN_interp, .opts=InterpOptions, .retType=(uint)JSI_TT_USEROBJ },
    { "alias",  InterpAliasCmd,   0,  3, "name:string=void, func:function|null=void, args:array|function|null=void",.help="Set/get alias command in the interp", .retType=(uint)JSI_TT_ANY },
    { "conf",   InterpConfCmd,    0,  1, "val:string|object=void",.help="Configure options" , .opts=InterpOptions, .retType=(uint)JSI_TT_ANY },
    { "send",   InterpSendCmd,    1,  1, "msg", .help="Send message to enqueue on subinterps recvCmd handler", .info=FN_send, .retType=(uint)JSI_TT_ANY },
    { "eval",   InterpEvalCmd,    1,  2, "js:string, async:boolean=false", .help="Interpet javascript code within subinterp", .info=FN_eval, .retType=(uint)JSI_TT_ANY },
    { "info",   InterpInfoCmd,    0,  0,  "", .help="Return detailed info about interp", .retType=(uint)JSI_TT_OBJECT },
    { "call",   InterpCallCmd,    2,  3, "funcName:string, args:string|array, async:boolean=false", .help="Call named function in subinterp", .info=FN_call, .retType=(uint)JSI_TT_ANY },
    { NULL,     NULL, .help="Commands for accessing interps" }
};
/*
    { "alias",      InterpAliasCmd,     NULL,   3,  3, "interp,funcName,function",  },
    { "aliases",    InterpAliasesCmd,   NULL,   1,  2, "interp?,funcName?",  },
    { "children",   InterpChildrenCmd,  NULL,   0,  0, "",  },
    { "create",     InterpCreateCmd,    NULL,   0,  1, "?isSafe?",  },
    { "delete",     InterpDeleteCmd,    NULL,   1,  1, "interp",  },
    { "exists",     InterpExistsCmd,    NULL,   1,  1, "interp",  },
    { "eval",       InterpEvalCmd,      NULL,   2,  2, "interp,string",  },
    { "limit",      InterpLimitCmd,     NULL,   1,  2, "interp?,options?",  },
*/

static Jsi_UserObjReg interpobject = {
    "Interp",
    interpCmds,
    interpObjFree,
    interpObjIsTrue,
    interpObjEqual
};


static int InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *fobj;
    Jsi_Value *toacc;
    InterpObj *cmdPtr = (InterpObj *)Jsi_Calloc(1,sizeof(*cmdPtr));
    SIGINIT(cmdPtr,INTERPOBJ);
    cmdPtr->parent = interp;

    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);

    if (!(cmdPtr->subinterp = Jsi_InterpNew(interp, 0,0, arg))) {
        Jsi_Free(cmdPtr);
        return JSI_ERROR;
    }
    Jsi_Interp *sinterp = cmdPtr->subinterp;
    if (sinterp->scriptStr != 0 && sinterp->scriptFile != 0) {
        Jsi_LogError("can not use both scriptStr and scriptFile options");
        goto bail;
    }

    toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Interp", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    fobj = Jsi_ValueGetObj(interp, toacc);
    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &interpobject, fobj, cmdPtr))<0)
        goto bail;
    cmdPtr->fobj = fobj;
    cmdPtr->aliases = Jsi_HashNew(interp, JSI_KEYS_STRING, AliasFree);
#ifndef JSI_OMIT_THREADS
    if (sinterp->subthread) {
       /* if (sinterp->scriptStr == 0 && sinterp->scriptFile == 0) {
            Jsi_LogError("must give scriptStr or scriptFile option with thread");
            goto bail;
        }*/
#ifdef __WIN32
        if (!_beginthread( NewInterpThread, 0, cmdPtr )) {
            Jsi_LogError("thread create failed");
            goto bail;
        }
#else
        pthread_t nthread;
        if (pthread_create(&nthread, NULL, NewInterpThread, cmdPtr) != 0) {
            Jsi_LogError("thread create failed");
            goto bail;
        }
#endif
#else
    if (0) {
#endif
    } else {
        int rc = JSI_OK;
        if (sinterp->scriptStr != 0) {
            rc = Jsi_EvalString(sinterp, sinterp->scriptStr, 0);
        } else if (sinterp->scriptFile != 0) {
            rc = Jsi_EvalFile(sinterp, sinterp->scriptFile, 0);        
        }
        if (rc != JSI_OK)
            goto bail;
    }
    return JSI_OK;
    
bail:
    interpObjErase(cmdPtr);
    Jsi_ValueMakeUndef(interp, ret);
    return JSI_ERROR;
}

int Jsi_DoneInterp(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &interpobject);
    return JSI_OK;
}

static int InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
  
    return Jsi_OptionsConf(interp, InterpOptions, Jsi_ValueArrayIndex(interp, args, 0), udf?udf->subinterp:interp, ret, 0);

}

Jsi_Value *Jsi_ReturnValue(Jsi_Interp *interp) {
    return interp->retPtr;
}

int jsi_InterpInit(Jsi_Interp *interp)
{
    Jsi_Hash *isys;
    if (!(isys = Jsi_UserObjRegister(interp, &interpobject)))
        Jsi_LogFatal("Can not init interp\n");

    Jsi_CommandCreateSpecs(interp, interpobject.name, interpCmds, isys, 0);
    return JSI_OK;
}

int Jsi_InterpSafe(Jsi_Interp *interp)
{
    return interp->isSafe;
}

int Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* file, int toWrite)
{
    Jsi_Value *v, *dirs = (toWrite ? interp->safeWriteDirs : interp->safeReadDirs);
    if (!interp->isSafe)
        return JSI_OK;
    if (!dirs)
        return JSI_ERROR;
    int i, n, m, argc = Jsi_ValueGetLength(interp, dirs);
    char *str, *dstr = Jsi_ValueString(interp, file, &n); /* TODO: normalize? */
    if (!dstr)
        return JSI_ERROR;
    char *scp = strrchr(dstr, '/');
    if (scp)
        n -= strlen(scp);
    for (i=0; i<argc; i++) {
        v = Jsi_ValueArrayIndex(interp, dirs, i);
        str = Jsi_ValueString(interp, v, &m);
        if (v && str && strncmp(str, dstr, m) == 0 && (n==m || dstr[m] == '/'))
            return JSI_OK;
    }
    return JSI_ERROR;
}

#endif
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <errno.h>
#include <sys/time.h>

#ifdef HAVE_READLINE
# include <readline/readline.h>
# include <readline/history.h>
#endif

void* Jsi_Realloc(void *m,unsigned int size) {
    void *v = realloc(m,size);
    return v;
}
void* Jsi_Malloc(unsigned int size) {
    void *v = malloc(size);
    return v;
}
void* Jsi_Calloc(unsigned int n,unsigned int size) {
    void *v = calloc(n,size);
    return v;
}
void  Jsi_Free(void *n) { free(n); }

/* Get time in milliseconds since Jan 1, 1970 */
Jsi_Number Jsi_DateTime(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    Jsi_Number num = ((Jsi_Number)tv.tv_sec*1000.0 + (Jsi_Number)tv.tv_usec/1000.0);
    return num;
}


#ifndef JSI_LITE_ONLY

int jsi_fatalexit = JSI_LOG_FATAL;

static void (*logHook)(const char *buf, va_list va) = NULL;

void Jsi_LogMsg(Jsi_Interp *interp, int code, const char *format,...) {
    va_list va;
    va_start (va, format);
    char pbuf[BUFSIZ/8] = "";
    char buf[BUFSIZ/2];
    const char *mt = "", *term = "", *pterm=pbuf;
    static char lastMsg[BUFSIZ/2] = "";
    static int lastCnt = 0;
    if (interp==NULL)
        interp = jsiMainInterp;

    const char *curFile = NULL;
    if (interp)
        curFile = (interp->curIp && interp->curIp->fname? interp->curIp->fname:interp->curFile);
    if (!curFile) curFile = "";
    /* Filter out try/catch (TODO: and non-syntax errors??). */
    if (code == JSI_LOG_PARSE || interp == NULL) {
        if (logHook)
            (*logHook)(format, va);
        else
            vfprintf(stderr, format, va);
        va_end(va);
        return;
    }
    if (code == JSI_LOG_ERROR && (interp->tryDepth-interp->withDepth)>0 && interp->inParse<=0 
        /*&& !interp->errMsgBuf[0]*/) { /* TODO: should only do the first or traceback? */
        vsnprintf(interp->errMsgBuf, sizeof(interp->errMsgBuf), format, va);
        interp->errFile = curFile;
        interp->errLine = interp->curIp->line;
        va_end(va);
        return;
    }
    switch (code) {
        case JSI_LOG_FATAL: mt = "fatal"; break;
        case JSI_LOG_ERROR: mt = "error"; break;
        case JSI_LOG_PARSE: mt = "parse"; break;
        case JSI_LOG_WARN:  mt = "warning"; break;
        case JSI_LOG_INFO: mt = "info"; break;
        case JSI_LOG_BUG: mt = "bug"; break;
        case JSI_LOG_TODO: mt = "todo"; break;
    } 
    if (!strchr(format,'\n')) term = "\n";
    if (interp && interp->lastPushStr && interp->lastPushStr[0]) {
        char *ss = interp->lastPushStr;
        char psbuf[BUFSIZ/6];
        if (strchr(ss,'%')) {
            char *s = ss, *sd = psbuf;
            int plen=0, llen = sizeof(psbuf)-2;
            while (*s && plen<llen) {
                if (*s == '%')
                    sd[plen++] = '%';
                sd[plen++] = *s;
                s++;
            }
            sd[plen] = 0;
            ss = psbuf;
        }
        while (*ss && isspace(*ss))
            ss++;
        if (*ss)
            snprintf(pbuf, sizeof(pbuf), "    (at or near \"%s\")\n", ss);
    }
    pbuf[sizeof(pbuf)-1] = 0;
    int line = 0;
    if (interp->parseLine)
        line = interp->parseLine->first_line;
    else if (interp->curIp)
        line = interp->curIp->line;
    if (interp && line>0 && curFile && strchr(curFile,'%')==0)
        snprintf(buf, sizeof(buf), "%s:%d: %s: %s%s%s",  curFile, line, mt,format, pterm, term);
    else
        snprintf(buf, sizeof(buf), "%s: %s%s%s", mt, format, pterm, term);
    buf[sizeof(buf)-1]=0;

    if (logHook)
        (*logHook)(buf, va);
    else if (interp->logAllowDups)
        vfprintf(stderr, buf, va);
    else {
        char buf1[BUFSIZ/2];
        vsnprintf(buf1, sizeof(buf1), buf, va);
        if (buf1[0] && lastCnt && strcmp(buf1, lastMsg)==0) {
            lastCnt++;
            goto done;
        } else if (lastMsg[0] && lastCnt>1 ) {
            fprintf(stderr, "REPEAT: Last msg repeated %d times...\"\n" ,lastCnt);
        }
        if (buf1[0] == 0 || (buf1[0] == '.' && buf1[1] == 0))
            goto done;
        lastCnt = 1;
        strcpy(lastMsg, buf1);
        fputs(buf1, stderr);
    }
done:
    va_end(va);
    if (code & jsi_fatalexit)
        exit(1);
}

const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str)
{
    Jsi_HashEntry *hPtr;
    int isNew;
    hPtr = Jsi_HashEntryNew(interp->strKeyTbl, str, &isNew);
    assert(hPtr) ;
    return (const char*)Jsi_HashKeyGet(hPtr);
}

const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str)
{
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(interp->strKeyTbl, str);
    if (!hPtr) {
        return NULL;
    }
    return (const char*)Jsi_HashKeyGet(hPtr);
}

extern int Jsi_PkgProvide(Jsi_Interp *interp, const char *name, const char *version)
{
    return JSI_ERROR;
}

extern int Jsi_PkgRequire(Jsi_Interp *interp, const char *name, const char *version)
{
    return JSI_ERROR;
}

Jsi_Value *Jsi_VarLookup(Jsi_Interp *interp, const char *varname)
{
    Jsi_Value *v;
    v = Jsi_ValueObjLookup(interp, interp->incsc, (char*)varname, 0);
    if (!v)
        v = jsi_ScopeChainObjLookupUni(interp->ingsc, (char*)varname);
    return v;
}

static char *FindEndB(char *cp) {
    
    if (*cp == '\"'||*cp == '\'') {
        char endc = *cp;
        cp++;
        while (*cp && *cp != endc) {
            if (*cp == '\\' && cp[1]) cp++;
            cp++;
        }
        if (*cp == endc)
            cp++;
        if (*cp != ']')
            return NULL;
        return cp;
    } else
        return strchr(cp, ']');
}

/* Lookup a name, eg.  "a[b].c  a.b.c  a[b][c]  a.b[c]  a["b"].c  a[1].c  */
Jsi_Value *Jsi_NameLookup(Jsi_Interp *interp, const char *name)
{
    int cnt = 0, len, isq;
    char *nam = (char*)name, *cp, *cp2, *ocp, *kstr;
    DECL_VALINIT(tv);
    DECL_VALINIT(nv);
    DECL_VALINIT(key);
    Jsi_Value *v = NULL, *nvPtr = &nv;
    Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.
    Jsi_DString dStr = {};
    cp2 = strchr(nam,'[');
    cp = strchr(nam, '.');
    if (cp2 && (cp==0 || cp2<cp))
        cp = cp2;
    if (!cp)
        return Jsi_VarLookup(interp, nam);
    Jsi_DSSetLength(&dStr, 0);
    Jsi_DSAppendLen(&dStr, nam, cp-nam);
    v = Jsi_VarLookup(interp, Jsi_DSValue(&dStr));
    if (!v)
        goto bail;
    while (cnt++ < 1000) {
        ocp = cp;
        nam = cp+1;
        isq = 0;
        if (*cp == '[') {
            cp = FindEndB(cp+1); /* handle [] in strings. */
            if (!cp) goto bail;
            len = cp-nam;
            cp++;
            if (len>=2 && ((nam[0] == '\"' && nam[len-1] == '\"') || (nam[0] == '\'' && nam[len-1] == '\''))) {
                nam += 1;
                len -= 2;
                isq = 1;
            }
        } else if (*cp == '.') {
            cp2 = strchr(nam,'[');
            cp = strchr(nam, '.');
            if (cp2 && (cp==0 || cp2<cp))
                cp = cp2;
            len = (cp ? cp-nam : strlen(nam));
        } else {
            goto bail;
        }
        Jsi_DSSetLength(&dStr, 0);
        Jsi_DSAppendLen(&dStr, nam, len);
        kstr = Jsi_DSValue(&dStr);
        if (*ocp == '[' && isq == 0 && isdigit(kstr[0]) && Jsi_ValueIsArray(interp, v)) {
            int nn;
            if (Jsi_GetInt(interp, kstr, &nn, 0) != JSI_OK)
                goto bail;
            v = Jsi_ValueArrayIndex(interp, v, nn);
            if (!v)
                goto bail;
        } else if (*ocp == '[' && isq == 0) {
            Jsi_Value *kv = Jsi_VarLookup(interp, kstr);
            if (!kv)
                goto bail;
            jsi_ValueSubscriptLen(interp, v, kv, &nvPtr, 1);
            goto keyon;
        } else {
            Jsi_ValueMakeStringKey(interp, &kPtr, kstr); 
            jsi_ValueSubscriptLen(interp, v, kPtr, &nvPtr, 1);
keyon:
            if (nv.vt == JSI_VT_UNDEF)
                goto bail;
            else {
                tv = nv;
                v = &tv;
            }
        }
        if (cp == 0 || *cp == 0) break;
    }
    //Jsi_ValueReset(interp, &ret);
    Jsi_DSFree(&dStr);
    if (v && v == &tv) {
        v = Jsi_ValueNew(interp);
        //Jsi_ValueMove(interp, v, &tv);
#ifdef JSI_MEM_DEBUG
        memcpy(v, &tv, sizeof(tv)-sizeof(tv.VD));
        v->VD.label3 = tv.VD.func;
#else
        *v = tv;
#endif
    }
    return v;
bail:
    Jsi_DSFree(&dStr);
    return NULL;
}

Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp)
{
    return interp->csc;
}

typedef struct {
    Jsi_DString *dStr;
    int quote; /* Set to JSI_OUTPUT_JSON, etc*/
    int depth;
} objwalker;

static int IsAlnum(const char *cp)
{
    while (*cp)
        if (isalnum(*cp) || *cp == '_')
            cp++;
        else
            return 0;
    return 1;
}

static void jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr);

static int IsKeyword(Jsi_Interp *interp, char *str) {
    return (Jsi_HashEntryFind(interp->lexkeyTbl, str) != 0);
}

static int _object_get_callback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_Value *v;
    objwalker *ow = (objwalker *)data;
    Jsi_DString *dStr = ow->dStr;
    int len;
    char *str;
    if ((hPtr->f.bits.dontenum))
        return JSI_OK;
    v =(Jsi_Value*) Jsi_TreeValueGet(hPtr);
    if ((ow->quote&JSI_OUTPUT_JSON) && v && v->vt == JSI_VT_UNDEF)
        return JSI_OK;
    str = (char*)Jsi_TreeKeyGet(hPtr);
    char *cp = Jsi_DSValue(dStr);
    len = Jsi_DSLength(dStr);
    if (len>=2 && cp[len-2] != '{')
        Jsi_DSAppend(dStr, ", ", NULL);
    if (((ow->quote&JSI_OUTPUT_JSON) == 0 || (ow->quote&JSI_JSON_STRICT) == 0) && IsAlnum(str) && !IsKeyword(tree->interp, str))
        Jsi_DSAppend(dStr, str, NULL);
    else
        /* JSON/spaces, etc requires quoting the name. */
        Jsi_DSAppend(dStr, "\"", str, "\"", NULL);
    Jsi_DSAppend(dStr, ":", NULL);
    ow->depth++;
    jsiValueGetString(tree->interp, v, dStr, ow);
    ow->depth--;
    return JSI_OK;
}

/* Format value into dStr.  Toplevel caller does init/free. */
static void jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr)
{
    char buf[100], *str;
    if (owPtr->depth > interp->maxDepth) {
        Jsi_LogError("recursive ToString");
        return;
    }
    int quote = owPtr->quote;
    int isjson = owPtr->quote&JSI_OUTPUT_JSON;
    double num;
    switch(v->vt) {
        case JSI_VT_UNDEF:
            Jsi_DSAppend(dStr, "undefined", NULL);
            return;
        case JSI_VT_NULL:
            Jsi_DSAppend(dStr, "null", NULL);
            return;
        case JSI_VT_VARIABLE:
            Jsi_DSAppend(dStr, "variable", NULL);
            return;
        case JSI_VT_BOOL:
            Jsi_DSAppend(dStr, (v->d.val ? "true":"false"), NULL);
            return;
        case JSI_VT_NUMBER:
            num = v->d.num;
outnum:
            if (jsi_is_integer(num)) {
                sprintf(buf, "%d", (int)num);
                Jsi_DSAppend(dStr, buf, NULL);
            } else if (jsi_is_wide(num)) {
                sprintf(buf, "%Ld", (Jsi_Wide)num);
                Jsi_DSAppend(dStr, buf, NULL);
            } else if (jsi_ieee_isnormal(num)) {
                sprintf(buf, "%" JSI_NUMGFMT, num);
                Jsi_DSAppend(dStr, buf, NULL);
            } else if (jsi_ieee_isnan(num)) {
                Jsi_DSAppend(dStr, "NaN", NULL);
            } else {
                int s = jsi_ieee_infinity(num);
                if (s > 0) Jsi_DSAppend(dStr, "+Infinity", NULL);
                else if (s < 0) Jsi_DSAppend(dStr, "-Infinity", NULL);
                else Jsi_LogBug("Ieee function problem");
            }
            return;
        case JSI_VT_STRING:
            str = v->d.s.str;
outstr:
            if (!quote) {
                Jsi_DSAppend(dStr, str, NULL);
                return;
            }
            Jsi_DSAppend(dStr,"\"", NULL);
            while (*str) {
                if ((*str == '\'' && (!(isjson))) || *str == '\"' ||
                    (*str == '\n' && (!(owPtr->quote&JSI_OUTPUT_NEWLINES))) || *str == '\r' || *str == '\t' || *str == '\f' || *str == '\b'  ) {
                    char pcp[2];
                    *pcp = *str;
                    pcp[1] = 0;
                    Jsi_DSAppendLen(dStr,"\\", 1);
                    switch (*str) {
                        case '\r': *pcp = 'r'; break;
                        case '\n': *pcp = 'n'; break;
                        case '\t': *pcp = 't'; break;
                        case '\f': *pcp = 'f'; break;
                        case '\b': *pcp = 'b'; break;
                    }
                    Jsi_DSAppendLen(dStr,pcp, 1);
                } else if (!isprint(*str))
                    /* TODO: encode */
                    if (isjson) {
                        char ubuf[10];
                        sprintf(ubuf, "\\u00%.02x", (unsigned char)*str);
                        Jsi_DSAppend(dStr,ubuf, NULL);
                        //Jsi_DSAppendLen(dStr,".", 1);
                    } else
                        Jsi_DSAppendLen(dStr,str, 1);
                    
                else
                    Jsi_DSAppendLen(dStr,str, 1);
                str++;
            }
            Jsi_DSAppend(dStr,"\"", NULL);
            return;
        case JSI_VT_OBJECT: {
            Jsi_Obj *o = v->d.obj;
            switch(o->ot) {
                case JSI_OT_BOOL:
                    Jsi_DSAppend(dStr, (o->d.val ? "true":"false"), NULL);
                    return;
                case JSI_OT_NUMBER:
                    num = o->d.num;
                    goto outnum;
                    return;
                case JSI_OT_STRING:
                    str = o->d.s.str;
                    goto outstr;
                    return;
                case JSI_OT_FUNCTION: {
                    Jsi_FuncObjToString(interp, o, dStr);
                    return;
                }
                case JSI_OT_REGEXP:
                    Jsi_DSAppend(dStr, o->d.robj->pattern, NULL);
                    return;
                case JSI_OT_USEROBJ: 
                    jsi_UserObjToName(interp, o->d.uobj, dStr);
                    return;
                case JSI_OT_ITER:
                    Jsi_DSAppend(dStr, "*ITER*", NULL);
                    return;
            }
                        
            if (o->isarrlist)
            {
                Jsi_Value *nv;
                int i, len = o->arrCnt;
                
                if (!o->arr)
                    len = Jsi_ValueGetLength(interp, v);
                Jsi_DSAppend(dStr,"[ ", NULL);
                for (i = 0; i < len; ++i) {
                    nv = Jsi_ValueArrayIndex(interp, v, i);
                    if (i) Jsi_DSAppend(dStr,", ", NULL);
                    if (nv) jsiValueGetString(interp, nv, dStr, owPtr);
                    else Jsi_DSAppend(dStr, "undefined", NULL);
                }
                Jsi_DSAppend(dStr," ]", NULL);
            } else {
                Jsi_DSAppend(dStr,"{ ", NULL);
                owPtr->depth++;
                Jsi_TreeWalk(o->tree, _object_get_callback, owPtr, 0);
                owPtr->depth--;
                Jsi_DSAppend(dStr," }", NULL);
            }
            return;
        }
        default:
            Jsi_LogBug("Unexpected value type: %d\n", v->vt);
    }
}

/* Format value into dStr.  Toplevel caller does init/free. */
const char* Jsi_ValueGetDString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, int quote)
{
    objwalker ow;
    ow.quote = quote;
    ow.depth = 0;
    ow.dStr = dStr;
    Jsi_DSInit(dStr);
    jsiValueGetString(interp, v, dStr, &ow);
    return Jsi_DSValue(dStr);
}

void Jsi_Puts(Jsi_Interp* interp, Jsi_Value *v, int flags)
{
    int quote = (flags&JSI_OUTPUT_QUOTE);
    int iserr = (flags&JSI_OUTPUT_STDERR);
    Jsi_DString dStr = {};
    const char *cp = Jsi_ValueString(interp, v, 0);
    if (cp) {
        fprintf((iserr?stderr:stdout),"%s", cp);
        return;
    }
    Jsi_DSInit(&dStr);
    Jsi_ValueGetDString(interp, v, &dStr, quote);
    fprintf((iserr?stderr:stdout),"%s",Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return;
}

extern int yyparse(jsi_Pstate *ps);

char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey)
{
    Jsi_HashEntry *hPtr;
    if (isKey) *isKey = 0;
    if (!nocreate) {
        *isKey = 1;
         if (isKey) *isKey = 1;
        return (char*)Jsi_KeyAdd(interp, str);
    }
    hPtr = Jsi_HashEntryFind(interp->strKeyTbl, str);
    if (!hPtr) {
        return Jsi_Strdup(str);;
    }
    if (isKey) *isKey = 1;
    *isKey = 1;
    return (char*)Jsi_HashKeyGet(hPtr);
}

static int balanced(char *str) {
    int cnt = 0, quote = 0;
    char *cp = str;
    while (*cp) {
        switch (*cp) {
        case '\\':
            cp++;
            break;
        case '{': case '(': case '[':
            cnt++;
            break;
        case '\'': case '\"':
            quote++;
            break;
        case '}': case ')': case ']':
            cnt--;
            break;
        }
        if (*cp == 0)
            break;
        cp++;
    }
    return ((quote%2) == 0 && cnt <= 0);
}

static char *get_inputline(int istty, const char *prompt)
{
    char *res;
#ifdef HAVE_READLINE
    if (istty) {
        res = readline(prompt);
        if (res && *res) add_history(res);
        return res;
    }
#endif
    int done = 0;
    char bbuf[BUFSIZ];
    Jsi_DString dStr = {};
    if (istty)
        fputs(prompt, stdout);
    fflush(stdout);
    while (!done) { /* Read a line. */
        bbuf[0] = 0;
        if (fgets(bbuf, sizeof(bbuf), stdin) == NULL)
            return NULL;
        Jsi_DSAppend(&dStr, bbuf, NULL);
        if (strlen(bbuf) < (sizeof(bbuf)-1) || bbuf[sizeof(bbuf)-1] == '\n')
            break;
    }
    res = strdup(Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return res;
}

static Jsi_Interp* interactiveInterp = NULL;
#ifdef HAVE_READLINE
static Jsi_Value *completeValues = NULL;
static int jsiRlStart = 0;

static char *jsiRlCmdMatches(const char *text, int state) {
    static int idx, len;
    const char *name;
    Jsi_Interp* interp = interactiveInterp;
    if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))
        return NULL;
    Jsi_Value **arr = completeValues->d.obj->arr;
    int aLen = completeValues->d.obj->arrCnt;

    if (!state)
    {
        idx = 0;
        len = Jsi_Strlen(text)-jsiRlStart;
    }
    while (idx<aLen)
    {
        name = Jsi_ValueString(interp, arr[idx], NULL);
        if (!name) name = "";
        idx++;
        if (Jsi_Strncmp(name, text+jsiRlStart, len) == 0)
            return (Jsi_Strdup(name));
    }
    return NULL;
}

static char **jsiRlGetMatches(const char *cstr, int start, int end) {
    char **matches = NULL;
    char *str = rl_line_buffer;
    jsiRlStart = start;
    if (1 || start == 0 || !completeValues) {
        int rc;
        Jsi_Interp* interp = interactiveInterp;
        if (!completeValues)
            completeValues = Jsi_ValueNew1(interp);
        Jsi_Value *func = interp->onComplete;
        if (func == NULL || !Jsi_ValueIsFunction(interp, func))
            func = Jsi_NameLookup(interp, "Info.completions");
        if (func && Jsi_ValueIsFunction(interp, func)) {
            Jsi_Value *items[3] = {};
            items[0] = Jsi_ValueNewStringDup(interp, str);
            items[1] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);
            items[2] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);;
            Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));
            //fprintf(stderr, "CCCCC: %s %d %d\n", str, start, end);
            rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);
            if (rc != JSI_OK)
                fprintf(stderr, "bad completion");
        }
        matches = rl_completion_matches(str, jsiRlCmdMatches);
    }
    return matches;
}
#endif

/* Collect and execute code from stdin.  The first byte of flags are passed to Jsi_ValueGetDString(). */
int Jsi_Interactive(Jsi_Interp* interp, int flags) {
    int rc = 0, done = 0, len, quote = (flags & 0xff), istty = 1;
    const char *prompt = "# ";
    char *buf;
    if (interactiveInterp) {
        Jsi_LogError("multiple interactive not supported");
        return JSI_ERROR;
    }
    interactiveInterp = interp;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
#ifndef __WIN32
    istty = isatty(fileno(stdin));
#else
    istty = _isatty(_fileno(stdin));
#endif
#ifdef HAVE_READLINE
    Jsi_DString dHist = {};
    char *hist = NULL;
    rl_attempted_completion_function = jsiRlGetMatches;
    if(interp->noreadline == 0 && !interp->parent)
    {
        hist = Jsi_NormalPath(interp, "~/.jsish_history", &dHist);
        if (hist)
            read_history(hist);
    }
#endif
    interp->level++;
    while (done==0 && interp->exited==0) {
        buf = get_inputline(istty, prompt);
        if (buf) {
          Jsi_DSAppend(&dStr, buf, NULL);
          free(buf);
        } else {
          done = 1;
        }
        len = Jsi_DSLength(&dStr);
        if (done && len == 0)
            break;
        buf = Jsi_DSValue(&dStr);
        if (done == 0 && (!balanced(buf))) {
            prompt = "> ";
            if (len<5)
                break;
            continue;
        }
        prompt = "# ";
        while ((len = Jsi_Strlen(buf))>0 && (isspace(buf[len-1])))
            buf[len-1] = 0;
        if (buf[0] == 0)
            continue;
        if (interp->onEval == NULL) {
            /* Convenience: add semicolon to "var" statements (required by parser). */
            if (strncmp(buf,"var ", 4) == 0 && strchr(buf, '\n')==NULL && strchr(buf, ';')==NULL)
                strcat(buf, ";");
                rc = Jsi_EvalString(interp, buf, JSI_EVAL_RETURN);
        }
        else
        {
            Jsi_Value *func = interp->onEval;
            if (func && Jsi_ValueIsFunction(interp, func)) {
                Jsi_Value *items[1] = {};
                items[0] = Jsi_ValueNewStringDup(interp, buf);
                Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
                rc = Jsi_FunctionInvoke(interp, func, args, &interp->retPtr, interp->csc);
                if (rc != JSI_OK)
                    fprintf(stderr, "bad eval");
            }
        }
        if (interp->exited)
            break;
        if (rc == 0) {
             if (interp->retPtr->vt != JSI_VT_UNDEF || interp->noUndef==0) {
                Jsi_DString eStr = {};
                fputs(Jsi_ValueGetDString(interp, interp->retPtr, &eStr, quote), stdout);
                Jsi_DSFree(&eStr);
                fputs("\n", stdout);
             }
        } else if (!interp->exited) {
            fputs("ERROR\n", stderr);
        }
        Jsi_DSSetLength(&dStr, 0);
        len = 0;
    }
    interp->level--;
#ifdef HAVE_READLINE
    if (hist) {
        stifle_history(100);
        write_history(hist);
    }
    Jsi_DSFree(&dHist);
#endif
    Jsi_DSFree(&dStr);
    if (interp->exited && interp->level <= 0)
    {
        rc = interp->exitCode;
        Jsi_InterpDelete(interp);
    } else if (interp == interp->mainInterp)
        interp->retPtr = NULL;
    interactiveInterp = NULL;
    return rc;
}

int Jsi_PackageProvide(Jsi_Interp *interp, const char *name, const char *version)
{
    return JSI_OK;
}
int Jsi_PackageRequire(Jsi_Interp *interp, const char *name, const char *version)
{
    return JSI_OK;
}

int Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value)
{
    int isNew;
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryNew(interp->thisTbl, _this, &isNew);
    if (!hPtr)
        return -1;
    Jsi_HashValueSet(hPtr, value);
    return isNew;
}

void *Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this)
{
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(interp->thisTbl, _this);
    if (!hPtr)
        return NULL;
    return Jsi_HashValueGet(hPtr);
}

int Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *value)
{
    int isNew;
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryNew(interp->protoTbl, key, &isNew);
    if (!hPtr)
        return -1;
    Jsi_HashValueSet(hPtr, value);
    return isNew;
}

void *Jsi_PrototypeGet(Jsi_Interp *interp, const char *key)
{
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(interp->protoTbl, key);
    if (!hPtr)
        return NULL;
    return Jsi_HashValueGet(hPtr);
}

int Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj)
{
    Jsi_HashEntry *hPtr;
    Jsi_Value *val;
    hPtr = Jsi_HashEntryFind(interp->protoTbl, key);
    if (!hPtr)
        return JSI_ERROR;
    val = (Jsi_Value *)Jsi_HashValueGet(hPtr);
    obj->__proto__ = val;
    return JSI_OK;
}

const char *Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *o)
{
     switch (o->ot) {
        case JSI_OT_BOOL: return "boolean"; break;
        case JSI_OT_FUNCTION: return "function"; break;
        case JSI_OT_NUMBER: return "number"; break;
        case JSI_OT_STRING: return "string"; break;  
        case JSI_OT_REGEXP: return "regexp"; break;  
        case JSI_OT_ITER: return "iter"; break;  
        case JSI_OT_ARRAY: return "array"; break;  
        case JSI_OT_OBJECT: return "object"; break;
        case JSI_OT_USEROBJ:
            if (o->__proto__) {
                Jsi_HashEntry *hPtr;
                Jsi_HashSearch search;
                            
                for (hPtr = Jsi_HashEntryFirst(interp->thisTbl,&search); hPtr != NULL;
                    hPtr = Jsi_HashEntryNext(&search))
                    if (Jsi_HashValueGet(hPtr) == o->__proto__)
                        return (char*)Jsi_HashKeyGet(hPtr);
            }
            
            return "userobj";
            break;
            //return Jsi_ObjGetType(interp, v->d.obj);
     }
     return "";
}

extern Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj)
{
    return obj->ot;
}

const char *Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v)
{
    switch (v->vt) {
        case JSI_VT_BOOL: return "boolean"; break;
        case JSI_VT_UNDEF: return "undefined"; break;
        case JSI_VT_NULL: return "null"; break;
        case JSI_VT_NUMBER: return "number"; break;
        case JSI_VT_STRING: return "string"; break;  
        case JSI_VT_VARIABLE: return "variable"; break;  
        case JSI_VT_OBJECT: return Jsi_ObjTypeStr(interp, v->d.obj);
    }
    return "";
}

/* Shim to instantiate a new obj-command and return its userobj data pointer for C use. */
void *Jsi_NewCmdObj(Jsi_Interp *interp, char *name, char *arg1, char *opts, char *var) {
    char buf[BUFSIZ];
    if (arg1)
        sprintf(buf, "%s%snew %s('%s', %s);", var?var:"", var?"=":"return ", name, arg1, opts?opts:"null");
    else
        sprintf(buf, "%s%snew %s(%s);", var?var:"", var?"=":"return ", name, opts?opts:"null");
    int rc = Jsi_EvalString(interp, buf, 0);
    if (rc != JSI_OK)
        return NULL;
    Jsi_Value *vObj = interp->retPtr;
    if (var)
        vObj = Jsi_NameLookup(interp, var);
    if (!vObj)
        return NULL;
    return Jsi_UserObjGetData(interp, vObj, NULL);
}

#endif

Jsi_Map* Jsi_MapNew (Jsi_Interp *interp, Jsi_Map_Type listType, unsigned int keyType, Jsi_HashDeleteProc *freeProc)
{
    Jsi_Map *lPtr, lval;
    lval.typ = listType;
    switch (listType) {
        case JSI_MAP_HASH: lval.v.hash = Jsi_HashNew(interp, keyType, freeProc); break;
        case JSI_MAP_TREE: lval.v.tree = Jsi_TreeNew(interp, keyType, freeProc); break;
        default: return NULL;
    }
    if (!lval.v.hash) return NULL;
    lPtr = (Jsi_Map*)Jsi_Malloc(sizeof(*lPtr));
    *lPtr = lval;
    return lPtr;
}

void Jsi_MapDelete (Jsi_Map *listPtr) {
    switch (listPtr->typ) {
        case JSI_MAP_HASH: Jsi_HashDelete(listPtr->v.hash); break;
        case JSI_MAP_TREE: Jsi_TreeDelete(listPtr->v.tree); break;
        default: return;
    }
    Jsi_Free(listPtr);
}
Jsi_MapEntry* Jsi_MapSet(Jsi_Map *listPtr, void *key, void *value){
    switch (listPtr->typ) {
        case JSI_MAP_HASH: Jsi_HashSet(listPtr->v.hash, key, value); break;
        case JSI_MAP_TREE: Jsi_TreeSet(listPtr->v.tree, key, value); break;
    }
    return NULL;
}
void* Jsi_MapGet(Jsi_Map *listPtr, void *key){
    switch (listPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashGet(listPtr->v.hash, key);
        case JSI_MAP_TREE: return Jsi_TreeGet(listPtr->v.tree, key);
    }
    return NULL;
}
static int jsi_GetListType(Jsi_MapEntry *h) {
    Jsi_HashEntry *hPtr =(Jsi_HashEntry *)h;
    return hPtr->typ;
}
void* Jsi_MapKeyGet(Jsi_MapEntry *h){
    switch (jsi_GetListType(h)) {
        case JSI_MAP_HASH: return Jsi_HashKeyGet((Jsi_HashEntry*)h);
        case JSI_MAP_TREE: return Jsi_TreeKeyGet((Jsi_TreeEntry*)h);
    }
    return NULL;
}
#ifndef JSI_LITE_ONLY
int Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *listPtr, Jsi_Value **ret, int flags){
    switch (listPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashKeysDump(interp, (Jsi_Hash*)listPtr, ret, flags);
        case JSI_MAP_TREE: return Jsi_TreeKeysDump(interp, (Jsi_Tree*)listPtr, ret, flags);
    }
    return JSI_ERROR;
}
#endif
void* Jsi_MapValueGet(Jsi_MapEntry *h){
    switch (jsi_GetListType(h)) {
        case JSI_MAP_HASH: return Jsi_HashValueGet((Jsi_HashEntry*)h);
        case JSI_MAP_TREE: return Jsi_TreeValueGet((Jsi_TreeEntry*)h);
    }
    return NULL;
}
void Jsi_MapValueSet(Jsi_MapEntry *h, void *value){
    switch (jsi_GetListType(h)) {
        case JSI_MAP_HASH: return Jsi_HashValueSet((Jsi_HashEntry*)h, value);
        case JSI_MAP_TREE: return Jsi_TreeValueSet((Jsi_TreeEntry*)h, value);
    }
}
Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *listPtr, const void *key){
    switch (listPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryFind(listPtr->v.hash, key);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryFind(listPtr->v.tree, key);
    }
    return NULL;
}
Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *listPtr, const void *key, int *isNew){
    switch (listPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryNew(listPtr->v.hash, key, isNew);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryNew(listPtr->v.tree, key, isNew);
    }
    return NULL;
}
int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr){
    switch (jsi_GetListType(entryPtr)) {
        case JSI_MAP_HASH: return Jsi_HashEntryDelete((Jsi_HashEntry*)entryPtr);
        case JSI_MAP_TREE: return Jsi_TreeEntryDelete((Jsi_TreeEntry*)entryPtr);
    }
    return 0;
}
Jsi_MapEntry* Jsi_MapEntryFirst (Jsi_Map *listPtr, Jsi_MapSearch *searchPtr){
    searchPtr->typ = listPtr->typ;
    switch (listPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryFirst(listPtr->v.hash, &searchPtr->v.hash);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryFirst(listPtr->v.tree, &searchPtr->v.tree, 0);
    }
    return NULL;
}
Jsi_MapEntry* Jsi_MapEntryNext (Jsi_MapSearch *searchPtr){
    switch (searchPtr->typ) {
        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryNext(&searchPtr->v.hash);
        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryNext(&searchPtr->v.tree);
    }
    return NULL;
}
int Jsi_MapSize(Jsi_Map *listPtr) {
    switch (listPtr->typ) {
        case JSI_MAP_HASH: return Jsi_HashSize(listPtr->v.hash);
        case JSI_MAP_TREE: return Jsi_TreeSize(listPtr->v.tree);
    }
    return -1;
}

// List

    
Jsi_List *Jsi_ListNew(Jsi_ListAttr *attr)
{
    Jsi_List *list = (Jsi_List *)Jsi_Calloc(1, sizeof(Jsi_List) + (attr && attr->valueSpace>0?attr->valueSpace:0));
    SIGINIT(list, LIST);
    if (attr)
        list->attr = *attr;
    if ((list->attr.useMutex) && ((list->attr.lockProc == NULL) || (list->attr.lockProc == Jsi_ListLock))) {
        list->mutex = Jsi_MutexNew(NULL, 0, 0);
        if (list->mutex) {
            list->attr.lockProc = Jsi_ListLock;
        }
    }
    return list;
}

void Jsi_ListDelete(Jsi_List *list) {
    Jsi_ListClear(list);
    if (list->mutex)
        Jsi_MutexDelete(NULL, list->mutex);
    if (list->attr.freeProc)
        (*list->attr.freeProc)(list, NULL);
    else
        free(list);
}

Jsi_Bool Jsi_ListTypeMatches(Jsi_List *list, Jsi_ListEntry *item)
{
    if (list != item->list)
        return (list->attr.freeProc == item->list->attr.freeProc && list->attr.valueSpace == item->list->attr.valueSpace);
    return 0;
}

Jsi_Bool Jsi_ListIsIn(Jsi_List *list, Jsi_ListEntry *item)
{
    if (list->head == item)
        return 1;
    if (list == item->list && (item->next || item->prev))   
        return 1;
    return 0;
}

Jsi_ListEntry* Jsi_ListInsert(Jsi_List *list, Jsi_ListEntry *item, Jsi_ListEntry *at)
{
    Assert(item && item->next==NULL && item->prev==NULL && list);
    if (list->attr.lockProc && (*list->attr.lockProc)(list, 1) != JSI_OK)
        return NULL;
    if (!item->list)
         item->list = list;
    else if (list != item->list) {
        Assert(list->attr.freeProc == item->list->attr.freeProc);
        item->list = list;
    }
    if (!list->head) {
        list->head = list->tail = item;
    } else if (item == list->head) {
        assert(0);
    } else if (at == NULL) {
        item->prev = list->tail;
        list->tail->next = item;
        list->tail = item;
    } else if (at == list->head) {
        item->next = list->head;
        list->head->prev = item;
        list->head = item;
    } else {
        item->next = at;
        item->prev = at->prev;
        at->prev->next = item;
        at->prev = item;
    }
    list->numEntries++;
    item->list = list;
    if (list->attr.lockProc)
        (*list->attr.lockProc)(list, 0);
    return item;
}
 
Jsi_ListEntry* Jsi_ListRemove(Jsi_List *list, Jsi_ListEntry *item)
{
    Assert(item && list->head && list->tail && item->list && item->list);
    if (list->attr.lockProc && (*list->attr.lockProc)(list, 1) != JSI_OK)
        return NULL;
    if (item == list->head) {
        if (list->head == list->tail)
            list->head = list->tail = NULL;
        else
            list->head = list->head->next;
    }
    else if (item == list->tail) {
        list->tail = list->tail->prev;
        list->tail->next = NULL;
    } else {
        item->prev->next = item->next;
        if (item->next)
            item->next->prev = item->prev;
    }
    list->numEntries--;
    item->next = item->prev = NULL;
    if (list->attr.lockProc)
        (*list->attr.lockProc)(list, 0);
    return item;
}


Jsi_ListEntry *Jsi_ListEntryNew(Jsi_List* list) {
    int extra = (list?list->attr.valueSpace:0);
    Jsi_ListEntry *l = (Jsi_ListEntry*)Jsi_Calloc(1, sizeof(Jsi_ListEntry)+extra);
    SIGINIT(l, LISTENTRY);
    l->list = list;
    if (extra)
        l->value = (void*)(((char*)l)+sizeof(Jsi_ListEntry));
    return l;
}

void Jsi_ListEntryDelete(Jsi_ListEntry *l) {
    Assert(l->next==NULL && l->prev==NULL);
    if (l->list && l->list->attr.freeProc)
        (*l->list->attr.freeProc)(l->list, l);
    else
        free(l);
}

void Jsi_ListClear(Jsi_List *list) {
    Jsi_ListEntry *l;
    if (list->attr.lockProc && (*list->attr.lockProc)(list, 1) != JSI_OK)
        return;
    while (list->head) {
        l = list->head;
        list->head = list->head->next;
        l->next = l->prev = NULL;
        Jsi_ListEntryDelete(l);
    }
    list->numEntries = 0;
    if (list->attr.lockProc)
        (*list->attr.lockProc)(list, 0);
}
 
int Jsi_ListLock(Jsi_List *list, int lock) {
    if (!list->mutex)
        return JSI_OK;
    if (lock)
        return Jsi_MutexLock(NULL, list->mutex);
    Jsi_MutexUnlock(NULL, list->mutex);
    return JSI_OK;
}

void* Jsi_ListGetAttr(Jsi_List *list, Jsi_ListAttr **attr)
{
    if (attr)
        *attr = &list->attr;
    return list->attr.data;
}

int Jsi_ListSize(Jsi_List *list) { return list->numEntries;}

void* Jsi_ListEntryGetValue(Jsi_ListEntry *l) { return l?l->value:NULL; }
void Jsi_ListEntrySetValue(Jsi_ListEntry *l, void *value) { l->value = value;}
Jsi_ListEntry* Jsi_ListEntryPrev(Jsi_ListEntry *l) { return l->prev; }
Jsi_ListEntry* Jsi_ListEntryNext(Jsi_ListEntry *l) { return l->next; }

Jsi_ListEntry* Jsi_ListGetFront(Jsi_List *list) {return list->head;}
Jsi_ListEntry* Jsi_ListGetBack(Jsi_List *list) { return list->tail;}
Jsi_ListEntry* Jsi_ListPopFront(Jsi_List *list) { return Jsi_ListRemove(list, list->head);}
Jsi_ListEntry* Jsi_ListPopBack(Jsi_List *list) {return Jsi_ListRemove(list, list->tail);}
Jsi_ListEntry* Jsi_ListPushFront(Jsi_List *list, Jsi_ListEntry *item) {return Jsi_ListInsert(list, item, list->head);}
Jsi_ListEntry* Jsi_ListPushBack(Jsi_List *list, Jsi_ListEntry *item) {return Jsi_ListInsert(list, item, NULL);}
Jsi_ListEntry* Jsi_ListPushFrontNew(Jsi_List *list, void *value) {
    Jsi_ListEntry* l = Jsi_ListEntryNew(list);
    l->value = value;
    return Jsi_ListInsert(list, l, list->head);
}
Jsi_ListEntry* Jsi_ListPushBackNew(Jsi_List *list, void *value) {
    Jsi_ListEntry* l = Jsi_ListEntryNew(list);
    l->value = value;
    return Jsi_ListInsert(list, l, NULL);
}


#ifndef JSI_OMIT_THREADS

#ifdef __WIN32
#include <windows.h>
#else
#include <pthread.h>
#endif

typedef struct Jsi_Mutex_ {
    int flags;
    int lockTimeout;
    int threadErrCnt;
#ifdef __WIN32
    CRITICAL_SECTION mtx
#else
    pthread_mutex_t mtx;
#endif
} Jsi_Mutex;

#ifdef __WIN32
#include <windows.h>

static int MutexLock(Jsi_Interp *interp, Jsi_Mutex* mtx) {
    int timeout = mtx->lockTimeout;
    if (interp && timeout<0)
        timeout = interp->lockTimeout;
    if (timeout<=0)
        EnterCriticalSection(&mtx->mtx);
    else {
        uint cnt = timeout;
        while (cnt-- >= 0) {
            if (TryEnterCriticalSection(&mtx->mtx))
                return JSI_OK;
            usleep(1000);
        }
        Jsi_LogError("lock timed out");
        if (interp)
            interp->threadErrCnt++;
        mtx->threadErrCnt++;
        return JSI_ERROR;
    }
    return JSI_OK;
}
static void MutexUnlock(Jsi_Mutex* mtx) { LeaveCriticalSection(&mtx->mtx); }
static void MutexInit(Jsi_Mutex *mtx) {  InitializeCriticalSection(&mtx->mtx); }

static void MutexDone(Jsi_Mutex *mtx) { DeleteCriticalSection(&mtx->mtx); }
#else /* ! __WIN32 */

#include <pthread.h>
static int MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) {
    int timeout = mtx->lockTimeout;
    if (interp && timeout<0)
        timeout = interp->lockTimeout;
    if (timeout<=0)
        pthread_mutex_lock(&mtx->mtx);
    else {
        struct timespec ts;
        ts.tv_sec = timeout/1000;
        ts.tv_nsec = 1000 * (timeout%1000);
        int rc = pthread_mutex_timedlock(&mtx->mtx, &ts);
        if (rc != 0) {
            Jsi_LogError("lock timed out");
            if (interp)
                interp->threadErrCnt++;
            mtx->threadErrCnt++;
            return JSI_ERROR;
        }
    }
    return JSI_OK;
}
static void MutexUnlock(Jsi_Mutex *mtx) { pthread_mutex_unlock(&mtx->mtx); }
static void MutexInit(Jsi_Mutex *mtx) {
    pthread_mutexattr_t Attr;
    pthread_mutexattr_init(&Attr);
    if (mtx->flags & JSI_MUTEX_RECURSIVE)
        pthread_mutexattr_settype(&Attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&mtx->mtx, &Attr);
}

static void MutexDone(Jsi_Mutex *mtx) { pthread_mutex_destroy(&mtx->mtx); }
#endif /* ! __WIN32 */

int Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { if (interp) interp->lockRefCnt++; return MutexLock(interp, mtx);}
void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexUnlock(mtx); if (interp) interp->lockRefCnt--; }
Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) {
     Jsi_Mutex *mtx = (Jsi_Mutex *)Jsi_Calloc(1,sizeof(Jsi_Mutex));
     mtx->lockTimeout = timeout;
     mtx->flags = flags;
     MutexInit(mtx);
     return mtx;
}
void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexDone(mtx); Jsi_Free(mtx);}
//void Jsi_MutexInit(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexInit(mtx); }
void* Jsi_InterpThread(Jsi_Interp *interp) { return interp->threadId; }
void* Jsi_CurrentThread(void) {
#ifdef __WIN32
    return (void*)GetCurrentThreadId();
#else
    return (void*)pthread_self();
#endif
}

#else /* ! JSI_OMIT_THREADS */
int Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { return JSI_OK; }
void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { }
Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp) { return NULL; }
void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { }
void* Jsi_CurrentThread(void) { return NULL; }
void* Jsi_InterpThread(Jsi_Interp *interp) { return NULL; }
#endif

Jsi_Number Jsi_Version(void) {
    Jsi_Number d = JSI_VERSION;
    return d;
}
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/* Jsi_Obj constructor */
static int ObjectConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        /* new operator will do the rest */
        return JSI_OK;
    }
    
    if (Jsi_ValueGetLength(interp, args) <= 0) {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        o->__proto__ = interp->Object_prototype;
        Jsi_ValueMakeObject(interp, ret, o);
        return JSI_OK;
    }
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (!v || v->vt == JSI_VT_UNDEF || v->vt == JSI_VT_NULL) {
        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
        Jsi_ValueMakeObject(interp, ret, o);
        return JSI_OK;
    }
    Jsi_ValueDup2(interp, ret, v);
    Jsi_ValueToObject(interp, *ret);
    return JSI_OK;
}

/* Function.prototype pointed to a empty function */
static int FunctionPrototypeConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return JSI_OK;
}

static int Function_constructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {      /* Todo, parse the argument, return the new function obj */
        _this->d.obj->ot = JSI_OT_FUNCTION;
        return JSI_OK;
    }
    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_FUNCTION);
    Jsi_ValueMakeObject(interp, ret, o);
    return JSI_OK;
}

/* delete array[0], array[1]->array[0] */
void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)
{
    if (v->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("Jsi_ValueArrayShift, target is not object");
        return;
    }
    Jsi_Obj *o = v->d.obj;
    if (o->isarrlist) {
        int i;
        if (!o->arrCnt)
            return;
        if (o->arr[0])
            Jsi_DecrRefCount(interp, o->arr[0]);
        for (i=1; i<o->arrCnt; i++) {
            o->arr[i-1] = o->arr[i];
        }
        o->arr[o->arrCnt--] = NULL;
        return;
    }
    
    int len = Jsi_ObjGetLength(interp, v->d.obj);
    if (len <= 0) return;
    
    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);
    if (!v0) return;
    
    Jsi_ValueReset(interp, &v0);
    
    int i;
    Jsi_Value *last = v0;
    for (i = 1; i < len; ++i) {
        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);
        if (!t) return;
        Jsi_ValueCopy(interp, last, t);
        Jsi_ValueReset(interp, &t);
        last = t;
    }
    
    Jsi_ObjSetLength(interp, v->d.obj, len - 1);
}

Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr)
{
    int i;
    // Extract typechecking info from argStr for builtin commands on first call
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    int argc;
    char **argv, *sname, *stype, *cp;
    Jsi_SplitStr(argStr, &argc, &argv, ",", &dStr);
    if (argc<=0)
        return NULL;
    Jsi_ScopeStrs *ss = jsi_ScopeStrsNew();
    for (i=0; i<argc; i++) {
        sname = argv[i];
        stype = NULL;
        while (sname && *sname && isspace(*sname)) { sname++; }
        if ((cp=Jsi_Strchr(sname, '=')))
            *cp = 0;
        if ((cp=Jsi_Strchr(sname, ':'))) {
            stype = cp+1;
            *cp = 0;
            while (*stype && isspace(*stype)) { stype++; }
            if (*stype) {
                cp = stype+Jsi_Strlen(stype)-1;
                while (cp>=stype && isspace(*cp)) { *cp = 0; cp--; }
            }
        }
        if (sname && *sname) {
            cp = sname+Jsi_Strlen(sname)-1;
            while (cp>=sname && isspace(*cp)) { *cp = 0; cp--; }
        }
        jsi_ScopeStrsPush(interp, ss, sname, jsi_typeGet(interp, stype));
    }
    Jsi_DSFree(&dStr);
    return ss;
}

// Runtime function call checker.
int jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc)
{
    int i, rc = JSI_OK;
    Jsi_ScopeStrs *argnames;
    // Extract typechecking info from argStr for builtin commands on first call
    const char *argStr = (func->cmdSpec ? func->cmdSpec->argStr: NULL);
    if (alloc && func->type == FC_BUILDIN && func->callCnt == 0 && func->argnames==NULL
        && argStr && Jsi_Strchr(argStr, ':'))
        func->argnames = jsi_ParseArgStr(interp, argStr);
    argnames = func->argnames;
    int argc = Jsi_ValueGetLength(interp, args);
    if (alloc && jsi_RunFuncCallCheck(interp, func, argc, func->name, NULL) != JSI_OK
        && (interp->typeCheck>=jsi_TypeChk_Error))
        rc = JSI_ERROR;
    if (!argnames)
        return rc;
    
    int addargs = func->callflags.bits.addargs;
    for (i = 0; i < argnames->count; ++i) {
        int n = i-addargs;
        const char *argkey = jsi_ScopeStrsGet(argnames, i);
        if (!argkey) break;
        
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);
        if (!alloc) {
            if (func->type == FC_BUILDIN)
                continue;
            if (v==NULL  && i >= addargs)
                v = argnames->args[n].defValue;
            if (v)
                Jsi_DecrRefCount(interp, v);
        } else {
            if (v==NULL  && i >= addargs)
                v = argnames->args[n].defValue;
            if (v && rc == JSI_OK && i >= addargs) {
                int typ = argnames->args[n].type;
                if (typ)
                    rc = jsi_ArgTypeCheck(interp, typ, v, "for argument", argkey, i+1, func);
            }
            if (func->type == FC_BUILDIN)
                continue;
            if (v)
                Jsi_IncrRefCount(interp, v);
            else {
                v = Jsi_ValueNew(interp);
            }
            jsi_ValueObjSet(interp, args, argkey, v, JSI_OM_DONTENUM | JSI_OM_INNERSHARED, 1);
        }
    }
    return rc;
}

void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall)
{
    if (interp->hasCallee) {
        Jsi_Value *callee = Jsi_ValueNew1(interp);
        Jsi_ValueCopy(interp, callee, tocall);
        Jsi_ValueInsert(interp, args, "\1callee\1", callee, JSI_OM_DONTENUM);
        Jsi_DecrRefCount(interp, callee);
    }
}

int Jsi_FunctionCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret)
{
    Jsi_Value *tocall = _this;
    if (!Jsi_ValueIsFunction(interp, tocall)) {
        Jsi_LogError("can not execute expression, expression is not a function\n");
        return -1;
    }

    if (!tocall->d.obj->d.fobj) {   /* empty function */
        return JSI_OK;
    }
    
    /* func to call */
    Jsi_Func *fstatic = tocall->d.obj->d.fobj->func;
    
    /* new this */
    Jsi_Value *ntPtr;
    Jsi_Value *arg1 = NULL;
    if ((arg1 = Jsi_ValueArrayIndex(interp, args, 0)) && !Jsi_ValueIsUndef(interp, arg1)
        && !Jsi_ValueIsNull(interp, arg1))
        ntPtr = Jsi_ValueDup(interp, arg1);
    else
        ntPtr = Jsi_ValueDup(interp, interp->Top_object);
    Jsi_ValueToObject(interp, ntPtr);
    
    /* prepare args */
    Jsi_ValueArrayShift(interp, args);
    int res = jsi_SharedArgs(interp, args, fstatic, 1);
    
    if (res == JSI_OK) {
        jsi_InitLocalVar(interp, args, fstatic);
        jsi_SetCallee(interp, args, tocall);
        
        if (fstatic->type == FC_NORMAL) {
            res = jsi_evalcode(interp->ps, fstatic->opcodes, tocall->d.obj->d.fobj->scope, 
                       args, ntPtr, ret);
        } else {
            res = fstatic->callback(interp, args, ntPtr, ret, fstatic);
        }
        fstatic->callCnt++;
    }
    if (res == JSI_OK && fstatic->retType)
        res = jsi_ArgTypeCheck(interp, fstatic->retType, *ret, "returned from", fstatic->name, 0, fstatic);
    jsi_SharedArgs(interp, args, fstatic, 0);
    Jsi_DecrRefCount(interp, ntPtr);
    return res;
}

static int FunctionCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_LogError("Execute call as constructor\n");
        return -1;
    }
    
    return Jsi_FunctionCall(interp, args, _this, ret);
}


static int ObjectKeysCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc = Jsi_ValueGetKeys(interp, _this, *ret);
    if (rc != JSI_OK)
        Jsi_LogWarn("can not call Keys() with non-object");
    return rc;
}

int jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{//TODO: support quote arg
    int quote = JSI_OUTPUT_QUOTE;
    Jsi_DString dStr = {};
    Jsi_ValueGetDString(interp, _this, &dStr, quote);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}


int Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret)
{
    int isalloc = 0;
    Jsi_Value *tocall = _this;
    if (!Jsi_ValueIsFunction(interp, tocall)) {
        Jsi_LogError("can not execute expression, expression is not a function\n");
        return -1;
    }

    if (!tocall->d.obj->d.fobj) {   /* empty function */
        return 0;
    }
    
    /* func to call */
    Jsi_Func *fstatic = tocall->d.obj->d.fobj->func;
    
    /* new this */
    Jsi_Value *ntPtr;
    Jsi_Value *arg1 = NULL;
    if ((arg1 = Jsi_ValueArrayIndex(interp, args, 0)) && !Jsi_ValueIsUndef(interp, arg1)
        && !Jsi_ValueIsNull(interp, arg1))
        ntPtr = Jsi_ValueDup(interp, arg1);
    else
        ntPtr = Jsi_ValueDup(interp, interp->Top_object);
    Jsi_ValueToObject(interp, ntPtr);
    
    /* prepare args */
    Jsi_Value *newscope = Jsi_ValueArrayIndex(interp, args, 1);
    if (newscope) {
        if (newscope->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, newscope->d.obj)) {
            Jsi_LogError("second argument to Function.prototype.apply must be an array\n");
            return -1;
        }
    } else {
        isalloc = 1;
        newscope = jsi_ObjValueNew(interp);
        Jsi_ObjSetLength(interp, newscope->d.obj, 0);
        Jsi_IncrRefCount(interp, newscope);
    }
    
    int res = jsi_SharedArgs(interp, newscope, fstatic, 1);
    if (res == JSI_OK) {
        jsi_InitLocalVar(interp, newscope, fstatic);
        jsi_SetCallee(interp, newscope, tocall);
    
        if (fstatic->type == FC_NORMAL) {
            res = jsi_evalcode(interp->ps, fstatic->opcodes, tocall->d.obj->d.fobj->scope, 
                newscope, ntPtr, ret);
        } else {
            res = fstatic->callback(interp, newscope, ntPtr, ret, fstatic);
        }
        fstatic->callCnt++;
    }
    if (res == JSI_OK && fstatic->retType)
        res = jsi_ArgTypeCheck(interp, fstatic->retType, *ret, "returned from", fstatic->name, 0, fstatic);
    jsi_SharedArgs(interp, newscope, fstatic, 0);
    if (isalloc)
        Jsi_DecrRefCount(interp, newscope);
    Jsi_DecrRefCount(interp, ntPtr);
    return res;
}


static int ObjectValueOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_ValueDup2(interp, ret, _this);
    return JSI_OK;
}

#ifdef JSI_HAS___PROTO__
int jsi_GetPrototypeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args,0);
    if (v->vt != JSI_VT_OBJECT)
        return JSI_ERROR;
    Jsi_ValueDup2(interp, ret, v->d.obj->__proto__);
    return JSI_OK;
}

int jsi_SetPrototypeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args,0);
    Jsi_Value *a = Jsi_ValueArrayIndex(interp, args,1);
    if (v->vt != JSI_VT_OBJECT || a->vt != JSI_VT_OBJECT)
        return JSI_ERROR;
    v->d.obj->__proto__ = Jsi_ValueDup(interp, a);
    v->d.obj->clearProto = 1;
    return JSI_OK;
}
#endif

int jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    char *key = Jsi_ValueArrayIndexToStr(interp, args,0, NULL);
    v = Jsi_ValueObjLookup(interp, _this, key, 0);
    Jsi_ValueMakeBool(interp, ret, (v != NULL));
    return JSI_OK;
}

static int ObjectIsPrototypeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *proto, *sproto, *v = Jsi_ValueArrayIndex(interp, args,0);
    int bval = 0;
    if (v->vt != JSI_VT_OBJECT || _this->vt != JSI_VT_OBJECT) {
        goto retval;
    }
    proto = _this->d.obj->__proto__;
    sproto = v->d.obj->__proto__;
    if (!proto)
        goto retval;
    while (sproto) {
        if ((bval=(sproto == proto)))
            break;
        if (sproto->vt != JSI_VT_OBJECT)
            break;
        sproto = sproto->d.obj->__proto__;
    }
retval:
    Jsi_ValueMakeBool(interp, ret, bval);
    return JSI_OK;
    
}

static int ObjectIsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args,0);
    Jsi_Value *v2 = Jsi_ValueArrayIndex(interp, args,1);
    Jsi_ValueMakeBool(interp, ret, Jsi_ValueIsEqual(interp, v1, v2));
    return JSI_OK;
}

static int ObjectCreateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->noInherit) {
        Jsi_LogError("inheritance is disabled in interp");
        return JSI_ERROR;
    }
    Jsi_Obj *obj;
    Jsi_Value *proto = Jsi_ValueArrayIndex(interp, args,0);
    Jsi_Value *props = Jsi_ValueArrayIndex(interp, args,1);

    if (proto->vt != JSI_VT_NULL && proto->vt != JSI_VT_OBJECT) {
        Jsi_LogError("arg 1 is not a proto object or null");
        return JSI_ERROR;
    }
    if (props && (props->vt != JSI_VT_OBJECT || props->d.obj->ot != JSI_OT_OBJECT)) {
        Jsi_LogError("arg 2 is not a properties object");
        return JSI_ERROR;
    }
        
    Jsi_ValueMakeObject(interp, ret, obj=Jsi_ObjNew(interp));
    if (proto->vt == JSI_VT_OBJECT) {
        obj->__proto__ = proto;
        obj->clearProto = 1;
        Jsi_IncrRefCount(interp, proto);
    }
    if (props) {
        Jsi_Obj *pobj = props->d.obj;
        Jsi_TreeEntry *tPtr;
        Jsi_TreeSearch search;
        for (tPtr = Jsi_TreeEntryFirst(pobj->tree, &search, 0);
            tPtr; tPtr = Jsi_TreeEntryNext(&search)) {
            Jsi_Value *v = (Jsi_Value *)Jsi_TreeValueGet(tPtr);
            if (v && v->f.bits.dontenum == 0)
                Jsi_ObjInsert(interp, obj, (const char *)Jsi_TreeKeyGet(tPtr), v, 0);
        }
        Jsi_TreeSearchDone(&search);
    }
    return JSI_OK;
    
}

static int ObjectBindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *obj = interp->lastBindSubscriptObj;
    if (obj == NULL || obj->ot != JSI_OT_FUNCTION) {
        Jsi_LogError("invalid bind call");
        return JSI_ERROR;
    }
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0); /*TODO: supposed to use this object in call*/
    if (!((v->vt == JSI_VT_UNDEF) || (v->vt == JSI_VT_OBJECT && 
        (v->d.obj->ot == JSI_OT_OBJECT || v->d.obj->ot == JSI_OT_FUNCTION)))) {
        Jsi_LogError("expected an object or 'undefined'");
        return JSI_ERROR;
    }
    Jsi_Func *func = obj->d.fobj->func;
    Jsi_Obj *o = Jsi_ObjNew(interp);
    Jsi_Func *f = func;
    o->d.fobj = jsi_FuncObjNew(interp, f);
    o->ot = JSI_OT_FUNCTION;
    f->bindArgs = Jsi_ValueDup(interp, args);
    v = Jsi_ValueMakeObject(interp, NULL, o);
    Jsi_ValueDup2(interp, ret, v);
    v->d.obj->d.fobj->scope = jsi_ScopeChainDupNext(interp, obj->d.fobj->scope, v);
    Jsi_HashSet(interp->genValueTbl, v, v);
    return JSI_OK;
    
}

static int ObjectPropertyIsEnumerableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    int b = 0;

    char *key = Jsi_ValueArrayIndexToStr(interp, args,0, NULL);
    v = Jsi_ValueObjLookup(interp, _this, key, 0);
    b = (v && (v->f.bits.dontenum==0));

    Jsi_ValueMakeBool(interp, ret, b);
    return JSI_OK;
}

static int ObjectToLocaleStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);
}

static int FunctionApplyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_LogError("Execute apply as constructor\n");
        return -1;
    }
    
    return Jsi_FunctionApply(interp, args, _this, ret);
}

Jsi_Value *jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name) {
    Jsi_Value *v = jsi_ObjValueNew(interp);
    Jsi_IncrRefCount(interp, v);
    //v->f.bits.isglob = 1;
#ifdef JSI_MEM_DEBUG
    v->VD.label = "jsi_ProtoValueNew1";
    v->VD.label2 = name;
#endif
    if (name != NULL)
        Jsi_PrototypeDefine(interp, name, v);
    return v;
}

Jsi_Value *jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent)
{
    Jsi_Value *fproto;
    if (parent == NULL)
        parent = "Object";
    fproto = jsi_ProtoObjValueNew1(interp, name);
    Jsi_PrototypeObjSet(interp, parent, Jsi_ValueGetObj(interp, fproto));
    return fproto;
}

static Jsi_CmdSpec functionCmds[] = {
    { "Function",  Function_constructor,   0, 0,  "", JSI_CMD_IS_CONSTRUCTOR, .help="Function constructor (unfinished)", .retType=(uint)JSI_TT_FUNCTION },
    { "apply",     FunctionApplyCmd,       1, 2,  "thisArg:null|object, args:array=void", .help="Call function passing args array", .retType=(uint)JSI_TT_ANY },
    { "call",      FunctionCallCmd,        1, -1, "thisArg:null|object, arg1, ...", .help="Call function with args", .retType=(uint)JSI_TT_ANY },
    { NULL, .help="Commands for accessing functions" }
};

int jsi_FunctionInit(Jsi_Interp *interp)
{
    Jsi_CommandCreateSpecs(interp, NULL, functionCmds, interp->Function_prototype, JSI_CMDSPEC_PROTO);
    return JSI_OK;
}

/* TODO: defineProperty, defineProperties, */
static Jsi_CmdSpec objectCmds[] = {
#ifndef __JSI_OMITDECL
    { "Object",         ObjectConstructor,      0,  1,  "val:object|null=void", JSI_CMD_IS_CONSTRUCTOR, .help="Object constructor", .retType=(uint)JSI_TT_OBJECT },
    { "bind",           ObjectBindCmd,          1, -1, "thisArg:null|object, ...", .help="Creates a new function that when called, has its this keyword set to the provided thisArg", .retType=(uint)JSI_TT_ANY },
    { "create",         ObjectCreateCmd,        1, 2, "proto:null|object, properties:object=void", .help="Create a new object with prototype object and properties", .retType=(uint)JSI_TT_OBJECT },
#ifdef JSI_HAS___PROTO__
    { "getPrototypeOf", jsi_GetPrototypeOfCmd,  1, 1, "name:object", .help="Return prototype of an object", .retType=(uint)JSI_TT_OBJECT },
#endif
    { "hasOwnProperty", jsi_HasOwnPropertyCmd,  1, 1, "name:string", .help="Returns a true if object has the specified property", .retType=(uint)JSI_TT_BOOL },
    { "is",             ObjectIsCmd, 2, 2, "value1, value2", .help="Tests if two values are equal", .retType=(uint)JSI_TT_BOOL },
    { "isPrototypeOf",  ObjectIsPrototypeOfCmd, 1, 1, "name", .help="Tests for an object in another object's prototype chain", .retType=(uint)JSI_TT_BOOL },
    { "keys",           ObjectKeysCmd,          0, 0, "", .help="Return the keys of an object or array", .retType=(uint)JSI_TT_ARRAY },
    { "propertyIsEnumerable", ObjectPropertyIsEnumerableCmd,1, 1, "name", .help="Determine if a property is enumerable", .retType=(uint)JSI_TT_BOOL },
#ifdef JSI_HAS___PROTO__
    { "setPrototypeOf", jsi_SetPrototypeOfCmd,  2, 2, "name:object, value:object", .help="Set prototype of an object" },
#endif
    { "toLocaleString", ObjectToLocaleStringCmd,0, 1, "quote:boolean=false", .help="Convert to string", .retType=(uint)JSI_TT_STRING },
    { "toString",       jsi_ObjectToStringCmd,  0, 1, "quote:boolean=false", .help="Convert to string", .retType=(uint)JSI_TT_STRING }, 
    { "valueOf",        ObjectValueOfCmd,       0, 0, "", .help="Returns primitive value", .retType=(uint)JSI_TT_ANY },
    { NULL, .help="Commands for accessing Objects" }
#endif
};

int jsi_ObjectInit(Jsi_Interp *interp)
{
    Jsi_CommandCreateSpecs(interp, NULL, objectCmds, interp->Object_prototype, JSI_CMDSPEC_PROTO);
    return JSI_OK;
}

int jsi_ObjectDone(Jsi_Interp *interp)
{
    return JSI_OK;
}

int jsi_ProtoInit(Jsi_Interp *interp)
{
     /* Function and Object are created together. */
    Jsi_Value *global = interp->csc;
    /* Top, the default "this" value, pointed to global, is an object */
    interp->Top_object = global;

    /* object_prototype the start of protochain */
    interp->Object_prototype = jsi_ProtoObjValueNew1(interp, "Object");
    interp->Top_object->d.obj->__proto__ = interp->Object_prototype;
        
    /* Function.prototype.prototype is a common object */
    interp->Function_prototype_prototype = jsi_ProtoObjValueNew1(interp, "Function.prototype");
    interp->Function_prototype_prototype->d.obj->__proto__ = interp->Object_prototype;
    
    /* Function.prototype.__proto__ pointed to Jsi_Obj.prototype */
    interp->Function_prototype = jsi_MakeFuncValue(interp, FunctionPrototypeConstructor, "prototype");
    //Jsi_IncrRefCount(interp, interp->Function_prototype);
    Jsi_ValueInsertFixed(interp, interp->Function_prototype, "prototype", 
                              interp->Function_prototype_prototype);
    interp->Function_prototype->d.obj->__proto__ = interp->Object_prototype;
    
    /* Jsi_Obj.__proto__ pointed to Function.prototype */
    Jsi_Value *_Object = jsi_MakeFuncValue(interp, ObjectConstructor, "prototype");
    //Jsi_IncrRefCount(interp, _Object);
    Jsi_ValueInsertFixed(interp, _Object, "prototype", interp->Object_prototype);
    _Object->d.obj->__proto__ = interp->Function_prototype;

    /* both Function.prototype,__proto__ pointed to Function.prototype */
    Jsi_Value *_Function = jsi_MakeFuncValue(interp, Function_constructor, "prototype");
    //Jsi_IncrRefCount(interp, _Function);
    Jsi_ValueInsertFixed(interp, _Function, "prototype", interp->Function_prototype);
    _Function->d.obj->__proto__ = interp->Function_prototype;

    Jsi_ValueInsert(interp, global, "Object", _Object, JSI_OM_DONTENUM);
    Jsi_ValueInsert(interp, global, "Function", _Function, JSI_OM_DONTENUM);

    //Jsi_HashSet(interp->genValueTbl, _Object, _Object);
    //Jsi_HashSet(interp->genValueTbl, _Function, _Function);
    //Jsi_HashSet(interp->genValueTbl, interp->Object_prototype , interp->Object_prototype);
    //Jsi_HashSet(interp->genValueTbl, interp->Function_prototype, interp->Function_prototype);
    Jsi_HashSet(interp->genObjTbl, interp->Function_prototype->d.obj, interp->Function_prototype->d.obj);

    interp->cleanObjs[0] = _Function->d.obj;
    interp->cleanObjs[1] = _Object->d.obj;
    interp->cleanObjs[2] = NULL;

    jsi_ObjectInit(interp);
    jsi_FunctionInit(interp);
    
    jsi_StringInit(interp);
    jsi_BooleanInit(interp);
    jsi_NumberInit(interp);
    jsi_ArrayInit(interp);
    jsi_RegexpInit(interp);
    jsi_MathInit(interp);
    jsi_TreeInit(interp);
    return JSI_OK;
}

int Jsi_DoneProto(Jsi_Interp *interp)
{
    jsi_ObjectDone(interp);
 /*   jsi_FunctionDone(interp);
    
    jsi_StringDone(interp);
    jsi_BooleanDone(interp);
    jsi_NumberDone(interp);
    jsi_ArrayDone(interp);
    jsi_RegexpDone(interp);
    jsi_MathDone(interp);
    jsi_TreeDone(interp);*/
    return JSI_OK;
}
#endif
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <assert.h>
#include <dirent.h>

#ifndef __WIN32
#include <pwd.h>
#include <unistd.h>
#else
#include <windef.h>
#endif
#include <limits.h>

static Jsi_Filesystem *cwdFsPtr = NULL;
static Jsi_DString pwdStr = {};
static char *jsi_pwd = NULL;

#ifndef JSI_LITE_ONLY

#define _JSI_GETFP(ch) (ch && ch->fp ? ch->fp : stdin)

//static Jsi_CmdSpec filesysCmds[];

static char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *path, char *newPath);


typedef struct FileObj {
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Channel chan;
    Jsi_Value *fname;
    char *filename;
    char *mode;
    Jsi_Obj *fobj;
    int objId;
} FileObj;

static void fileObjErase(FileObj *fo);
static int fileObjFree(Jsi_Interp *interp, void *data);
static int fileObjIsTrue(void *data);
static int fileObjEqual(void *data1, void *data2);

#ifdef __WIN32
char *get_current_dir_name() {
    static char buf[MAX_PATH];
     getcwd(buf, sizeof(buf));
     return buf;
}
#endif

static const char *jsi_TildePath(Jsi_Interp *interp, const char* path, Jsi_DString *dStr) {
    if (*path != '~')
        return path;
    const char *homedir = jsi_GetHomeDir(interp);
    if (!homedir)
        return path;
    Jsi_DSAppend(dStr, homedir, path[1] == '/' ? "" : "/", path+1, NULL);
    return Jsi_DSValue(dStr);
}

int jsi_FSScandirProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,
   int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**))
{
    const char *dirname = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*dirname == '~')
        dirname = jsi_TildePath(interp, dirname, &dStr);
    int rc = scandir(dirname, namelist, filter, compar);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSCreateDirectoryProc(Jsi_Interp *interp, Jsi_Value* path) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    int rc;
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);

#ifdef __WIN32
    rc = mkdir(pathPtr);
#else
    rc = mkdir(pathPtr, 0666);
#endif
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSRenameProc(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dest) {
    const char *zSrc = Jsi_ValueToString(interp, src, NULL);
    const char *zDest = Jsi_ValueToString(interp, dest, NULL);
    Jsi_DString dStr = {}, eStr = {};
    if (*zSrc == '~')
        zSrc = jsi_TildePath(interp, zSrc, &dStr);
    if (*zDest == '~')
        zDest = jsi_TildePath(interp, zDest, &eStr);
    int rc = rename(zSrc, zDest);
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&eStr);
    return rc;
}

static Jsi_Value * jsi_FSListVolumesProc(Jsi_Interp *interp) {return 0;}

static int jsi_FSRemoveProc(Jsi_Interp *interp, Jsi_Value* path, int flags) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = remove(pathPtr);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSPathInFilesystemProc(Jsi_Interp *interp, Jsi_Value* path,void **clientDataPtr) {return 1;}

static int jsi_FSAccessProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = access(pathPtr, mode);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSChmodProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {
#ifdef __WIN32
    return -1;
#else
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = chmod(pathPtr, mode);
    Jsi_DSFree(&dStr);
    return rc;
#endif
}

static int jsi_FSStatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = stat(pathPtr, buf);
    Jsi_DSFree(&dStr);
    return rc;
}

static int jsi_FSLstatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
#ifdef __WIN32
    return jsi_FSStatProc(interp, path, buf);
#else
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = lstat(pathPtr, buf);
    Jsi_DSFree(&dStr);
    return rc;
#endif
}
static int jsi_FSFlushProc(Jsi_Channel chan) { return fflush(_JSI_GETFP(chan));}
static int jsi_FSTellProc(Jsi_Channel chan) { return ftell(_JSI_GETFP(chan));}
static int jsi_FSEofProc(Jsi_Channel chan) { return feof(_JSI_GETFP(chan));}
static int jsi_FSTruncateProc(Jsi_Channel chan, unsigned int len) { return ftruncate(fileno(_JSI_GETFP(chan)), len);}
static int jsi_FSRewindProc(Jsi_Channel chan) { rewind(_JSI_GETFP(chan)); return 0;}
static int jsi_FSCloseProc(Jsi_Channel chan) { return fclose(_JSI_GETFP(chan));}
static int jsi_FSSeekProc(Jsi_Channel chan, Jsi_Wide offset, int mode) { return fseek(_JSI_GETFP(chan), offset, mode);}

static int jsi_FSWriteProc(Jsi_Channel chan, const char *buf, int size) {
    Jsi_Interp *interp = chan->interp;
    Jsi_MutexUnlock(interp, interp->Mutex);
    int rc = fwrite(buf, 1, size, _JSI_GETFP(chan));
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        Jsi_LogBug("could not get mutex in write");
    }
    return rc;
}

static int jsi_FSReadProc(Jsi_Channel chan, char *buf, int size) {
    Jsi_Interp *interp = chan->interp;
    Jsi_MutexUnlock(interp, interp->Mutex);
    int rc = fread(buf, 1, size, _JSI_GETFP(chan));
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        Jsi_LogBug("could not get mutex in read");
    }
    return rc;
}
#ifdef __WIN32
#define jsi_FSLinkProc NULL
#define jsi_FSReadlinkProc NULL
#else //__WIN32
static int jsi_FSLinkProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    const char *toPtr = Jsi_ValueToString(interp, toPath, NULL);
    Jsi_DString dStr = {}, eStr = {};
    int rc;
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    if (*toPtr == '~')
        toPtr = jsi_TildePath(interp, toPtr, &eStr);
    if (linkType != 0)
        rc = link(pathPtr, toPtr);
    else
        rc = symlink(pathPtr, toPtr);
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&eStr);
    return rc;
}

static int jsi_FSReadlinkProc(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size) {
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    Jsi_DString dStr = {};
    if (*pathPtr == '~')
        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);
    int rc = readlink(pathPtr, buf, size);
    Jsi_DSFree(&dStr);
    return rc;
}
#endif // __WIN32

static int jsi_FSGetcProc(Jsi_Channel chan) {
    return fgetc(_JSI_GETFP(chan));
}

static int jsi_FSUngetcProc(Jsi_Channel chan, int ch) {
    return ungetc(ch, _JSI_GETFP(chan));
}

static char * jsi_FSGetsProc(Jsi_Channel chan, char *s, int size) {
    return fgets(s, size, _JSI_GETFP(chan));
}

/* Not used as Jsi_Open already handles native. */
Jsi_Channel jsi_FSOpenProc(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)
{
    return Jsi_Open(interp, file, modeString);
}

typedef struct FSList {
    Jsi_Filesystem* fsPtr;
    void *data;
    struct FSList *next;
} FSList;

static FSList *jsiFSList = NULL;
static Jsi_Chan StdChans[3];

static Jsi_Filesystem jsiFilesystem = {
    .typeName="native",
    .structureLength=sizeof(Jsi_Filesystem),
    .version=1,
    .pathInFilesystemProc=jsi_FSPathInFilesystemProc,
    .realpathProc=jsi_FSRealPathProc,
    .statProc=jsi_FSStatProc,
    .lstatProc=jsi_FSLstatProc,
    .accessProc=jsi_FSAccessProc,
    .chmodProc=jsi_FSChmodProc,
    .openProc=jsi_FSOpenProc,
    .scandirProc=jsi_FSScandirProc,
    .readProc=jsi_FSReadProc,
    .writeProc=jsi_FSWriteProc,
    .getsProc=jsi_FSGetsProc,
    .getcProc=jsi_FSGetcProc,
    .ungetcProc=jsi_FSUngetcProc,
    .flushProc=jsi_FSFlushProc,
    .seekProc=jsi_FSSeekProc,
    .tellProc=jsi_FSTellProc,
    .eofProc=jsi_FSEofProc,
    .truncateProc=jsi_FSTruncateProc,
    .rewindProc=jsi_FSRewindProc,
    .closeProc=jsi_FSCloseProc,
    .linkProc=jsi_FSLinkProc,
    .readlinkProc=jsi_FSReadlinkProc,
    .listVolumesProc=jsi_FSListVolumesProc,
    .createDirectoryProc=jsi_FSCreateDirectoryProc,
    .removeProc=jsi_FSRemoveProc,
    .renameProc=jsi_FSRenameProc,
};

Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id) {
    if (id<0 || id>2)
        return NULL;
    return StdChans+id;
}

int Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data) {
    FSList *fsl = (FSList *)Jsi_Calloc(1, sizeof(*fsl));
    fsl->fsPtr = fsPtr;
    fsl->data = data;
    fsl->next = jsiFSList;
    jsiFSList = fsl;
    return JSI_OK;
}

int Jsi_FSUnregister(Jsi_Filesystem *fsPtr) {
    FSList *fsl = jsiFSList, *flast = NULL;
    while (fsl) {
        if (fsl->fsPtr == fsPtr) {
            if (flast)
                flast->next = fsl->next;
            else
                jsiFSList = fsl->next;
            Jsi_Free(fsl);
            break;
        }
        flast = fsl;
        fsl = fsl->next;
    }
    return JSI_OK;
}

Jsi_Filesystem* Jsi_FilesystemForPath(Jsi_Interp *interp, Jsi_Value* path, void**clientDataPtr) {
    FSList *fsl = jsiFSList;
    if (!fsl) return NULL;
    clientDataPtr = NULL;
    const char *pathStr = Jsi_ValueToString(interp, path, NULL);
    if (pathStr[0] == '~')
        return &jsiFilesystem;
    if (pathStr[0] == '.' && pathStr[1] == 0)
        return (cwdFsPtr ? cwdFsPtr : &jsiFilesystem);
    while (1) {
        if (fsl->fsPtr->pathInFilesystemProc && fsl->fsPtr->pathInFilesystemProc(interp, path, clientDataPtr))
            break;
        if (!fsl->next)
            break;
        fsl = fsl->next;
    }
    return (fsl ? fsl->fsPtr : &jsiFilesystem);
}
int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len) {
#ifdef __WIN32
    return -1;
#else
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->readlinkProc) return -1;
    return fsPtr->readlinkProc(interp, path, ret, len);
#endif
}

int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->statProc) return -1;
    return fsPtr->statProc(interp, path, buf);
}

int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);
    if (fsPtr == NULL || !fsPtr->linkProc) return -1;
    return fsPtr->linkProc(interp, src, dest, typ);
}

int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->lstatProc) return -1;
    return fsPtr->lstatProc(interp, path, buf);
}

int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->chmodProc) return -1;
    return fsPtr->chmodProc(interp, path, mode);
}
int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->accessProc) return -1;
    return fsPtr->accessProc(interp, path, mode);
}
int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->removeProc) return -1;
    return fsPtr->removeProc(interp, path, flags);
}
int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);
    if (fsPtr != Jsi_FilesystemForPath(interp, src, &data)) return -1;
    if (fsPtr == NULL || !fsPtr->renameProc) return -1;
    return fsPtr->renameProc(interp, src,dst);
}

int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value* path, Jsi_Dirent ***namelist,
 int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**)) 
 {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == NULL || !fsPtr->scandirProc) return -1;
    return fsPtr->scandirProc(interp, path, namelist, filter, compar);
}

int Jsi_IsNative(Jsi_Interp *interp, Jsi_Value *file) {
    void *data;
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, file, &data);
    if (fsPtr && fsPtr == &jsiFilesystem)
        return 1;
    else
        return 0;
}

static Jsi_Filesystem *jsi_FilesysFind(const char *name)
{
    FSList *fsPtr = jsiFSList;
    while (fsPtr != NULL) {
        if (!Jsi_Strcmp(fsPtr->fsPtr->typeName, name))
            return fsPtr->fsPtr;
        fsPtr = fsPtr->next;
    }
    return NULL;
}

Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)
{
    /* Find fsys, and use open there. */
    Jsi_Filesystem *fsPtr;
    Jsi_Chan *ch = NULL;
    void *data;
    const char *fileName = Jsi_ValueToString(interp, file, NULL);
    const char *s = modeString;
    char Mode[sizeof(ch->modes)];
    Jsi_StatBuf sb;
    Jsi_Value *path = NULL;
    int n, i, mode = 0, rc, writ;
    if (!s)
        s = "r";
    if (Jsi_Strlen(s) >= sizeof(ch->modes)) {
        Jsi_LogError("mode too long: %s", s);
        return NULL;
    }
    if (Jsi_Strchr(s, 'z') || Jsi_Strchr(s, 'Z')) {
        Jsi_Filesystem *fsPtr = jsi_FilesysFind("jfz");
        if (!fsPtr) {
            Jsi_LogError("compressed files unsupported");
            return NULL;
        }
        ch = fsPtr->openProc(interp, file, s);
        if (!ch)
            return NULL;
        Jsi_Chan *nch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*nch));
        *nch = *ch;
        nch->fsPtr = fsPtr;
        return nch;
    }
    for (i=0, n = 0; s[i]; i++) {
        switch (s[i]) {
            case '+': break;
            case 'b': break;
            case 'r': if (!strchr(s,'+')) mode |= JSI_FS_READONLY; break;
            case 'a':
            case 'w': if (!strchr(s,'+')) mode |= JSI_FS_WRITEONLY; break;
            default: Jsi_LogError("unknown mode char: %c", s[i]); return NULL;
        }
        Mode[n++] = s[i];
    }
    Mode[n] = 0;
    /* Fixup files in the ~ dir */
    rc = Jsi_Stat(interp, file,&sb);
    if ((rc != 0 || *fileName == '~') && (fileName = Jsi_FileRealpath(interp, file, NULL))) {
        path = Jsi_ValueNewString(interp, fileName, -1);
        Jsi_IncrRefCount(interp, path);
        rc = Jsi_Stat(interp, path, &sb);
        if (rc == 0)
            file = path;
    }

    if (rc == 0 &&  sb.st_mode & S_IFDIR )
    {
        Jsi_LogError("can not open a directory");
        goto done;
    }
    fsPtr = Jsi_FilesystemForPath(interp, file, &data);
    writ = (strchr(s,'w') || strchr(s,'a') || strchr(s,'+'));
    if (interp->isSafe && Jsi_InterpAccess(interp, file, writ) != JSI_OK) {
        Jsi_LogError("%s access denied", writ?"write":"read");
        goto done;
    }
    if (fsPtr && fsPtr != &jsiFilesystem) {
        ch = fsPtr->openProc(interp, file, Mode);
        if (ch)
            ch->isNative = 0;
    } else {
        FILE *fp = fopen(fileName, Mode);
        fsPtr = &jsiFilesystem;
        if (!fp)
            goto done;
        ch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*ch));
        ch->fp = fp;
        ch->isNative = 1;
    }
    if (ch) {
        ch->flags |= mode; // + (zLevel<<24);
        Jsi_Strcpy(ch->modes, s);
        ch->interp = interp;
        ch->fsPtr = fsPtr;
        ch->fname = fileName;
    }
done:
    if (path)
        Jsi_DecrRefCount(interp, path);
    return ch;
}

int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName,
    const char *newValue) {return JSI_OK;}
    
Jsi_Wide Jsi_Seek(Jsi_Channel chan, Jsi_Wide offset, int mode) {
    if (!chan->fsPtr->seekProc) return -1;
    return chan->fsPtr->seekProc(chan, offset, mode);
}
Jsi_Wide Jsi_Tell(Jsi_Channel chan) {
    if (!chan->fsPtr->tellProc) return -1;
    return chan->fsPtr->tellProc(chan);
}
int Jsi_Eof(Jsi_Channel chan) {
    if (!chan->fsPtr->eofProc) return -1;
    return chan->fsPtr->eofProc(chan);
}
Jsi_Wide Jsi_Rewind(Jsi_Channel chan) {
    if (!chan->fsPtr->rewindProc) return -1;
    return chan->fsPtr->rewindProc(chan);
}

/*Jsi_StatBuf* Jsi_AllocStatBuf(void) {return 0;}*/

int Jsi_Read(Jsi_Channel chan, char *bufPtr, int toRead) {
    if (!chan->fsPtr->readProc) return -1;
    return chan->fsPtr->readProc(chan, bufPtr, toRead);
}
int Jsi_Write(Jsi_Channel chan, const char *bufPtr, int slen) {
    if (!chan->fsPtr->writeProc) return -1;
    return chan->fsPtr->writeProc(chan, bufPtr, slen);
}
int Jsi_Truncate(Jsi_Channel chan, unsigned int len) {
    if (!chan->fsPtr->truncateProc) return -1;
    return chan->fsPtr->truncateProc(chan, len);
}

int Jsi_Close(Jsi_Channel chan) {
    if (!chan->fsPtr->closeProc) return -1;
    if (chan->flags&JSI_FS_NOCLOSE) return -1;
    int rc = chan->fsPtr->closeProc(chan);
    if (rc == 0)
        Jsi_Free(chan);
    return rc;
}
int Jsi_Flush(Jsi_Channel chan) {
    if (!chan->fsPtr->flushProc) return -1;
    return chan->fsPtr->flushProc(chan);
}

int Jsi_Getc(Jsi_Channel chan) {
    if (!chan->fsPtr->getcProc) return -1;
    return chan->fsPtr->getcProc(chan);
}

int Jsi_Ungetc(Jsi_Channel chan, int ch) {
    if (!chan->fsPtr->ungetcProc) return -1;
    return chan->fsPtr->ungetcProc(chan, ch);
}

char * Jsi_Gets(Jsi_Channel chan, char *s, int size) {
    if (!chan->fsPtr->getsProc) return NULL;
    return chan->fsPtr->getsProc(chan, s, size);
}

int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path) {
    void *data;
    int rc = 0;
    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);
    if (interp->isSafe && Jsi_InterpAccess(interp, path, 0) != JSI_OK) {
            Jsi_LogError("read access denied");
            return JSI_ERROR;
    }
    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);
    if (fsPtr == &jsiFilesystem) {
        rc = chdir(pathPtr);
        if (rc < 0)
            return -1;
        /* If change out of native fs, GetCwd will use pwdStr */
        fsPtr = NULL;
    }
    Jsi_DSSetLength(&pwdStr, 0);
    Jsi_DSAppendLen(&pwdStr, pathPtr, -1);
    cwdFsPtr = fsPtr;
    jsi_pwd = fsPtr ? Jsi_DSValue(&pwdStr) : NULL;
    return rc;
}

char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *file, Jsi_DString *dStr) {
    return Jsi_NormalPath(interp, Jsi_ValueString(interp, file, NULL), dStr);
}

char *Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *spath, char *newname)
{
    char *path = Jsi_ValueString(interp, spath, 0);
    if (!path) return NULL;
    return Jsi_FileRealpathStr(interp, path, newname);
}

static char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *src, char *newPath) {
    return Jsi_FileRealpath(interp, src, newPath);
}

char *Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *src, char *newname)
{
    /* TODO: resolve pwd first. */
    void *data;
    Jsi_Filesystem *fsPtr;
    Jsi_DString dStr;
    const char *npath = Jsi_ValueNormalPath(interp, src, &dStr);
    Jsi_Value *tPtr = Jsi_ValueNew1(interp);
    Jsi_ValueMakeStringDup(interp, &tPtr, npath);
    fsPtr = Jsi_FilesystemForPath(interp, tPtr, &data);
    Jsi_DSFree(&dStr);
    Jsi_DecrRefCount(interp, tPtr);
    if (fsPtr == NULL || !fsPtr->realpathProc) return NULL;
    return fsPtr->realpathProc(interp, src, newname);
}


static void fileObjErase(FileObj *fo)
{
    if (fo->filename) {
        Jsi_Close(fo->chan);
        Jsi_Free(fo->filename);
        Jsi_DecrRefCount(fo->interp, fo->fname);
        Jsi_Free(fo->mode);
    }
    fo->filename = NULL;
}

static int fileObjFree(Jsi_Interp *interp, void *data)
{
    FileObj *fo = (FileObj *)data;
    SIGASSERT(fo,FILEOBJ);
    fileObjErase(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static int fileObjIsTrue(void *data)
{
    FileObj *fo = (FileObj *)data;
    SIGASSERT(fo,FILEOBJ);
    if (!fo->filename) return JSI_OK;
    else return 1;
}

static int fileObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

static int try_open_file(Jsi_Interp *interp, FileObj *udf, Jsi_Value *args)
{
    int ret = JSI_ERROR;
    fileObjErase(udf);
    // TODO: stdin, stdout, stderr, etc.
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    if (fname && Jsi_ValueIsString(interp, fname)) {
        Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 1);
        const char *mode = NULL;
        const char *fstr = Jsi_ValueString(interp, fname, NULL);
        if (vmode && Jsi_ValueIsString(interp,vmode)) {
            mode = Jsi_ValueString(interp, vmode, NULL);
        }
        if (interp->isSafe && Jsi_InterpAccess(interp, fname, (mode && (strchr(mode,'w')||strchr(mode,'+')))) != JSI_OK)
            return JSI_ERROR;
        char *rmode = Jsi_Strdup(mode ? mode : "r");
        Jsi_Channel chan = Jsi_Open(interp, fname, rmode);
        if (chan) {
            udf->chan = chan;
            udf->fname = fname;
            udf->interp = interp;
            Jsi_IncrRefCount(interp, fname);
            udf->filename = Jsi_Strdup(fstr);
            udf->mode = Jsi_Strdup(rmode);
            ret = JSI_OK;
        }
        Jsi_Free(rmode);
    }
    return ret;
}

#define UdfGet(udf, _this, funcPtr) \
   FileObj *udf = (FileObj *)Jsi_UserObjGetData(interp, _this, funcPtr); \
    if (!udf) { \
        Jsi_LogError("File.%s called with non-file object\n", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    }

static int FilesysOpenCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    if (try_open_file(interp, udf, args) != JSI_OK) {
        Jsi_ValueMakeBool(interp, ret, 0);
    }
    Jsi_ValueMakeBool(interp, ret, 1);
    return JSI_OK;
}

static int FilesysCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    fileObjErase(udf);
    Jsi_ValueMakeBool(interp, ret, 1);
    return JSI_OK;
}

static int FilesysGetsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int len;
    UdfGet(udf, _this, funcPtr);
    if (!udf->filename) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    char buf[BUFSIZ>8196?BUFSIZ:8196];
    if (!Jsi_Gets(udf->chan, buf, sizeof(buf))) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    buf[sizeof(buf)-1] = 0;
    len = strlen(buf);
    if (len > 0 && buf[len-1] == '\n')
        buf[len-1] = 0;
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(buf));
    return JSI_OK;
}


static int FilesysModeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    if (udf->mode)
        Jsi_ValueMakeStringKey(interp, ret, udf->mode);
    return JSI_OK;
}

static int FilesysFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    if (udf->filename)
        Jsi_ValueMakeString(interp, ret, Jsi_Strdup(udf->filename));
    return JSI_OK;
}

static int FilesysReadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int  sum = 0, n;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    UdfGet(udf, _this, funcPtr);
    char buf[BUFSIZ];
    int argc = Jsi_ValueGetLength(interp, args);
    int nsiz = -1, cnt = 0, rsiz;
    
    if (!udf->filename) {
        goto bail;
    }
    if (argc>0 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &nsiz) != JSI_OK)
        goto bail;
    while (cnt++ < MAX_LOOP_COUNT) {
        /* TODO: limit max size. */
        rsiz = sizeof(buf);
        if (nsiz>0 && ((sum+n)>nsiz))
            rsiz = (nsiz-sum);
        if ((n = Jsi_Read(udf->chan, buf, rsiz)) <= 0)
            break;
        Jsi_DSAppendLen(&dStr, buf, n);
        sum += n;
        if (nsiz>=0 && sum >=nsiz)
            break;
    }
    Jsi_ValueMakeDStringObject(interp, ret, &dStr);
    return JSI_OK;
    
bail:
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeUndef(interp, ret);
    return JSI_OK;
}


static int FilesysSeekCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    static const char *posStr[] = { "set", "cur", "end", NULL };
    enum { W_SET, W_CUR, W_END };
    UdfGet(udf, _this, funcPtr);
    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vWhence = Jsi_ValueArrayIndex(interp, args, 1);
    int mode = 0, p;
    Jsi_Wide pos;
    Jsi_Number num;
    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)
        return JSI_ERROR;
    if (Jsi_ValueGetIndex(interp, vWhence, posStr, "position", 0, &p) != JSI_OK)
        return JSI_ERROR;
    switch (p) {
        case W_SET: mode = SEEK_SET; break;
        case W_CUR: mode = SEEK_CUR; break;
        case W_END: mode = SEEK_END; break;
    }
    pos = (Jsi_Wide)num;
    pos = Jsi_Seek(udf->chan, pos, mode);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);
    return JSI_OK;
}

static int FilesysTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Number num;
    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)
        return JSI_ERROR;
    num = (Jsi_Number)Jsi_Truncate(udf->chan, (unsigned int)num);
    Jsi_ValueMakeNumber(interp, ret, num);
    return JSI_OK;
}

static int FilesysStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 0);
}

static int FilesysLstatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 1);
}

static int FilesysTellCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    Jsi_Wide pos = Jsi_Tell(udf->chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);
    return JSI_OK;
}

static int FilesysFlushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    int pos = Jsi_Flush(udf->chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);
    return JSI_OK;
}

static int FilesysWriteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int  sum = 0, n, m;
    UdfGet(udf, _this, funcPtr);
    char *buf = Jsi_ValueArrayIndexToStr(interp, args, 0, &m);

    if (!udf->filename) {
        goto bail;
    }
    while (m > 0 && sum < MAX_LOOP_COUNT && (n = Jsi_Write(udf->chan, buf, m)) > 0) {
        /* TODO: limit max size. */
        sum += n;
        m -= n;
    }
bail:
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sum);
    return JSI_OK;
}

static int FilesysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
   
    UdfGet(udf, _this, funcPtr);
    if (!udf->filename) {
        Jsi_ValueMakeBool(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *toput = Jsi_ValueArrayIndex(interp, args, 0);
    if (!toput) {
        Jsi_ValueMakeBool(interp, ret, 0);
        return JSI_OK;
    }
    const char * cp = Jsi_ValueToString(interp, toput, NULL);

    if (Jsi_Printf(udf->chan, "%s\n", cp?cp:"") < 0) {
        Jsi_ValueMakeBool(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_ValueMakeBool(interp, ret, 1);
    return JSI_OK;
}

static int FilesysEofCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    UdfGet(udf, _this, funcPtr);
    Jsi_ValueMakeBool(interp, ret, Jsi_Eof(udf->chan));
    return JSI_OK;
}

int Jsi_Printf(Jsi_Channel chan, const char *fmt, ...)
{
    va_list va;
    int n;
    FILE *fp = (chan && chan->fp ? chan->fp : stdout);
    va_start(va,fmt);
    n = vfprintf(fp, fmt, va);
    va_end(va);
    return n;
}


static int FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);
    

static Jsi_CmdSpec filesysCmds[] = {
    { "Channel",   FilesysConstructor,1,  2,  "file:string, mode:string='r'", JSI_CMD_IS_CONSTRUCTOR, .help="A file input/output object. The mode string is r or w and an optional +", .retType=(uint)JSI_TT_USEROBJ },
    { "close",  FilesysCloseCmd,   0,  0, "", .help="close the file", .retType=(uint)JSI_TT_VOID },
//    { "conf",   FilesysConfCmd,     0,  1, "val:string|options",.help="Configure options" , .opts=filesysOptions},
    { "eof",    FilesysEofCmd,     0,  0, "", .help="Return true if read to end-of-file", .retType=(uint)JSI_TT_BOOL },
    { "filename", FilesysFilenameCmd, 0,  0, "", .help="Get file name", .retType=(uint)(uint)JSI_TT_STRING },
    { "flush",  FilesysFlushCmd,   0,  0, "", .help="Flush file output", .retType=(uint)JSI_TT_NUMBER },
    { "gets",   FilesysGetsCmd,    0,  0, "", .help="Get one line of input", .retType=(uint)JSI_TT_STRING },
    { "lstat",  FilesysLstatCmd,   0,  0, "", .help="Return status for file", .retType=(uint)JSI_TT_OBJECT },
    { "mode",   FilesysModeCmd,    0,  0, "", .help="Get file mode used with open", .retType=(uint)JSI_TT_STRING },
    { "open",   FilesysOpenCmd,    1, -1, "file:string, mode:string='r'", .help="Open the file (after close)", .retType=(uint)JSI_TT_BOOL },
    { "puts",   FilesysPutsCmd,    1,  1, "str", .help="Write one line of output", .retType=(uint)JSI_TT_BOOL },
    { "read",   FilesysReadCmd,    0,  1, "size:number=-1", .help="Read some or all of file", .retType=(uint)JSI_TT_STRING },
    { "seek",   FilesysSeekCmd,    2,  2, "pos:number, whence:number", .help="Seek to position. Return 0 if ok", .retType=(uint)JSI_TT_NUMBER },
    { "stat",   FilesysStatCmd,    0,  0, "", .help="Return status for file", .retType=(uint)JSI_TT_OBJECT },
    { "truncate",FilesysTruncateCmd,    1,  1, "pos:number", .help="Truncate file", .retType=(uint)JSI_TT_NUMBER },
    { "tell",   FilesysTellCmd,    0,  0, "", .help="Return current position", .retType=(uint)JSI_TT_NUMBER },
    { "write",  FilesysWriteCmd,   1,  1, "data", .help="Write data to file", .retType=(uint)JSI_TT_NUMBER },
    { NULL, .help="Commands for accessing Channel objects for file IO" }
};


static Jsi_UserObjReg fileobject = {
    "Channel",
    filesysCmds,
    fileObjFree,
    fileObjIsTrue,
    fileObjEqual
};

static int FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *that = _this;
    if (!Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "File", o);
        Jsi_ValueMakeObject(interp, ret, o);
        that = *ret;
    }

    FileObj *fobj = (FileObj *)Jsi_Calloc(1,sizeof(*fobj));
    SIGINIT(fobj, FILEOBJ);
    if (try_open_file(interp, fobj, args) != JSI_OK) { /* Error out on open fail */
        Jsi_Free(fobj);
        Jsi_LogError("open failed");
        return JSI_ERROR;
    }
    Jsi_Obj *nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);
    fobj->objId = Jsi_UserObjNew(interp, &fileobject, nobj, fobj);
    if (fobj->objId<0) {
        Jsi_Free(fobj); // TODO: finish cleanup
        return JSI_ERROR;
    }
    fobj->fobj = nobj;
    return JSI_OK;
}

static void SetupStdChan(Jsi_Chan* ch, FILE *fp, Jsi_Filesystem *fsPtr, int flags) {
    memset(ch, 0, sizeof(*ch));
    ch->fp = fp;
    ch->fsPtr = fsPtr;
    ch->flags = flags|JSI_FS_NOCLOSE;
}

Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name)
{
    if (strlen(name)==1) {
        switch (name[0]) {
            case '0' : return StdChans;
            case '1' : return StdChans+1;
            case '2' : return StdChans+2;
        }
    }
    if (!strcmp(name, "stdin")) return StdChans;
    if (!strcmp(name, "stdout")) return StdChans+1;
    if (!strcmp(name, "stderr")) return StdChans+2;
    Jsi_Obj *obj = jsi_UserObjFromName(interp, name);
    if (!obj)
        return NULL;
    Jsi_UserObj *uobj = obj->d.uobj;
    if (uobj->reg != &fileobject)
        return NULL;
    FileObj *fobj = (FileObj *)uobj->data;
    return fobj->chan;
}

int Jsi_DoneFilesys(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &fileobject);
    return JSI_OK;
}

int jsi_FilesysInit(Jsi_Interp *interp)
{

    Jsi_DSInit(&pwdStr);
    Jsi_Hash *fsys;
    if (!(fsys = Jsi_UserObjRegister(interp, &fileobject))) {
        Jsi_LogFatal("Can not init file system\n");
        return JSI_ERROR;
    }
    Jsi_CommandCreateSpecs(interp, fileobject.name, filesysCmds, fsys, 0);
    if (jsiFSList == NULL) {
        Jsi_FSRegister(&jsiFilesystem, NULL);
        SetupStdChan(StdChans, stdin, &jsiFilesystem, JSI_FS_READONLY);
        SetupStdChan(StdChans+1, stdout, &jsiFilesystem, JSI_FS_WRITEONLY);
        SetupStdChan(StdChans+2, stderr, &jsiFilesystem, JSI_FS_WRITEONLY);
    }
#ifndef JSI_OMIT_ZVFS
    Jsi_InitZvfs(interp);
#endif
    return JSI_OK;
}

void jsi_FilesysDone(Jsi_Interp *interp)
{
    Jsi_DoneZvfs(interp);
    while (jsiFSList != NULL) {
        FSList *fsPtr = jsiFSList;
        jsiFSList = fsPtr->next;
        if (fsPtr)
            Jsi_Free(fsPtr);
    }
}

#endif // JSI_LITE_ONLY


const char *jsi_GetHomeDir(Jsi_Interp *interp) {
    const char *str = NULL;
    if (interp->homeDir)
        return interp->homeDir;
#ifdef __WIN32
    str = getenv("USERPROFILE"); /* TODO: windows home dir. */
#else
        
    if ((str = getenv("HOME")) == NULL) {
        struct passwd pwd, *pw;
        char buf[20000];
        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        
            str = pw->pw_dir;
    }
#endif
    if (!str) {
        Jsi_LogBug("no home dir");
        str = "/";
    }
#ifdef JSI_LITE_ONLY
    return str;
#else
    return (interp->homeDir = Jsi_KeyAdd(interp, str));
#endif
}

/* TODO: reconcile with NormalizeUnixPath */
char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr) {
    char prefix[3] = "";
    char cdbuf[PATH_MAX];
    Jsi_DSInit(dStr);
    if (!path) return NULL;
    if (*path == '/')
        Jsi_DSAppend(dStr, path, NULL);
#ifdef __WIN32  /* TODO: add proper handling for windows paths. */
    else if (*path && path[1] == ':') {
        prefix[0] = *path;
        prefix[1] = path[1];
        prefix[2] = 0;
        path += 2;
        goto full;
    }
#endif
    else if (path[0] == '~') {
        Jsi_DSAppend(dStr, jsi_GetHomeDir(interp), (path[1] == '/' ? "" : "/"), path+1, NULL);
    } else if (path[0] == '.' && path[1] == 0) {
        if (jsi_pwd) {
            Jsi_DSAppend(dStr, jsi_pwd, NULL);
        } else {
            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), NULL);
        }
    } else {
#ifdef __WIN32
full:
#endif
        if (jsi_pwd) {
            Jsi_DSAppend(dStr, jsi_pwd, "/", path, NULL);
        } else {
            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), "/", path, NULL);
        }
    }
    Jsi_DString sStr = {};
    char *cp = Jsi_DSValue(dStr);
    int i=0, n=0, m, nmax, unclean=0, slens[PATH_MAX];
    char *sp = cp, *ss;
    char *sptrs[PATH_MAX];
    while (*cp && n<PATH_MAX) {
        while (*cp && *cp == '/') {
            cp++;
            if (*cp == '/')
                unclean = 1;
        }
        sptrs[n] = cp;
        if (cp[0] == '.' && (cp[1] == '.' || cp[1] == '/'))
            unclean = 1;
        ss = cp++;
        while (*ss && *ss != '/')
            ss++;
        slens[n++] = (ss-cp) + 1;
        cp = ss;
    }
    if (!unclean)
        return sp;
    /* Need to remove //, /./, /../ */
    nmax = n--;
    while (n>0) {
        if (slens[n]<=0) {
            n--;
            continue;
        }
        if (strncmp(sptrs[n],".",slens[n])==0)
            slens[n] = 0;
        else if (strncmp(ss,"..",slens[n])==0) {
            int cnt = 0;
            m = n-1;
            while (m>=0 && cnt<1) {
                if (slens[m])
                    cnt++;
                slens[m] = 0;
                m--;
            }
            if (cnt<1)
                return sp;  /* Can't fix it */
        }
        n--;
    }
    /* TODO: prefix for windows. */
    Jsi_DSAppend(&sStr, prefix, NULL);
    for (i=0; i<nmax; i++) {
        if (slens[i]) {
            Jsi_DSAppend(&sStr, "/", NULL);
            Jsi_DSAppendLen(&sStr, sptrs[i], slens[i]);
        }
    }
    Jsi_DSSetLength(dStr, 0);
    Jsi_DSAppend(dStr, Jsi_DSValue(&sStr), NULL);
    Jsi_DSFree(&sStr);
    return Jsi_DSValue(dStr);
}

char * Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr) {
    char cdbuf[PATH_MAX];
    Jsi_DSInit(cwdPtr);
    if (cwdFsPtr)
        Jsi_DSAppend(cwdPtr, Jsi_DSValue(&pwdStr), NULL);
    else
        Jsi_DSAppend(cwdPtr, getcwd(cdbuf, sizeof(cdbuf)), NULL);
    return Jsi_DSValue(cwdPtr);
}

#ifdef __WIN32
#define realpath(R,N) _fullpath(N,R, _MAX_PATH)

/* For ridding backslashes from env vars */
static void DeBackSlashify(char *cp) {
    char *dp = cp;
    while (*cp) {
        if (*cp == '\\') {
            *dp = '/';
        } else
            *dp = *cp;
        cp++; dp++;
    }
    *dp = 0;
}
#endif

static void NormalizeUnixPath(Jsi_Interp *interp, char *path) {
    char **argv; int argc, i;
    if (!strstr(path, "./")) return;
    Jsi_DString dStr = {}, eStr = {};
    if (path[0] != '/' && strstr(path, "..")) {
        char *npath = Jsi_GetCwd(interp, &eStr);
        if (npath && strcmp(npath,"/")) {
            Jsi_DSAppend(&eStr, "/", path, NULL);
            path = Jsi_DSValue(&eStr);
        }
    }
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    Jsi_SplitStr(path, &argc, &argv, "/", &sStr);
    char *cp = path;
    *cp = 0;
    for (i=0; i<argc; i++) {
        if (i == 0 && argv[0][0] == 0) {
            continue;
        } else if (argv[i][0] == 0) {
            continue;
        } else if (!strcmp(argv[i],".")) {
            continue;
        } else if (!strcmp(argv[i],"..")) {
            char *pcp = dStr.str;
            pcp = strrchr(pcp, '/');
            if (pcp && pcp != dStr.str) {
                *pcp = 0;
            }
            continue;
        } else {
            Jsi_DSAppend(&dStr, "/", argv[i], NULL);
        }
    }
    Jsi_DSFree(&sStr);
    Jsi_Strcpy(path, dStr.str);
    Jsi_DSFree(&dStr);
    Jsi_DSFree(&eStr);
}

char *Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newname)
{
    if (!path) return NULL;
    Jsi_DString dStr;
    char *npath = (char*)path, *apath;
    Jsi_DSInit(&dStr);
    if (*path == '~') {
#ifndef __WIN32
        struct passwd pw, *pwp; /* TODO: could fallback to using env HOME. */
        char buf[BUFSIZ];
        int n = getpwuid_r(getuid(), &pw, buf, sizeof(buf), &pwp);
        const char *homedir = (n == 0 ? pwp->pw_dir : "");
        Jsi_DSAppend(&dStr, homedir, path[1] == '/' ? "" : "/", path+1, NULL);
#else
        const char *homedir = getenv("HOMEPATH");
        if (!homedir) homedir = "/";
        const char *homedrv = getenv("HOMEDRIVE");
        if (!homedrv) homedrv = "";
        Jsi_DSAppend(&dStr, homedrv, homedir, path[1] == '/' ? "" : "/", path+1, NULL);
#endif
        npath = Jsi_DSValue(&dStr);
    }
    apath = realpath(npath, newname);
    if (!apath) {
        apath = Jsi_Strdup(npath);
#ifndef __WIN32
        /* If path not exists on unix we try to eliminate ../ and /./ etc.*/
        NormalizeUnixPath(interp, apath);
#endif
    }
#ifdef __WIN32
    DeBackSlashify(apath);
#endif
    Jsi_DSFree(&dStr);
    return apath;
}

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#ifdef __WIN32
char *strcasestr(const char *haystack, const char *needle)
{
        int nlen = strlen(needle);
        int hlen = strlen(haystack) - nlen + 1;
        int i;

        for (i = 0; i < hlen; i++) {
                int j;
                for (j = 0; j < nlen; j++) {
                        unsigned char c1 = haystack[i+j];
                        unsigned char c2 = needle[j];
                        if (toupper(c1) != toupper(c2))
                                goto next;
                }
                return (char *) haystack + i;
        next:
                ;
        }
        return NULL;
}
#endif

uint Jsi_Strlen(const char *str) {
    return strlen(str);
}

int Jsi_Strncasecmp(const char *str1, const char *str2, int n)
{
    if (n<0)
        return strcasecmp(str1,str2);
    return strncasecmp(str1,str2,n);
}
int Jsi_Strncmp(const char *str1, const char *str2, int n)
{
   return strncmp(str1,str2,n);
}

uint Jsi_StrlenSet(const char *str, uint len) {
    char *s = (char*)str;
    uint olen = strlen(str);
    assert(len>=0);
    if (olen<len)
        return olen;
    s[len] = 0;
    return len;
}

char *Jsi_Strdup(const char *str) {
    return strdup(str);
}

char *jsi_SubstrDup(const char *a, int start, int len)
{
    if (len == 0) return Jsi_Strdup("");
    
    int lenofa = Jsi_Strlen(a);
    while (start < 0) start += lenofa;
    if (start >= lenofa) return Jsi_Strdup("");
    
    int maxcpy = lenofa - start;
    
    if (len > 0) {
        maxcpy = maxcpy < len ? maxcpy : len;
    }
    
    char *r = (char*)Jsi_Malloc(maxcpy + 1);

    Jsi_Strncpy(r, a + start, maxcpy + 1);
    return r;
}


char* Jsi_Strchr(const char *str, int c)
{
    return strchr((char*)str, c);
}

char* Jsi_Strcpy(char *dst, const char *src)
{
    return strcpy(dst, src);
}

char* Jsi_Strncpy(char *str1, const char *str2, int len)
{
    char* cp = strncpy(str1, str2, len-1);
    str1[len-1] = 0;
    return cp;
}

int Jsi_Strcmp(const char *str1, const char *str2)
{
    return strcmp(str1, str2);
}

int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict)
{
    if (dict==0)
        return (nocase ? Jsi_Strncasecmp(str1,str2, -1) : strcmp(str1, str2));
    return Jsi_DictionaryCompare(str1, str2);
}

char *Jsi_Strcatdup(const char *str1, const char *str2)
{
    int l1 = strlen(str1), l2 = strlen(str2);
    char *cp = (char*)Jsi_Malloc(l1+l2+1);
    strcpy(cp, str1);
    return strcat(cp, str2);
}


int Jsi_Strpos(const char *str, int start, const char *s2, int nocase)
{
    const char *sstr = str;
    int len = strlen(str);
    if (len<start)
        return -1;
    str += start;
    const char *s = (nocase?strcasestr(str,s2):strstr(str, s2));
    if (!s)
        return -1;
    return (s-sstr);
}

int Jsi_Strrpos(const char *str, int start, const char *s2, int nocase)
{
    const char *sstr = str, *s, *os = NULL;
    int len = strlen(str);
    if (len<start)
        return -1;
    str += start;
    while (*str && (s = (nocase?strcasestr(str,s2):strstr(str, s2)))) {
        os = s;
        str += 1;
    }
    if (!os)
        return -1;
    return (os-sstr);
}

int
Jsi_DictionaryCompare( const char *left, const char *right)
{
  int diff, zeros;
  int secondaryDiff = 0;

  while (1) {
    if (isdigit(UCHAR(*right)) && isdigit(UCHAR(*left))) {
      /*
       * There are decimal numbers embedded in the two
       * strings.  Compare them as numbers, rather than
       * strings.  If one number has more leading zeros than
       * the other, the number with more leading zeros sorts
       * later, but only as a secondary choice.
       */

      zeros = 0;
      while ((*right == '0') && (isdigit(UCHAR(right[1])))) {
        right++;
        zeros--;
      }
      while ((*left == '0') && (isdigit(UCHAR(left[1])))) {
        left++;
        zeros++;
      }
      if (secondaryDiff == 0) {
        secondaryDiff = zeros;
      }

      /*
       * The code below compares the numbers in the two
       * strings without ever converting them to integers.  It
       * does this by first comparing the lengths of the
       * numbers and then comparing the digit values.
       */

      diff = 0;
      while (1) {
        if (diff == 0) {
          diff = UCHAR(*left) - UCHAR(*right);
        }
        right++;
        left++;
        /* Ignore commas in numbers. */
        if (*left == ',') {
          left++;
        }
        if (*right == ',') {
          right++;
        }
        if (!isdigit(UCHAR(*right))) {
          if (isdigit(UCHAR(*left))) {
            return 1;
          } else {
            /*
             * The two numbers have the same length. See
             * if their values are different.
             */

            if (diff != 0) {
              return diff;
            }
            break;
          }
        } else if (!isdigit(UCHAR(*left))) {
          return -1;
        }
      }
      continue;
    }
    diff = UCHAR(*left) - UCHAR(*right);
    if (diff) {
      if (isupper(UCHAR(*left)) && islower(UCHAR(*right))) {
        diff = UCHAR(tolower(*left)) - UCHAR(*right);
        if (diff) {
          return diff;
        } else if (secondaryDiff == 0) {
          secondaryDiff = -1;
        }
      } else if (isupper(UCHAR(*right)) && islower(UCHAR(*left))) {
        diff = UCHAR(*left) - UCHAR(tolower(UCHAR(*right)));
        if (diff) {
          return diff;
        } else if (secondaryDiff == 0) {
          secondaryDiff = 1;
        }
      } else {
        return diff;
      }
    }
    if (*left == 0) {
      break;
    }
    left++;
    right++;
  }
  if (diff == 0) {
    diff = secondaryDiff;
  }
  return diff;
}

#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define ChkString0(_this, funcPtr) \
    if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_STRING) { \
        Jsi_LogError("apply String.%s to a non-string object\n", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    }
    
#define ChkString(_this, funcPtr, dest, lenPtr) \
    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \
       _this->d.obj->__proto__ == interp->String_prototype->d.obj->__proto__ ) { \
        skip = 1; \
        dest = Jsi_ValueArrayIndexToStr(interp, args, 0, lenPtr); \
    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_STRING) { \
        Jsi_LogError("apply String.%s to a non-string object\n", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    } else  { \
        dest = Jsi_ValueString(interp, _this, lenPtr); \
        if (!dest) dest = (char*)""; \
    }

static int StringConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        const char *nv = "";
        if (Jsi_ValueGetLength(interp, args) > 0) {
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
            if (v) {
                
                nv = Jsi_ValueToString(interp, v, NULL);
            }
        }
        _this->d.obj->ot = JSI_OT_STRING;
        _this->d.obj->d.s.str = Jsi_Strdup(nv);
        _this->d.obj->d.s.len = -1;
        //Jsi_ObjSetLength(interp, _this->d.obj, Jsi_Strlen(nv));
        /*
        int i;
        int len = Jsi_Strlen(nv);
        for (i = 0; i < len; ++i) {
            Jsi_Value *v = Jsi_ValueNew(interp);
            Jsi_ValueMakeString(interp,v, jsi_SubstrDup(nv, i, 1));

            jsi_ValueInsertArray(interp, _this, i, v, JSI_OM_DONTDEL|JSI_OM_DONTENUM);
        }*/
        
        return JSI_OK;
    }
    if (Jsi_ValueGetLength(interp, args) > 0) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueDup2(interp, ret, v);
            Jsi_ValueToString(interp, *ret, NULL);
            return JSI_OK;
        }
    }
    Jsi_ValueMakeStringDup(interp, ret, "");
    return JSI_OK;
}

static int StringFromCharCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char unibuf[BUFSIZ+1], *u = unibuf;
    //ChkString0(_this, funcPtr);
    
    int len = Jsi_ValueGetLength(interp, args);
    int i;

    if (len > BUFSIZ)
        len = BUFSIZ;
    
    unibuf[len] = 0;

    for (i = 0; i < len; ++i) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);
        if (!v) Jsi_LogBug("Arguments Jsi_LogError\n");

        Jsi_ValueToNumber(interp, v);
        u[i] = (char) v->d.num;
    }
    u[i] = 0;
    Jsi_ValueMakeStringDup(interp, ret, unibuf);
    return JSI_OK;
}


static int StringSplitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char **argv; int argc;
    int skip = 0, rc = JSI_OK;
    char *v;
    
    ChkString(_this, funcPtr, v, NULL);

    Jsi_Value *spliton = Jsi_ValueArrayIndex(interp, args, skip);
    
    if (!spliton || !Jsi_ValueIsString(interp, spliton)) {
        Jsi_ValueMakeStringDup(interp, ret, v);
        return JSI_OK;
    }
    char* split = Jsi_ValueString(interp, spliton, NULL);

    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    Jsi_SplitStr(v, &argc, &argv, split, &sStr);
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    if (Jsi_ObjArraySizer(interp, obj, argc) <= 0) {
        Jsi_LogError("index too large: %d", argc);
        rc = JSI_ERROR;
        Jsi_ObjFree(interp, obj);
        goto bail;
    }
    Jsi_ValueMakeArrayObject(interp, ret, obj);
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_Value *v = Jsi_ValueNewStringDup(interp, argv[i]);
        Jsi_IncrRefCount(interp, v);
        obj->arr[i] = v;
    }
    Jsi_ObjSetLength(interp, obj, argc);
    
bail:
    Jsi_DSFree(&sStr);
    return rc;
}

static int StringSubstrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *v;
    ChkString(_this, funcPtr, v, NULL);

    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *len = Jsi_ValueArrayIndex(interp, args, skip+1);
    
    Jsi_Number nstart, nlen;
    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {
        Jsi_ValueMakeStringDup(interp, ret, v);
        return JSI_OK;
    }
    int istart = (int)nstart;
    if (!len || Jsi_GetNumberFromValue(interp,len, &nlen) != JSI_OK) {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, -1));
        return JSI_OK;
    }
    int ilen = (int)nlen;
    if (ilen <= 0) {
        Jsi_ValueMakeStringDup(interp, ret, "");
    } else {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, ilen));
    }
    return JSI_OK;
}

static int StringSubstringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0, ilen = 0;
    char *v;
    ChkString(_this, funcPtr, v, &ilen);

    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, skip+1);
    
    Jsi_Number nstart, nend;
    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {
        Jsi_ValueMakeStringDup(interp, ret, v);
        return JSI_OK;
    }
    int istart = (int)nstart;
    
    if (!end || Jsi_GetNumberFromValue(interp,end, &nend) != JSI_OK) {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, -1));
        return JSI_OK;
    }
    int iend = (int)nend;
    if (iend>ilen)
        iend = ilen;
    if (iend < istart) {
        Jsi_ValueMakeStringDup(interp, ret, "");
    } else {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(v, istart, iend-istart+1));
    }
    return JSI_OK;
}


static int StringIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *v;
    ChkString(_this, funcPtr, v, NULL);

    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip+1);

    if (!seq) {
        Jsi_ValueMakeNumber(interp,ret, -1);
        return JSI_OK;
    }

    const char *vseq = Jsi_ValueToString(interp, seq, NULL);
    int istart = 0;
    if (start) {
        if (Jsi_GetIntFromValue(interp, start, &istart)) {
            return JSI_ERROR;
        }
        if (istart < 0) istart = 0;
    }

    int r = Jsi_Strpos(v, istart, vseq, 0);
    Jsi_ValueMakeNumber(interp, ret, r);

    return JSI_OK;
}

static int StringMatchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *source_str;
    ChkString(_this, funcPtr, source_str, NULL);
    //int source_len = Jsi_Strlen(source_str);
    char *v = source_str;
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);

    if (Jsi_ValueIsString(interp, seq)) {
        char *cp = Jsi_ValueString(interp, seq, NULL);

        if (jsi_RegExpValueNew(interp, cp, seq) != JSI_OK)
            return JSI_ERROR;
    }
    /* TODO: differentiate from re.exec() */
    return Jsi_RegExpMatches(interp, seq, v, *ret);
}

static int StringCharCodeAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *ttPtr = Jsi_ValueNew1(interp);
    Jsi_ValueCopy(interp, ttPtr, _this);
    const char *ttStr = Jsi_ValueToString(interp, ttPtr, NULL);
    
    int slen = Jsi_Strlen(ttStr);
    int pos = 0;
    Jsi_Value *vpos;
    if ((vpos = Jsi_ValueArrayIndex(interp, args, 0))) {
        jsi_ValueToOInt32(interp, vpos);
        pos = (int)vpos->d.num;
    }

    if (pos < 0 || pos >= slen) {
        Jsi_ValueMakeNumber(interp, ret, jsi_ieee_makenan());
    } else {
        Jsi_ValueMakeNumber(interp, ret, ttStr[pos]);
    }
    Jsi_DecrRefCount(interp, ttPtr);
    return JSI_OK;
}


static int _StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int ends)
{
    int skip = 0;
    const char *tstr = " \t\n\r", *vstr;
    int vend,  n, slen = Jsi_Strlen(tstr), vlen;
    ChkString(_this, funcPtr, vstr, &vlen);
    
    Jsi_Value *tchars = Jsi_ValueArrayIndex(interp, args, skip);
    
    if (tchars) {
        tstr = Jsi_ValueToString(interp, tchars, NULL);
        slen = Jsi_Strlen(tstr);
    }
    
    if (ends&1) {
        while (*vstr) {
            for (n=0; n<slen; n++)
                if (tstr[n] == *vstr) break;
            if (n>=slen) break;
            vstr++;
            vlen--;
        }
    }
    vend = vlen-1;
    if (ends&2) {
        for (; vend>=0; vend--) {
            for (n=0; n<slen; n++)
                if (tstr[n] == vstr[vend]) break;
            if (n>=slen) break;
        }
    }
    Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(vstr, 0, vend+1));
    return JSI_OK;
}

static int StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 3);
}
static int StringTrimLeftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 1);
}

static int StringTrimRightCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 2);
}


static char *unistrdup_tolower(const char *str)
{
    char *cp, *s;
    cp = s = (char*)Jsi_Strdup(str);
    while (*cp) {
        *cp = tolower(*cp);
        cp++;
    }
    return s;
}

static char *unistrdup_toupper(const char *str)
{
    char *cp, *s;
    cp = s = (char*)Jsi_Strdup(str);
    while (*cp) {
        *cp = toupper(*cp);
        cp++;
    }
    return s;
}

static int StringToLowerCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *str, *vstr;
    ChkString(_this, funcPtr, vstr, NULL);
    skip = skip;
    str = unistrdup_tolower(vstr);
    Jsi_ValueMakeString(interp, ret, str);
    return JSI_OK;
}

static int StringToUpperCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *str, *vstr;
    ChkString(_this, funcPtr, vstr, NULL);
    skip = skip;

    str = unistrdup_toupper(vstr);
    Jsi_ValueMakeString(interp, ret, str);
    return JSI_OK;
}

static int StringToTitleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *str, *vstr;
    ChkString(_this, funcPtr, vstr, NULL);
    skip = skip;
    str = Jsi_Strdup(vstr);
    str[0] = toupper(str[0]);
    Jsi_ValueMakeString(interp, ret, str);
    return JSI_OK;
}

static int StringCharAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int pos = 0, len, skip = 0;
    char *vstr;
    ChkString(_this, funcPtr, vstr, &len);
    skip = skip;
   
    Jsi_Value *vpos = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetIntFromValue(interp, vpos, &pos)) {
        return JSI_ERROR;        
    }
    if (pos<0 || pos >=len)
        Jsi_ValueMakeStringDup(interp, ret, "");
    else
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(vstr, pos, 1));
    return JSI_OK;
}

static int StringLastIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    char *v;
    ChkString(_this, funcPtr, v, NULL);

    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1+skip);

    if (!seq) {
        Jsi_ValueMakeNumber(interp, ret, -1);
        return JSI_OK;
    }

    const char *vseq = Jsi_ValueToString(interp, seq, NULL);
    int istart = 0;
    if (start) {
        if (Jsi_GetIntFromValue(interp, start, &istart)) {
            return JSI_ERROR;
        }
        if (istart < 0) istart = 0;
    }

    int r = Jsi_Strrpos(v, istart, vseq, 0);
    Jsi_ValueMakeNumber(interp, ret, r);

    return JSI_OK;;
}

static int StringConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    const char *vstr;
    ChkString(_this, funcPtr, vstr, NULL);
    
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, vstr, NULL);
    int i, argc = Jsi_ValueGetLength(interp, args);
    for (i=skip; i<argc; i++)
    {
        Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, i);
        if (Jsi_GetStringFromValue(interp, s, &vstr)) {
            Jsi_LogError("String get failure\n");
            Jsi_DSFree(&dStr);
            return JSI_ERROR;
        }
        Jsi_DSAppend(&dStr, vstr, NULL);
    }

    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return JSI_OK;
    
}

static int StringSliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int skip = 0;
    const char *vstr;
    ChkString(_this, funcPtr, vstr, NULL);

    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 1+skip);
    int istart, iend, len = strlen(vstr);

    if (Jsi_GetIntFromValue(interp, start, &istart)) {
        return JSI_ERROR;
    }
    if (istart < 0)
        istart = len-istart;
    if (istart < 0)
        istart = 0;
    if (istart>=len)
        istart = len-1;
    iend = len-1;
    if (end) {
        if (Jsi_GetIntFromValue(interp, end, &iend)) {
            return JSI_ERROR;
        }
        if (iend < 0)
            iend = len+iend;
        if (iend>=len)
            iend = len-1;
        if (iend<istart)
            iend = istart;
    }

    char *r = jsi_SubstrDup(vstr, istart, iend);
    Jsi_ValueMakeString(interp, ret, r);
    return JSI_OK;
}

/*
static int StringFormatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    Jsi_DString dStr = {};
    rc = Jsi_FormatString(interp, args, &dStr);
    if (rc != JSI_OK)
        return rc;
    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}*/
#define MAX_SUB_MATCHES 50

static int StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    /* Now handles perl regex flag extensions.*/
    const char *source_str;
    int source_len;
    const char *replace_str;
    int replace_len;
    int regexec_flags = 0;
    Jsi_Value *seq;
    Jsi_DString dStr = {};
    regex_t *regex;
    Jsi_Regex *re;
    const char *p;
    int skip = 0;

    int offset = 0, n, j, opt_all = 0, num_matches = 0;
    /* Is a generic  String.replace if _this->d.obj is a function */
    ChkString(_this, funcPtr, source_str, &source_len);
    
    seq = Jsi_ValueArrayIndex(interp, args, skip);

    replace_str = Jsi_ValueArrayIndexToStr(interp, args, 1+skip, &replace_len);
    Jsi_DSInit(&dStr);

    if (Jsi_ValueIsString(interp, seq)) {
        const char *ce, *cp = Jsi_ValueString(interp, seq, NULL);
        if (!(ce = strstr(source_str, cp)))
            Jsi_ValueMakeStringDup(interp, ret, source_str);
        else {
            int slen;
            slen = (ce-source_str);
            if (slen)
                Jsi_DSAppendLen(&dStr, source_str, slen);
            Jsi_DSAppendLen(&dStr, replace_str, replace_len);
            Jsi_DSAppend(&dStr, ce+strlen(cp), NULL);
            Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
            Jsi_DSFree(&dStr);
        }
        return JSI_OK;
    }
    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_ValueMakeNull(interp, ret);
        return JSI_OK;
    }

    re = seq->d.obj->d.robj;
    regex = &re->reg;
    opt_all = (re->eflags & JSI_REG_GLOB);
    
    regmatch_t pmatch[MAX_SUBREGEX];
    memset(&pmatch, 0, MAX_SUBREGEX * sizeof(regmatch_t));
    /* If an offset has been specified, adjust for that now.
     * If it points past the end of the string, point to the terminating null
     */
    if (offset) {
        if (offset < 0) {
            offset += source_len + 1;
        }
        if (offset > source_len) {
            offset = source_len;
        }
        else if (offset < 0) {
            offset = 0;
        }
    }

    Jsi_DSAppendLen(&dStr, source_str, offset);
    n = source_len - offset;
    p = source_str + offset;
    int rc = JSI_OK;
    do {
        if (num_matches > 10000000) {
            Jsi_LogBug("regexp infinite loop");
            rc = JSI_ERROR;
            break;
        }
        int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags);

        if (match >= REG_BADPAT) {
            char buf[100];

            regerror(match, regex, buf, sizeof(buf));
            Jsi_LogError("error while matching pattern: %s", buf);
            Jsi_DSFree(&dStr);
            return JSI_ERROR;
        }
        if (match == REG_NOMATCH) {
            break;
        }
        num_matches++;
        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);
        
        for (j = 0; j < replace_len; j++) {
            int idx;
            int c = replace_str[j];

            if (c == '&') {
                idx = 0;
            }
            else if (c == '\\' && j < replace_len) {
                c = replace_str[++j];
                if ((c >= '0') && (c <= '9')) {
                    idx = c - '0';
                }
                else if ((c == '\\') || (c == '&')) {
                    Jsi_DSAppendLen(&dStr, replace_str + j, 1);
                    continue;
                }
                else {
                    Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2);
                    continue;
                }
            }
            else {
                Jsi_DSAppendLen(&dStr, replace_str + j, 1);
                continue;
            }
            if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) {
                Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so,
                    pmatch[idx].rm_eo - pmatch[idx].rm_so);
            }
        }

        p += pmatch[0].rm_eo;
        n -= pmatch[0].rm_eo;
        /* If -all is not specified, or there is no source left, we are done */
        if (!opt_all || n == 0 || pmatch[0].rm_eo == 0) {
            break;
        }
        /* An anchored pattern without -line must be done */
        if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') {
            break;
        }
        
        /* If the pattern is empty, need to step forwards */
        if (re->pattern[0] == '\0' && n) {
            /* Need to copy the char we are moving over */
            Jsi_DSAppendLen(&dStr, p, 1);
            p++;
            n--;
        }

        regexec_flags |= REG_NOTBOL;
    } while (n);

    /*
     * Copy the portion of the string after the last match to the
     * result variable.
     */
    Jsi_DSAppend(&dStr, p, NULL);

    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    
    return rc;

}

static int StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{

    int skip = 0;
    char *source_str;
    ChkString(_this, funcPtr, source_str, NULL);
    //int source_len = Jsi_Strlen(source_str);
    
    char *v = _this->d.obj->d.s.str;
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);

    if (Jsi_ValueIsString(interp, seq)) {
        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);
        int n = -1;
        if ((ce = strstr(source_str, cp))) {
            n = (ce-source_str);
        }
        Jsi_ValueMakeNumber(interp, ret, n);
        return JSI_OK;
    }
    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {
        Jsi_ValueMakeNumber(interp, ret, -1);
        return JSI_OK;
    }

    regex_t *reg = &seq->d.obj->d.robj->reg;
    
    regmatch_t pos[MAX_SUBREGEX];
    memset(&pos, 0, MAX_SUBREGEX * sizeof(regmatch_t));
    int r;
    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {
        if (r == REG_NOMATCH) {
            Jsi_ValueMakeNumber(interp, ret, -1.0);
            return JSI_OK;
        }
        if (r >= REG_BADPAT) {
            char buf[100];

            regerror(r, reg, buf, sizeof(buf));
            Jsi_LogError("error while matching pattern: %s", buf);
            return JSI_ERROR;
        }

    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);
    return JSI_OK;
}

/* UNIMPL: 'toLocaleLowerCase', 'toLocaleUpperCase', 'localeCompare', */

static Jsi_CmdSpec stringCmds[] = {
    { "String",     StringConstructor,      0,  1,  "str", JSI_CMD_IS_CONSTRUCTOR, .help="String constructor", .retType=(uint)JSI_TT_STRING },
/*    { "localeCompare",StringLocaleCompareCmd,1, 1, "pos" },*/
    { "charAt",     StringCharAtCmd,        1, 1, "index:number", .help="Return char at index", .retType=(uint)JSI_TT_STRING},
    { "charCodeAt", StringCharCodeAtCmd,    1, 1, "index:number", .help="Return char code at index", .retType=(uint)JSI_TT_NUMBER },
    { "fromCharCode",StringFromCharCodeCmd, 0,-1, "code:string, ...", JSI_CMDSPEC_NONTHIS, .help="Return char its code number", .retType=(uint)JSI_TT_STRING},
    { "concat",     StringConcatCmd,        0,-1, "str:string, ...", .help="Append one or more strings", .retType=(uint)JSI_TT_STRING },
    { "indexOf",    StringIndexOfCmd,       1, 2, "str:string, start:number", .help="Return index of char", .retType=(uint)JSI_TT_NUMBER },
    { "lastIndexOf",StringLastIndexOfCmd,   1, 2, "str:string, start:number", .help="Return index of last char", .retType=(uint)JSI_TT_NUMBER },
    { "match",      StringMatchCmd,         1, 1, "pattern:regexp|string", .help="Return array of matches", .retType=(uint)JSI_TT_ARRAY|JSI_TT_NULL },
    { "replace",    StringReplaceCmd,       2, 2, "pattern:regexp|string, replace:string", .help="Return a string after replacement", .retType=(uint)JSI_TT_STRING },
    { "search",     StringSearchCmd,        1, 1, "pattern:regexp|string", .help="Return index of first char matching pattern", .retType=(uint)JSI_TT_NUMBER },
    { "slice",      StringSliceCmd,         1, 2, "start:number, end:number", .help="Return section of string", .retType=(uint)JSI_TT_STRING },
    { "split",      StringSplitCmd,         1, 1, "char:string", .help="Split on char and return Array", .retType=(uint)JSI_TT_ARRAY },
    { "substr",     StringSubstrCmd,        0, 2, "start:number, length:number", .help="Return substring", .retType=(uint)JSI_TT_STRING },
    { "substring",  StringSubstringCmd,     0, 2, "start:number, end:number", .help="Return substring", .retType=(uint)JSI_TT_STRING },
    { "toLocaleLowerCase",StringToLowerCaseCmd,0, 0, "",.help="Lower case", .retType=(uint)JSI_TT_STRING },
    { "toLocaleUpperCase",StringToUpperCaseCmd,0, 0, "",.help="Upper case", .retType=(uint)JSI_TT_STRING },
    { "toLowerCase",StringToLowerCaseCmd,   0, 0, "",.help="Return lower cased string", .retType=(uint)JSI_TT_STRING },
    { "toUpperCase",StringToUpperCaseCmd,   0, 0, "",.help="Return upper cased string", .retType=(uint)JSI_TT_STRING },
    { "toTitle",    StringToTitleCmd,       0, 1, "chars:string",.help="Make first char upper case", .retType=(uint)JSI_TT_STRING },
    { "trim",       StringTrimCmd,          0, 1, "chars:string",.help="Trim chars", .retType=(uint)JSI_TT_STRING },
    { "trimLeft",   StringTrimLeftCmd,      0, 1, "chars:string",.help="Trim chars from left", .retType=(uint)JSI_TT_STRING },
    { "trimRight",  StringTrimRightCmd,     0, 1, "chars:string",.help="Trim chars from right", .retType=(uint)JSI_TT_STRING },
    { NULL, .help="Commands for accessing string objects." }
};

int jsi_StringInit(Jsi_Interp *interp)
{
    interp->String_prototype = Jsi_CommandCreateSpecs(interp, "String", stringCmds, NULL, 0);
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

static int BooleanConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        int nv = 0;
        if (Jsi_ValueGetLength(interp, args) > 0) {
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
            if (v) {
                nv = Jsi_ValueIsTrue(interp, v);
            }
        }
        _this->d.obj->ot = JSI_OT_BOOL;
        _this->d.obj->d.val = nv;
        return JSI_OK;
    }
    if (Jsi_ValueGetLength(interp, args) > 0) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueMakeBool(interp, ret, Jsi_ValueIsTrue(interp, v));
            return JSI_OK;
        }
    }
    Jsi_ValueMakeBool(interp, ret, 0);
    return JSI_OK;
}

static Jsi_CmdSpec booleanCmds[] = {
    { "Boolean",  BooleanConstructor, 0,  1,  "bool:boolean=false", .help="Boolean constructor", .flags=JSI_CMD_IS_CONSTRUCTOR, .retType=(uint)JSI_TT_BOOL },
    { NULL, .help="A Boolean object" }
};

int jsi_BooleanInit(Jsi_Interp *interp)
{
    interp->Boolean_prototype = Jsi_CommandCreateSpecs(interp, "Boolean", booleanCmds, NULL, 0);
    return JSI_OK;
}
#endif

#include <math.h>
#include <float.h>
#include <stdio.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

int jsi_ieee_isnormal(Jsi_Number a) { return isnormal(a); }
int jsi_ieee_isnan(Jsi_Number a) { return isnan(a); }
int jsi_ieee_infinity(Jsi_Number a) {
#ifndef HAVE_MUSL
    return isinf(a);
#else
    if (!isinf(a))
        return 0;
    return (a<0 ? -1 : 1);
#endif
}
int jsi_is_integer(Jsi_Number n) { return (isnormal(n) ? (Jsi_Number)((int)(n)) == (n) : n==0.0); }
int jsi_is_wide(Jsi_Number n) { return (isnormal(n) && (Jsi_Number)((Jsi_Wide)(n)) == (n)); }

Jsi_Number jsi_ieee_makeinf(int i)
{
    Jsi_Number r = INFINITY;
    if (i < 0) r = -r;
    return r;
}

Jsi_Number jsi_ieee_makenan(void)
{
    return NAN;
}

void jsi_num_itoa10(int value, char* str)
{
    sprintf(str, "%d", value);
    return;
}

void jsi_num_uitoa10(unsigned int value, char* str)
{
    sprintf(str, "%u", value);
}

int jsi_num_isNaN(Jsi_Number value)
{
    /* Hacky test for NaN */
    return ((value != value));
}

int jsi_num_isFinite(Jsi_Number value)
{
    Jsi_Number r = INFINITY;
    return (jsi_num_isNaN(value)==0 && value != r && r != -value);
}

void jsi_num_dtoa2(Jsi_Number value, char* str, int prec)
{
    if (jsi_num_isNaN(value)) {
        Jsi_Strcpy(str,"NaN");
        return;
    }
    sprintf(str, "%.*" JSI_NUMGFMT, prec, value);
}
int jsi_num_isEqual(Jsi_Number n1, Jsi_Number n2)
{
    return (n1 == n2); // TODO: Do we need more?
   /* int n1n = jsi_num_isNan(n1); 
    int n2n = jsi_num_isNan(n2);
    if (n1n && n2n)
        return 1;
    if (n1n || n2n)
        return 0;
    return ((n2-n1)==0);*/
}

#ifndef JSI_LITE_ONLY
static int NumberConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        Jsi_Number nv = 0.0;
        if (Jsi_ValueGetLength(interp, args) > 0) {
            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
            if (v) {
                Jsi_ValueToNumber(interp, v);
                nv = v->d.num;
            }
        }
        _this->d.obj->ot = JSI_OT_NUMBER;
        _this->d.obj->d.num = nv;
        return JSI_OK;
    }
    if (Jsi_ValueGetLength(interp, args) > 0) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v) {
            Jsi_ValueDup2(interp, ret, v);
            Jsi_ValueToNumber(interp, *ret);
            return JSI_OK;
        }
    }
    Jsi_ValueMakeNumber(interp, ret, 0.0);
    return JSI_OK;
}

   
#define ChkStringN(_this, funcPtr, dest) \
    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \
       _this->d.obj->__proto__ == interp->Number_prototype->d.obj->__proto__ ) { \
        skip = 1; \
        dest = Jsi_ValueArrayIndex(interp, args, 0); \
    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_NUMBER) { \
        Jsi_LogError("apply Number.%s to a non-number object\n", funcPtr->cmdSpec->name); \
        return JSI_ERROR; \
    } else  { \
        dest = _this; \
    }
    
static int NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[100];
    int prec, skip = 0;
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)
        return JSI_ERROR;
    if (prec<0) prec = 0;
    Jsi_GetDoubleFromValue(interp, v, &num);
    sprintf(buf,"%.*" JSI_NUMFFMT, prec, num);
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static int NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[100];
    int prec, skip = 0;
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)
        return JSI_ERROR;
    if (prec<0) prec = 0;
    Jsi_GetDoubleFromValue(interp, v, &num);
    sprintf(buf,"%.*" JSI_NUMFFMT, prec, num);
    if (num<0)
        prec++;
    buf[prec+1] = 0;
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static int NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[100];
    int prec, len, skip = 0;
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)
        return JSI_ERROR;
    if (prec<0) prec = 0;
    Jsi_GetDoubleFromValue(interp, v, &num);
    sprintf(buf,"%.*" JSI_NUMEFMT, prec, num);
    len = strlen(buf);
    if (len >= 4 && buf[len-2] == '0' && buf[len-3] == '+') {
        buf[len-2] = buf[len-1];
        buf[len-1] = 0;
    }
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static int NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[500];
    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Number num;
    Jsi_Value *v;
    ChkStringN(_this, funcPtr, v);
    Jsi_GetDoubleFromValue(interp, v, &num);
    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK
        || radix<2))
        return JSI_ERROR;
    if (argc==skip)
        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);
    switch (radix) {
        case 16: sprintf(buf, "%llx", (Jsi_Wide)num); break;
        case 8: sprintf(buf, "%llo", (Jsi_Wide)num); break;
        case 10: sprintf(buf, "%lld", (Jsi_Wide)num); break;
        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);
    }
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static Jsi_CmdSpec numberCmds[] = {
    { "Number",         NumberConstructor,      0, 1, "num:number=0", JSI_CMD_IS_CONSTRUCTOR, .help="Number constructor", .retType=(uint)JSI_TT_NUMBER },
    { "toFixed",        NumberToFixedCmd,       1, 1, "num:number", .help="Formats a number with x numbers of digits after the decimal point", .retType=(uint)JSI_TT_STRING },
    { "toExponential",  NumberToExponentialCmd, 1, 1, "num:number", .help="Converts a number into an exponential notation", .retType=(uint)JSI_TT_STRING },
    { "toPrecision",    NumberToPrecisionCmd,   1, 1, "num:number", .help="Formats a number to x length", .retType=(uint)JSI_TT_STRING },
    { "toString",       NumberToStringCmd,      0, 1, "radix:number=10", .help="Convert to string", .retType=(uint)JSI_TT_STRING }, 
    { NULL,.help="Commands for accessing number objects" }
};

int jsi_NumberInit(Jsi_Interp *interp)
{
    Jsi_Value *val, *global = interp->csc;
    val = interp->Number_prototype = Jsi_CommandCreateSpecs(interp, "Number", numberCmds, NULL, 0);

    Jsi_Value *NaN = Jsi_ValueMakeNumber(interp, NULL, jsi_ieee_makenan());

    Jsi_Value *Inf = Jsi_ValueMakeNumber(interp, NULL, jsi_ieee_makeinf(1));
    
    Jsi_ValueInsertFixed(interp, global, "NaN", NaN);
    Jsi_ValueInsertFixed(interp, global, "Infinity", Inf);
    interp->NaNValue = NaN;
    interp->InfValue = Inf;
#define MCONST(name,v) Jsi_ValueInsert(interp, val, name, Jsi_ValueNewNumber(interp, v), JSI_OM_READONLY)
    MCONST("MAX_VALUE", DBL_MAX);
    MCONST("MIN_VALUE", DBL_MIN);
    MCONST("NEGATIVE_INFINITY", jsi_ieee_makeinf(-1));
    Jsi_ValueInsertFixed(interp, val, "POSITIVE_INFINITY", Inf);
    Jsi_ValueInsertFixed(interp, val, "NaN", NaN);
    return JSI_OK;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#ifdef HAVE_MUSL
#define NO_QSORT_R 1
#endif

static int ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *obj;
    
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    
    int argc = Jsi_ValueGetLength(interp, args);
    int curlen = Jsi_ObjGetLength(interp, obj);
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);
        if (!ov) { Jsi_LogBug("Arguments Error\n"); ov = Jsi_ValueNew(interp); }
        jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);
    }
    
    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));
    return JSI_OK;
}

static int ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    Jsi_Obj *obj;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    int i = Jsi_ObjGetLength(interp, obj) - 1;

    if (i < 0) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    
    if (obj->arr) {
        if ((v = obj->arr[i])) {
            obj->arr[i] = NULL;
            obj->arrCnt--;
        }
    } else {
        v = Jsi_ValueArrayIndex(interp, _this, i);
    }
    if (v) {
        Jsi_DecrRefCount(interp, *ret);
        *ret = v;
    }
    Jsi_ObjSetLength(interp, obj, i);
    return JSI_OK;
}


static int ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *jstr = "";
    int argc, curlen;
    Jsi_DString dStr = {};
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    curlen = Jsi_ObjGetLength(interp, _this->d.obj);
    if (curlen == 0) {
        goto bail;
    }

    if (Jsi_ValueGetLength(interp, args) >= 1) {
        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);
        if (sc != NULL)
            jstr = Jsi_ValueToString(interp, sc, NULL);
    }
    
    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {
        goto bail;
    }
    int i;
    for (i = 0; i < argc; ++i) {
        const char *cp;
        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);
        if (!ov) {
            /* TODO: are NULL args ok? */ 
            continue;
            cp = "";
        } else
            cp = Jsi_ValueToString(interp, ov, NULL);
        if (i && jstr[0])
            Jsi_DSAppend(&dStr, jstr, NULL);
        Jsi_DSAppend(&dStr, cp, NULL);
    }
    
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
bail:
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(""));
    return JSI_OK;        
}


Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {
    Jsi_Value *va;
    Jsi_Obj *obj;
    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj)) {
        return NULL;
    }
    if (arg2->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg2->d.obj)) {
        return NULL;
    }
    int len1 = arg1->d.obj->arrCnt;
    int len2 = arg2->d.obj->arrCnt;
    Jsi_Obj *nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    Jsi_ObjArraySizer(interp, nobj, len1+len2);

    int i, j = 0;
    obj = arg1->d.obj;
    for (i = 0; i<len1; i++, j++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[j] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);
    }
    obj = arg2->d.obj;
    for (i = 0; i<len2; i++, j++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[j] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);
    }
    Jsi_ObjSetLength(interp, nobj, len1+len2);
    va = Jsi_ValueMakeArrayObject(interp, NULL, nobj);
    return va;
}

static int ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Value *va;
    Jsi_Obj *obj;
    int curlen, argc, nsiz, rc = JSI_OK;
    Jsi_Obj *nobj;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    obj = _this->d.obj;
    
    argc = Jsi_ValueGetLength(interp, args);
    curlen = Jsi_ObjGetLength(interp, obj);
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
   
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    nsiz = obj->arrMaxSize;
    if (nsiz<=0) nsiz = 100;
    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {
        rc = JSI_ERROR;
        Jsi_LogError("index too large: %d", nsiz+1);
        goto bail;
    }

    int i, j, m;
    for (i = 0; i<curlen; i++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[i] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);
    }
    m = i;
    for (i = 0; i < argc; i++) {
         va = Jsi_ValueArrayIndex(interp, args, i);
         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {
            int margc = Jsi_ValueGetLength(interp, va);
            Jsi_Obj *mobj = va->d.obj;
            Jsi_ObjListifyArray(interp, mobj);
            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {
                rc = JSI_ERROR;
                Jsi_LogError("index too large: %d", curlen);
                goto bail;
            }
            for (j = 0; j<margc; j++, m++)
            {
                if (!mobj->arr[j]) continue;
                nobj->arr[m] = NULL;
                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);
            }
        } else {
            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {
                rc = JSI_ERROR;
                Jsi_LogError("index too large: %d", curlen);
                goto bail;
            }
            nobj->arr[m] = NULL;
            Jsi_ValueDup2(interp, nobj->arr+m++, va);
       }
    }
    Jsi_ObjSetLength(interp, nobj, curlen);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    return JSI_OK;
        
bail:
    Jsi_ValueMakeNull(interp, ret);
    return rc;
}

static int ArrayMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj, *nobj;
    int curlen, nsiz;
    int i, rc = JSI_OK;
    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    sthis = Jsi_ValueArrayIndex(interp, args, 1);
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);
    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    nsiz = obj->arrCnt;
    if (nsiz<=0) nsiz = 1;
    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {
        Jsi_LogError("index too large: %d", nsiz);
        rc = JSI_ERROR;
        goto bail;
    }
    Jsi_ValueMakeArrayObject(interp, ret, nobj);

    for (i = 0; i < curlen; i++) {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        nobj->arr[i] = Jsi_ValueNew1(interp);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, nobj->arr+i, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        if( JSI_OK!=rc ) {
            goto bail;
        }
    }
    Jsi_ObjSetLength(interp, nobj, curlen);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return JSI_OK;
        
bail:
    Jsi_ValueMakeNull(interp, ret);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return rc;
}

static int ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj, *nobj;
    int curlen, nsiz;
    int i, rc = JSI_OK;
    Jsi_Value *func, *vpargs, *nthis = NULL;
    int fval, n = 0;
    Jsi_Value *sthis, *nrPtr;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    sthis = Jsi_ValueArrayIndex(interp, args, 1);
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);
    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    nsiz = obj->arrCnt;
    if (nsiz<=0) nsiz = 1;
    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {
        Jsi_LogError("index too large: %d", nsiz);
        rc = JSI_ERROR;
        goto bail;
    }
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    nrPtr = Jsi_ValueNew1(interp);
    for (i = 0; i < curlen; i++) {
        if (!obj->arr[i]) continue;
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        fval = Jsi_ValueIsTrue(interp, nrPtr);
        Jsi_ValueMakeUndef(interp, &nrPtr);
        if( JSI_OK!=rc ) {
            goto bail;
        }
        if (fval) {
            nobj->arr[n++] = obj->arr[i];
            Jsi_IncrRefCount(interp, obj->arr[i]);
        }
    }
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    Jsi_DecrRefCount(interp, nrPtr);
    Jsi_ObjSetLength(interp, nobj, n);
    return JSI_OK;
        
bail:
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    Jsi_DecrRefCount(interp, nrPtr);
    Jsi_ValueMakeNull(interp, ret);
    return rc;
}


static int ArrayReverseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    int i, n, m;
    Jsi_Value *tval;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_LogError("expected array");
        return JSI_ERROR;
    }
    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *nthis = NULL;
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);

    obj = _this->d.obj;
    Jsi_ObjListifyArray(interp, obj);
    m = obj->arrCnt/2;
    for (i = 0, n=obj->arrCnt-1; i < m; i++, n--) {
        tval = obj->arr[i];
        obj->arr[i] = obj->arr[n];
        obj->arr[n] = tval;
    }
    Jsi_ValueDup2(interp, ret, _this);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return JSI_OK;
}

static int ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) 
{
    Jsi_Obj *obj;
    int curlen;
    int i, rc;
    Jsi_Value *func, *vpargs;

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_LogError("expected array");
        return JSI_ERROR;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *nthis = NULL;
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);

    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);

    for (i = 0; i < obj->arrCnt; i++) {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        if( JSI_OK!=rc ) {
            return rc;
        }
    }
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    return JSI_OK;
}

static int ArraySomeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    int curlen;
    int i, rc = JSI_OK;
    Jsi_Value *func, *vpargs;
    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);

    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_LogError("expected array");
        return JSI_ERROR;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (!Jsi_ValueIsFunction(interp, func)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    Jsi_Value *nthis = NULL;
    if (!sthis)
        sthis = nthis = Jsi_ValueNew1(interp);

    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);    
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
    int fval = 0;
    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);
    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {
        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, obj->arr+i, 1, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);
        Jsi_DecrRefCount(interp, vpargs);
        fval = Jsi_ValueIsTrue(interp, nrPtr);
        Jsi_ValueMakeUndef(interp, &nrPtr);
        if (fval)
            break;
    }
    if (rc == JSI_OK)
        Jsi_ValueMakeBool(interp, ret, fval);
    if (nthis)
        Jsi_DecrRefCount(interp, nthis);
    Jsi_DecrRefCount(interp, nrPtr);
    return rc;

}
/*
static int ArrayIsarrayCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    int isa = (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj));
    Jsi_ValueMakeBool(interp, ret, isa);
    return JSI_OK;
}*/

static int ArrayIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return 0;
    }
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1);
    int istart, n;
    Jsi_Obj *obj = _this->d.obj;
    if (!seq) {
        goto bail;
    }
    
    n = Jsi_ObjGetLength(interp, obj);    
    if (n == 0) {
        goto bail;
    }
    Jsi_Number nstart;
    istart = 0;
    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {
        istart = (int) nstart;
        if (istart >= n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            istart = 0;
    }
    Jsi_ObjListifyArray(interp, obj);
    int i;
    for (i = istart; i < n; i++)
    {
        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {
            Jsi_ValueMakeNumber(interp, ret, i);
            return JSI_OK;
        }
    }
bail:
    Jsi_ValueMakeNumber(interp, ret, -1);
    return JSI_OK;
}

static int ArrayLastindexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1);
    int istart, n;
    Jsi_Obj *obj = _this->d.obj;
    if (!seq) {
        goto bail;
    }
    
    n = Jsi_ObjGetLength(interp, obj);    
    if (n == 0) {
        goto bail;
    }
    Jsi_Number nstart;
    istart = n-1;
    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {
        istart = (int)nstart;
        if (istart >= n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            goto bail;
    }
    Jsi_ObjListifyArray(interp, obj);
    int i;
    for (i = istart; i >= 0; i--)
    {
        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {
            Jsi_ValueMakeNumber(interp, ret, i);
            return JSI_OK;
        }
    }
bail:
    Jsi_ValueMakeNumber(interp, ret, -1);
    return JSI_OK;
}


static int ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    int i;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))
        i = 0;
    else
        i = Jsi_ObjGetLength(interp, _this->d.obj);
    Jsi_ValueMakeNumber(interp, ret, i);
    return JSI_OK;
}

static int ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    Jsi_Value *v;
    int n;
    
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    Jsi_ObjListifyArray(interp, obj);
    n = Jsi_ObjGetLength(interp, obj);
    assert(n <= obj->arrCnt);
    if (n<=0) {
        Jsi_ValueMakeUndef(interp, ret);
    } else {
        n--;
        v = obj->arr[0];
        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));
        obj->arr[n] = NULL;
        Jsi_ValueDup2(interp, ret, v);
        Jsi_DecrRefCount(interp, v);
        Jsi_ObjSetLength(interp, obj, n);
    }
    return JSI_OK;
}

static int ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Obj *obj;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    obj = _this->d.obj;
    
    int argc = Jsi_ValueGetLength(interp, args);
    int curlen = Jsi_ObjGetLength(interp, obj);
    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    if (argc <= 0) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_ObjListifyArray(interp, obj);
    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) {
        Jsi_LogError("too long");
        return JSI_ERROR;
    }
    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));
    obj->arrCnt += argc;
    int i;
    for (i = 0; i < argc; ++i) {
        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);
        obj->arr[i] = NULL;
        if (!ov) { Jsi_LogBug("Arguments Error\n"); continue; }
        obj->arr[i] = ov;
        Jsi_IncrRefCount(interp, ov);
    }
    Jsi_ObjSetLength(interp, obj, curlen+argc);
    
    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));
    return JSI_OK;
}


static int ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {
   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 1);
    int istart = 0, iend, rc = JSI_OK, n, nsiz;
    Jsi_Obj *nobj, *obj;
    if (!start) {
        goto bail;
    }
    obj = _this->d.obj;
    n = Jsi_ObjGetLength(interp, obj);
    Jsi_Number nstart;
    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {
        istart = (int)nstart;
        if (istart >= n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            goto bail;
    }
      
    if (n == 0) {
        goto bail;
    }
    Jsi_Number nend;
    iend = n-1;
    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {
        iend = (int) nend;
        if (iend >= n)
            iend = n;
        if (iend < 0)
            iend = (n+iend);
        if (iend<0)
            goto bail;
    }
    nsiz = iend-istart+1;
    if (nsiz<=0)
        goto bail;
    Jsi_ObjListifyArray(interp, obj);
    
    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);

    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {
        Jsi_LogError("index too large: %d", nsiz);
        rc = JSI_ERROR;
        goto bail;
    }

    int i, m;
    for (m = 0, i = istart; i <= iend; i++, m++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[m] = NULL;
        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);
    }
    Jsi_ObjSetLength(interp, nobj, nsiz);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    return JSI_OK;
    
bail:
    Jsi_ValueMakeNull(interp, ret);
    return rc;
}

typedef struct {
    Jsi_Interp *interp;
    int flags;
} SortInfo;

#ifdef NO_QSORT_R
static Jsi_Interp *curInterp = NULL;
static int sortFlags = 0;

static int SortSubCmd(const void *p1, const void *p2) {
#else
static int SortSubCmd(const void *p1, const void *p2, void *thunk) {
    SortInfo *si = (SortInfo *)thunk;
    Jsi_Interp *curInterp = si->interp;
    int sortFlags = si->flags;
#endif

    Jsi_Value *v1 = *(Jsi_Value**)p1, *v2 = *(Jsi_Value**)p2;
    if (curInterp == NULL || curInterp->deleting)
        return 0;
    VALCHK(v1);
    VALCHK(v2);
    int rc;
    if (v1 != NULL && v2 != NULL)
        rc = Jsi_ValueCmp(curInterp, v1, v2, sortFlags);
    else {
        if (v1 == v2) 
            rc = 0;
        else if (v1 == NULL)
            rc = 1;
        else
            rc = -1;
    }
    if ((sortFlags&JSI_SORT_DESCEND))
        return rc;
    return -rc;
}

int Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int flags)
{
    if (val->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, val->d.obj)) {
        return JSI_ERROR;
    }
    Jsi_Obj *obj = val->d.obj;
    Jsi_ObjListifyArray(interp, obj);
    if (obj->arrCnt <= 0) {
        return JSI_OK;
    }
#ifdef __WIN32
#define qsort_r qsort_s
#endif

#ifdef NO_QSORT_R
    curInterp = interp;
    sortFlags = flags;
    qsort(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd);
    curInterp = NULL;
#else
    SortInfo si;
    si.interp = interp;
    si.flags = flags;
    qsort_r(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd, &si);
#endif
    return JSI_OK;
}

static int ArraySortCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v;
    char *sortDesc;
    int flags = 0, curlen;
    Jsi_Obj *obj;
    Jsi_Value *sd;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail;
    }
    obj = _this->d.obj;
    curlen = Jsi_ObjGetLength(interp, obj);

    if (curlen <= 0) {
        goto done;
    }
    sd = Jsi_ValueArrayIndex(interp, args, 0);
    if (sd && (sortDesc = Jsi_ValueString(interp, sd, NULL))) {
        /* TODO: cleanup/argchk */
        if (strstr(sortDesc,"desc")) flags |= JSI_SORT_DESCEND;
        if (strstr(sortDesc,"ascii")) flags |= JSI_SORT_ASCII;
        if (strstr(sortDesc,"nocase")) flags |= JSI_SORT_NOCASE;
    }
    Jsi_ObjListifyArray(interp, obj);
#ifdef NO_QSORT_R
    /* TODO: mutex. */
    curInterp = interp;
    sortFlags = flags;
    qsort(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd);
    curInterp = NULL;
#else
    SortInfo si;
    si.interp = interp;
    si.flags = flags;
    qsort_r(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd, &si);
#endif

    if (interp->deleting)
        return JSI_ERROR;
done:
    v = Jsi_ValueMakeObject(interp, NULL, obj);
    Jsi_ValueReplace(interp, ret, v);
    return JSI_OK;
bail:
    Jsi_ValueMakeNull(interp, ret);
    return JSI_OK;
}

static int ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *va;
    Jsi_Obj *obj, *nobj;
    int newlen, asiz, argc, istart, n, rhowmany, ilen, curlen;
    Jsi_Value *start, *howmany;
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        goto bail2;
    }
    obj = _this->d.obj;
    
    start = Jsi_ValueArrayIndex(interp, args, 0);
    howmany = Jsi_ValueArrayIndex(interp, args, 1);
    argc = Jsi_ValueGetLength(interp, args);
    istart = 0;
    ilen = (argc>=2 ? argc - 2 : 0);
    n = Jsi_ObjGetLength(interp, obj);
    curlen = n;
    
    if (!start) {
        goto bail2;
    }

    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    Jsi_ObjSetLength(interp, nobj, 0);
    
    /* Determine start index. */
    Jsi_Number nstart;
    if (Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {
        istart = (int)nstart;
        if (istart >= n)
            goto bail;
        if (istart < 0)
            istart = (n+istart);
        if (istart<0)
            istart=0;
    }
      
    Jsi_Number nhow;
    rhowmany = n-istart;
    if (howmany && Jsi_GetNumberFromValue(interp, howmany, &nhow) == JSI_OK) {
        rhowmany = (int)nhow;
        if (rhowmany >= (n-istart))
            rhowmany = n-istart;
        if (rhowmany < 0)
            rhowmany = (n-istart);
        if (rhowmany<0)
            goto bail;
    }
    asiz = istart+1;

    if (curlen < 0) {
        Jsi_ObjSetLength(interp, obj, 0);
    }
    Jsi_ObjListifyArray(interp, obj);
   
    Jsi_ObjArraySizer(interp, nobj, asiz);

    /* Move elements to return object. */
    int i, j, m;
    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++,i++, j++)
    {
        if (!obj->arr[i]) continue;
        nobj->arr[m] = NULL;
        nobj->arr[m] = obj->arr[i];
    }
    Jsi_ObjSetLength(interp, nobj, m);
    
    /* Shift remaining down. */
    for (; rhowmany && i<curlen; i++)
    {
        obj->arr[i-rhowmany] = obj->arr[i];
        obj->arr[i] = NULL;
    }
    curlen -= j;
    /* Add elements. */
    newlen = curlen + argc - (argc>=2?2:1);
    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {
        Jsi_LogError("too long");
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    if (ilen>0) {
        for (i = curlen-1; i>=istart; i--) {
            obj->arr[i+ilen] = obj->arr[i];
            obj->arr[i] = NULL;
        }
        for (m=istart, i = 2; i<argc; m++,i++) {
            va = Jsi_ValueArrayIndex(interp, args, i);
            if (!va) continue;
            obj->arr[m] = NULL;
            Jsi_ValueDup2(interp, obj->arr+m, va);
        }
    }
    Jsi_ObjSetLength(interp, obj, newlen);
bail:    
    return JSI_OK;
     
            
bail2:
    Jsi_ValueMakeNull(interp, ret);
    return JSI_OK;
}

static int ArrayConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *target;
    
    if (Jsi_FunctionIsConstructor(funcPtr)) target = _this;
    else {
        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        o->__proto__ = interp->Array_prototype;
        Jsi_ValueMakeObject(interp, ret, o);
        target = *ret;
    }

    if (argc == 1) {
        Jsi_Number nv;
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v && Jsi_GetNumberFromValue(interp,v, &nv) == JSI_OK) {
            int len = (int)nv;
            if (!jsi_is_integer(v->d.num) || len < 0) {
                Jsi_LogError("Invalid array length\n");
                return JSI_ERROR;
            }
            target->d.obj->isarrlist = 1;
            if (Jsi_ObjArraySizer(interp, target->d.obj, len) <= 0)
                return JSI_ERROR;
            return JSI_OK;
        }
    }

    int i;
    target->d.obj->isarrlist = 1;
    if (Jsi_ObjArraySizer(interp, target->d.obj, 0) <= 0)
            return JSI_ERROR;
    
    for (i = 0; i < argc; ++i) {
        Jsi_Value *argv = Jsi_ValueArrayIndex(interp, args, i);   ;
        jsi_ValueInsertArray(interp, _this, i, argv, 0);
    }
    return JSI_OK;
}
            
static Jsi_CmdSpec arrayCmds[] = {
    { "Array",      ArrayConstructor,   0,-1, "...", JSI_CMD_IS_CONSTRUCTOR, .help="Array constructor", .retType=(uint)JSI_TT_ARRAY },
    { "concat",     ArrayConcatCmd,     0,-1, "...", .help="Return array with args appended", .retType=(uint)JSI_TT_ARRAY },
    { "filter",     ArrayFilterCmd,     1, 2, "callback:function, this:object=void", .help="Return a filtered array", .retType=(uint)JSI_TT_ARRAY },
    { "forEach",    ArrayForeachCmd,    1, 2, "callback:function, this:object=void", .help="Invoke function with each item in array", .retType=(uint)JSI_TT_ARRAY },
    { "indexOf",    ArrayIndexOfCmd,    1, 2, "str:string, startIdx:number=0", .help="Return index of first occurrance in array", .retType=(uint)JSI_TT_NUMBER },
   // { "isArray",    ArrayIsarrayCmd,    0, 0, "", .help="Return true if array is internally a C array" },
    { "join",       ArrayJoinCmd,       0, 1, "sep:string=''", .help="Return elements joined by char", .retType=(uint)JSI_TT_STRING },
    { "lastIndexOf",ArrayLastindexOfCmd,1, 2, "val:any, start:number=0", .help="Return index of last occurence in array", .retType=(uint)JSI_TT_NUMBER },
    { "map",        ArrayMapCmd,        1, 2, "callback:function, this:object=void", .help="Creates a new array with the results of calling a provided function on every element in this array", .retType=(uint)JSI_TT_ARRAY },
    { "pop",        ArrayPopCmd,        0, 0, "", .help="Remove and return last element of array", .retType=(uint)JSI_TT_ANY },
    { "push",       ArrayPushCmd,       1,-1, "val:any, ...", .help="Push one or more elements onto array and return size", .retType=(uint)JSI_TT_NUMBER },
    { "shift",      ArrayShiftCmd,      0, 0, "", .help="Remove first element and shift downwards", .retType=(uint)JSI_TT_ANY },
    { "sizeOf",     ArraySizeOfCmd,     0, 0, "", .help="Return size of array", .retType=(uint)JSI_TT_NUMBER },
    { "slice",      ArraySliceCmd,      1, 2, "start:number, end:number=void", .help="Return sub-array", .retType=(uint)JSI_TT_ARRAY },
    { "some",       ArraySomeCmd,       1, 2, "callback:function, this:object=void", .help="Return true on first element function returns true on", .retType=(uint)JSI_TT_BOOL },
    { "sort",       ArraySortCmd,       0, 1, "compare:function=void", .help="Sort an array", .retType=(uint)JSI_TT_ARRAY },
    { "splice",     ArraySpliceCmd,     1,-1, "start:number, howmany:number=void, ...", .help="Change the content of an array, adding new elements while removing old elements", .retType=(uint)JSI_TT_ARRAY },
    { "reverse",    ArrayReverseCmd,    0, 0, "", .help="Reverse order of all elements in an array", .retType=(uint)JSI_TT_ARRAY },
    { "unshift",    ArrayUnshiftCmd,    0,-1, "...", .help="Add new elements to start of array and return size", .retType=(uint)JSI_TT_NUMBER },
    { NULL, .help="Provide access to array objects" }
};

int jsi_ArrayInit(Jsi_Interp *interp)
{
    interp->Array_prototype = Jsi_CommandCreateSpecs(interp, "Array", arrayCmds, NULL, 0);
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#ifndef JSI_OMIT_LOAD

#ifdef __WIN32
#define dlsym(l,s) GetProcAddress(l,s)
#define dlclose(l) FreeLibrary(l)
#include <windows.h>
#else
#include <dlfcn.h>
#endif

#ifndef RTLD_NOW
    #define RTLD_NOW 0
#endif
#ifndef RTLD_LOCAL
    #define RTLD_LOCAL 0
#endif

#endif

typedef struct LoadData {
    const char *name;
    Jsi_Value *fname;
#ifdef __WIN32
    HMODULE handle;
#else
    void *handle;
#endif
} LoadData;

#ifndef JSI_OMIT_LOAD

/**
 * Note that jsi_LoadLibrary() requires a path to an existing file.
 *
 * If it is necessary to search JSI_LIBPATH, use Jsi_PkgRequire() instead.
 */
int jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName, Jsi_Value *fval)
{
#ifdef __WIN32
    HMODULE handle = LoadLibrary(pathName);
#else
    void *handle = dlopen(pathName, RTLD_NOW | RTLD_LOCAL);
#endif
    if (handle == NULL) {
        // FYI: Valgrind shows a mem-leak here.
        Jsi_LogError("loading extension \"%s\": %s", pathName, dlerror());
        return JSI_ERROR;
    }
    /* We use a unique init symbol depending on the extension name.
     * This is done for compatibility between static and dynamic extensions.
     * For extension readline.so, the init symbol is "Jsi_readlineInit"
     */
    const char *pt;
    const char *pkgname;
    int pkgnamelen, n;
    char initsym[100];
    const char *cp = "";
    Jsi_InitProc *onload = NULL;
    struct Jsi_Stubs **vp = NULL;
    Jsi_HashEntry *hPtr;
    LoadData *d;

    pt = strrchr(pathName, '/');
    if (pt) {
        pkgname = pt + 1;
    }
    else {
        pkgname = pathName;
    }
    pt = strchr(pkgname, '.');
    if (pt) {
        pkgnamelen = pt - pkgname;
    }
    else {
        pkgnamelen = strlen(pkgname);
    }
    for (n = 0; n<6 && onload==NULL; n++)
    {
        char ch;
        if (n==2) { /* Skip lib prefix. */
            if (pkgnamelen<4 || strncasecmp(pkgname,"lib",3))
                break;
            pkgname += 3;
            pkgnamelen -= 3;
        }
        if (n==4) { /* Skip lib prefix. */
            if (pkgnamelen<4 || strncasecmp(pkgname,"jsi",3))
                break;
            pkgname += 3;
            pkgnamelen -= 3;
        }
        ch = ((n%2) ? pkgname[0] : toupper(pkgname[0]));
        snprintf(initsym, sizeof(initsym), "Jsi_Init%c%.*s", ch, pkgnamelen-1, pkgname+1);
        cp = initsym+8;
        hPtr = Jsi_HashEntryFind(interp->loadTbl, cp);
        if (hPtr) { /* Already loaded? */
            d = (LoadData*)Jsi_HashValueGet(hPtr);
            if (d && d->handle)
                return JSI_OK;
        }
        onload = (Jsi_InitProc *)dlsym(handle, initsym);
#ifndef JSI_OMIT_STUBS
        if (onload) {
            /* Handle stubs. TODO: handle other libs like sqliteStubsPtr, websocketStubsPtr, etc... */
            vp = (struct Jsi_Stubs**)dlsym(handle, "jsiStubsPtr");
            if (vp) {
                *vp = jsiStubsTblPtr;
            }
        }
#endif
    }
    
    if (onload == NULL) {
        Jsi_LogError("No %s symbol found in extension %s", initsym, pathName);
    }
    else if (onload(interp) != JSI_ERROR) {
        int isNew;
        hPtr = Jsi_HashEntryNew(interp->loadTbl, cp, &isNew);
        if (hPtr && isNew) {
            d = (LoadData*)Jsi_Calloc(1, sizeof(*d));
            d->handle = handle;
            d->name = (char*)Jsi_HashKeyGet(hPtr);
            d->fname = fval;
            Jsi_IncrRefCount(interp, fval);
            Jsi_HashValueSet(hPtr, d);
            return JSI_OK;
        }
        Jsi_LogError("duplicate load");
    }

    if (handle) {
        dlclose(handle);
    }
    return JSI_ERROR;
}
#else
int jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName, Jsi_Value *fval)
{
    Jsi_LogError("load not supported");
    return JSI_ERROR;
}
#endif

int jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    LoadData *d = (LoadData*)ptr;
#ifndef JSI_OMIT_LOAD
    dlclose(d->handle);
#endif
    if (d->fname)
        Jsi_IncrRefCount(interp, d->fname);
    Jsi_Free(d);
    return JSI_OK;
}

int Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr)
{
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->loadTbl, name);
    if (!hPtr)
        return JSI_ERROR;
    LoadData *d = (LoadData*)Jsi_HashValueGet(hPtr);
    if (d==NULL || !d->handle)
        return JSI_ERROR;
    char initsym[100];
    snprintf(initsym, sizeof(initsym), "%sStubsTblPtr", name);
    void **vp = NULL;
#ifndef JSI_OMIT_LOAD
    vp = (void**)dlsym(d->handle, initsym);
#endif
    if (vp == NULL || !*vp)
        return JSI_ERROR;
    *ptr = *vp;
    return JSI_OK;
}

#define FN_load JSI_INFO("\
Load a shared libary and call the _Init function.\
")
static int LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args, 
    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *fval = Jsi_ValueArrayIndex(interp, args, 0);
    char *v = Jsi_Realpath(interp, fval, NULL);
    Jsi_StatBuf fbuf;
    int rc;
    if (v == NULL || Jsi_Stat(interp, fval, &fbuf) || !Jsi_IsNative(interp, fval)) {
        Jsi_LogError("can not load: %s", (v?v:"null"));
        rc = JSI_ERROR;
    } else {
        rc = jsi_LoadLibrary(interp, v, fval);
    }
    if (v)
        Jsi_Free(v);
    return rc;
}

static Jsi_CmdSpec loadCmds[] = {
    { "load",   LoadLoadCmd, 1, 1, "shlib:string", .help="Load a shared executable and invoke its _Init call", .info=FN_load, .retType=(uint)JSI_TT_VOID },
//TODO: { "unload", LoadUnloadCmd,  NULL,   1, 1, "shlib.so", .help="Unload a shared executable and invoke its _Done call", .info=FN_load, .retType=(uint)JSI_TT_VOID },
    { NULL, .help="Commands for managing shared libraries" }
};

int jsi_LoadInit(Jsi_Interp *interp)
{
    Jsi_CommandCreateSpecs(interp, "", loadCmds, NULL, JSI_CMDSPEC_NOTOBJ);
    return JSI_OK;
}


#ifdef __WIN32
#undef dlsym
#undef dlclose
#endif
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdint.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#define REBUILD_MULTIPLIER  3

#if JSI_IS64BIT
#define RANDOM_INDEX        HashOneWord
#define DOWNSHIFT_START     62
#else 
#define RANDOM_INDEX(tablePtr, i) \
    (((((long) (i))*1103515245) >> (tablePtr)->downShift) & (tablePtr)->mask)
#define DOWNSHIFT_START 28
#endif

static jsi_Hash HashArray (const void *key, size_t length);
static Jsi_HashEntry *HashArrayFind (Jsi_Hash *tablePtr, const void 
*key);
static Jsi_HashEntry *HashArrayCreate (Jsi_Hash *tablePtr,
    const void *key, int *newPtr);
static jsi_Hash HashString (const char *string);
static void RebuildTable (Jsi_Hash *tablePtr);
static Jsi_HashEntry *HashStringFind (Jsi_Hash *tablePtr,
    const void *key);
static Jsi_HashEntry *HashStringCreate (Jsi_Hash *tablePtr,
    const void *key, int *newPtr);
static Jsi_HashEntry *HashOneWordFind (Jsi_Hash *tablePtr,
    const void *key);
static Jsi_HashEntry *HashOneWordCreate (Jsi_Hash *tablePtr,
    const void *key, int *newPtr);

#if JSI_IS64BIT
static jsi_Hash HashOneWord (Jsi_Hash *tablePtr,
    const void *key));

#endif /* JSI_IS64BIT */

static jsi_Hash
HashString( const char *string)
{
     jsi_Hash result;
     jsi_Hash c;

    result = 0;
    while ((c = *string++) != 0) {
    result += (result << 3) + c;
    }
    return (jsi_Hash)result;
}
static Jsi_HashEntry *
HashStringFind( Jsi_Hash *tablePtr, const void *key)
{
    jsi_Hash hval;
    Jsi_HashEntry *hPtr;
    size_t hindex;

    hval = HashString((char *)key);
    hindex = hval & tablePtr->mask;

    /*
     * Search all of the entries in the appropriate bucket.
     */

    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
            hPtr = hPtr->nextPtr) {
        if (hPtr->hval == hval) {
            const char *p1, *p2;

            for (p1 = (char*)key, p2 = hPtr->key.string; ; p1++, p2++) {
                if (*p1 != *p2) {
                    break;
                }
                if (*p1 == '\0') {
                    return hPtr;
                }
            }
        }
    }
    return NULL;
}

static Jsi_HashEntry *
HashStringCreate( Jsi_Hash *tablePtr, const void *key, int *newPtr)
{
    jsi_Hash hval;
    Jsi_HashEntry **bucketPtr;
    Jsi_HashEntry *hPtr;
    size_t size, hindex;

    hval = HashString((const char*)key);
    hindex = hval & tablePtr->mask;

    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
            hPtr = hPtr->nextPtr) {
        if (hPtr->hval == hval) {
            const char *p1, *p2;

            for (p1 = (const char*)key, p2 = hPtr->key.string; ; p1++, p2++) {
                if (*p1 != *p2) {
                    break;
                }
                if (*p1 == '\0') {
                    if (newPtr)
                        *newPtr = 0;
                    return hPtr;
                }
            }
        }
    }

    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_HashEntry) + strlen((char*)key) - sizeof(jsi_HashKey) + 1;
    hPtr = (Jsi_HashEntry*)Jsi_Malloc(size);
    bucketPtr = tablePtr->buckets + hindex;
    hPtr->tablePtr = tablePtr;
    hPtr->nextPtr = *bucketPtr;
    hPtr->hval = hval;
    hPtr->clientData = 0;
    Jsi_Strcpy(hPtr->key.string, (char*)key);
    *bucketPtr = hPtr;
    tablePtr->numEntries++;


    if (tablePtr->numEntries >= tablePtr->rebuildSize) {
        RebuildTable(tablePtr);
    }
    return hPtr;
}

#if JSI_IS64BIT
/*
 *----------------------------------------------------------------------
 *
 * HashOneWord --
 *
 *  Compute a one-word hash value of a 64-bit word, which then can
 *  be used to generate a hash index.
 *
 *  From Knuth, it's a multiplicative hash.  Multiplies an unsigned
 *  64-bit value with the golden ratio (sqrt(5) - 1) / 2.  The
 *  downshift value is 64 - n, when n is the log2 of the size of
 *  the hash table.
 *      
 * Results:
 *  The return value is a one-word summary of the information in
 *  64 bit word.
 *
 * Side effects:
 *  None.
 *
 *----------------------------------------------------------------------
 */
static jsi_Hash
HashOneWord(
    Jsi_Hash *tablePtr,
    const void *key)
{
    uint64_t a0, a1;
    uint64_t y0, y1;
    uint64_t y2, y3;
    uint64_t p1, p2;
    uint64_t result;
    /* Compute key * GOLDEN_RATIO in 128-bit arithmetic */
    a0 = (uint64_t)key & 0x00000000FFFFFFFF;
    a1 = (uint64_t)key >> 32;

    y0 = a0 * 0x000000007f4a7c13;
    y1 = a0 * 0x000000009e3779b9;
    y2 = a1 * 0x000000007f4a7c13;
    y3 = a1 * 0x000000009e3779b9;
    y1 += y0 >> 32;     /* Can't carry */
    y1 += y2;           /* Might carry */
    if (y1 < y2) {
        y3 += (1LL << 32);  /* Propagate */
    }

    /* 128-bit product: p1 = loword, p2 = hiword */
    p1 = ((y1 & 0x00000000FFFFFFFF) << 32) + (y0 & 0x00000000FFFFFFFF);
    p2 = y3 + (y1 >> 32);

    /* Left shift the value downward by the size of the table */
    if (tablePtr->downShift > 0) {
        if (tablePtr->downShift < 64) {
            result = ((p2 << (64 - tablePtr->downShift)) |
                      (p1 >> (tablePtr->downShift & 63)));
        } else {
            result = p2 >> (tablePtr->downShift & 63);
        }
    } else {
        result = p1;
    }
    /* Finally mask off the high bits */
    return (jsi_Hash)(result & tablePtr->mask);
}

#endif /* JSI_IS64BIT */

static Jsi_HashEntry *
HashOneWordFind( Jsi_Hash *tablePtr,  const void *key)
{
     Jsi_HashEntry *hPtr;
    size_t hindex;

    hindex = RANDOM_INDEX(tablePtr, key);

    /*
     * Search all of the entries in the appropriate bucket.
     */
    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
        hPtr = hPtr->nextPtr) {
    if (hPtr->key.oneWordValue == key) {
        return hPtr;
    }
    }
    return NULL;
}

static Jsi_HashEntry *
HashOneWordCreate( Jsi_Hash *tablePtr, const void *key, int *newPtr)
{
    Jsi_HashEntry **bucketPtr;
     Jsi_HashEntry *hPtr;
    size_t hindex;

    hindex = RANDOM_INDEX(tablePtr, key);


    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
        hPtr = hPtr->nextPtr) {
        if (hPtr->key.oneWordValue == key) {
            if (newPtr)
                *newPtr = 0;
            return hPtr;
        }
    }

    if (newPtr)
        *newPtr = 1;
    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1,sizeof(*hPtr));
    hPtr->typ = JSI_MAP_HASH;
    bucketPtr = tablePtr->buckets + hindex;
    hPtr->tablePtr = tablePtr;
    hPtr->nextPtr = *bucketPtr;
    hPtr->hval = (jsi_Hash)key;
    hPtr->clientData = 0;
    hPtr->key.oneWordValue = (void *)key; 
    *bucketPtr = hPtr;
    tablePtr->numEntries++;


    if (tablePtr->numEntries >= tablePtr->rebuildSize) {
        RebuildTable(tablePtr);
    }
    return hPtr;
}

static jsi_Hash
HashArray(const void *key, size_t length )
{
    const char *string = (const char *) key;
    unsigned int result;
    int c, i;

    result = 0;

    for (i=0, c=*string++ ; i<(int)length; i++, c=*string++) {
        result += (result<<3) + c;
    }
    return (jsi_Hash)result;
}



static Jsi_HashEntry *
HashArrayFind( Jsi_Hash *tablePtr, const void *key)
{
    jsi_Hash hval;
     Jsi_HashEntry *hPtr;
    size_t hindex;

    hval = HashArray(key, tablePtr->keyType);
    hindex = hval & tablePtr->mask;

    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
        hPtr = hPtr->nextPtr) {
        if (hPtr->hval == hval) {
            if (memcmp(hPtr->key.words, key, tablePtr->keyType))
                break;
        }
    }
    return NULL;
}

static Jsi_HashEntry *
HashArrayCreate( Jsi_Hash *tablePtr,  const void *key, int *newPtr)
{
    jsi_Hash hval;
    Jsi_HashEntry **bucketPtr;
    int count;
     Jsi_HashEntry *hPtr;
    size_t size, hindex;

    hval = HashArray(key, tablePtr->keyType);
    hindex = hval & tablePtr->mask;

    /*
     * Search all of the entries in the appropriate bucket.
     */
    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;
            hPtr = hPtr->nextPtr) {
        if (hPtr->hval == hval) {
            if (memcmp(hPtr->key.words, key, tablePtr->keyType))
                break;
        }
    }

    /* Entry not found.  Add a new one to the bucket. */
    if (newPtr)
        *newPtr = 1;
    /* We assume here that the size of the key is at least 2 words */
    size = sizeof(Jsi_HashEntry) + tablePtr->keyType -
           sizeof(jsi_HashKey);
    hPtr = (Jsi_HashEntry*)Jsi_Malloc(size);
    bucketPtr = tablePtr->buckets + hindex;
    hPtr->tablePtr = tablePtr;
    hPtr->nextPtr = *bucketPtr;
    hPtr->hval = hval;
    hPtr->clientData = 0;
    count = tablePtr->keyType;
    memcpy(hPtr->key.words, key, count);
    *bucketPtr = hPtr;
    tablePtr->numEntries++;

    /*
     * If the table has exceeded a decent size, rebuild it with many
     * more buckets.
     */
    if (tablePtr->numEntries >= tablePtr->rebuildSize) {
        RebuildTable(tablePtr);
    }
    return hPtr;
}


Jsi_HashEntry *
Jsi_HashEntryFind( Jsi_Hash *tablePtr, const void *key)
{
    if (tablePtr->lockProc && (*tablePtr->lockProc)(tablePtr, 1) != JSI_OK)
        return NULL;
    Jsi_HashEntry *hPtr = (*((tablePtr)->findProc))(tablePtr, key);
    if (tablePtr->lockProc)
        (*tablePtr->lockProc)(tablePtr, 0);
    return hPtr;
}

Jsi_HashEntry *
Jsi_HashEntryNew(Jsi_Hash *tablePtr, const void *key, int *newPtr)
{
    if (tablePtr->lockProc && (*tablePtr->lockProc)(tablePtr, 1) != JSI_OK)
        return NULL;
    Jsi_HashEntry *hPtr =  (*((tablePtr)->createProc))(tablePtr, key, newPtr);
#ifdef JSI_HAS_SIG_HASHENTRY
    SIGINIT(hPtr, HASHENTRY);
#endif
    if (tablePtr->lockProc)
        (*tablePtr->lockProc)(tablePtr, 0);
    return hPtr;
}

static void
RebuildTable(Jsi_Hash *tablePtr)
{
    Jsi_HashEntry **bucketPtr, **oldBuckets;
    Jsi_HashEntry **oldChainPtr, **endPtr;
    Jsi_HashEntry *hPtr, *nextPtr;
    size_t hindex;

    oldBuckets = tablePtr->buckets;
    endPtr = tablePtr->buckets + tablePtr->numBuckets;
    tablePtr->numBuckets <<= 2;
    tablePtr->buckets = (Jsi_HashEntry**)Jsi_Calloc(tablePtr->numBuckets, 
                   sizeof(Jsi_HashEntry *));
    tablePtr->rebuildSize <<= 2;
    tablePtr->downShift -= 2;
    tablePtr->mask = tablePtr->numBuckets - 1;

 
    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {

    for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {
        for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {
        nextPtr = hPtr->nextPtr;
        hindex = RANDOM_INDEX(tablePtr, hPtr->key.oneWordValue);
        bucketPtr = tablePtr->buckets + hindex;
        hPtr->nextPtr = *bucketPtr;
        *bucketPtr = hPtr;
        }
    }
    } else {
        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {
            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {
            nextPtr = hPtr->nextPtr;
            hindex = hPtr->hval & tablePtr->mask;
            bucketPtr = tablePtr->buckets + hindex;
            hPtr->nextPtr = *bucketPtr;
            *bucketPtr = hPtr;
            }
        }
    }

    if (oldBuckets != tablePtr->staticBuckets) {
        Jsi_Free(oldBuckets);
    }
}

Jsi_Hash *
Jsi_HashNew(Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc freeProc)
{
    Jsi_Hash *tablePtr = (Jsi_Hash*)Jsi_Calloc(1,sizeof(*tablePtr));
    SIGINIT(tablePtr, HASH);
    tablePtr->typ = JSI_MAP_HASH;
    tablePtr->interp = interp;
    tablePtr->buckets = tablePtr->staticBuckets;
    tablePtr->numBuckets = JSI_SMALL_HASH_TABLE;
    tablePtr->rebuildSize = JSI_SMALL_HASH_TABLE * REBUILD_MULTIPLIER;
    tablePtr->downShift = DOWNSHIFT_START;
    tablePtr->freeProc = freeProc;

    tablePtr->mask = (jsi_Hash)(tablePtr->numBuckets - 1);
    tablePtr->keyType = keyType;

    switch (keyType) {
    case JSI_KEYS_STRING:   /* NUL terminated string keys. */
        tablePtr->findProc = HashStringFind;
        tablePtr->createProc = HashStringCreate;
        break;

    case JSI_KEYS_STRINGKEY: /* Lookup from another String hash, eg. Jsi_KeyAdd() */
    case JSI_KEYS_ONEWORD: /* A pointer. */
        tablePtr->findProc = HashOneWordFind;
        tablePtr->createProc = HashOneWordCreate;
        break;

    default:            /* Structs. */
        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {
            Jsi_LogError("Jsi_HashNew: Key size can't be %d, must be >= %d\n", keyType, JSI_KEYS_STRUCT_MINSIZE);
            Jsi_Free(tablePtr);
            return NULL;
        }
        tablePtr->findProc = HashArrayFind;
        tablePtr->createProc = HashArrayCreate;
        break;
    }
    return tablePtr;
}

int
Jsi_HashEntryDelete(Jsi_HashEntry *entryPtr)
{
    Jsi_HashEntry *prevPtr;
    Jsi_HashEntry **bucketPtr;
    size_t hindex;
    Jsi_Hash *tablePtr = entryPtr->tablePtr;
    Jsi_Interp *interp = tablePtr->interp;
    JSI_NOTUSED(interp);
    int cnt = 0;
#ifdef JSI_HAS_SIG_HASHENTRY
    SIGASSERT(entryPtr, HASHENTRY);
#endif
    if (tablePtr->lockProc && (*tablePtr->lockProc)(tablePtr, 1) != JSI_OK)
        return 0;
    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {
        hindex = RANDOM_INDEX(tablePtr, (const void *)entryPtr->hval);
    } else {
        hindex = (entryPtr->hval & tablePtr->mask);
    }
    bucketPtr = tablePtr->buckets + hindex;
    if (*bucketPtr == entryPtr) {
        *bucketPtr = entryPtr->nextPtr;
        cnt++;
    } else {
        for (prevPtr = *bucketPtr; /*empty*/; prevPtr = prevPtr->nextPtr) {
            if (prevPtr == NULL) {
                Jsi_LogFatal("malformed bucket chain in Jsi_HashEntryDelete");
            }
            if (prevPtr->nextPtr == entryPtr) {
                prevPtr->nextPtr = entryPtr->nextPtr;
                cnt++;
                break;
            }
        }
    }
    if (tablePtr->lockProc)
        (*tablePtr->lockProc)(tablePtr, 0);
    tablePtr->numEntries--;
    Jsi_Free(entryPtr);
    return cnt;
}

void
Jsi_HashDelete(Jsi_Hash *tablePtr)
{
    Jsi_HashEntry *hPtr, *nextPtr;
    size_t i;
    if (!tablePtr)
        return;
    if (tablePtr->lockProc && (*tablePtr->lockProc)(tablePtr, 1) != JSI_OK)
        return;
    for (i = 0; i < (size_t)tablePtr->numBuckets; i++) {
        hPtr = tablePtr->buckets[i];
        while (hPtr != NULL) {
            nextPtr = hPtr->nextPtr;
            if (tablePtr->freeProc && hPtr->clientData)
                (tablePtr->freeProc)(tablePtr->interp, hPtr, hPtr->clientData);
            Jsi_Free(hPtr);
            hPtr = nextPtr;
        }
    }
    
    if (tablePtr->buckets != tablePtr->staticBuckets) {
        Jsi_Free(tablePtr->buckets);
    }
    if (tablePtr->lockProc)
        (*tablePtr->lockProc)(tablePtr, 0);
    Jsi_Free(tablePtr);
}

Jsi_HashEntry *
Jsi_HashEntryFirst(Jsi_Hash *tablePtr, Jsi_HashSearch *searchPtr) 
{
    searchPtr->tablePtr = tablePtr;
    searchPtr->nextIndex = 0;
    searchPtr->nextEntryPtr = NULL;
    return Jsi_HashEntryNext(searchPtr);
}


void *Jsi_HashValueGet(Jsi_HashEntry *h)
{
    return h->clientData;
}

void Jsi_HashValueSet(Jsi_HashEntry *h, void *value)
{
    h->clientData = value;
}

void *Jsi_HashKeyGet(Jsi_HashEntry *h)
{
    Jsi_Hash *tablePtr = h->tablePtr;
    if (tablePtr->keyType == JSI_KEYS_ONEWORD)
        return h->key.oneWordValue;
    else
        return h->key.string;
}

Jsi_HashEntry *
Jsi_HashEntryNext(Jsi_HashSearch *searchPtr)
{
    Jsi_HashEntry *hPtr;
    Jsi_Hash *tablePtr = searchPtr->tablePtr;
    int locked = 0;
    
    while (searchPtr->nextEntryPtr == NULL) {
        if (searchPtr->nextIndex >= (size_t)tablePtr->numBuckets) {
            if (tablePtr->lockProc && locked)
                (*tablePtr->lockProc)(tablePtr, 0);
            return NULL;
        }
        if (tablePtr->lockProc && locked == 0 && (*tablePtr->lockProc)(tablePtr, locked++) != JSI_OK)
            return NULL;
        searchPtr->nextEntryPtr =
            tablePtr->buckets[searchPtr->nextIndex];
        searchPtr->nextIndex++;
    }
    if (tablePtr->lockProc && locked)
        (*tablePtr->lockProc)(tablePtr, 0);
    hPtr = searchPtr->nextEntryPtr;
    searchPtr->nextEntryPtr = hPtr->nextPtr;
    return hPtr;
}


Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *tbl, void *key, void *value) {
    Jsi_HashEntry *hPtr;
    int isNew;
    hPtr = Jsi_HashEntryNew(tbl, key, &isNew);
    if (!hPtr) return hPtr;
    Jsi_HashValueSet(hPtr, value);
    return hPtr;
}

void *Jsi_HashGet(Jsi_Hash *tbl, void *key) {
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryFind(tbl, key);
    if (!hPtr)
        return NULL;
    return Jsi_HashValueGet(hPtr);
}

#ifndef JSI_LITE_ONLY
int Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *tablePtr, Jsi_Value **ret, int flags) {
    char *key;
    int n = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Obj *nobj;
    
    if (tablePtr->keyType != JSI_KEYS_STRING && tablePtr->keyType != JSI_KEYS_STRINGKEY)
        return JSI_ERROR;
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    for (hPtr = Jsi_HashEntryFirst(tablePtr, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        key = (char*)Jsi_HashKeyGet(hPtr);
        Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n++);
    }
    return JSI_OK;
}
#endif

int Jsi_HashSize(Jsi_Hash *hashPtr) { return hashPtr->numEntries; }
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

static struct { const char *name; const char *type; } optTypeInfo[JSI_OPTION_END+1] = {
    {"NONE",""}, {"BOOL","char"}, {"INT","int"}, {"WIDE", "Jsi_Wide"},
    {"BYTE", "Jsi_BYTE"}, {"WORD", "Jsi_WORD"}, {"DWORD", "Jsi_DWORD"}, {"QWORD","Jsi_QWORD"},
    {"DOUBLE", "Jsi_Number"}, {"STRING", "Jsi_Value*"}, {"DSTRING", "Jsi_DString"},
    {"STRKEY","const char*"}, {"STRBUF","Jsi_Strbuf"},
    {"VALUE", "Jsi_Value*"}, {"VAR","Jsi_Value*"}, {"OBJ","Jsi_Obj*"}, {"ARRAY", "Jsi_Value*"},
    {"FUNC", "Jsi_Value*"}, {"DATETIME","Jsi_Number"}, {"DATE","Jsi_Number"},
    {"TIME","Jsi_Number"}, {"TIMESTAMP","time_t"}, {"CUSTOM",""},
    {NULL}
};

int Jsi_OptionsValid(Jsi_Interp *interp,  Jsi_OptionSpec* spec)
{
    int i = 0;
    while (spec[i].type>JSI_OPTION_NONE && spec[i].type < JSI_OPTION_END) {
        if (spec[i].help && strchr(spec[i].help, '\n')) {
            if (interp)
                Jsi_LogError("item \"%s\": help contains newline", spec[i].name);
            return 0;
        }
        i++;
    }
    return 1;
}

#ifndef JSI_LITE_ONLY

static void DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName);

static int DeleteSpecCacheTable(Jsi_Interp *interp, void *clientData)
{
  Jsi_Hash *tablePtr = (Jsi_Hash *) clientData;
  Jsi_HashEntry *entryPtr;
  Jsi_HashSearch search;

  for (entryPtr = Jsi_HashEntryFirst(tablePtr,&search); entryPtr != NULL;
      entryPtr = Jsi_HashEntryNext(&search)) {

    Jsi_Free(Jsi_HashValueGet(entryPtr));
  }
  Jsi_HashDelete(tablePtr);
  return JSI_OK;
}

static Jsi_OptionSpec * GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
    Jsi_OptionSpec *cachedSpecs;
    Jsi_Hash *specCacheTablePtr;
    Jsi_HashEntry *entryPtr;
    int isNew;

    specCacheTablePtr = (Jsi_Hash*)Jsi_InterpGetData(interp, "jsi:OptionSpec", NULL);
    if (specCacheTablePtr == NULL) {
        specCacheTablePtr = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);
        Jsi_InterpSetData(interp, "jsi:OptionSpec",
                         DeleteSpecCacheTable, specCacheTablePtr);
    }
    
    entryPtr = Jsi_HashEntryNew(specCacheTablePtr, (char *) staticSpecs, &isNew);
    if (isNew) {
        unsigned int entrySpace = sizeof(Jsi_OptionSpec);
        const Jsi_OptionSpec *staticSpecPtr;

        for (staticSpecPtr=staticSpecs; staticSpecPtr->type>=JSI_OPTION_NONE && staticSpecPtr->type!=JSI_OPTION_END; staticSpecPtr++)
            entrySpace += sizeof(Jsi_OptionSpec);
        assert(staticSpecPtr->type==JSI_OPTION_END);

        cachedSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);
        memcpy((void *) cachedSpecs, (void *) staticSpecs, entrySpace);
        Jsi_HashValueSet(entryPtr, cachedSpecs);

    } else {
        cachedSpecs = (Jsi_OptionSpec *) Jsi_HashValueGet(entryPtr);
    }

    return cachedSpecs;
}

const Jsi_OptionSpec *
Jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
#ifdef NO_CACHED_SPECS
    return (Jsi_OptionSpec*)staticSpecs;
#else
    /* If we aren't master interp, need to cache due to init and modified flags if Jsi_OptionsChanged is called. */
    if (interp->mainInterp == NULL) {
        interp->mainInterp = interp;
    }
    if (interp == interp->mainInterp) {
        return staticSpecs;
    }
    return GetCachedOptionSpecs(interp, staticSpecs);
#endif
}

/**********************************/

static Jsi_OptionSpec *
FindOptionSpec(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, int flags)
{
    Jsi_OptionSpec *specPtr;
    char c;      /* First character of current argument. */
    Jsi_OptionSpec *matchPtr; /* Matching spec, or NULL. */
    size_t length;

    
    if (name == NULL) {
        Jsi_LogError("Null name for option");
        return NULL;
    }
    c = name[0];
    length = strlen(name);
    matchPtr = NULL;
    for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name; specPtr++) {

        if ((specPtr->name[0] != c)
                || (strncmp(specPtr->name, name, length) != 0)) {
            continue;
        }
        if (specPtr->name[length] == 0) {
            return specPtr;   /* Stop on a perfect match. */
        }
        if (matchPtr != NULL) {
            Jsi_LogError("ambiguous option \"%s\"", name);
            return (Jsi_OptionSpec *) NULL;
        }
        matchPtr = specPtr;
    }

    if (matchPtr == NULL) {
        Jsi_DString dStr = {};
        Jsi_DSAppend(&dStr, "unknown option \"", name, "\" not one of: ", NULL);
    
        for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name; specPtr++) {
            if (specPtr->name == NULL) {
                break;
            }
            if (name[0] != '?' || specPtr->type < 0 || specPtr->type >= JSI_OPTION_END) {
                Jsi_DSAppend(&dStr, specPtr->name, " ", NULL);
            } else {
                if (optTypeInfo[JSI_OPTION_END].name != 0) {
                    fprintf(stderr, "Jsi_OptionTypes out of sync with enum\n");
                    continue;
                }
                Jsi_DSAppend(&dStr, "?", specPtr->name, " <", optTypeInfo[specPtr->type].name, ">? ", NULL);
            }
        }
        assert(specPtr->type == JSI_OPTION_END);
        Jsi_LogError("%s", Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        return (Jsi_OptionSpec *) NULL;
    }
    return matchPtr;
}


static int
SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue)
{
    char *ptr;
    int n, flags = specPtr->flags;
    Jsi_Wide wcount = 0;
    char *record = (char*)rec;

    ptr = (char *)record + specPtr->offset;
    if (specPtr->type<=JSI_OPTION_NONE || specPtr->type>=JSI_OPTION_END) {
        Jsi_LogError("unknown option type \"%d\" for \"%s\"", specPtr->type, specPtr->name);
        return JSI_ERROR;
    }
    if (specPtr->custom) {
        Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
        if (cust && cust->parseProc) {
            if ((*cust->parseProc)(interp, specPtr, argValue, NULL, record) != JSI_OK)
                return JSI_ERROR;
        } else {
            Jsi_LogError("missing or bad custom for \"%s\"", specPtr->name);
            return JSI_ERROR;
        }
        goto done;
    }

    switch (specPtr->type) {
    case JSI_OPTION_CUSTOM:
    case JSI_OPTION_NONE:
    case JSI_OPTION_END:
        break;

    case JSI_OPTION_BOOL: {
        if (!argValue)
            *(char*)ptr = 0;
        else if (Jsi_GetBoolFromValue(interp, argValue, &n) != JSI_OK)
            return JSI_ERROR;
        else
            *(char*)ptr = n;
        break;
    }

    case JSI_OPTION_INT:
        if (!argValue)
            *(int*)ptr = 0;
        else if (Jsi_GetIntFromValue(interp, argValue, (int *)ptr) != JSI_OK) {
            return JSI_ERROR;
        }
        break;
        
    case JSI_OPTION_WIDE:
        if (argValue) {
            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {
                return JSI_ERROR;
            }
        }
        *((int *)ptr) = (int)wcount;
        break;

    case JSI_OPTION_BYTE:
        if (argValue) {
            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {
                return JSI_ERROR;
            }
        }
        *((Jsi_BYTE *)ptr) = (Jsi_BYTE)wcount;
        break;
    case JSI_OPTION_WORD:
        if (argValue) {
            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {
                return JSI_ERROR;
            }
        }
        *((Jsi_WORD *)ptr) = (Jsi_WORD)wcount;
        break;
    case JSI_OPTION_DWORD:
        if (argValue) {
            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {
                return JSI_ERROR;
            }
        }
        *((Jsi_DWORD *)ptr) = (Jsi_DWORD)wcount;
        break;
    case JSI_OPTION_QWORD:
        if (argValue) {
            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {
                return JSI_ERROR;
            }
        }
        *((Jsi_QWORD *)ptr) = (Jsi_QWORD)wcount;
        break;

    case JSI_OPTION_DOUBLE:
        if (!argValue)
            *(Jsi_Number*)ptr = 0;
        else if (Jsi_GetDoubleFromValue(interp, argValue, (Jsi_Number *)ptr) != JSI_OK)
            return JSI_ERROR;
        break;
    case JSI_OPTION_STRKEY:
    {
        if (!argValue)
            *(const char**)ptr = NULL;
        else {
            const char *scp;
            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                return JSI_ERROR;
            }
            *(const char**)ptr = Jsi_KeyAdd(interp,scp);
        }
    }
    break;
    case JSI_OPTION_STRBUF:
    {
        if (!argValue)
            *(char*)ptr = 0;
        else {
            const char *scp;
            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                return JSI_ERROR;
            }
            strncpy((char*)ptr, scp, specPtr->size);
            ((char*)ptr)[specPtr->size-1] = 0;
        }
    }
    break;
#define _JSI_OPT_ARGSET(argValue, ptr) \
    if (!(flags&JSI_OPT_NO_DUPVALUE)) {\
        Jsi_IncrRefCount(interp, argValue); \
        if (*((Jsi_Value **)ptr)) Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \
    }\
    *((Jsi_Value **)ptr) = argValue;
    
    case JSI_OPTION_STRING:
        if (!argValue)
            *(Jsi_Value**)ptr = NULL;
        else {
            if (!Jsi_ValueIsString(interp, argValue)) {
                Jsi_LogError("expected a string");
                return JSI_ERROR;
            }
            _JSI_OPT_ARGSET(argValue, ptr);
        }
        break;
        
    case JSI_OPTION_DSTRING:
        Jsi_DSInit((Jsi_DString *)ptr);
        if (argValue)
        {
            const char *scp;
            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                return JSI_ERROR;
            }
            Jsi_DSAppend((Jsi_DString *)ptr, scp, NULL);
        }
        break;
    
    case JSI_OPTION_DATE:
    case JSI_OPTION_TIME:
    case JSI_OPTION_DATETIME: {
       if (argValue)
        {
            if (Jsi_ValueIsNumber(interp, argValue)) {
                Jsi_GetNumberFromValue(interp, argValue, (Jsi_Number*)ptr);
            } else {
                const char *scp;
                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                    return JSI_ERROR;
                }
                if (JSI_OK != Jsi_DatetimeParse(interp, scp, "", 0, (Jsi_Number*)ptr))
                    return JSI_ERROR;
            }
        } else {
            *(Jsi_Number*)ptr = 0;
        }
        break;
    }
    case JSI_OPTION_TIMESTAMP: {
       if (argValue)
        {
            if (Jsi_ValueIsNumber(interp, argValue)) {
                Jsi_Number num;
                Jsi_GetNumberFromValue(interp, argValue, &num);
                *(time_t*)ptr = (time_t)num;
            } else {
                const char *scp;
                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {
                    return JSI_ERROR;
                }
                Jsi_Number nval;
                if (JSI_OK != Jsi_DatetimeParse(interp, scp, "", 0, &nval))
                    return JSI_ERROR;
                *(time_t*)ptr = nval/1000LL;
            }
        } else {
            *(time_t*)ptr = 0;
        }
        break;
    }
    
    case JSI_OPTION_VAR:
        if (!argValue)
            *(Jsi_Value**)ptr = NULL;
        else {
            if (argValue->vt != JSI_VT_NULL && argValue->vt != JSI_VT_VARIABLE) {
                Jsi_LogError("expected a var");
                return JSI_ERROR;
            }
            _JSI_OPT_ARGSET(argValue, ptr);
        }
        break;

    case JSI_OPTION_FUNC:
        if (!argValue)
            *(Jsi_Value**)ptr = NULL;
        else {
            if (argValue->vt != JSI_VT_NULL && (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_FUNCTION)) {
                Jsi_LogError("expected a func value");
                return JSI_ERROR;
            }
            _JSI_OPT_ARGSET(argValue, ptr);
        }
        break;

    case JSI_OPTION_OBJ:
        if (!argValue)
            *(Jsi_Obj**)ptr = NULL;
        else {
            if (argValue->vt != JSI_VT_OBJECT) {
                Jsi_LogError("expected an object");
                return JSI_ERROR;
            }
        }
    case JSI_OPTION_VALUE:
        if (!argValue)
            *(Jsi_Value**)ptr = NULL;
        else {
            _JSI_OPT_ARGSET(argValue, ptr);
        }
        break;
    case JSI_OPTION_ARRAY:
        if (!argValue)
            *(Jsi_Value**)ptr = NULL;
        else {
            if (argValue->vt != JSI_VT_OBJECT || !argValue->d.obj->isarrlist) {
                Jsi_LogError("expected an array");
                return JSI_ERROR;
            }
            _JSI_OPT_ARGSET(argValue, ptr);
        }
        break;

    }
done:
    specPtr->flags |= JSI_OPT_IS_SPECIFIED;
    return JSI_OK;
}

int
Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *option, void* rec, Jsi_Value *argValue, int flags)
{
    char *record = (char*)rec;
    Jsi_OptionSpec *specPtr;
    specs = GetCachedOptionSpecs(interp, specs);
    specPtr = FindOptionSpec(interp, specs, option, flags);
    if (!specPtr)
        return JSI_ERROR;
    return SetOption(interp, specPtr, option, record, argValue);
}

static int
GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, Jsi_Value **valuePtr, const char *option)
{
    char *ptr;
    
    if (specPtr == NULL) {
        Jsi_LogError("no such option: %s", option);
        return JSI_ERROR;
    }
    //isNull = ((*string == '\0') && (specPtr->flags & JSI_OPTION_NULL_OK));
    
    ptr = (char *)record + specPtr->offset;
    if (specPtr->type<0 || specPtr->type>=JSI_OPTION_END) {
        Jsi_LogError("no such option: %s", option);
        return JSI_ERROR;
    }
    if (specPtr->custom) {
        Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
        if (cust->formatProc)
            return (*cust->formatProc) (interp, specPtr, valuePtr, NULL, record);
    }

    switch (specPtr->type) {
    case JSI_OPTION_NONE:
        Jsi_LogError("invalid option type 0");
        return JSI_ERROR;
        break;
    case JSI_OPTION_END:
        break;
    case JSI_OPTION_BOOL:
        Jsi_ValueMakeBool(interp, valuePtr,*(char*)ptr );
        break;
    case JSI_OPTION_INT:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int *)ptr));
        break;
    case JSI_OPTION_WIDE:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_Wide *)ptr));
        break;
    case JSI_OPTION_BYTE:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_BYTE *)ptr));
        break;
    case JSI_OPTION_WORD:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_WORD *)ptr));
        break;
    case JSI_OPTION_DWORD:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_DWORD *)ptr));
        break;
    case JSI_OPTION_QWORD:
        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_QWORD *)ptr));
        break;
    case JSI_OPTION_DOUBLE:
        Jsi_ValueMakeNumber(interp, valuePtr, *(Jsi_Number *)ptr);
        break;
        
    case JSI_OPTION_DSTRING:
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue((Jsi_DString*)ptr));
        break;
    
    case JSI_OPTION_DATE:
    case JSI_OPTION_TIME:
    case JSI_OPTION_DATETIME: {
        Jsi_DString dStr = {};
        Jsi_DatetimeFormat(interp, *(Jsi_Wide*)ptr, "", 0, &dStr);
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        break;
    }
    case JSI_OPTION_TIMESTAMP: {
        Jsi_DString dStr = {};
        Jsi_DatetimeFormat(interp, 1000LL* (Jsi_Wide)*(time_t*)ptr, "%Y-%m-%d %H:%M:%S", 0, &dStr);
        Jsi_ValueMakeStringDup(interp, valuePtr, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
        break;
    }
    case JSI_OPTION_STRBUF:
        if (ptr)
            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);
        else
            Jsi_ValueMakeNull(interp, valuePtr);
        break;

    case JSI_OPTION_STRKEY:
        ptr = *(char **)ptr;
        if (ptr)
            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);
        else
            Jsi_ValueMakeNull(interp, valuePtr);
        break;

    case JSI_OPTION_STRING:
    case JSI_OPTION_VAR:
    case JSI_OPTION_FUNC:
    case JSI_OPTION_OBJ:
    case JSI_OPTION_VALUE:
    case JSI_OPTION_ARRAY:
        if (*(Jsi_Value **)ptr)
            Jsi_ValueReplace(interp, valuePtr, *(Jsi_Value **)ptr);
        else
            Jsi_ValueMakeNull(interp, valuePtr);
        break;

    case JSI_OPTION_CUSTOM:
        break;

    }

    return JSI_OK;
}

Jsi_Value *
Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *name, void *rec, int offset)
{
    char *record = (char*)rec;
    Jsi_Value *valuePtr;
    valuePtr = *(Jsi_Value **)(record + offset);
    return valuePtr;
}


int
Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, const char *option, Jsi_Value** valuePtr, int flags)
{
    char *record = (char*)rec;
    Jsi_OptionSpec *specPtr;

    specPtr = FindOptionSpec(interp, specs, option, flags);
    if (specPtr == NULL || GetOption(interp, specPtr, record, valuePtr, option) != JSI_OK) {
        return JSI_ERROR;
    }

    return JSI_OK;

}

int
Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Value **ret, int flags)
{
    char *record = (char*)rec;
    Jsi_OptionSpec *specPtr = specs;
    int len = 0, i = 0, count = 0;
    if (!Jsi_OptionsValid(interp, specs))
        return JSI_ERROR;
    
    while (specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name) {
        specPtr++;
        len+=2;
    }
    if (!len)
        return JSI_OK;
    Jsi_Value *rv = Jsi_ValueMakeObject(interp, NULL, NULL);
    Jsi_IncrRefCount(interp, rv);
    Jsi_Obj *obj = rv->d.obj;
    specPtr = specs;
    while (specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name) {
        Jsi_Value  *vv = Jsi_ValueNew1(interp);
        if (GetOption(interp, specPtr, record, &vv, NULL) != JSI_OK) {
            Jsi_DecrRefCount(interp, vv);
            Jsi_DecrRefCount(interp, rv);
            return JSI_ERROR;
        }
        if (flags&JSI_OPTS_VERBOSE) {
            // dump: type,value,help,info,init
            Jsi_Value *vrv = Jsi_ValueMakeObject(interp, NULL, NULL);
            Jsi_IncrRefCount(interp, vrv);
            Jsi_Obj *vobj = vrv->d.obj;
            Jsi_ObjInsert(interp, vobj, "value", vv, 0);
            Jsi_DecrRefCount(interp, vv);
            vv = vrv;
            DumpOptionSpec(interp, vobj, specPtr, 0);
        }
        Jsi_ObjInsert(interp, obj, specPtr->name, vv, 0);
        Jsi_DecrRefCount(interp, vv);
        count++;
        i++;
        specPtr++;
    }
    assert(specPtr->type == JSI_OPTION_END);
    Jsi_ValueReplace(interp, ret, rv);
    Jsi_DecrRefCount(interp, rv);
    return JSI_OK;
}

int
Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args, void *rec, int flags)
{
    Jsi_OptionSpec *specPtr;
    int count = 0;
    char *record = (char*)rec;
    Jsi_TreeEntry *tPtr;
    Jsi_TreeSearch search;
    Jsi_Obj *to;
    if (!Jsi_OptionsValid(interp, specs))
        return -1;

    if (interp->compat && !(flags&JSI_OPTS_FORCE_STRICT))
        flags |=  JSI_OPTS_IGNORE_EXTRA;
    assert((sizeof(optTypeInfo)/sizeof(optTypeInfo[0]) == (JSI_OPTION_END+1)));
    specs = GetCachedOptionSpecs(interp, specs);
    
    if (args == NULL || args->vt == JSI_VT_NULL) {
        for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name; specPtr++) {
            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;
            if (SetOption(interp, specPtr, (char*)specPtr->name, record, NULL) != JSI_OK)
                return -1;
        }
        assert(specPtr->type == JSI_OPTION_END);
        return 0;
    }
    if (args->vt != JSI_VT_OBJECT || args->d.obj->ot != JSI_OT_OBJECT || args->d.obj->arr) {
        Jsi_LogError("expected object");
        return -1;
    }
    to = args->d.obj;

    if ((JSI_OPTS_IS_UPDATE&flags)==0) {
        for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name; specPtr++) {
            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;
        }
        assert(specPtr->type == JSI_OPTION_END);
    }
        
    for (tPtr = Jsi_TreeEntryFirst(to->tree, &search, 0);
        tPtr != NULL; tPtr = Jsi_TreeEntryNext(&search)) {
        
        const char *arg;
        Jsi_Value *optval;
        count++;
        arg =(char*) Jsi_TreeKeyGet(tPtr);
        optval = (Jsi_Value*)Jsi_TreeValueGet(tPtr);

        specPtr = FindOptionSpec(interp, specs, arg, flags);
        if (specPtr == NULL) {
            if (flags&JSI_OPTS_IGNORE_EXTRA)
                continue;
            count = -1;
            goto done;
        }

        if ((JSI_OPT_READ_ONLY&specPtr->flags)) {
            Jsi_LogWarn("Error option is readonly: \"%.40s\"", specPtr->name);
            count = -1;
            goto done;
        }
        if ((JSI_OPTS_IS_UPDATE&flags) && (JSI_OPT_INIT_ONLY&specPtr->flags)) {
            Jsi_LogWarn("Error can not update option: \"%.40s\"", specPtr->name);
            count = -1;
            goto done;
        }

        if (SetOption(interp, specPtr, (char*)arg, record, optval) != JSI_OK) {
            Jsi_LogWarn("Error processing option: \"%.40s\"", specPtr->name);
            count = -1;
            goto done;
        }
 
        specPtr->flags |= JSI_OPT_IS_SPECIFIED;
    }
done:
    Jsi_TreeSearchDone(&search);
    return count;

}

int
Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *val, void *rec, Jsi_Value **ret, int flags)
{
    flags |= JSI_OPTS_IS_UPDATE;
    if (!Jsi_OptionsValid(interp, specs))
        return JSI_ERROR;
    
    if (!val)
        return Jsi_OptionsDump(interp, specs, rec, ret, flags);
    if (val->vt == JSI_VT_NULL)
        return Jsi_OptionsDump(interp, specs, rec, ret, flags|JSI_OPTS_VERBOSE);
    if (Jsi_ValueIsString(interp, val)) {
        const char *cp = Jsi_ValueString(interp, val, NULL);
        if (cp && *cp)
            return Jsi_OptionsGet(interp, specs, rec, cp, ret, flags);
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, specs);
        Jsi_ValueReplace(interp, ret, svalue);
        return JSI_OK;
    }
    if (val->vt != JSI_VT_OBJECT) {
        Jsi_LogError("expected string, object, or null");
        return JSI_ERROR;
    }
    if (Jsi_OptionsProcess(interp, specs, val, rec, JSI_OPTS_IS_UPDATE) < 0)
        return JSI_ERROR;
    return JSI_OK;
}

static void DumpCustomSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionCustom* spec, void *data)
{
    if (spec->help) {
        if (Jsi_Strchr(spec->help, '\n'))
            Jsi_LogError("%s .help contains newline: %s", spec->name, spec->help);
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringKey(interp, spec->help),0);
    }
    if (spec->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringKey(interp, spec->info),0);
    Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, spec->name),0);
#if 0
    if (spec == &jsi_OptSwitchEnum || spec == &jsi_OptSwitchEnumNocase || spec == &jsi_OptSwitchBitset) {
        char **lst = data;
        int i = 0;
        Jsi_DString dStr = {};
        if (spec == &jsi_OptSwitchBitset)
            Jsi_DSAppend(&dStr, "Zero or more of: [", NULL);
        else
            Jsi_DSAppend(&dStr, "One of: [", NULL);
        while (lst[i]) {
            Jsi_DSAppend(&dStr, (i?" ,":""), lst[i], NULL);
            i++;
        }
        Jsi_DSAppend(&dStr, "].", NULL);
        Jsi_ObjInsert(interp, nobj, "data", Jsi_ValueNewStringDup(interp, Jsi_DSValue(&dStr)),0);
        Jsi_DSFree(&dStr);
   /*
    else if (spec == Jsi_OptSwitchSubopt) {
    } else {
        //TODO: custom dumper?*/
    }
#endif
}

static void DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName)
{
    if (addName)
        Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, spec->name),0);
    if (spec->help) {
        if (Jsi_Strchr(spec->help, '\n'))
            Jsi_LogError("%s .help contains newline: %s", spec->name, spec->help);
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringKey(interp, spec->help),0);
    }
    if (spec->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringKey(interp, spec->info),0);
    Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp, Jsi_OptionTypeStr(spec->type,0)),0);
    Jsi_ObjInsert(interp, nobj, "tname", Jsi_ValueNewStringKey(interp, Jsi_OptionTypeStr(spec->type,1)),0);
    if (spec->init)
        Jsi_ObjInsert(interp, nobj, "init", Jsi_ValueNewStringKey(interp, spec->init),0);
    Jsi_ObjInsert(interp, nobj, "initOnly", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_INIT_ONLY)!=0), 0);
    Jsi_ObjInsert(interp, nobj, "readOnly", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_READ_ONLY)!=0), 0);
    Jsi_ObjInsert(interp, nobj, "size", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->size), 0);
    if (spec->flags)
        Jsi_ObjInsert(interp, nobj, "flags", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->flags), 0);
    if (spec->data) {
        if (spec->type == JSI_OPTION_CUSTOM && (spec->custom == Jsi_Opt_SwitchBitset ||
            spec->custom == Jsi_Opt_SwitchEnum)) {
            Jsi_ObjInsert(interp, nobj, "data", Jsi_ValueNewArray(interp, (char**)spec->data, -1), 0);
        } else
            Jsi_ObjInsert(interp, nobj, "data", Jsi_ValueNewNumber(interp, (Jsi_Number)(int)spec->data), 0);
    }
    if (spec->type == JSI_OPTION_CUSTOM && spec->custom) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
        Jsi_Value *cvalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        DumpCustomSpec(interp, sobj,  Jsi_OptionCustomBuiltin(spec->custom), spec->data);
        Jsi_ObjInsert(interp, nobj, "customArg", cvalue,0);
    }
}

void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)
{
    int i = 0;
    while (spec[i].type>JSI_OPTION_NONE && spec[i].type < JSI_OPTION_END) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        DumpOptionSpec(interp, sobj, spec+i, 1);
        Jsi_ObjArrayAdd(interp, nobj, svalue);
        i++;
    }
}

Jsi_DbMultipleBind *Jsi_CDataLookup(Jsi_Interp *interp, const char *name)
{
    Jsi_HashEntry* hPtr;
    hPtr = Jsi_HashEntryFind(interp->optionDataHash, name);
    if (!hPtr)
        return NULL;
    return (Jsi_DbMultipleBind*)Jsi_HashValueGet(hPtr);
}

int Jsi_CDataRegister(Jsi_Interp *interp, const char *name, Jsi_OptionSpec *specs, void *data, int numData, int flags)
{
    int isNew;
    Jsi_DbMultipleBind* opts;
    Jsi_HashEntry* hPtr;
    if (data == NULL) {
        hPtr = Jsi_HashEntryFind(interp->optionDataHash, name);
        if (!hPtr) {
            Jsi_LogError("unknown option-data: %s", name);
            return JSI_ERROR;
        }
        opts = (Jsi_DbMultipleBind*)Jsi_HashValueGet(hPtr);
        if (opts)
            Jsi_Free(opts);
        Jsi_HashEntryDelete(hPtr);
        return JSI_OK;
    }
    if (!Jsi_OptionsValid(interp, specs))
        return JSI_ERROR;
    hPtr = Jsi_HashEntryNew(interp->optionDataHash, name, &isNew);
    if (hPtr == NULL ||
            !(opts = (Jsi_DbMultipleBind*) (isNew ? Jsi_Calloc(2, sizeof(*opts)) : Jsi_HashValueGet(hPtr))))
        return JSI_ERROR;
    opts->opts = specs;
    opts->data = data;
    opts->numData = numData;
    opts->flags = flags;
    Jsi_HashValueSet(hPtr, opts);
    return JSI_OK;
}

static int ValueToVerify(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record )
{
    if (inStr)
        return JSI_ERROR;
    Jsi_Value **s = (Jsi_Value**)((char*)record) + spec->offset;
    Jsi_ValueHandlerProc *vfunc = (Jsi_ValueHandlerProc*)spec->data;
    if (!vfunc) {
        Jsi_LogError("custom value spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    if (!inValue) {
        if (*s)
            Jsi_DecrRefCount(interp, *s);
        *s = NULL;
        return JSI_OK;
    }
    if (vfunc(interp, inValue) != JSI_OK)
        return JSI_ERROR;
    *s = inValue;
    if (*s)
        Jsi_IncrRefCount(interp, *s);
    return JSI_OK;
}

static int VerifyToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record)
{
    if (dStr)
        return JSI_ERROR;
    Jsi_Value **s = (Jsi_Value**)(((char*)record) + spec->offset);
    if (*s)
        Jsi_ValueReplace(interp, outValue, *s);
    return JSI_OK;
}

static void VerifyFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)
{
    Jsi_Value **v = (Jsi_Value**)ptr;
    if (v)
        Jsi_DecrRefCount(interp, *v);
}

static Jsi_OptionCustom jsi_OptSwitchValueVerify = {
    .name="value", .parseProc=ValueToVerify, .formatProc=VerifyToValue, .freeProc=VerifyFree, .help="A value"
};
#else

static Jsi_OptionSpec * GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
    return (Jsi_OptionSpec *)staticSpecs;
}

#endif


/*
 *----------------------------------------------------------------------
 * Given the configuration specifications and one or more option
 * patterns (terminated by a NULL), indicate if any of the matching
 * configuration options has been reset.
 *
 * Results:
 *      Returns count of each options that has changed, 0 otherwise.
 *
 *----------------------------------------------------------------------
 */
int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *spec, const char *pattern, ...)
{
    va_list argList;
    Jsi_OptionSpec *specPtr;
    const char *option = pattern;
    int cnt = 0;
    
    va_start(argList, pattern);
    spec = GetCachedOptionSpecs(interp, spec);
    do  {
        for (specPtr = spec; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END; specPtr++) {
            if ((Jsi_GlobMatch(option, specPtr->name, 0)) &&
                    (specPtr->flags & JSI_OPT_IS_SPECIFIED)) {
                cnt++;
            }
        }
        assert(specPtr->type == JSI_OPTION_END);

    } while ((option = va_arg(argList, char *)) != NULL);
    va_end(argList);
    return cnt;
}

Jsi_OptionSpec *
Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)
{
    unsigned int entrySpace = sizeof(Jsi_OptionSpec);
    const Jsi_OptionSpec *staticSpecPtr;
    Jsi_OptionSpec *newSpecs;

    for (staticSpecPtr=staticSpecs; staticSpecPtr->type>JSI_OPTION_NONE && staticSpecPtr->type<JSI_OPTION_END && staticSpecPtr->name;
            staticSpecPtr++) {
        entrySpace += sizeof(Jsi_OptionSpec);
    }

    newSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);
    memcpy((void *) newSpecs, (void *) staticSpecs, entrySpace);
    return newSpecs;
}

/* Free data items and reset values back to 0. */
void
Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, int flags /*unused*/)
{
    Jsi_OptionSpec *specPtr;
    char *record = (char*)rec;
    for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END && specPtr->name; specPtr++) {
        char *ptr = record + specPtr->offset;
        if (specPtr->flags&JSI_OPT_NO_CLEAR)
            continue;
        if ((*(char **)ptr != NULL) && specPtr->custom) {
            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
            if (cust->freeProc != NULL) {
                (*cust->freeProc)(interp, specPtr, *(char **)ptr);
                return;
            }
        }

        switch (specPtr->type) {
#ifndef JSI_LITE_ONLY
        case JSI_OPTION_VALUE:
        case JSI_OPTION_STRING:
        case JSI_OPTION_OBJ:
        case JSI_OPTION_ARRAY:
        case JSI_OPTION_FUNC:
        case JSI_OPTION_VAR:
        {
            Jsi_Value **vpp = (Jsi_Value**)ptr, *vPtr = *vpp;
            if (vPtr && (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)))
                Jsi_DecrRefCount(interp, vPtr);
            *vpp = 0;
            break;
        }
#endif
        case JSI_OPTION_STRKEY:
            *(char**)ptr = 0;
            break;
        case JSI_OPTION_STRBUF:
            *(char*)ptr = 0;
            break;
        case JSI_OPTION_DSTRING:
            Jsi_DSFree((Jsi_DString *)ptr);
            break;
        case JSI_OPTION_TIMESTAMP:
            *(time_t*)ptr = 0;
            break;
        case JSI_OPTION_WIDE:
            *(Jsi_Wide*)ptr = 0;
            break;
        case JSI_OPTION_BYTE:
            *(Jsi_BYTE*)ptr = 0;
            break;
        case JSI_OPTION_WORD:
            *(Jsi_WORD*)ptr = 0;
            break;
        case JSI_OPTION_DWORD:
            *(Jsi_DWORD*)ptr = 0;
            break;
        case JSI_OPTION_QWORD:
            *(Jsi_QWORD*)ptr = 0;
            break;
        case JSI_OPTION_BOOL:
            *(char*)ptr = 0;
            break;
        case JSI_OPTION_INT:
            *(int*)ptr = 0;
            break;
        case JSI_OPTION_DATE:
        case JSI_OPTION_TIME:
        case JSI_OPTION_DATETIME:
        case JSI_OPTION_DOUBLE:
            *(Jsi_Wide*)ptr = 0;
            break;
        case JSI_OPTION_CUSTOM:
            break;
        default:
            if (specPtr->size>0)
                memset(ptr, 0, specPtr->size);
            break;
        }
    }
}

const char *Jsi_OptionTypeStr(Jsi_OptionTypes typ, int tname)
{
    if (typ>=0 && typ<JSI_OPTION_END)
        return (tname?optTypeInfo[typ].type:optTypeInfo[typ].name);
    return NULL;
}

static int ValueToEnum(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record )
{
    int n, *s = (int*)(((char*)record) + spec->offset);
    const char **list = (const char **)spec->data;
    int flags = (spec->flags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);
    if (!list) {
        Jsi_LogError("custom enum spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    if (inStr) {
        if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, "enum", flags, &n))
            return JSI_ERROR;
        *s = n;
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, "enum", flags, &n))
        return JSI_ERROR;
    *s = n;
#endif
    return JSI_OK;
}

static int EnumToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record)
{
    int i, n, *s = (int*)(((char*)record) + spec->offset);
    const char **list = (const char**)spec->data;
    if (!list) {
        Jsi_LogError("custom enum spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    if (outStr) {
        n = *s;
        for (i=0; i<n && list[i]; i++) ; /* Look forward til n */
        if (!list[i]) {
            Jsi_LogWarn("enum has unknown value: %d", *s);
            return JSI_ERROR;
        }
        Jsi_DSAppendLen(outStr, list[i], -1);
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    int rc = EnumToValue(interp, spec, NULL, &dStr, record);
    if (rc == JSI_OK)
        Jsi_ValueMakeStringKey(interp, outValue, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return rc;
#endif
    return JSI_ERROR;
}

static Jsi_OptionCustom jsi_OptSwitchEnum = {
    .name="enum", .parseProc=ValueToEnum, .formatProc=EnumToValue, .freeProc=0, .help="one value from list"
};


static int ValueToBitset(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record )
{
    int i, argc, n, *s = (int*)(((char*)record) + spec->offset);
    char **argv;
    const char **list = (const char**)spec->data;
    int m = 0, flags = (spec->flags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);
    if (!list) {
        Jsi_LogError("custom enum spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    if (inStr) {
        if (!inStr) {
            *s = 0;
            return JSI_OK;
        }
        Jsi_DString sStr;
        Jsi_DSInit(&sStr);
        Jsi_SplitStr(inStr, &argc, &argv, "", &sStr);
        
        for (i=0; i<argc; i++) {
            if (JSI_OK != Jsi_GetIndex(interp, argv[i], list, "enum", flags, &n))
                return JSI_ERROR;
            m |= (1<<n);
        }
        Jsi_DSFree(&sStr);
        *s = m;
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    if (!inValue) {
        *s = 0;
        return 0;
    }
    if (!Jsi_ValueIsArray(interp, inValue)) {
        Jsi_LogError("expected array");
        return JSI_ERROR;
    }
    argc = Jsi_ValueGetLength(interp, inValue);
    for (i=0; i<argc; i++) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);
        if (JSI_OK != Jsi_ValueGetIndex(interp, v, list, "bitset", flags, &n)) {
            return JSI_ERROR;
        }
        m |= (1<<n);
    }
    *s = m;
#endif
    return JSI_OK;
}

static int BitsetToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record)
{
    int i, n, cnt = 0, *s = (int*)(((char*)record) + spec->offset);
    const char **list = (const char**)spec->data;
    if (!list) {
        Jsi_LogError("custom enum spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
            
    if (outStr) {
        n = *s;
        for (i=0; list[i]; i++) {
            if (!(n & (1<<i)))
                continue;
            if (cnt++)
                Jsi_DSAppendLen(outStr, " ", 1);
            Jsi_DSAppendLen(outStr, list[i], -1);
        }
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    n = *s;
    for (i=0; list[i]; i++) {
        Jsi_Value *v;
        if (!(n&(1<<i))) continue;
        cnt++;
        v = Jsi_ValueMakeStringKey(interp, NULL, list[i]);
        Jsi_ObjArrayAdd(interp, obj, v);
    }
    Jsi_ObjSetLength(interp, obj, cnt);
    Jsi_ValueMakeArrayObject(interp, outValue, obj);
#endif
    return JSI_OK;
}

static Jsi_OptionCustom jsi_OptSwitchBitset = {
    .name="bitset", .parseProc=ValueToBitset, .formatProc=BitsetToValue, .freeProc=0, .help="An int field accessed a bit at a time"
};

/* Scanning function */
static int ValueToSubopt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record )
{
#ifndef JSI_LITE_ONLY
    if (inStr)
        return JSI_ERROR;
    int flags = 0;
    char *s = ((char*)record) + spec->offset;
    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;
  
    if (spec == subspec) {
        Jsi_LogError("subspec was recursive");
        return JSI_ERROR;
    }
    if (!subspec) {
        Jsi_LogError("custom suboption spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    if (inValue && Jsi_ValueIsNull(interp, inValue) == 0 &&
        (Jsi_ValueIsObjType(interp, inValue, JSI_OT_OBJECT)==0 || inValue->d.obj->isarrlist)) {
        Jsi_LogError("expected object");
        return JSI_ERROR;
    }
    return (Jsi_OptionsProcess(interp, subspec, inValue, s, flags)<0 ? JSI_ERROR : JSI_OK);
#else
    return JSI_ERROR;
#endif
}

/* Printing function. */
static int SuboptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record)
{
#ifndef JSI_LITE_ONLY
    if (outStr)
        return JSI_ERROR;
    char *s = ((char*)record) + spec->offset;
    int flags = 0;
    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;
    if (spec == subspec) {
        Jsi_LogError("recursive subspec not allowed");
        return JSI_ERROR;
    }
    if (!subspec) {
        Jsi_LogError("custom suboption spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    return Jsi_OptionsDump(interp, subspec, s, outValue, flags);
#else
    return JSI_ERROR;
#endif
}

static void SuboptFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)
{
    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;
    Jsi_OptionsFree(interp, subspec, ptr, 0);
}

static Jsi_OptionCustom jsi_OptSwitchSuboption = {
    .name="suboption", .parseProc=ValueToSubopt, .formatProc=SuboptToValue, .freeProc=SuboptFree,
};

static int ValueToBitfield(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record )
{
    Jsi_Wide w;
    int m = 0, flags = spec->flags;
    if (!spec->bitop) {
        Jsi_LogError("custom spec did not set bitop: %s", spec->name);
        return JSI_ERROR;
    }
    if (inStr) {
        if ((spec->flags == JSI_OPT_BITFIELD_BOOL)) {
            static const char *list[] = { "false", "true", NULL };
            if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, "boolean", flags, &m))
                return JSI_ERROR;
            w = m;
        } else if (spec->data) {
            const char **list = (const char **)spec->data;
            if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, "enum", flags, &m))
                return JSI_ERROR;
            w = m;
        } else {
            if (JSI_OK != Jsi_GetInt(interp, inStr, &m, 0))
                return JSI_ERROR;
            w = m;
        }
        if (JSI_OK != spec->bitop(interp, spec, record, &w, 1))
            return JSI_ERROR;
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_Bool b;
    if ((spec->flags & JSI_OPT_BITFIELD_BOOL)) {
        if (JSI_OK != Jsi_ValueGetBoolean(interp, inValue, &b))
            return JSI_ERROR;
        w = b;
    } else if (spec->data) {
        const char **list = (const char **)spec->data;
        if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, "enum", flags, &m))
            return JSI_ERROR;
        w = m;
    } else {
        Jsi_Number n;
        if (JSI_OK != Jsi_ValueGetNumber(interp, inValue, &n))
            return JSI_ERROR;
        w = (Jsi_Wide)n;
    }
    if (JSI_OK != spec->bitop(interp, spec, record, &w, 1))
        return JSI_ERROR;
#endif
    return JSI_OK;
}

static int BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record)
{
    Jsi_Wide w;
    //int flags = spec->flags;
    if (!spec->bitop) {
        Jsi_LogError("custom spec did not set bitop: %s", spec->name);
        return JSI_ERROR;
    }
    if (JSI_OK != spec->bitop(interp, spec, record, &w, 0))
        return JSI_ERROR;
    if (outStr) {
        if ((spec->flags && JSI_OPT_BITFIELD_BOOL)) {
            int b = (int)w;
            if (b == 0 || b == 1)
                Jsi_DSAppend(outStr, b?"true":"false", NULL);
            else
                Jsi_LogError("invalid bool");
        } else if (spec->data) {
            const char **list = (const char **)spec->data;
            int i, n = (int)w;
            for (i=0; i<n && list[i]; i++) ; /* Look forward til n */
            if (!list[i]) {
                Jsi_LogError("enum has unknown value: %d", n);
                return JSI_ERROR;
            }
            Jsi_DSAppend(outStr, list[i], NULL);
        } else {
            if (!Jsi_DSPrintf(outStr, "%lld", w))
                return JSI_ERROR;
        }
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    if ((spec->flags&JSI_OPT_BITFIELD_BOOL)) {
        int b = (int)w;
        if (b == 0 || b == 1)
            Jsi_ValueMakeBool(interp, outValue, b);
        else
            Jsi_LogError("invalid bool");
    } else if (spec->data) {
        const char **list = (const char **)spec->data;
        int i, n = (int)w;
        for (i=0; i<n && list[i]; i++) ; /* Look forward til n */
        if (!list[i]) {
            Jsi_LogError("enum has unknown value: %d", n);
            return JSI_ERROR;
        }
        Jsi_DSAppend(outStr, list[i], NULL);
        Jsi_ValueMakeStringKey(interp, outValue, list[i]);
    } else {
        Jsi_ValueMakeNumber(interp, outValue, (Jsi_Number)w);
    }
    return JSI_OK;
#endif
    return JSI_ERROR;
}

static Jsi_OptionCustom jsi_OptSwitchCBitfield = {
    .name="c_bitfield", .parseProc=ValueToBitfield, .formatProc=BitfieldToValue, .freeProc=0, .help="C Bitfield access"
};

static Jsi_OptionCustom* custOpts[] = { NULL,
    &jsi_OptSwitchEnum, 
    &jsi_OptSwitchBitset,
    &jsi_OptSwitchSuboption, 
    &jsi_OptSwitchCBitfield,
#ifndef JSI_LITE_ONLY
    &jsi_OptSwitchValueVerify
#endif
};

Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust) {
    if ((int)cust>0 && (int)cust<(int)(sizeof(custOpts)/sizeof(custOpts[0])))
        return custOpts[(int)cust];
    return cust;
}
#ifndef JSI_LITE_ONLY
#ifndef JSI_OMIT_STUBS
#include "jsiInt.h"
#include "jsiStubs.h"
  
static int Jsi_Stubs__initialize(Jsi_Interp *interp, double version, const char* name, int flags, 
    const char *md5, int bldFlags, int stubSize, int structSizes, void **ptr);

Jsi_Stubs jsiStubsTbl = { __JSI_STUBS_INIT__ };
Jsi_Stubs *jsiStubsTblPtr = &jsiStubsTbl;

int Jsi_Stubs__initialize(Jsi_Interp *interp, double version, const char* name, int flags, 
    const char *md5, int bldFlags, int stubSize, int structSizes, void **ptr)
{
    
    if (strcmp(name,"jsi")) { /* Sub-stub support */
        int rc = Jsi_StubLookup(interp, name, ptr);
        if (rc != JSI_OK)
            return JSI_ERROR;
        Jsi_Stubs *sp = *(Jsi_Stubs **)ptr;
        if (sp->_Jsi_Stubs__initialize && sp->sig == JSI_STUBS_SIG &&
            sp->_Jsi_Stubs__initialize != jsiStubsTbl._Jsi_Stubs__initialize)
            return (*sp->_Jsi_Stubs__initialize)(interp, version, name, flags, md5, bldFlags, stubSize, structSizes, ptr);
        Jsi_LogError("failed to find stub for %s", name);
        return JSI_ERROR;
    }
    int structSize = JSI_STUBS_STRUCTSIZES;
    int strict = (flags & JSI_STUBS_STRICT);
    int sizediff = (sizeof(Jsi_Stubs) - stubSize);
    assert(jsiStubsTbl.sig == JSI_STUBS_SIG);
    if (sizediff<0 || (strict && (strcmp(md5, JSI_STUBS_MD5) || sizediff || structSize != structSizes))) {
        fprintf(stderr, "%s: extension from incompatible build: %s\n", name, (sizediff ? "size changed": md5));
        return JSI_ERROR;
    }
    if (bldFlags != jsiStubsTbl.bldFlags) {
        fprintf(stderr, "%s: extension build flags mismatch (different libc?)\n", name);
        if (strict)
            return JSI_ERROR;
    }
    if (version > JSI_VERSION) {
        fprintf(stderr, "%s: extension version newer than jsish (%g > %g)\n", name, version, JSI_VERSION);
        if (strict)
            return JSI_ERROR;
    }
    return JSI_OK;
}
#endif
#endif
#ifndef JSI_LITE_ONLY
/*
 * Implements the internals of the format command for jsi
 *
 * The FreeBSD license
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE JSI PROJECT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * JSI OR TCL PROJECTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the Jsi Tcl Project.
 *
 * Based on code originally from Tcl 8.5:
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 *
 * See the file "tcl.license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 */
#include <ctype.h>
#include <string.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#include "jsiUtf8.h"
#endif

//#define JSI_UTF_MAX 3
#define JSI_INTEGER_SPACE 24
#define MAX_FLOAT_WIDTH 320

/**
 * Apply the printf-like format in fmtObjPtr with the given arguments.
 *
 * Returns a new object with zero reference count if OK, or NULL on error.
 */
int Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr)
{
    const char *span, *format, *formatEnd, *msg;
    int numBytes = 0, argIndex = 1, gotXpg = 0, gotSequential = 0, argCnt;
    static const char * const mixedXPG =
        "cannot mix \"%\" and \"%n$\" conversion specifiers";
    static const char * const badIndex[2] = {
        "not enough arguments for all format specifiers",
        "\"%n$\" argument index out of range"
    };
    int formatLen;
    Jsi_Value *v;
    
    /* A single buffer is used to store numeric fields (with sprintf())
     * This buffer is allocated/reallocated as necessary
     */
    char stat_buf[100], *num_buffer = stat_buf;
    int num_buffer_size = sizeof(stat_buf);
    argCnt = Jsi_ValueGetLength(interp, args);

    if (argCnt<1) {
        msg = "missing format";
        goto errorMsg;
    }
    format = Jsi_ValueArrayIndexToStr(interp, args,0, &formatLen);
    
    span = format;
    formatEnd = format + formatLen;
    Jsi_DSInit(dStr);

    while (format != formatEnd) {
        char *end;
        int gotMinus, sawFlag;
        int gotPrecision, useShort, useLong;
        long width, precision;
        int newXpg;
        int ch;
        int step;
        int doubleType;
        char pad = ' ';
        char spec[2*JSI_INTEGER_SPACE + 12];
        char *p;

        int formatted_chars;
        int formatted_bytes;
        const char *formatted_buf = NULL;

        step = jsi_utf8_tounicode(format, &ch);
        format += step;
        if (ch != '%') {
            numBytes += step;
            continue;
        }
        if (numBytes) {
            Jsi_DSAppendLen(dStr, span, numBytes);
            numBytes = 0;
        }

        /*
         * Saw a % : process the format specifier.
         *
         * Step 0. Handle special case of escaped format marker (i.e., %%).
         */

        step = jsi_utf8_tounicode(format, &ch);
        if (ch == '%') {
            span = format;
            numBytes = step;
            format += step;
            continue;
        }

        /*
         * Step 1. XPG3 position specifier
         */

        newXpg = 0;
        if (isdigit(ch)) {
            int position = strtoul(format, &end, 10);
            if (*end == '$') {
                newXpg = 1;
                argIndex = position - 1;
                format = end + 1;
                step = jsi_utf8_tounicode(format, &ch);
            }
        }
        if (newXpg) {
            if (gotSequential) {
                msg = mixedXPG;
                goto errorMsg;
            }
            gotXpg = 1;
        } else {
            if (gotXpg) {
                msg = mixedXPG;
                goto errorMsg;
            }
            gotSequential = 1;
        }
        if ((argIndex < 0) || (argIndex >= argCnt)) {
            msg = badIndex[gotXpg];
            goto errorMsg;
        }

        /*
         * Step 2. Set of flags. Also build up the sprintf spec.
         */
        p = spec;
        *p++ = '%';

        gotMinus = 0;
        sawFlag = 1;
        do {
            switch (ch) {
            case '-':
                gotMinus = 1;
                break;
            case '0':
                pad = ch;
                break;
            case ' ':
            case '+':
            case '#':
                break;
            default:
                sawFlag = 0;
                continue;
            }
            *p++ = ch;
            format += step;
            step = jsi_utf8_tounicode(format, &ch);
        } while (sawFlag);

        /*
         * Step 3. Minimum field width.
         */

        width = 0;
        if (isdigit(ch)) {
            width = strtoul(format, &end, 10);
            format = end;
            step = jsi_utf8_tounicode(format, &ch);
        } else if (ch == '*') {
            if (argIndex >= argCnt - 1) {
                msg = badIndex[gotXpg];
                goto errorMsg;
            }
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (Jsi_GetLongFromValue(interp, v, &width) != JSI_OK) {
                goto error;
            }
            if (width < 0) {
                width = -width;
                if (!gotMinus) {
                    *p++ = '-';
                    gotMinus = 1;
                }
            }
            argIndex++;
            format += step;
            step = jsi_utf8_tounicode(format, &ch);
        }

        /*
         * Step 4. Precision.
         */

        gotPrecision = precision = 0;
        if (ch == '.') {
            gotPrecision = 1;
            format += step;
            step = jsi_utf8_tounicode(format, &ch);
        }
        if (isdigit(ch)) {
            precision = strtoul(format, &end, 10);
            format = end;
            step = jsi_utf8_tounicode(format, &ch);
        } else if (ch == '*') {
            if (argIndex >= argCnt - 1) {
                msg = badIndex[gotXpg];
                goto errorMsg;
            }
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (Jsi_GetLongFromValue(interp, v, &precision) != JSI_OK) {
                goto error;
            }

            /*
             * TODO: Check this truncation logic.
             */

            if (precision < 0) {
                precision = 0;
            }
            argIndex++;
            format += step;
            step = jsi_utf8_tounicode(format, &ch);
        }

        /*
         * Step 5. Length modifier.
         */

        useShort = 0;
        useLong = 0;
        if (ch == 'h') {
            useShort = 1;
            format += step;
            step = jsi_utf8_tounicode(format, &ch);
        } else if (ch == 'l') {
            useLong = 1;
            format += step;
            step = jsi_utf8_tounicode(format, &ch);
            if (ch == 'l') {
                format += step;
                step = jsi_utf8_tounicode(format, &ch);
            }
        }

        format += step;
        span = format;

        /*
         * Step 6. The actual conversion character.
         */

        if (ch == 'i') {
            ch = 'd';
        }

        doubleType = 0;

        /* Each valid conversion will set:
         * formatted_buf   - the result to be added
         * formatted_chars - the length of formatted_buf in characters
         * formatted_bytes - the length of formatted_buf in bytes
         */
        switch (ch) {
        case '\0':
            msg = "format string ended in middle of field specifier";
            goto errorMsg;
        case 's': {
            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (Jsi_GetStringFromValue(interp, v, &formatted_buf) != JSI_OK)
                goto error;
            formatted_bytes = 
            formatted_chars = Jsi_Strlen(formatted_buf);
            if (gotPrecision && (precision < formatted_chars)) {
                /* Need to build a (null terminated) truncated string */
                formatted_chars = precision;
                formatted_bytes = jsi_utf8_index(formatted_buf, precision);
            }
            break;
        }
        case 'c': {
            Jsi_Wide code;

            v = Jsi_ValueArrayIndex(interp, args, argIndex);
            if (Jsi_GetWideFromValue(interp, v, &code) != JSI_OK) {
                goto error;
            }
            /* Just store the value in the 'spec' buffer */
            formatted_bytes = jsi_utf8_fromunicode(spec, code);
            formatted_buf = spec;
            formatted_chars = 1;
            break;
        }

        case 'e':
        case 'E':
        case 'f':
        case 'g':
        case 'G':
            doubleType = 1;
            /* fall through */
        case 'd':
        case 'u':
        case 'o':
        case 'x':
        case 'X': {
            Jsi_Wide w;
            Jsi_Number d;
            int length;

            /* Fill in the width and precision */
            if (width) {
                p += sprintf(p, "%ld", width);
            }
            if (gotPrecision) {
                p += sprintf(p, ".%ld", precision);
            }

            /* Now the modifier, and get the actual value here */
            if (doubleType) {
                v = Jsi_ValueArrayIndex(interp, args, argIndex);
                if (Jsi_GetDoubleFromValue(interp, v, &d) != JSI_OK) {
                    goto error;
                }
                length = MAX_FLOAT_WIDTH;
            }
            else {
                v = Jsi_ValueArrayIndex(interp, args, argIndex);
                if (Jsi_GetWideFromValue(interp, v, &w) != JSI_OK) {
                    goto error;
                }
                length = JSI_INTEGER_SPACE;
                if (useShort) {
                    *p++ = 'h';
                    if (ch == 'd') {
                        w = (short)w;
                    }
                    else {
                        w = (unsigned short)w;
                    }
                }
                else {
                    *p++ = 'l';
#ifdef HAVE_LONG_LONG
                    if (useLong && sizeof(long long) == sizeof(Jsi_Wide)) {
                        *p++ = 'l';
                    }
#endif
                }
            }

            *p++ = (char) ch;
            *p = '\0';

            /* Adjust length for width and precision */
            if (width > length) {
                length = width;
            }
            if (gotPrecision) {
                length += precision;
            }

            /* Increase the size of the buffer if needed */
            if (num_buffer_size < length + 1) {
                num_buffer_size = length + 1;
                num_buffer = (char*)Jsi_Realloc((num_buffer==stat_buf?NULL:num_buffer), num_buffer_size);
            }

            if (doubleType) {
                snprintf(num_buffer, length + 1, spec, d);
            }
            else {
                formatted_bytes = snprintf(num_buffer, length + 1, spec, w);
            }
            formatted_chars = formatted_bytes = strlen(num_buffer);
            formatted_buf = num_buffer;
            break;
        }

        default: {
            /* Just reuse the 'spec' buffer */
            spec[0] = ch;
            spec[1] = '\0';
            Jsi_LogError("bad field specifier \"%s\"", spec);
            goto error;
        }
        }

        if (!gotMinus) {
            while (formatted_chars < width) {
                Jsi_DSAppendLen(dStr, &pad, 1);
                formatted_chars++;
            }
        }

        Jsi_DSAppendLen(dStr, formatted_buf, formatted_bytes);

        while (formatted_chars < width) {
            Jsi_DSAppendLen(dStr, &pad, 1);
            formatted_chars++;
        }

        argIndex += gotSequential;
    }
    if (numBytes) {
        Jsi_DSAppendLen(dStr, span, numBytes);
    }

    if (num_buffer!=stat_buf)
        Jsi_Free(num_buffer);
    return JSI_OK;

errorMsg:
    Jsi_LogError("%s", msg);
error:
    Jsi_DSFree(dStr);
    if (num_buffer!=stat_buf)
        Jsi_Free(num_buffer);
    return JSI_ERROR;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION

#include "jsiInt.h"
#include "jsmn.h"
#endif

static int utf8tounicode(const char *str, int *uc)
{
    unsigned const char *s = (unsigned const char *)str;

    if (s[0] < 0xc0) {
        *uc = s[0];
        return 1;
    }
    if (s[0] < 0xe0) {
        if ((s[1] & 0xc0) == 0x80) {
            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);
            return 2;
        }
    }
    else if (s[0] < 0xf0) {
        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80)) {
            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);
            return 3;
        }
    }
    else if (s[0] < 0xf8) {
        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80) && ((str[3] & 0xc0) == 0x80)) {
            *uc = ((s[0] & ~0xf0) << 18) | ((s[1] & ~0x80) << 12) | ((s[2] & ~0x80) << 6) | (s[3] & ~0x80);
            return 4;
        }
    }

    /* Invalid sequence, so just return the byte */
    *uc = *s;
    return 1;
}

#define hexdigit(c) (isdigit(c)?(c-'0'):(10+(toupper(c)-'A')))
static const char hexchars[] = "0123456789ABCDEF";

#if 0
static unsigned int
EncodeUtf(unsigned char *ci, unsigned char *uo) {
    int ival, ilen;
    uo[0] = '\\';
    uo[1] = 'u';
    uo[6] = 0;
    ilen = utf8tounicode((const char*)ci,&ival);
    uo[2] = hexchars[(ival&0xF000)>>12];
    uo[3] = hexchars[(ival&0xF00)>>8];
    uo[4] = hexchars[(ival&0xF0)>>4];
    uo[5] = hexchars[(ival&0x0F)];
    return ilen;
}
#endif

static unsigned int
jsi_DecodeUtf(const char *str, char*uo) {
    unsigned char c;
    unsigned int uc = 0, len = 0;
    int pos = 0;

    while(pos<4) {
        c = str[pos];
        if(!isxdigit(c)) {
            return 0;
        }
        uc += ((unsigned int)hexdigit(c) << ((3-pos++)*4));
    }
    if (uc < 0x80) {
        uo[0] = uc;
        len = 1;
    } else if (uc < 0x800) {
        uo[0] = 0xc0 | (uc >> 6);
        uo[1] = 0x80 | (uc & 0x3f);
        len = 2;
    } else {
        uo[0] = 0xe0 | (uc >> 12);
        uo[1] = 0x80 | ((uc >> 6) & 0x3f);
        uo[2] = 0x80 | (uc & 0x3f);
        len = 3;
    }
    return len;
}

 unsigned int
jsi_EncodeUtf(unsigned char *ci, unsigned char *uo) {
    int ival, ilen;
    uo[0] = '\\';
    uo[1] = 'u';
    uo[6] = 0;
    ilen = utf8tounicode((const char*)ci,&ival);
    uo[2] = hexchars[(ival&0xF000)>>12];
    uo[3] = hexchars[(ival&0xF00)>>8];
    uo[4] = hexchars[(ival&0xF0)>>4];
    uo[5] = hexchars[(ival&0x0F)];
    return ilen;
}

static Jsi_Value *jsonNewStringObj(Jsi_Interp *interp, const char* str, int len)
{

    Jsi_Value *v = NULL;
    char buf[100], *dp = buf;
    const char *cp = str;
    Jsi_DString dStr = {};
    int ulen;
    
    while ((cp-str)<len) {
        if (*cp == '\\') {
            switch (cp[1]) {
                case 'b': *dp++ = '\b'; break;
                case 'n': *dp++ = '\n'; break;
                case 'r': *dp++ = '\r'; break;
                case 'f': *dp++ = '\f'; break;
                case 't': *dp++ = '\t'; break;
                case '\\': *dp++ = '\\'; break;
                case 'u': 
                    if ((ulen=jsi_DecodeUtf(cp+2, dp))) {
                        dp += ulen;
                        cp += 4;
                    } else {                    
                        *dp++ = '\\';
                        *dp++ = 'u';
                    }
                    break;
            }
            cp+=2;
        } else {
            *dp++ = *cp++;
        }
        if ((dp-buf)>90) {
            *dp = 0;
            dp = buf;
            Jsi_DSAppend(&dStr, buf, NULL);
        }
    }
    *dp = 0;
    Jsi_DSAppend(&dStr, buf, NULL);
    v = Jsi_ValueMakeString(interp, NULL, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return v;
}

static Jsi_Value* jsonGenObject(Jsi_Interp *interp, jsmn_parser *p, const char *js, uint pos, uint *endPos);
static Jsi_Value* jsonGenArray(Jsi_Interp *interp, jsmn_parser *p, const char *js, uint pos, uint *endPos);

static Jsi_Value*
jsonGen1Value(Jsi_Interp *interp, jsmn_parser *p, const char *js, uint i, uint *endPos, int incr)
{
    uint len;
    const char *t;
    Jsi_Value *v = NULL;
    
    switch (p->tokens[i].type) {
        case JSMN_PRIMITIVE:
            t = jsmn_tokstr(p, js, i, &len);
            if (len == 4 && Jsi_Strncmp(t, "true", len)==0)
                v = Jsi_ValueMakeBool(interp, NULL, 1);
            else if (len == 5 && Jsi_Strncmp(t, "false", len)==0)
                v = Jsi_ValueMakeBool(interp, NULL, 0);
            else if (len == 4 && Jsi_Strncmp(t, "null", len)==0)
                v = Jsi_ValueMakeNull(interp, NULL);
            else if (len == 9 && Jsi_Strncmp(t, "undefined", len)==0)
                v = Jsi_ValueMakeNull(interp, NULL);
            else {
                char *ep;
                Jsi_Number d;
                d = strtod(t,&ep);
                if (ep>(t+len))
                    Jsi_LogWarn("bad number %*s\n", len, t);
                v = Jsi_ValueMakeNumber(interp, NULL, d);
            }
            break;
        case JSMN_STRING:
            t = jsmn_tokstr(p, js, i, &len);
            v = jsonNewStringObj(interp, t, len);
            break;
        case JSMN_ARRAY:
            v = jsonGenArray(interp, p, js, i, &i);
            i--;
            break;
        case JSMN_OBJECT:
            v = jsonGenObject(interp, p, js, i, &i);
            i--;
            break;
        default:
            break;
    }
    if (endPos)
        *endPos = i;
    if (v == NULL)
        v = Jsi_ValueMakeUndef(interp, NULL);
    if (incr)
        Jsi_IncrRefCount(interp, v);
    return v;
}

static Jsi_Value*
jsonGenObject(Jsi_Interp *interp, jsmn_parser *p, const char *js, uint pos, uint *endPos)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    Jsi_Value *nv, *v = Jsi_ValueMakeObject(interp, NULL, obj);
    uint i, n, len;
    jsmntok_t *tok;
    const char *t;
    tok = p->tokens+pos;
    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {

        Jsi_DString dStr;
        t = jsmn_tokstr(p, js, i, &len);
        i++; n++;
        if (n>=tok->size)
            nv = Jsi_ValueMakeUndef(interp, NULL);
        else
            nv = jsonGen1Value(interp, p, js, i, &i, 0);
        Jsi_DSInit(&dStr);
        Jsi_DSAppendLen(&dStr, t, len);
        Jsi_ObjInsert(interp, obj, Jsi_DSValue(&dStr), nv, p->flags);
        Jsi_DSFree(&dStr);
    }
    if (endPos)
        *endPos = i;
    return v;
}

static Jsi_Value*
jsonGenArray(Jsi_Interp *interp, jsmn_parser *p, const char *js, uint pos, uint *endPos)
{
    if (js==NULL || !js[0])
        return NULL;
    Jsi_Value *v = Jsi_ValueNewArray(interp, 0, 0);
    Jsi_Obj *nobj = v->d.obj;
    uint i, n;
    jsmntok_t *tok;
    
    tok = p->tokens+pos;
    Jsi_ValueMakeArrayObject(interp, &v, nobj);
    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {
        if (n >= nobj->arrMaxSize) {
            if (Jsi_ObjArraySizer(interp, nobj, n+1)<=0) {
                break;
            }
        }
        nobj->arr[n] = jsonGen1Value(interp, p, js, i, &i, 1);
    }
    Jsi_ObjSetLength(interp, nobj, n);
    if (endPos)
        *endPos = i;
    return v;
}

int Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags)
{
    uint i = 0, r;
    int result = JSI_OK, strict = (flags & JSI_JSON_STRICT);
    jsmntok_t *tok;
    Jsi_Value *v;
    const char *err;
    if (js == NULL || js[0] == 0)
        return JSI_OK;

    JSMN_DECLARE(pp, tokens);
    jsmn_parser *p = &pp;
    pp.strict = strict;
    pp.flags = flags;

    r = jsmn_parse(p, js);
    if (r != JSMN_SUCCESS) {
        int ofs = pp.pos, len = Jsi_Strlen(js);
        if (ofs<0 || ofs>len)
            ofs = 0;
        err = p->errStr;
        if (!err)
            err = jsmn_errname(r);
        Jsi_LogError("parse error (%s) at offset %d \"%.30s\"", err, ofs, js+ofs);
        result = JSI_ERROR;
        goto done;
    }
    tok = p->tokens;
    if (tok->size<=0) {
        Jsi_ValueMakeUndef(interp, ret);
        goto done;
    }
    v = jsonGen1Value(interp, p, js, i, &i, 1);
    Jsi_ValueReplace(interp, ret, v);
    Jsi_DecrRefCount(interp, v);
done:
    jsmn_free(&pp);
    return result;
}

int Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) 
{
    va_list argList;
    uint n;
    char buf[BUFSIZ], *cp = buf;
    Jsi_DString dStr = {};
    va_start(argList, fmt);
    n = vsnprintf(buf, sizeof(buf), fmt, argList);
    if (n<0 || n>JSI_MAX_ALLOC_BUF) {
        Jsi_LogError("Jsi_JSONParseFmt error: rc = %d", n);
        va_end(argList);
        return JSI_ERROR;
    }
    if (n >= sizeof(buf)) {
        uint m;
        Jsi_DSSetLength(&dStr, n+1);
        m = vsnprintf(dStr.str, n+1, fmt, argList);
        assert(m == n);
        cp = Jsi_DSValue(&dStr);
    }
    va_end(argList);
    return Jsi_JSONParse(interp, cp, ret, 0);
}

static int _JSONParseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int strict)
{
    const char *js;
    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 0); 
    js = Jsi_ValueToString(interp, jsv, NULL);
    return Jsi_JSONParse(interp, js, ret, strict);
  
}


static int JSONParseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _JSONParseCmd(interp, args, _this, ret, funcPtr, 1);
}

static int JSONScanCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _JSONParseCmd(interp, args, _this, ret, funcPtr, 0);
}


static int JSONCheckCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{

    int r, result = JSI_OK;
    Jsi_Bool strict = 0;
    const char *cp;
    JSMN_DECLARE(p, tokens);
    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &strict) == JSI_OK)
        p.strict = strict;
    cp = Jsi_ValueToString(interp, jsv, NULL);
    
    r = jsmn_parse(&p, cp);
    Jsi_ValueMakeBool(interp, ret, r == JSMN_SUCCESS);
    jsmn_free(&p);
    return result;
}

/* TODO: Actually use len for blob. */
char *
Jsi_JSONQuote(Jsi_Interp *interp, const char *cp, int len, Jsi_DString *dsPtr)
{
    char cbuf[10];
    Jsi_DSAppend(dsPtr,"\"",NULL);
    while (*cp) {
        if (*cp == '\\' || *cp == '/' || *cp == '\"') {
            cbuf[0] = '\\';
            cbuf[1] = *cp;
            cbuf[2] = 0;
            Jsi_DSAppend(dsPtr,cbuf,NULL);
        } else if (!isprint(*cp)) {
            int ilen;
            switch (*cp) {
                case '\b': Jsi_DSAppend(dsPtr,"\\b",NULL); break;
                case '\n': Jsi_DSAppend(dsPtr,"\\n",NULL); break;
                case '\r': Jsi_DSAppend(dsPtr,"\\r",NULL); break;
                case '\f': Jsi_DSAppend(dsPtr,"\\f",NULL); break;
                case '\t': Jsi_DSAppend(dsPtr,"\\t",NULL); break;
                default:
                    if ((ilen = jsi_EncodeUtf((unsigned char *)cp, (unsigned char*)cbuf))) {
                        Jsi_DSAppend(dsPtr,cbuf,NULL);
                        cp += (ilen-1);
                    }
            }
        } else {
            cbuf[0] = *cp;
            cbuf[1] = 0;
            Jsi_DSAppend(dsPtr,cbuf,NULL);
        }
        cp++;
    }
    
    Jsi_DSAppend(dsPtr,"\"", NULL);
    return Jsi_DSValue(dsPtr);;
}

static int JSONStringifyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int quote = JSI_OUTPUT_JSON|JSI_JSON_STRICT;
    Jsi_DString dStr = {};
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_ValueGetDString(interp, arg, &dStr, quote);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static int JSONStringifyNSCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int quote = JSI_OUTPUT_JSON;
    Jsi_DString dStr = {};
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_ValueGetDString(interp, arg, &dStr, quote);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

int Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret)
{
    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);
    if (func)
        return Jsi_FunctionInvoke(interp, func, args, ret, NULL);
    Jsi_LogError("can not find cmd: %s", cmdstr);
    return JSI_ERROR;
}

static Jsi_CmdSpec jsonCmds[] = {
    { "parse",      JSONParseCmd,       1, 1, "str:string", .help="Parse JSON and return js", .retType=(uint)JSI_TT_ANY },
    { "parseNS",    JSONScanCmd,        1, 1, "str:string", .help="Non-strict parse (member names not quoted)", .retType=(uint)JSI_TT_ANY},
    { "check",      JSONCheckCmd,       1, 2, "str:string, strict:boolean=false", .help="Return true if str is JSON", .retType=(uint)JSI_TT_BOOL },
    { "stringify",  JSONStringifyCmd,   1, 1, "obj:object", .help="Return JSON from a js object", .retType=(uint)JSI_TT_STRING },
    { "stringifyNS",JSONStringifyNSCmd, 1, 1, "obj:object", .help="Return Non-strict JSON (member names not quoted)", .retType=(uint)JSI_TT_STRING },
    { NULL, .help="Commands for handling JSON data" }
};

int jsi_JSONInit(Jsi_Interp *interp)
{
    Jsi_CommandCreateSpecs(interp, "JSON", jsonCmds, NULL, JSI_CMDSPEC_NOTOBJ);
#ifdef TEST_JSON_INVOKE
    Jsi_Value *ret = Jsi_ValueNew1(interp);
    Jsi_CommandInvokeJSON(interp, "Info.cmds", "[\"*\", true]", ret);
    Jsi_Puts(interp, &ret, 0);
    Jsi_DecrRefCount(interp, ret);
#endif
    return JSI_OK;
}
#endif
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#include "jsiUtf8.h"
#endif
#include <errno.h>

static const char *JsiCharsetMatch(const char *pattern, int c, int flags)
{
    int inot = 0;
    int pchar;
    int match = 0;
    int nocase = 0;

    if (flags & JSI_CMP_NOCASE) {
        nocase++;
        c = jsi_utf8_upper(c);
    }

    if (flags & JSI_CMP_CHARSET_SCAN) {
        if (*pattern == '^') {
            inot++;
            pattern++;
        }

        /* Special case. If the first char is ']', it is part of the set */
        if (*pattern == ']') {
            goto first;
        }
    }

    while (*pattern && *pattern != ']') {
        /* Exact match */
        if (pattern[0] == '\\') {
first:
            pattern += jsi_utf8_tounicode_case(pattern, &pchar, nocase);
        }
        else {
            /* Is this a range? a-z */
            int start;
            int end;
            pattern += jsi_utf8_tounicode_case(pattern, &start, nocase);
            if (pattern[0] == '-' && pattern[1]) {
                /* skip '-' */
                pattern += jsi_utf8_tounicode(pattern, &pchar);
                pattern += jsi_utf8_tounicode_case(pattern, &end, nocase);

                /* Handle reversed range too */
                if ((c >= start && c <= end) || (c >= end && c <= start)) {
                    match = 1;
                }
                continue;
            }
            pchar = start;
        }

        if (pchar == c) {
            match = 1;
        }
    }
    if (inot) {
        match = !match;
    }

    return match ? pattern : NULL;
}


char *Jsi_Itoa(int n)
{
    static char buf[100];
    sprintf(buf, "%d", n);
    return buf;
}
/* Split on char, or whitespace if ch==0. */
static void SplitChar(const char *str, int *argcPtr,
              char ***argvPtr, char ch, Jsi_DString *dStr)
{
    char *cp, *ep, *p, **argv;
    int cnt = 1, len, i;

    len = strlen(str);
    cp = (char*)str;
    while (*cp) {
        if (ch)
            cp = strchr(cp,ch);
        else {
            while (*cp && !isspace(*cp))
                cp++;
        }
        if (cp == NULL || *cp == 0) break;
        cp++;
        cnt++;
    }
    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    argv = (char**)Jsi_DSValue(dStr);
    *argvPtr = argv;
    *argcPtr = cnt;
    p = (char*)&(argv[cnt+2]);
    argv[cnt+1] = p;
    Jsi_Strcpy(p, str);
    cp = p;
    i = 0;
    argv[i++] = p;
    while (*cp) {
        if (ch)
            ep = strchr(cp,ch);
        else {
            ep = cp;
            while (*ep && !isspace(*ep))
                ep++;
        }
        if (ep == NULL || *ep == 0) break;
        *ep = 0;
        cp = ep+1;
        argv[i++] = cp;
    }
    argv[cnt] = NULL;
}

int
Jsi_GetIndex( Jsi_Interp *interp, char *str,
    const char **tablePtr, const char *msg, int flags,
    int *indexPtr)
{
  const char *msg2 = "unknown ";
  char **cp, *c;
  int cond, index = -1, slen, i, dup = 0;
  int exact = (flags & JSI_CMP_EXACT);
  int nocase = (flags & JSI_CMP_NOCASE);
  slen = strlen(str);
 /* if (slen==0) {
    Jsi_LogError("empty option %s %s", msg, str);
    return JSI_ERROR;
  }*/
  cp = (char**)tablePtr;
  i = -1;
  while (*cp != 0) {
    i++;
    c = *cp;
    if (c[0] != str[0]) { cp++; continue; }
    if (!nocase)
        cond = (exact ? Jsi_Strcmp(c,str) : Jsi_Strncmp(c,str,slen));
    else {
        cond = (exact ? Jsi_Strncasecmp(c,str, -1) : Jsi_Strncasecmp(c,str,slen));
    }
    if (cond == 0) {
      if (index<0) {
        index = i;
      } else {
        dup = 1;
        break;
      }
    }
    cp++;
  }
  if (index >= 0 && dup == 0) {
    *indexPtr = index;
    return JSI_OK;
  }
  if (exact && (dup || index<=0)) {
    if (interp != NULL) {
      msg2 = (index>=0? "unknown ":"duplicate ");
    }
    goto err;
  }
  cp = (char**)tablePtr;
  i = -1;
  dup = 0;
  index = -1;
  while (*cp != 0) {
    i++;
    c = *cp;
    if (c[0] == str[0] && Jsi_Strncmp(c,str, slen) == 0) {
      if (index<0) {
        index = i;
        if (slen == (int)Jsi_Strlen(c))
            break;
      } else {
        if (interp != NULL) {
          msg2 = "ambiguous ";
        }
        goto err;
      }
    }
    cp++;
  }
  if (index >= 0 && dup == 0) {
    *indexPtr = index;
    return JSI_OK;
  }
err:
  if (interp != NULL) {
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, msg2, msg, " \"", str, "\" not one of: ", NULL);
    cp = (char**)tablePtr;
    while (*cp != 0) {
      c = *cp;
      Jsi_DSAppend(&dStr, c, NULL);
      Jsi_DSAppend(&dStr, " ", NULL);
      cp++;
    }
    Jsi_LogError("%s", Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
  }
  return JSI_ERROR;
}

int Jsi_GlobMatch(const char *pattern, const char *string, int nocase)
{
    int c;
    int pchar;
    while (*pattern) {
        switch (pattern[0]) {
            case '*':
                while (pattern[1] == '*') {
                    pattern++;
                }
                pattern++;
                if (!pattern[0]) {
                    return 1;   /* match */
                }
                while (*string) {
                    if (Jsi_GlobMatch(pattern, string, nocase))
                        return 1;       /* match */
                    string += jsi_utf8_tounicode(string, &c);
                }
                return 0;       /* no match */

            case '?':
                string += jsi_utf8_tounicode(string, &c);
                break;

            case '[': {
                    string += jsi_utf8_tounicode(string, &c);
                    pattern = JsiCharsetMatch(pattern + 1, c, nocase ? JSI_CMP_NOCASE : 0);
                    if (!pattern) {
                        return 0;
                    }
                    if (!*pattern) {
                        /* Ran out of pattern (no ']') */
                        continue;
                    }
                    break;
                }
            case '\\':
                if (pattern[1]) {
                    pattern++;
                }
                /* fall through */
            default:
                string += jsi_utf8_tounicode_case(string, &c, nocase);
                jsi_utf8_tounicode_case(pattern, &pchar, nocase);
                if (pchar != c) {
                    return 0;
                }
                break;
        }
        pattern += jsi_utf8_tounicode_case(pattern, &pchar, nocase);
        if (!*string) {
            while (*pattern == '*') {
                pattern++;
            }
            break;
        }
    }
    if (!*pattern && !*string) {
        return 1;
    }
    return 0;
}

Jsi_Stack* Jsi_StackNew(void)
{
    Jsi_Stack *stack = (Jsi_Stack*)Jsi_Calloc(1, sizeof(Jsi_Stack));
    return stack;
}

void Jsi_StackFree(Jsi_Stack *stack)
{
    Jsi_Free(stack->vector);
    Jsi_Free(stack);
}

int Jsi_StackLen(Jsi_Stack *stack)
{
    return stack->len;
}

void Jsi_StackPush(Jsi_Stack *stack, void *element)
{
    int neededLen = stack->len + 1;

    if (neededLen > stack->maxlen) {
        stack->maxlen = neededLen < 20 ? 20 : neededLen * 2;
        stack->vector = (void**)Jsi_Realloc(stack->vector, sizeof(void *) * stack->maxlen);
    }
    stack->vector[stack->len] = element;
    stack->len++;
}

void *Jsi_StackPop(Jsi_Stack *stack)
{
    if (stack->len == 0)
        return NULL;
    stack->len--;
    return stack->vector[stack->len];
}

void *Jsi_StackPeek(Jsi_Stack *stack)
{
    if (stack->len == 0)
        return NULL;
    return stack->vector[stack->len - 1];
}

void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeProc)
{
    int i;
    for (i = 0; i < stack->len; i++)
        freeProc(interp, stack->vector[i]);
    stack->len = 0;
}

typedef struct {
    void *data;
    Jsi_DeleteProc *delProc;
} AssocData;

/* Split on string. */
void Jsi_SplitStr(const char *str, int *argcPtr,
              char ***argvPtr, const char *ch, Jsi_DString *dStr)
{
    char *cp, *ep, *p, **argv;
    int cnt = 1, len, i, clen;
    if (!ch)
        ch = "";
    clen = strlen(ch);
    if (clen<=0)
        return SplitChar(str, argcPtr, argvPtr, *ch, dStr);
    len = strlen(str);
    cp = (char*)str;
    while (*cp) {
        cp = strstr(cp,ch);
 
        if (cp == NULL || *cp == 0) break;
        cp += clen;
        cnt++;
    }
    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));
    argv = (char**)Jsi_DSValue(dStr);
    *argvPtr = argv;
    *argcPtr = cnt;
    p = (char*)&(argv[cnt+2]);
    argv[cnt+1] = p;
    Jsi_Strcpy(p, str);
    cp = p;
    i = 0;
    argv[i++] = p;
    while (*cp) {
        ep = strstr(cp,ch);
        if (ep == NULL || *ep == 0) break;
        *ep = 0;
        cp = ep+clen;
        argv[i++] = cp;
    }
    argv[cnt] = NULL;
}

static int JsiCheckConversion(const char *str, const char *endptr)
{
    if (str[0] == '\0' || str == endptr) {
        return JSI_ERROR;
    }

    if (endptr[0] != '\0') {
        while (*endptr) {
            if (!isspace(UCHAR(*endptr))) {
                return JSI_ERROR;
            }
            endptr++;
        }
    }
    return JSI_OK;
}

static int JsiNumberBase(const char *str, int *base, int *sign)
{
    int i = 0;

    *base = 10;

    while (isspace(UCHAR(str[i]))) {
        i++;
    }

    if (str[i] == '-') {
        *sign = -1;
        i++;
    }
    else {
        if (str[i] == '+') {
            i++;
        }
        *sign = 1;
    }

    if (str[i] != '0') {
        /* base 10 */
        return 0;
    }

    /* We have 0<x>, so see if we can convert it */
    switch (str[i + 1]) {
        case 'x': case 'X': *base = 16; break;
        case 'o': case 'O': *base = 8; break;
        case 'b': case 'B': *base = 2; break;
        default: return 0;
    }
    i += 2;
    /* Ensure that (e.g.) 0x-5 fails to parse */
    if (str[i] != '-' && str[i] != '+' && !isspace(UCHAR(str[i]))) {
        /* Parse according to this base */
        return i;
    }
    /* Parse as base 10 */
    return 10;
}

/* Converts a number as per strtoull(..., 0) except leading zeros do *not*
 * imply octal. Instead, decimal is assumed unless the number begins with 0x, 0o or 0b
 */
static Jsi_Wide jsi_strtoull(const char *str, char **endptr)
{
#ifdef HAVE_LONG_LONG
    int sign;
    int base;
    int i = JsiNumberBase(str, &base, &sign);

    if (base != 10) {
        Jsi_Wide value = strtoull(str + i, endptr, base);
        if (endptr == NULL || *endptr != str + i) {
            return value * sign;
        }
    }

    /* Can just do a regular base-10 conversion */
    return strtoull(str, endptr, 10);
#else
    return (unsigned long)jsi_strtol(str, endptr);
#endif
}

static Jsi_Wide jsi_strtoul(const char *str, char **endptr)
{
#ifdef HAVE_LONG_LONG
    int sign;
    int base;
    int i = JsiNumberBase(str, &base, &sign);

    if (base != 10) {
        Jsi_Wide value = strtoul(str + i, endptr, base);
        if (endptr == NULL || *endptr != str + i) {
            return value * sign;
        }
    }

    /* Can just do a regular base-10 conversion */
    return strtoul(str, endptr, 10);
#else
    return (unsigned long)jsi_strtol(str, endptr);
#endif
}


int Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *widePtr, int base)
{
    char *endptr;

    if (base) {
        *widePtr = strtoull(string, &endptr, base);
    }
    else {
        *widePtr = jsi_strtoull(string, &endptr);
    }

    return JsiCheckConversion(string, endptr);
}

int Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base)
{
    char *endptr;
    if (base) {
        *n = strtoul(string, &endptr, base);
    }
    else {
        *n = (int)jsi_strtoul(string, &endptr);
    }
    return JsiCheckConversion(string, endptr);
}

int Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n)
{
    char *endptr;

    /* Callers can check for underflow via ERANGE */
    errno = 0;

    *n = strtod(string, &endptr);

    return JsiCheckConversion(string, endptr);
}

int Jsi_GetBool(Jsi_Interp* interp, const char *string, int *n)
{
    int len = strlen(string);
    if ((strncasecmp(string, "true", len)==0 && len<=4)) {
        *n = 1;
        return JSI_OK;
    }
    if ((strncasecmp(string, "false", len)==0 && len<=5)) {
        *n = 0;
        return JSI_OK;
    }
    return Jsi_GetInt(interp, string, n, 0);
}

#ifndef JSI_LITE_ONLY

void *Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc)
{
    Jsi_HashEntry *hPtr;
    AssocData *ptr;
    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);
    if (!hPtr)
        return NULL;
    ptr = (AssocData *)Jsi_HashValueGet(hPtr);
    if (!ptr)
        return NULL;
    if (proc)
        *proc = ptr->delProc;
    return ptr->data;
}
void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc *proc, void *data)
{
    int isNew;
    Jsi_HashEntry *hPtr;
    AssocData *ptr;
    hPtr = Jsi_HashEntryNew(interp->assocTbl, key, &isNew);
    if (!hPtr)
        return;
    if (isNew) {
        ptr = (AssocData *)Jsi_Calloc(1,sizeof(*ptr));
        Jsi_HashValueSet(hPtr, ptr);
    } else
        ptr = (AssocData *)Jsi_HashValueGet(hPtr);
    ptr->data = data;
    ptr->delProc = proc;
}

void jsi_DelAssocData(Jsi_Interp *interp, void *data) {
    AssocData *ptr = (AssocData *)data;
    if (!ptr) return;
    if (ptr->delProc)
        ptr->delProc(interp, ptr->data);
    Jsi_Free(ptr);
}

void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key)
{
    Jsi_HashEntry *hPtr;
    AssocData *ptr;
    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);
    if (!hPtr)
        return;
    ptr = (AssocData *)Jsi_HashValueGet(hPtr);
    Jsi_HashEntryDelete(hPtr);
    jsi_DelAssocData(interp, ptr);
}

void Jsi_SetResultFormatted(Jsi_Interp *interp, const char *fmt, ...) {
    va_list va;
    char buf[BUFSIZ];
    va_start (va, fmt);
    vsnprintf(buf, BUFSIZ, fmt, va);
    va_end(va);
    fprintf(stderr, "<Jsi_SetResultFormatted NOTIMPL>: %s\n", buf);

}


int Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **n)
{
    if (!value)
        return JSI_ERROR;
    if (value->vt == JSI_VT_STRING)
    {
        *n = (const char*)value->d.s.str;
         return JSI_OK;
    }
    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_STRING) {
        *n = value->d.obj->d.s.str;
        return JSI_OK;
    }
    Jsi_LogError("invalid string");
    return JSI_ERROR;
}

int Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n)
{
    if (!value)
        return JSI_ERROR;

    if (value->vt == JSI_VT_BOOL) {
        *n = value->d.val;
        return JSI_OK;
    }
    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_BOOL) {
        *n = value->d.obj->d.val;
        return JSI_OK;
    }
    Jsi_LogError("invalid bool");
    return JSI_ERROR;
}


int Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)
{
    if (!value)
        return JSI_ERROR;

    if (value->vt == JSI_VT_NUMBER) {
        *n = value->d.num;
        return JSI_OK;
    }
    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_NUMBER) {
        *n = value->d.obj->d.num;
        return JSI_OK;
    }
    if (interp)
        Jsi_LogError("invalid number");
    return JSI_ERROR;
}

int Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags)
{
    Jsi_Number d;
    int noMsg = (flags & JSI_NO_ERRMSG);
    /* TODO: inefficient to convert to double then back. */
    if (!value)
        return JSI_ERROR;
    d = Jsi_ValueToNumberInt(interp, value, 1);
    if (!jsi_num_isFinite(d))
    {
        if (!noMsg)
            Jsi_LogError("invalid number");
        return JSI_ERROR;
    }
    Jsi_ValueReset(interp,&value);
    Jsi_ValueMakeNumber(interp, &value, d);
    *n = (int)d;
    return JSI_OK;
}

int Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n)
{
    return Jsi_GetIntFromValueBase(interp, value, n, 0, 0);
}

int Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n)
{
    /* TODO: inefficient to convert to double then back. */
    if (!value)
        return JSI_ERROR;
    jsi_ValueToOInt32(interp, value);
    if (value->vt != JSI_VT_NUMBER)
    {
        Jsi_LogError("invalid number");
        return JSI_ERROR;
    }
    *n = (long)value->d.num;
    return JSI_OK;
}

int Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n)
{
    if (!value)
        return JSI_ERROR;
    jsi_ValueToOInt32(interp, value);
    if (value->vt != JSI_VT_NUMBER)
    {
        Jsi_LogError("invalid number");
        return JSI_ERROR;
    }
    *n = (Jsi_Wide)value->d.num;
    return JSI_OK;

}

int Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)
{
    if (!value)
        return JSI_ERROR;
    Jsi_ValueToNumber(interp, value);
    if (value->vt != JSI_VT_NUMBER)
    {
        Jsi_LogError("invalid number");
        return JSI_ERROR;
    }
    *n = value->d.num;
    return JSI_OK;
}

int
Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr,
    const char **tablePtr, const char *msg, int flags, int *indexPtr)
{
    char *val = Jsi_ValueString(interp, valPtr, NULL);
    if (val == NULL) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    return Jsi_GetIndex(interp, val, tablePtr, msg, flags, indexPtr);
}

Jsi_Value *Jsi_InterpResult(Jsi_Interp *interp)
{
    return interp->retPtr;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#else
char *strptime(const char *buf, const char *fmt, struct tm *tm);
#endif
#include <errno.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <signal.h>
#include <limits.h>

static int consoleInputCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[1024];
    char *p = buf;
    
    if (fgets(buf, 1024, stdin) == NULL) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    if ((p = Jsi_Strchr(buf, '\r'))) *p = 0;
    if ((p = Jsi_Strchr(buf, '\n'))) *p = 0;
    
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(buf));
    return JSI_OK;
}

typedef struct {
    int debug;
    Jsi_Bool index;
    Jsi_Bool isMain;
} SourceData;

static Jsi_OptionSpec SourceOptions[] = {
    JSI_OPT(INT,    SourceData, debug,  .help="Debug level" ),
    JSI_OPT(BOOL,   SourceData, index,  .help="Setup for load of jsiIndex.jsi files" ),
    JSI_OPT(BOOL,   SourceData, isMain, .help="Make Info.isMain() to true for the sourced file" ),
    JSI_OPT_END(SourceData)
};


static int SysSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    jsi_Pstate *ps = interp->ps;
    int rc = JSI_OK, flags = 0;
    int i, argc, oisi;
    SourceData data = {};
    Jsi_Value *v, *va = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);
    if (vo) {
        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) { /* Future options. */
            Jsi_LogError("expected options object");
            return JSI_ERROR;
        }
        if (Jsi_OptionsProcess(interp, SourceOptions, vo, &data, 0) < 0) {
            return JSI_ERROR;
        }
        if (data.index)
            flags |= JSI_EVAL_INDEX;
    }
    if ((interp->includeDepth+1) > interp->maxIncDepth) {
        Jsi_LogError("max source depth exceeded");
        return JSI_ERROR;
    }
    interp->includeDepth++;
    oisi = interp->isMain;
    interp->isMain = data.isMain;
    if (!Jsi_ValueIsArray(interp, va)) {
        v = va;
        if (v && Jsi_ValueIsString(interp,v)) {
            if (data.debug)
                fprintf(stderr, "sourcing: %s\n", Jsi_ValueString(interp, v, 0));
            rc = Jsi_EvalFile(ps->interp, v, flags);
        } else {
            Jsi_LogError("expected string");
            rc = JSI_ERROR;
        }
        goto done;
    }
    argc = Jsi_ValueGetLength(interp, va);
    for (i=0; i<argc && rc == JSI_OK; i++) {
        v = Jsi_ValueArrayIndex(interp, va, i);
        if (v && Jsi_ValueIsString(interp,v)) {
            if (data.debug)
                fprintf(stderr, "sourcing: %s\n", Jsi_ValueString(interp, v, 0));
            rc = Jsi_EvalFile(ps->interp, v, flags);
        } else {
            Jsi_LogError("expected string");
            rc = JSI_ERROR;
            break;
        }
    }
done:
    interp->isMain = oisi;
    interp->includeDepth--;
    return rc;
}

static void jsiGetTime(long *seconds, long *milliseconds)
{
    struct timeval tv;

    gettimeofday(&tv, NULL);
    *seconds = tv.tv_sec;
    *milliseconds = tv.tv_usec / 1000;
}

void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event) {
    SIGASSERT(event,EVENT);
    if (event->funcVal)
        Jsi_DecrRefCount(interp, event->funcVal);
    if (event->hPtr)
        Jsi_HashEntryDelete(event->hPtr);
    MEMCLEAR(event);
    Jsi_Free(event);
}

/* Create an event and add to interp event table. */
Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data)
{
    Jsi_Event *ev;
    while (1) {
        int isNew, id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));
        SIGINIT(ev,EVENT);
        ev->id = id;
        ev->handler = callback;
        ev->data = data;
        ev->hPtr = hPtr;
        Jsi_HashValueSet(hPtr, ev);
        break;
    }
    return ev;
}

/* Process events and return count. */
int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents)
{
    Jsi_Event *ev;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Value* nret = NULL;
    int rc, cnt = 0, newIdx = interp->eventIdx;
    long cur_sec, cur_ms;
    jsiGetTime(&cur_sec, &cur_ms);
    Jsi_Value *vpargs = NULL;

    /*if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)
        return JSI_ERROR;*/
    
    for (hPtr = Jsi_HashEntryFirst(interp->eventTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        
        if (!(ev = (Jsi_Event*)Jsi_HashValueGet(hPtr)))
            continue;
        SIGASSERT(ev,EVENT);
        if ((int)ev->id >= newIdx) /* Avoid infinite loop of event creating events. */
            continue;
        switch (ev->evType) {
            case JSI_EVENT_SIGNAL:
#ifndef JSI_OMIT_SIGNAL   /* TODO: win signals? */
                if (!jsi_SignalIsSet(interp, ev->sigNum))
                    continue;
                jsi_SignalClear(interp, ev->sigNum);
#endif
                break;
            case JSI_EVENT_TIMER:
                if (cur_sec <= ev->when_sec && (cur_sec != ev->when_sec || cur_ms < ev-> when_ms)) {
                    if (ev->when_sec && ev->when_ms)
                        continue;
                }
                break;
            case JSI_EVENT_ALWAYS:
                break;
            default: assert(0);
        }

        cnt++;
        ev->count++;
        if (ev->handler) {
            rc = ev->handler(interp, ev->data);
        } else {
            if (vpargs == NULL) {
                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
                Jsi_IncrRefCount(interp, vpargs);
            }
            nret = Jsi_ValueNew1(interp);
            rc = Jsi_FunctionInvoke(interp, ev->funcVal, vpargs, &nret, NULL);
        }
        if (interp->deleting) {
            cnt = -1;
            goto bail;
        }
        if (rc != JSI_OK) {
            if (interp->exited) {
                cnt = rc;
                goto bail;
            }
            Jsi_LogError("event function call failure");
        }
        if (ev->once) {
            Jsi_EventFree(interp, ev);
        } else {
            ev->when_sec = cur_sec + ev->initialms / 1000;
            ev->when_ms = cur_ms + ev->initialms % 1000;
            if (ev->when_ms >= 1000) {
                ev->when_sec++;
                ev->when_ms -= 1000;
            }
        }
        if (maxEvents>0 && cnt>=maxEvents)
            break;
    }
bail:
    if (vpargs)
        Jsi_DecrRefCount(interp, vpargs);
    if (nret)
        Jsi_DecrRefCount(interp, nret);
    /*Jsi_MutexUnlock(interp, interp->Mutex);*/
    return cnt;
}

/*
 * \brief: sleep for so many milliseconds with mutex unlocked.
 */
int Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim) {
    uint utim = 0;
    if (dtim <= 0)
        return JSI_OK;
    Jsi_MutexUnlock(interp, interp->Mutex);
    dtim = (dtim/1e3);
    if (dtim>1) {
        utim = 1e6*(dtim - (Jsi_Number)((int)dtim));
        dtim = (int)dtim;
    } else if (dtim<1) {
        utim = 1e6 * dtim;
        dtim = 0;
    }
    if (utim>0)
        usleep(utim);
    if (dtim>0)
        sleep(dtim);
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {
        Jsi_LogBug("could not reget mutex");
        return JSI_ERROR;
    }
    return JSI_OK;
}

typedef struct {
    int minTime;
    int maxEvents;
    int maxPasses;
    int sleep;
} UpdateData;

static Jsi_OptionSpec UpdateOptions[] = {
    JSI_OPT(INT,    UpdateData, maxEvents,  .help="Maximum number of events to process (or -1)" ),
    JSI_OPT(INT,    UpdateData, maxPasses,  .help="Maximum passes through event queue" ),
    JSI_OPT(INT,    UpdateData, minTime,    .help="Minimum milliseconds before returning, or -1 to loop forever" ),
    JSI_OPT(INT,    UpdateData, sleep,      .help="Time to sleep time (in milliseconds) between event checks. Default is 1" ),
    JSI_OPT_END(UpdateData)
};

#define FN_update JSI_INFO("\
Returns the number of events processed. \
Events are processed until minTime (in milliseconds) is exceeded, or forever if -1. \
The default minTime is 0, meaning return as soon as no events can be processed. \
A positive mintime will result in sleeps between event checks.")
static int SysUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int maxEvents = -1, hasopts = 0;
    int cnt = 0, lcnt = 0, rc = JSI_OK;
    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);
    long cur_sec, cur_ms;
    long start_sec, start_ms;
    jsiGetTime(&start_sec, &start_ms);
    UpdateData udata;
    memset(&udata, 0, sizeof(udata));
    udata.sleep = 1;
    jsi_AddEventHandler(interp); 
       
    if (opts != NULL) {
        Jsi_Number dms;
        if (opts->vt == JSI_VT_OBJECT) {
            hasopts = 1;
            if (Jsi_OptionsProcess(interp, UpdateOptions, opts, &udata, 0) < 0) {
                return JSI_ERROR;
            }
        } else if (opts->vt != JSI_VT_NULL && Jsi_GetNumberFromValue(interp, opts, &dms) != JSI_OK)
            return JSI_ERROR;
        else
            udata.minTime = (unsigned long)dms;
    }
  
    while (1) {
        long long diftime;
        int ne = Jsi_EventProcess(interp, maxEvents);
        if (ne<0)
            break;
        cnt += ne;
        if (Jsi_InterpGone(interp))
            return JSI_ERROR;
        if (udata.minTime==0)
            break;
        jsiGetTime(&cur_sec, &cur_ms);
        if (cur_sec == start_sec)
            diftime = (long long)(cur_ms-start_ms);
        else
            diftime = (cur_sec-start_sec)*1000LL + cur_ms + (1000-start_ms);
        if (udata.minTime>0 && diftime >= (long long)udata.minTime)
            break;
        if (udata.maxPasses && ++lcnt >= udata.maxPasses)
            break;
        if ((rc = Jsi_Sleep(interp, udata.sleep)) != JSI_OK)
            break;
    }
    if (hasopts)
        Jsi_OptionsFree(interp, UpdateOptions, &udata, 0);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);
    return rc;
}

static int intervalTimer(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int once)
{
    int isNew;
    Jsi_Event *ev;
    uint id;
    Jsi_Number milli;
    long milliseconds, cur_sec, cur_ms;
    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 1);
    
    if (!Jsi_ValueIsFunction(interp, fv)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    if (Jsi_GetNumberFromValue(interp, tv, &milli) != JSI_OK) {
        Jsi_LogError("expected number");
        return JSI_ERROR;
    }
    milliseconds = (long)milli;
    if (milliseconds < 0)
        milliseconds = 0;
    while (1) {
        id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));
        SIGINIT(ev,EVENT);
        ev->id = id;
        ev->funcVal = fv;
        Jsi_IncrRefCount(interp, fv);
        ev->hPtr = hPtr;
        jsiGetTime(&cur_sec, &cur_ms);
        ev->initialms = milliseconds;
        ev->when_sec = cur_sec + milliseconds / 1000;
        ev->when_ms = cur_ms + milliseconds % 1000;
        if (ev->when_ms >= 1000) {
            ev->when_sec++;
            ev->when_ms -= 1000;
        }
        ev->once = once;
        Jsi_HashValueSet(hPtr, ev);
        break;
    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);
    return JSI_OK;
}

static int setIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return intervalTimer(interp, args, _this, ret, funcPtr, 0);
}

static int clearIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Event *ev;
    Jsi_Number nid;
    int id;
    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_HashEntry *hPtr;
    if (Jsi_GetNumberFromValue(interp, tv, &nid) != JSI_OK) {
        Jsi_LogError("expected number");
        return JSI_ERROR;
    }
    id = (uint)nid;
    hPtr = Jsi_HashEntryFind(interp->eventTbl, (void*)id);
    if (hPtr == NULL) {
        Jsi_LogError("id not found: %d", id);
        return JSI_ERROR;
    }
    ev = (Jsi_Event*)Jsi_HashValueGet(hPtr);
    Jsi_EventFree(interp, ev);
    return JSI_OK;
}

static int setTimeoutCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return intervalTimer(interp, args, _this, ret, funcPtr, 1);
}

static int SysExitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int err = 0;
    Jsi_Value *v = NULL;
    Jsi_Number n;
    if (Jsi_ValueGetLength(interp, args) > 0) {
        v = Jsi_ValueArrayIndex(interp, args, 0);
        if (v && Jsi_GetNumberFromValue(interp,v, &n) == JSI_OK)
            err = (int)n;
        else {
            Jsi_LogError("expected number");
            return JSI_ERROR;
        }
    }
    if (interp->onExit && interp->parent && Jsi_FunctionInvokeBool(interp->parent, interp->onExit, v))
        return JSI_OK;
    if (interp->parent == NULL && 0) {
        if (interp == interp->mainInterp)
            exit(err);
        Jsi_InterpDelete(interp);
        return JSI_ERROR;
    } else {
        interp->exited = 1;
        interp->exitCode = err;
        return JSI_ERROR;
        /* TODO: cleanup events, etc. */
    }
    return JSI_OK;
}

int jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Bool b;
    int rc = 0;
    Jsi_Number d;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    char *msg = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    if (interp->nDebug)
        return JSI_OK;
    if (Jsi_ValueGetNumber(interp,v, &d) == JSI_OK)
        rc = (int)d;
    else if (Jsi_ValueGetBoolean(interp,v, &b) == JSI_OK)
        rc = b;
    else if (Jsi_ValueIsFunction(interp, v)) {
        Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, v, vpargs, ret, NULL);
        Jsi_DecrRefCount(interp, vpargs);
        Jsi_Bool b;
        if (Jsi_ValueGetNumber(interp, *ret, &d) == JSI_OK)
            rc = (int)d;
        else if (Jsi_ValueGetBoolean(interp, *ret, &b) == JSI_OK)
            rc = b;
        else {
            Jsi_LogWarn("invalid function assert");
            return JSI_ERROR;
        }
    } else {
        Jsi_LogWarn("invalid assert");
        return JSI_ERROR;
    }
    if (rc == 0) {
        Jsi_ValueDup2(interp, ret, v);
        Jsi_LogError("assert failed: %s", msg?msg:"");
        return JSI_ERROR;
    }
    return JSI_OK;
}


static int parseIntCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Wide w = 0;
    Jsi_Number d = 0;

    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *bv = Jsi_ValueArrayIndex(interp, args, 1);
    if (!v)
        return JSI_ERROR;
    if (!bv)
        d = Jsi_ValueToNumberInt(interp, v, 1);
    else {
        int base = 0;
        char *eptr, *str = Jsi_ValueString(interp, v, NULL);
        if (str == NULL || JSI_OK != Jsi_GetIntFromValue(interp, bv, &base) || base<2 || base>36)
            return JSI_ERROR;
        d = (Jsi_Number)strtoll(str, &eptr, base);
    }
    if (jsi_num_isNaN(d) || (jsi_num_isFinite(d)==0 && Jsi_GetDoubleFromValue(interp, v, &d) != JSI_OK))
        Jsi_ValueDup2(interp, ret, interp->NaNValue);
    else {
        w = (Jsi_Wide)d;
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)w);
    }
    return JSI_OK;
}

static int parseFloatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK)
        Jsi_ValueDup2(interp, ret, interp->NaNValue);
    else {
        Jsi_ValueMakeNumber(interp, ret, n);
    }
    return JSI_OK;
}


static int SysNoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return JSI_OK;
}

static int isNaNCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n;
    int rc = 0;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || jsi_num_isNaN(n))
        rc = 1;
    Jsi_ValueMakeBool(interp, ret, rc);
    return JSI_OK;
}
static int isFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number n;
    int rc = 1;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || !jsi_num_isFinite(n))
        rc = 0;
    Jsi_ValueMakeBool(interp, ret, rc);
    return JSI_OK;
}
/* Converts a hex character to its integer value */
static char from_hex(char ch) {
  return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;
}

/* Converts an integer value to its hex character*/
static char to_hex(char code) {
  static char hex[] = "0123456789abcdef";
  return hex[code & 15];
}

/* Returns a url-encoded version of str */
/* IMPORTANT: be sure to free() the returned string after use */
static char *url_encode(char *str) {
  char *pstr = str, *buf = (char*)Jsi_Malloc(strlen(str) * 3 + 1), *pbuf = buf;
  while (*pstr) {
    if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') 
      *pbuf++ = *pstr;
    else if (*pstr == ' ') 
      *pbuf++ = '+';
    else 
      *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);
    pstr++;
  }
  *pbuf = '\0';
  return buf;
}

/* Returns a url-decoded version of str */
/* IMPORTANT: be sure to free() the returned string after use */
static char *url_decode(char *str) {
  char *pstr = str, *buf = (char*)Jsi_Malloc(strlen(str) + 1), *pbuf = buf;
  while (*pstr) {
    if (*pstr == '%') {
      if (pstr[1] && pstr[2]) {
        *pbuf++ = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);
        pstr += 2;
      }
    } else if (*pstr == '+') { 
      *pbuf++ = ' ';
    } else {
      *pbuf++ = *pstr;
    }
    pstr++;
  }
  *pbuf = '\0';
  return buf;
}
/*
static int EscapeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
}
static int UnescapeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
}*/

static int EncodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    cp = url_encode(str);
    Jsi_ValueMakeString(interp, ret, cp);
    return JSI_OK;
}

static int DecodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    cp = url_decode(str);
    Jsi_ValueMakeString(interp, ret, cp);
    return JSI_OK;
}

static int SysSleepCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Number dtim = 1;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (v) {
        if (Jsi_GetDoubleFromValue(interp, v, &dtim) != JSI_OK) {
            return JSI_ERROR;
        }
    }
    return Jsi_Sleep(interp, dtim);
}


static int SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    extern char **environ;
    char *cp;
    int i;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    if (v != NULL) {
        const char *fnam = Jsi_ValueString(interp, v, NULL);
        if (!fnam) {
            Jsi_LogError("expected string");
            return JSI_ERROR;
        }
        cp = getenv(fnam);
        if (cp != NULL) {
            Jsi_ValueMakeString(interp, ret, Jsi_Strdup(cp));
        }
        return JSI_OK;
    }
   /* Single object containing result members. */
    Jsi_Value *vres;
    Jsi_Obj  *ores = Jsi_ObjNew(interp);
    Jsi_Value *nnv;
    char *val, nam[200];
    Jsi_ObjIncrRefCount(interp, ores);
    vres = Jsi_ValueMakeObject(interp, NULL, ores);
    Jsi_IncrRefCount(interp, vres);
    
    for (i=0; ; i++) {
        int n;
        cp = environ[i];
        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))
            break;
        n = val-cp;
        if (n>=(int)sizeof(nam))
            n = sizeof(nam)-1;
        Jsi_Strncpy(nam, cp, n);
        val = val+1;
        nnv = Jsi_ValueMakeString(interp, NULL, Jsi_Strdup(val));
        Jsi_ObjInsert(interp, ores, nam, nnv, 0);
    }
    Jsi_ValueReplace(interp, ret, vres);
    return JSI_OK;
}

static int SysSetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    const char *fnam = Jsi_ValueString(interp, v, NULL);
    Jsi_Value *vv = Jsi_ValueArrayIndex(interp, args, 1);
    const char *fval = Jsi_ValueString(interp, vv, NULL);
    int rc = -1;
    if (fnam == 0 || fval == 0) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }

    if (fnam[0] != 0) {
#ifndef __WIN32
        rc = setenv(fnam, fval, 1);
#else  /* TODO: win setenv */
        char ebuf[BUFSIZ];
        snprintf(ebuf, sizeof(ebuf), "%s=%s", fnam, fval);
        rc = _putenv(ebuf);
#endif
    }
    if (rc != 0) {
        Jsi_LogError("setenv failure: %s = %s", fnam, fval);
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int SysGetPidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)getpid());
    return JSI_OK;
}

static int SysGetPpidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifndef __WIN32
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)getppid());
#endif
    return JSI_OK;
}

typedef struct {
    Jsi_Value* inputStr;
    Jsi_Bool bg;
    Jsi_Bool noError;
    Jsi_Bool noTrim;
    Jsi_Bool retCode;
    Jsi_Bool retAll;
    Jsi_Bool retval;
} ExecOpts;

static Jsi_OptionSpec ExecOptions[] = {
    JSI_OPT(BOOL,   ExecOpts, bg,       .help="Run command in background using system() and return OS code" ),
    JSI_OPT(STRING, ExecOpts, inputStr, .help="Use string as input and return OS code" ),
    JSI_OPT(BOOL,   ExecOpts, noError,  .help="Suppress all OS errors" ),
    JSI_OPT(BOOL,   ExecOpts, noTrim,   .help="Do not trim trailing whitespace from output" ),
    JSI_OPT(BOOL,   ExecOpts, retAll,   .help="Return the OS return code and data as an object" ),
    JSI_OPT(BOOL,   ExecOpts, retCode,  .help="Return only the OS return code" ),
    {JSI_OPTION_END}
};

#define FN_exec JSI_INFO("\
If the command ends with '&', set the 'bg' option to true. \
If the second argument is null, set the 'noError' option to true. \
If the second argument is a string, the 'inputStr' option is set. \
By default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used")

static int SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->isSafe) {
        Jsi_LogError("no exec in safe mode");
        return JSI_ERROR;
    }
    int n, rc = JSI_OK, exitCode = 0, hasopts = 0, sLen, sLen2;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    const char *cp2=NULL, *cp = Jsi_ValueString(interp, arg, &sLen);
    Jsi_DString dStr = {};
    ExecOpts edata = {};
    edata.retval = 1;
    
    if (opt != NULL) {
        if (opt->vt == JSI_VT_OBJECT && opt->d.obj->ot == JSI_OT_OBJECT) {
            hasopts = 1;
            if (Jsi_OptionsProcess(interp, ExecOptions, opt, &edata, 0) < 0) {
                return JSI_ERROR;
            }
            if (edata.retCode)
                edata.retval = 0;
        } else if ((cp2=Jsi_ValueString(interp, opt, &sLen2))) {
            edata.inputStr = opt;
        } else if (Jsi_ValueIsNull(interp, opt)) {
                edata.noError = 1;
        } else {
            Jsi_LogError("expected: string?,null|instr?");
            return JSI_ERROR;
        }
    }

    int isbg = 0, ec = 0;
    if (edata.bg || (isbg=((sLen>1 && cp[sLen-1] == '&')))) {
        if (edata.inputStr) {
            Jsi_LogError("inputStr can not used with bg");
            goto done;
            rc = JSI_ERROR;
        }
        if (!isbg) {
            Jsi_DSAppend(&dStr, cp, " &", NULL);
            cp = Jsi_DSValue(&dStr);
        }
        edata.bg = 1;
        edata.retCode = 1;
        edata.retval = 0;
        exitCode = ((ec=system(cp))>>8);
        Jsi_DSSetLength(&dStr, 0);
    } else if (edata.inputStr) {
        edata.retCode = 1;
        edata.retval = 0;
        cp2 = Jsi_ValueString(interp, edata.inputStr, &sLen2);
        FILE *fp = popen(cp, "w");
        if (!fp) 
            exitCode = errno;
        else {
            while ((n=fwrite(cp2, 1, sLen, fp))>0) {
                sLen -= n;
            }
            exitCode = ((ec=pclose(fp))>>8);
        }
    } else {
        FILE *fp = popen(cp, "r");
        if (!fp) 
            exitCode = errno;
        else {
            char buf[BUFSIZ];;
            while ((n=fread(buf, 1, sizeof(buf), fp))>0)
                Jsi_DSAppendLen(&dStr, buf, n);
            exitCode = ((ec=pclose(fp))>>8);
        }
    }
    if (exitCode && edata.noError==0 && edata.retCode==0 && edata.retAll==0) {
        if (exitCode==ENOENT)
            Jsi_LogError("command not found: %s", cp);
        else
            Jsi_LogError("program exit code (%x)", exitCode);
        rc = JSI_ERROR;
    }
    if (!edata.noTrim) {
        char *cp = Jsi_DSValue(&dStr);
        int iLen = Jsi_DSLength(&dStr);
        while (iLen>0 && isspace(cp[iLen-1]))
            iLen--;
        cp[iLen] = 0;
    }
    if (edata.retAll) {
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeObject(interp, ret, nobj);
        Jsi_Value *cval = Jsi_ValueNewNumber(interp, (Jsi_Number)exitCode);
        Jsi_ObjInsert(interp, nobj, "code", cval, 0);
        cval = Jsi_ValueNewNumber(interp, (Jsi_Number)(ec&0xff));
        Jsi_ObjInsert(interp, nobj, "status", cval, 0);
        cval = Jsi_ValueNew(interp);
        Jsi_ValueFromDS(interp, &dStr, &cval);
        Jsi_ObjInsert(interp, nobj, "data", cval, 0);
        
    } else if (edata.retval)
        Jsi_ValueFromDS(interp, &dStr, ret);
    else {
        Jsi_DSFree(&dStr);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)exitCode);
    }
done:
    if (hasopts)
        Jsi_OptionsFree(interp, ExecOptions, &edata, 0);
    return rc;
}

#define FN_conslog JSI_INFO("\
Each argument is quoted (unlike the builtin string concatenation).\
If called with 0 or 1 argument, a newline is output, otherwise stderr is flushed")
static int consoleLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    int argc = Jsi_ValueGetLength(interp, args);
    int i, cnt = 0;
    for (i = 0; i < argc; ++i) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);
        if (!v) continue;
        if (cnt++)
            fprintf(stderr, " ");
        Jsi_Puts(interp, v, JSI_OUTPUT_QUOTE|JSI_OUTPUT_STDERR);
    }
    if (argc<=1)
        printf("\n");
    else
        fflush(stderr);
    return JSI_OK;
}

#define FN_puts JSI_INFO("\
Each argument is quoted (unlike the builtin string concatenation).\
If called with 0 or 1 argument, a newline is output, otherwise stdout is flushed")
static int SysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,
    Jsi_Func *funcPtr)
{
    int argc = Jsi_ValueGetLength(interp, args);;
    Jsi_Value *v;
    int i, cnt = 0;
    for (i=0; i<argc; i++) {
        v = Jsi_ValueArrayIndex(interp, args, i);
        if (!v) continue;
        if (cnt++)
            printf(" ");
        Jsi_Puts(interp, v, JSI_OUTPUT_QUOTE);
    }
    if (argc<=1)
        printf("\n");
    else
        fflush(stdout);
    return JSI_OK;
}

/*static int DateNowCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    Jsi_Number n = ((double)(tv.tv_usec/1000)) + ((double)tv.tv_sec)*1000;
    Jsi_ValueMakeNumber(interp, ret, n);
    return JSI_OK;
}*/


typedef struct {
    Jsi_Bool utc;
    const char *fmt;
} DateOpts;

static Jsi_OptionSpec DateOptions[] = {
    JSI_OPT(BOOL,   DateOpts, utc, .help="time is in utc" ),
    JSI_OPT(STRKEY, DateOpts, fmt, .help="format string for time" ),
    {JSI_OPTION_END}
};

static const char *timeFmts[] = {
    "%c",
    "%Y-%m-%d %H:%M:%S.",
    "%Y-%m-%dT%H:%M:%S.",
    "%Y-%m-%d %H:%M:%S %Z",
    "%Y-%m-%d %H:%M:%S",
    "%Y-%m-%d %H:%M",
    "%Y-%m-%d",
    "%Y-%m-%dT%H:%M:%S %Z",
    "%Y-%m-%dT%H:%M:%S",
    "%Y-%m-%dT%H:%M",
    "%Y-%m-%d",
    "%H:%M:%S.",
    "%H:%M:%S",
    "%H:%M",
    "%z",
    NULL
};

int Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr)
{
    const char *rv = NULL;
    Jsi_Wide n = -1;
    int j = 0, rc = JSI_OK;
    Jsi_Number ms = 0;
    struct tm tm = {};
    time_t t;
    if (!Jsi_Strcmp("now", str)) {
        struct timeval tv;
        struct timezone tz;
        gettimeofday(&tv, &tz);
        n = tv.tv_sec*1000LL + ((Jsi_Wide)tv.tv_usec)/1000LL;
        if (isUtc) {
            n += 60 * tz.tz_minuteswest;
        }
        if (datePtr)
            *datePtr = (Jsi_Number)n;
        return rc;
    }
    if (fmt && fmt[0]) {
        rv = strptime(str, fmt, &tm);
    } else {
        if (fmt) j++;
        while (timeFmts[j]) {
            rv = strptime(str, timeFmts[j], &tm);
            if (rv != NULL)
                break;
            j++;
        }
    }
    if (!rv)
        rc = JSI_ERROR;
    else {
        if (j <= 1 && rv != str && *(rv-1) == '.') {
            ms = atof(rv-1);
        }
        if (isUtc) {
#ifdef __WIN32
            t = _mkgmtime(&tm);
#else
            t = timegm(&tm);
#endif
        } else {
            t = mktime(&tm);
            //TODO: dst
            /*if (tm.tm_isdst)
                t -= 3600;*/
        }
        n = (Jsi_Number)t*1000 + ms;
    }
    if (rc == JSI_OK && datePtr)
        *datePtr = (Jsi_Number)n;
    return rc;
}

int Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number num, const char *fmt, int isUtc, Jsi_DString *dStr)
{
    char buf[1000];
    time_t tt;
    int rc = JSI_OK;
    Jsi_DString eStr;
    Jsi_DSInit(&eStr);
    
    tt = (time_t)(num/1000);
    if (fmt==NULL)
        fmt = timeFmts[0];
    else if (*fmt == 0) {
        if (!isUtc)
            fmt = timeFmts[1];
        else
            fmt = timeFmts[2];
    }
    int flen = Jsi_Strlen(fmt);
    if (flen>4 && Jsi_Strcmp(fmt+flen-2, "%f")==0) {
        Jsi_DSAppendLen(&eStr, fmt, flen-2);
        Jsi_DSAppendLen(&eStr, "%S.", -1);
        fmt = Jsi_DSValue(&eStr);
    }
#ifdef __WIN32
    struct tm *tm;
    if (isUtc)
        tm = gmtime(&tt);
    else
        tm = localtime(&tt);
    int rr = strftime(buf, sizeof(buf), fmt, tm);
#else
    struct tm tm;
    if (isUtc)
        gmtime_r(&tt, &tm);
    else
        localtime_r(&tt, &tm);
    int rr = strftime(buf, sizeof(buf), fmt, &tm);
#endif
       
    if (rr<=0) {
        Jsi_LogError("time format error");
        rc = JSI_ERROR;
    } else {
        Jsi_DSAppendLen(dStr, buf, -1);
        if (buf[rr-1] == '.') {
            snprintf(buf, sizeof(buf), "%3.3d", (int)(((Jsi_Wide)num)%1000));
            Jsi_DSAppendLen(dStr, buf[1]=='.'?buf+2:buf, -1);
        }
    }
    Jsi_DSFree(&eStr);
    return rc;
}

static int DateStrptimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number w = 0;
    int isOpt = 0, rc = JSI_OK;
    DateOpts opts = {};
    const char *fmt = NULL;
    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {
        if (Jsi_OptionsProcess(interp, DateOptions, opt, &opts, 0) < 0) {
            return JSI_ERROR;
        }
        isOpt = 1;
        fmt = opts.fmt;
    }
    rc = Jsi_DatetimeParse(interp, str, fmt, opts.utc, &w);
    if (rc != JSI_OK) {
        Jsi_ValueDup2(interp, ret, interp->NaNValue);
        rc = JSI_ERROR;
    } else
        Jsi_ValueMakeNumber(interp, ret, w);
    if (isOpt)
        Jsi_OptionsFree(interp, DateOptions, &opts, 0);
    return rc;
}

#define FN_strftime JSI_INFO("\
Giving null as the value will use current time.")
static int DateStrftimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value* opt = Jsi_ValueArrayIndex(interp, args, 1);
    const char *fmt = NULL, *cp = NULL;
    DateOpts opts = {};
    Jsi_Number num;
    int isOpt = 0, rc = JSI_OK;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    
    if (val==NULL || Jsi_ValueIsNull(interp, val))
        num = 1000.0 * (Jsi_Number)time(NULL);
    else if ((cp=Jsi_ValueString(interp, val, NULL))) {
        /* Handle below */
    } else if (Jsi_GetDoubleFromValue(interp, val, &num) != JSI_OK)
        return JSI_ERROR;
        
    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {
        if (Jsi_OptionsProcess(interp, DateOptions, opt, &opts, 0) < 0) {
            return JSI_ERROR;
        }
        isOpt = 1;
        fmt = opts.fmt;
    }
    const char *errMsg = "time format error";
    if (cp) {
        if (isdigit(*cp))
            rc = Jsi_GetDouble(interp, cp, &num);
        else {
            if (Jsi_Strcmp(cp,"now")==0) {
                num = Jsi_DateTime();
            } else {
                rc = JSI_ERROR;
                errMsg = "allowable strings are 'now' or digits";
            }
        }
    }
    if (rc == JSI_OK)
        rc = Jsi_DatetimeFormat(interp, num, fmt, opts.utc, &dStr);
    if (rc != JSI_OK) {
        Jsi_LogError("%s", errMsg);
    } else {
        Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
    }
    if (isOpt)
        Jsi_OptionsFree(interp, DateOptions, &opts, 0);
    Jsi_DSFree(&dStr);
    return rc;
}

#define FN_infovars JSI_INFO("\
Returns all values, data or function.")
static int InfoVarsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *key;
    int n, curlen = 0, isreg = 0, isobj = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Value *v;
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    const char *name = NULL;

    if (arg) {
        if (arg->vt == JSI_VT_STRING)
            name = arg->d.s.str;
        else if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;
                case JSI_OT_REGEXP: isreg = 1; break;
                case JSI_OT_FUNCTION:
                case JSI_OT_OBJECT: isobj = 1; break;
                default: return JSI_OK;
            }
        } else
            return JSI_OK;
    }
    if (!name)
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    if (isobj) {
        Jsi_TreeEntry* tPtr;
        Jsi_TreeSearch search;
        for (tPtr = Jsi_TreeEntryFirst(arg->d.obj->tree, &search, 0);
            tPtr; tPtr = Jsi_TreeEntryNext(&search)) {
            v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
            if (v==NULL || Jsi_ValueIsFunction(interp, v)) continue;
    
            n = curlen++;
            key = (char*)Jsi_TreeKeyGet(tPtr);
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);
        }
        Jsi_TreeSearchDone(&search);
        return JSI_OK;
    }
    for (hPtr = Jsi_HashEntryFirst(interp->varTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        if (Jsi_HashValueGet(hPtr))
            continue;
        key = (char*)Jsi_HashKeyGet(hPtr);
        if (name) {
            if (Jsi_Strcmp(name,key))
                continue;
            Jsi_ValueMakeObject(interp, ret, nobj);
            v = Jsi_VarLookup(interp, key);
            Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp,Jsi_ValueTypeStr(interp, v)),0);
            Jsi_ValueMakeObject(interp, ret, nobj);
            return JSI_OK;
        }
        if (isreg) {
            int ismat;
            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
            if (!ismat)
                continue;
        }
        n = curlen++;
        Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);
    }
    return JSI_OK;
}

static Jsi_Value *jsiNewConcatValue(Jsi_Interp *interp, const char *c1, const char *c2)
{
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppend(&dStr, c1, c2, NULL);
    Jsi_Value *val = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    return val;
}

static int InfoFuncDataSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int flags, Jsi_Obj *nobj)
{
    const char *key, *name = NULL, *ename;
    int n, curlen = 0, isreg = 0, isobj = 0, isglob = 0, nLen = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_FuncObj *fo;
    Jsi_Func *func;
    Jsi_Obj *fobj;
    Jsi_Value *val, *nval;
    int isfunc = (flags&1);
    int isdata = (flags&2);
    int addPre = (flags&4);
    Jsi_DString dPre = {};
    
    if (!nobj) {
        nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    }
    
    if (!arg)
        name = "*";
    else {
        if (arg->vt == JSI_VT_STRING)
            name = Jsi_ValueString(interp, arg, &nLen);
        else if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_STRING: name = Jsi_ValueString(interp, arg, &nLen); break;
                case JSI_OT_REGEXP: isreg = 1; break;
                case JSI_OT_OBJECT: isobj = 1; break;
                case JSI_OT_FUNCTION:
                    fo = arg->d.obj->d.fobj;
                    if (fo->func->type&FC_BUILDIN)
                        return JSI_OK;
                    goto dumpfunc;
                break;
                default: return JSI_OK;
            }
        } else
            return JSI_OK;
    }
    ename = name;
    if (isobj) {
        Jsi_TreeEntry* tPtr;
        Jsi_TreeSearch search;

dumpobj:
        for (tPtr = Jsi_TreeEntryFirst(arg->d.obj->tree, &search, 0);
            tPtr; tPtr = Jsi_TreeEntryNext(&search)) {
            Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
            key = (char*)Jsi_TreeKeyGet(tPtr);
            if (v==NULL) continue;
            if (Jsi_ValueIsFunction(interp, v)) {
                if (!isfunc) continue;
            } else {
                if (!isdata) continue;
            }
            if (isreg) {
                int ismat;
                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
                if (!ismat)
                    continue;
            } else if (ename) {
                if (isglob) {
                    if (!Jsi_GlobMatch(ename, key, 0))
                        continue;
                } else {
                    if (Jsi_Strcmp(ename, key))
                        continue;
                }
            }
    
            n = curlen++;
            nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):""), key);
            Jsi_ObjArraySet(interp, nobj, nval, n);
        }
        Jsi_TreeSearchDone(&search);
        Jsi_DSFree(&dPre);
        return JSI_OK;
    }
    
    Jsi_ScopeStrs *sstrs;            
    const char *gs, *gb, *dotStr;
    
    if (name) {
        val = Jsi_NameLookup(interp, name);
        if (val)
            goto dumpvar;
        gs=strchr(name,'*');
        gb=strchr(name,'[');
        dotStr = strrchr(name, '.');
        if (dotStr && ((gs && gs < dotStr) || (gb && gb < dotStr))) {
            Jsi_LogError("glob must be after last dot");
            return JSI_ERROR;
        }
        isglob = (gs || gb);
        if (!isglob)
            return JSI_OK;
        if (dotStr) {
            if (addPre)
                Jsi_DSAppendLen(&dPre, name, dotStr-ename+1);
            ename = dotStr+1;
            Jsi_DString pStr = {};
            Jsi_DSAppendLen(&pStr, name, dotStr-name);
            val = Jsi_NameLookup(interp, Jsi_DSValue(&pStr));
            Jsi_DSFree(&pStr);
            if (!val)
                return JSI_OK;
            if (Jsi_ValueIsObjType(interp, val, JSI_OT_OBJECT)) {
                arg = val;
                goto dumpobj;
            }
            return JSI_OK;
        } 
    }
        
    for (hPtr = Jsi_HashEntryFirst(interp->varTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        key = (char*)Jsi_HashKeyGet(hPtr);
        if (!isfunc)
            goto doreg;
        if (!(fobj = (Jsi_Obj*)Jsi_HashValueGet(hPtr)))
            continue;
        if (isfunc && name && isreg==0 && isglob==0) {

            if (Jsi_Strcmp(key, name))
                continue;
            /* Fill object with args and locals of func. */
            fo = fobj->d.fobj; 
            goto dumpfunc;
        }
doreg:
        if (isreg) {
            int ismat;
            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
            if (!ismat)
                continue;
        } else if (name) {
            if (isglob) {
                if (!Jsi_GlobMatch(name, key, 0))
                    continue;
            } else {
                if (Jsi_Strcmp(name, key))
                    continue;
            }
        }
        n = curlen++;
        nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):""), key);
        Jsi_ObjArraySet(interp, nobj, nval, n);
    }
    Jsi_DSFree(&dPre);
    return JSI_OK;

dumpfunc:
{
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    func = fo->func;
    sstrs = func->argnames;
    char *strs[sstrs->count+1];
    int i;
    for (i=0; i<sstrs->count; i++)
        strs[i] = sstrs->args[i].name;
    Jsi_Value *aval = Jsi_ValueNewArray(interp, strs, sstrs->count);
    Jsi_ObjInsert(interp, nobj, "args", aval, 0);
    sstrs = func->localnames;
    Jsi_Value *lval = Jsi_ValueNewArray(interp, strs, sstrs->count);
    Jsi_ObjInsert(interp, nobj, "locals", lval, 0);
    if (func->script) {
        lval = Jsi_ValueNewStringKey(interp, func->script);
        Jsi_ObjInsert(interp, nobj, "script", lval, 0);
        lval = Jsi_ValueNewNumber(interp, (Jsi_Number)func->opcodes->codes->line);
        Jsi_ObjInsert(interp, nobj, "lineStart", lval, 0);
        lval = Jsi_ValueNewNumber(interp, (Jsi_Number)func->bodyline.last_line);
        Jsi_ObjInsert(interp, nobj, "lineEnd", lval, 0);
    }
    return JSI_OK;
}
dumpvar:
    if (isfunc && Jsi_ValueIsFunction(interp, val)) {
        fo = val->d.obj->d.fobj;
        goto dumpfunc;
    }
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    Jsi_Value *aval = Jsi_ValueNewStringDup(interp, ename);
    Jsi_ObjInsert(interp, nobj, "name", aval, 0);
    aval = Jsi_ValueNewStringDup(interp, jsi_ValueTypeName(interp, val));
    Jsi_ObjInsert(interp, nobj, "type", aval, 0);
    return JSI_OK;
}

static int InfoLookupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    if (!str)
        return JSI_OK;
    Jsi_Value *val = Jsi_NameLookup(interp, str);
    if (!val)
        return JSI_OK;
    Jsi_ValueDup2(interp, ret, val);
    return JSI_OK;
}

static int InfoFuncsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);
}

#define FN_infodata JSI_INFO("\
Like info.vars(), but does not return function values.")
static int InfoDataCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 2, NULL);
}

static int InfoKeywordsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->lexkeyTbl) {
        Jsi_HashKeysDump(interp, interp->lexkeyTbl, ret, 0);
        Jsi_ValueArraySort(interp, *ret, 0);
    }
    return JSI_OK;
}


static int InfoOptionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    uint i, argc =  Jsi_ValueGetLength(interp, args);
    Jsi_DString dStr = {};
    const char *str;
    Jsi_DSAppend(&dStr, "[", NULL);
    for (i=1; (str = Jsi_OptionTypeStr((Jsi_OptionTypes)i, argc));i++)
        Jsi_DSAppend(&dStr, (i>1?", ":""), "\"", str, "\"", NULL);
    Jsi_DSAppend(&dStr, "]", NULL);
    Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    return JSI_OK;
}
static int InfoVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (!arg)
        Jsi_ValueMakeNumber(interp, ret, Jsi_Version());
    else if (!Jsi_ValueIsTrue(interp, arg))
        return JSI_ERROR;
    else {
        char buf[BUFSIZ];
        snprintf(buf, sizeof(buf),
            "{major:%d, minor:%d, release:%d}",
            JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);
        
        return Jsi_JSONParse(interp, buf, ret, 0);
    }
    return JSI_OK;
}


static int InfoIsMainCmd (Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int isi = (interp->isMain);
    if (isi == 0) {
        const char *c2 = interp->curFile;
        Jsi_Value *v1 = interp->argv0;
        if (c2 && v1 && Jsi_ValueIsString(interp, v1)) {
            char *c1 = Jsi_ValueString(interp, v1, NULL);
            isi = (c1 && !strcmp(c1,c2));
        }
    }
    Jsi_ValueMakeBool(interp, ret, isi);
    return JSI_OK;
}

static int InfoArgv0Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->argv0)
        Jsi_ValueDup2(interp, ret, interp->argv0);
     return JSI_OK;
}

static int InfoExecZipCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (interp->execZip)
        Jsi_ValueDup2(interp, ret, interp->execZip);
     return JSI_OK;
}

static int InfoScriptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    int isreg = 0;
    const char *name = NULL;

    if (!arg) {
        name = interp->curFile;
    } else {
        if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_FUNCTION: name = arg->d.obj->d.fobj->func->script; break;
                case JSI_OT_REGEXP: isreg = 1; break;
            }
        } else
            return JSI_OK;
    }
    if (isreg) {
        Jsi_HashEntry *hPtr;
        Jsi_HashSearch search;
        int curlen = 0, n;
        const char *key;
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
        for (hPtr = Jsi_HashEntryFirst(interp->fileTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
            key = (const char*)Jsi_HashKeyGet(hPtr);
            if (isreg) {
                int ismat;
                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);
                if (!ismat)
                    continue;
            }
            n = curlen++;
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);
        }
        return JSI_OK;
    }
    if (name)
        Jsi_ValueMakeStringDup(interp, ret, name);
    return JSI_OK;
}

static int InfoScriptDirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = interp->curDir;
    if (path)
        Jsi_ValueMakeString(interp, ret, Jsi_Strdup(path));
    return JSI_OK;
}

static int isBigEndian()
{
    union { unsigned short s; unsigned char c[2]; } uval = {0x0102};
    return uval.c[0] == 1;
}

static int InfoPlatformCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char buf[BUFSIZ];
#ifdef __WIN32
    const char *os="win", *platform = "win";
#else
    const char *os="linux", *platform = "unix";
#endif
#ifndef JSI_OMIT_THREADS
    int thrd = 1;
#else
    int thrd = 0;
#endif
    if (Jsi_FunctionReturnIgnored(interp, funcPtr))
        return JSI_OK;
    snprintf(buf, sizeof(buf),
        "{os:\"%s\", platform:\"%s\", hasThreads:%s, pointerSize:%d, "
        "intSize:%d, wideSize:%d, byteOrder:\"%sEndian\"}",
        os, platform, thrd?"true":"false", sizeof(void*), sizeof(int),
        sizeof(Jsi_Wide), isBigEndian()? "big" : "little");
        
    return Jsi_JSONParse(interp, buf, ret, 0);
}

static int InfoNamedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *nobj;
    char *argStr = NULL;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg && (argStr = (char*)Jsi_ValueString(interp, arg, NULL)) == NULL) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    return jsi_UserObjDump(interp, argStr, nobj);
}

/* 
    { "size",    cDataSize,     1,  1, "name", .help="" },
    { "names",   cDataNames,    0,  0, "Return name of all defined Cdata", .help="" },
    { "info",    cDataInfo,     1,  1, "name", .help="" },
    { "get",     cDataGet,      2,  3, "name,index?,field?", .help="" },
    { "set",     cDataSet,      3,  3, "name,index,fieldvals", .help="" },
*/

static int cDataNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return Jsi_HashKeysDump(interp, interp->optionDataHash, ret, 0);
}

enum {
    _JSI_CDATA_INFO=0,
    _JSI_CDATA_GET=1,
    _JSI_CDATA_SET=2,
    _JSI_CDATA_SIZE=3,
    _JSI_CDATA_SCHEMA=4,
    _JSI_CDATA_SCHEMAMD5=5,
    _JSI_CDATA_STRUCT=6
};

static int cdatasubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int sub)
{
    char *argStr = NULL;
    int i, aidx = 0, slen;
    Jsi_Number dnum;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg == NULL || (argStr = (char*)Jsi_ValueString(interp, arg, &slen)) == NULL) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    Jsi_DbMultipleBind* opts = (Jsi_DbMultipleBind*)Jsi_HashGet(interp->optionDataHash, argStr);
    if (!opts) {
        Jsi_LogError("unknown option-data: %s", argStr);
        return JSI_ERROR;
    }
    if (sub == _JSI_CDATA_INFO) { // Dump
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, opts->opts);
        Jsi_ValueDup2(interp, ret, svalue);
        return JSI_OK;
    }
    if (sub == _JSI_CDATA_SCHEMA || sub == _JSI_CDATA_SCHEMAMD5) {  // Generate a DB schema.
        char tbuf[100];
        Jsi_DString dStr, mStr;
        Jsi_DSInit(&dStr);
        Jsi_DSInit(&mStr);
        i = 0;
        const Jsi_OptionSpec *specs, *send = NULL;
        for (specs=opts->opts; specs->type>JSI_OPTION_NONE && specs->type<=JSI_OPTION_END; specs++) {
            const char *tstr = NULL;
            if (specs->flags&JSI_OPT_DB_DIRTY)
                continue;
            if (!Jsi_Strcmp(specs->name, "rowid"))
                continue;
            switch(specs->type) {
            case JSI_OPTION_BOOL: tstr = "BOOLEAN"; break;
            case JSI_OPTION_TIMESTAMP: tstr = "TIMESTAMP"; break;
            case JSI_OPTION_DATE: tstr = "DATE"; break;
            case JSI_OPTION_TIME: tstr = "TIME"; break;
            case JSI_OPTION_DATETIME: tstr = "DATETIME"; break;
            case JSI_OPTION_BYTE:
            case JSI_OPTION_WORD:
            case JSI_OPTION_DWORD:
            case JSI_OPTION_INT:
            case JSI_OPTION_QWORD:
            case JSI_OPTION_WIDE: tstr = "INT"; break;
            case JSI_OPTION_DOUBLE: tstr = "FLOAT"; break;
            
            case JSI_OPTION_STRBUF:
                tstr = tbuf;
                snprintf(tbuf, sizeof(tbuf), "VARCHAR(%d)", specs->size);;
                break;
            case JSI_OPTION_DSTRING: 
            case JSI_OPTION_STRKEY:
            case JSI_OPTION_STRING:
                tstr = "TEXT";
                break;
            case JSI_OPTION_CUSTOM:
                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {
                    if (specs->flags&JSI_OPT_FORCE_INT)
                        tstr = "INT";
                    else
                        tstr = "TEXT";
                } else
                    tstr = "";
                break;
            case JSI_OPTION_VALUE: /* Unsupported. */
            case JSI_OPTION_VAR:
            case JSI_OPTION_OBJ:
            case JSI_OPTION_ARRAY:
            case JSI_OPTION_FUNC:
            case JSI_OPTION_NONE:
                break;
            case JSI_OPTION_END:
                send = specs;
                break;
            }
            
            if (!tstr) continue;
            Jsi_DSAppend(&dStr, (i?"\n ,":"  "), (specs->extName?specs->extName:specs->name), NULL);
            Jsi_DSAppend(&mStr, (i?"\n ,":"  "), (specs->extName?specs->extName:specs->name), NULL);
            if (tstr[0]) {
                Jsi_DSAppend(&dStr, " ", tstr, NULL);
                Jsi_DSAppend(&mStr, " ", tstr, NULL);
            }
            if (specs->userData) {
                const char *udrest = NULL;
                if (specs->type == JSI_OPTION_TIMESTAMP && !Jsi_Strcmp(specs->userData, "DEFAULT"))
                    udrest = "(round((julianday('now') - 2440587.5)*86400.0))";
                else if (specs->type == JSI_OPTION_DATETIME && !Jsi_Strcmp(specs->userData, "DEFAULT"))
                    udrest = "(round((julianday('now','start of day') - 2440587.5)*86400000))";
                else if (specs->type == JSI_OPTION_DATE && !Jsi_Strcmp(specs->userData, "DEFAULT"))
                    udrest = "(round((julianday('now') - 2440587.5)*86400000))";
                else if (specs->type == JSI_OPTION_TIME && !Jsi_Strcmp(specs->userData, "DEFAULT"))
                    udrest = "(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400000))";
                Jsi_DSAppend(&dStr, " ", specs->userData, udrest, NULL);
                Jsi_DSAppend(&mStr, " ", specs->userData, udrest, NULL);
            }
            if (specs->help && sub != _JSI_CDATA_SCHEMAMD5)
                Jsi_DSAppend(&dStr, " -- ", specs->help, NULL);
            if (specs->type==JSI_OPTION_END)
                break;
            i++;
        }
        if (send->userData) {
            Jsi_DSAppend(&dStr,  send->userData, NULL);
            Jsi_DSAppend(&mStr,  send->userData, NULL);
        }
        char buf[33];
        Jsi_Md5Str(interp, buf, Jsi_DSValue(&mStr), -1);
        if (sub == _JSI_CDATA_SCHEMAMD5)
            Jsi_ValueMakeStringDup(interp, ret, buf);
        else {
            Jsi_DString eStr;
            Jsi_DSInit(&eStr);
            Jsi_DSAppend(&eStr, "\n-- '", send->name, "\': ", NULL);
            if (send->help)
                Jsi_DSAppend(&eStr,  send->help, NULL);
            Jsi_DSAppend(&eStr, "\n", Jsi_DSValue(&dStr), "\n-- MD5: ", buf, NULL);
            Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&eStr));
            Jsi_DSFree(&eStr);
        }
        Jsi_DSFree(&dStr);
        Jsi_DSFree(&mStr);
        return JSI_OK;
    }
    if (sub == _JSI_CDATA_STRUCT) {  // Generate the C struct
        Jsi_DString dStr;
        Jsi_DSInit(&dStr);
        i = 0;
        const Jsi_OptionSpec *specs, *send = NULL;
        for (specs=opts->opts; specs->type>JSI_OPTION_NONE && specs->type<=JSI_OPTION_END; specs++) {
            int nsz = 0;
            const char *tstr = NULL;
            switch(specs->type) {
            case JSI_OPTION_BOOL: tstr = "int"; break;
            case JSI_OPTION_TIMESTAMP: tstr = "time_t"; break;
            case JSI_OPTION_DATE:
            case JSI_OPTION_TIME:
            case JSI_OPTION_DATETIME: tstr = "Jsi_Number"; break;
            case JSI_OPTION_INT:
            case JSI_OPTION_BYTE:
            case JSI_OPTION_WORD:
            case JSI_OPTION_DWORD:
            case JSI_OPTION_QWORD:
            case JSI_OPTION_WIDE: tstr = "int"; break;
            case JSI_OPTION_DOUBLE: tstr = "Jsi_Number"; break;
            case JSI_OPTION_DSTRING: tstr = "Jsi_DString"; break;
            case JSI_OPTION_STRBUF:tstr = "char"; nsz=1; break;
            case JSI_OPTION_STRKEY:tstr = "char*"; break;
            case JSI_OPTION_STRING:tstr = "int"; break;
            case JSI_OPTION_CUSTOM:
                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {
                    tstr = "int";
                } else {
                    tstr = "char";
                    nsz = 1;
                }
                break;
            case JSI_OPTION_VALUE: /* Unsupported. */
            case JSI_OPTION_VAR:
            case JSI_OPTION_OBJ:
            case JSI_OPTION_ARRAY:
            case JSI_OPTION_FUNC:
            case JSI_OPTION_NONE:
                break;
            case JSI_OPTION_END:
                send = specs;
                break;
            }
            
            if (!tstr) continue;
            Jsi_DSAppend(&dStr, "\n    ", tstr, " ", specs->name, NULL);
            if (nsz) {
                Jsi_DSPrintf(&dStr, "[%d]", specs->size);
            }
            Jsi_DSAppend(&dStr, ";", NULL);
            if (specs->help)
                Jsi_DSAppend(&dStr, " /* ", specs->help, " */", NULL);
            if (specs->type==JSI_OPTION_END)
                break;
            i++;
        }
        Jsi_DString eStr;
        Jsi_DSInit(&eStr);
        Jsi_DSAppend(&eStr, "\n/* ", send->name, ": ", NULL);
        if (send->help)
            Jsi_DSAppend(&eStr,  send->help, NULL);
        Jsi_DSAppend(&eStr, " */\ntypedef struct ",  send->name, " {", Jsi_DSValue(&dStr), "\n};\n", NULL);
        Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&eStr));
        Jsi_DSFree(&eStr);
        
        Jsi_DSFree(&dStr);
        return JSI_OK;
    }
    
    int flags = opts->flags;
    void *rec = opts->data, *prec = rec;
    void **recPtrPtr = NULL;
    if (flags&JSI_DB_PTR_PTRS) {
        recPtrPtr = (void**)rec; /* This is really a void***, but gets recast below. */
        rec = *recPtrPtr;
    }
    int cnt = opts->numData;
    if (cnt<=0 && rec && flags&JSI_DB_PTR_PTRS) {
        for (cnt=0; ((void**)rec)[cnt]!=NULL; cnt++);
    } else if (cnt==0)
        cnt = 1;
    
    if (sub == _JSI_CDATA_SIZE) {
        Jsi_ValueMakeNumber(interp, ret, cnt);
        return JSI_OK;
    }

    Jsi_Value *argIdx = Jsi_ValueArrayIndex(interp, args, 1);
    if (Jsi_ValueGetNumber(interp, argIdx, &dnum) != JSI_OK)
        return JSI_ERROR;
    aidx = (int)dnum;
        
    if (aidx<0 || aidx>=cnt) {
        Jsi_LogError("index %d out of range: 0-%d", aidx, cnt);
        return JSI_ERROR;
    }
    Jsi_Value *arg2 = (argc>2 ? Jsi_ValueArrayIndex(interp, args, 2) : NULL);

    if (sub == _JSI_CDATA_GET && arg2 && (argStr = (char*)Jsi_ValueString(interp, arg2, &slen)) == NULL) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    if (flags & (JSI_DB_PTRS|JSI_DB_PTR_PTRS))
        prec = ((void**)rec)[aidx];
    else {
        for (i=0; opts->opts[i].type < JSI_OPTION_END; i++);
        int structSize = opts->opts[i].size;
        prec = (char*)rec + (aidx * structSize);
    }
    if (!prec)
        return JSI_OK;
    return Jsi_OptionsConf(interp, opts->opts, arg2, prec, ret, 0);
}

static int cDataInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_INFO);
}

static int cDataGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_GET);
}

static int cDataSetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_SET);
}

static int cDataSizeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_SIZE);
}

static int cDataSchemaCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_SCHEMA);
}

static int cDataSchemaMd5Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_SCHEMAMD5);
}

static int cDataStructCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) {
    return cdatasubCmd(interp, args, _this, ret, funcPtr, _JSI_CDATA_STRUCT);
}

static int InfoExecutableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (jsi_execName == NULL)
        Jsi_ValueMakeNull(interp, ret);
    else
        Jsi_ValueMakeStringKey(interp, ret, jsi_execName);
    return JSI_OK;
}

#define FN_infoevent JSI_INFO("\
With no args, returns list of all outstanding events.  With one arg, returns info\
for the given event id.")

static int InfoEventCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n = 0, nid;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Obj *nobj;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    if (arg && Jsi_GetIntFromValue(interp, arg, &nid) != JSI_OK)
        return JSI_ERROR;
    if (!arg) {
        nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    }

    for (hPtr = Jsi_HashEntryFirst(interp->eventTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        int id;
        id = (int)Jsi_HashKeyGet(hPtr);
        if (!arg) {
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewNumber(interp, (Jsi_Number)id), n);
            n++;
        } else if (id == nid) {
            Jsi_Event *ev = (Jsi_Event *)Jsi_HashValueGet(hPtr);
            Jsi_DString dStr;
            int rc;
            
            Jsi_DSInit(&dStr);
            switch (ev->evType) {
                case JSI_EVENT_SIGNAL:
                    Jsi_DSPrintf(&dStr, "{ type:\"signal\", sigNum:%d, count:%u, builtin:%s }", 
                        ev->sigNum, ev->count, (ev->handler?"true":"false") );
                    break;
                case JSI_EVENT_TIMER: {
             
                    long cur_sec, cur_ms;
                    long long ms;
                    jsiGetTime(&cur_sec, &cur_ms);
                    ms = (ev->when_sec*1000LL + ev->when_ms) - (cur_sec * 1000LL + cur_ms);
                    Jsi_DSPrintf(&dStr, "{ type:\"timer\", once:%s, when:%lld, count:%u, initial:%ld, builtin:%s }",
                        ev->once?"true":"false", ms, ev->count, ev->initialms, (ev->handler?"true":"false") );
                    break;
                }
                case JSI_EVENT_ALWAYS:
                    Jsi_DSPrintf(&dStr, "{ type:\"always\", count:%u, builtin:%s }", 
                        ev->count, (ev->handler?"true":"false") );
                    break;
            }
            rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
            Jsi_DSFree(&dStr);
            return rc;
        }
    }
    return JSI_OK;
}

static int eventInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return InfoEventCmd(interp, args, _this, ret, funcPtr);
}

static int InfoErrorCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    Jsi_ValueInsert( interp, *ret, "file", Jsi_ValueNewStringKey(interp, interp->errFile?interp->errFile:""), 0);
    Jsi_ValueInsert(interp, *ret, "line", Jsi_ValueNewNumber(interp, interp->errLine), 0);
    return JSI_OK;
}

void jsi_DumpCmdSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpec* spec, const char *name)
{
    Jsi_ObjInsert(interp, nobj, "minArgs", Jsi_ValueNewNumber(interp, spec->minArgs),0);
    Jsi_ObjInsert(interp, nobj, "maxArgs", Jsi_ValueNewNumber(interp, spec->maxArgs),0);
    if (spec->help)
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringKey(interp, spec->help),0);
    if (spec->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringKey(interp, spec->info),0);
    Jsi_ObjInsert(interp, nobj, "args", Jsi_ValueNewStringKey(interp, spec->argStr?spec->argStr:""),0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_ObjInsert(interp, nobj, "retType", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, spec->retType, &dStr)), 0);
    Jsi_DSFree(&dStr);
    Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, name?name:spec->name),0);
    Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp, "command"),0);
    if (spec->opts) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, spec->opts);
        Jsi_ObjInsert(interp, nobj, "options", svalue, 0);
    }
}
void jsi_DumpCmdItem(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpecItem* csi, const char *name)
{
    Jsi_ObjInsert(interp, nobj, "name", Jsi_ValueNewStringKey(interp, name), 0);
    Jsi_ObjInsert(interp, nobj, "type", Jsi_ValueNewStringKey(interp, "object"),0);
    Jsi_ObjInsert(interp, nobj, "constructor", Jsi_ValueNewBoolean(interp, csi && csi->isCons), 0);
    if (csi && csi->help)
        Jsi_ObjInsert(interp, nobj, "help", Jsi_ValueNewStringDup(interp, csi->help),0);
    if (csi && csi->info)
        Jsi_ObjInsert(interp, nobj, "info", Jsi_ValueNewStringDup(interp, csi->info),0);
    if (csi && csi->isCons && csi->spec->argStr)
        Jsi_ObjInsert(interp, nobj, "args", Jsi_ValueNewStringDup(interp, csi->spec->argStr),0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_ObjInsert(interp, nobj, "retType", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, csi->spec->retType, &dStr)), 0);
    Jsi_DSFree(&dStr);
    if (csi && csi->isCons && csi->spec->opts) {
        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);
        jsi_DumpOptionSpecs(interp, sobj, csi->spec->opts);
        Jsi_ObjInsert(interp, nobj, "options", svalue, 0);
    }
}

static int InfoCmdsCmdSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int all, int sort, Jsi_Obj *nobj)
{
    const char *key, *name = NULL, *cp;
    int curlen = 0, icnt = 0, isglob = 0, dots = 0, gotFirst = 0, ninc;
    Jsi_HashEntry *hPtr = NULL;
    Jsi_HashSearch search;
    Jsi_CmdSpecItem *csi;
    Jsi_DString dStr;
    const char *skey;
    Jsi_CmdSpec *spec;
    
    Jsi_DSInit(&dStr);
    int isreg = 0;

    if (!arg)
        name = "*";
    else {
        if (arg->vt == JSI_VT_STRING)
            name = arg->d.s.str;
        else if (arg->vt == JSI_VT_OBJECT) {
            switch (arg->d.obj->ot) {
                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;
                case JSI_OT_REGEXP: isreg = 1; break;
                case JSI_OT_FUNCTION:
                    spec = arg->d.obj->d.fobj->func->cmdSpec;
                    if (!spec)
                        return JSI_OK;
                    skey = spec->name;
                    goto dumpfunc;
                    break;
                default: return JSI_OK;
            }
        } else
            return JSI_OK;
    }
    ninc = 0;
    isglob = (isreg == 0 && name && (Jsi_Strchr(name,'*') || Jsi_Strchr(name,'[')));
    if (isglob) {
        cp = name;
        while (*cp) { if (*cp == '.') dots++; cp++; }
    }
    while (1) {
        if (++icnt == 1) {
           /* if (0 && name)
                hPtr = Jsi_HashEntryFind(interp->cmdSpecTbl, "");
            else */ {
                hPtr = Jsi_HashEntryFirst(interp->cmdSpecTbl, &search);
                gotFirst = 1;
            }
        } else if (icnt == 2 && name && !gotFirst)
            hPtr = Jsi_HashEntryFirst(interp->cmdSpecTbl, &search);
        else
            hPtr = Jsi_HashEntryNext(&search);
        if (!hPtr)
            break;
        csi = (Jsi_CmdSpecItem*)Jsi_HashValueGet(hPtr);
        key = (const char *)Jsi_HashKeyGet(hPtr);
        if (isglob && dots == 0 && *key && Jsi_GlobMatch(name, key, 0)) {
                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), curlen++);
                ninc++;
        }
        if (isglob == 0 && name && key[0] && Jsi_Strcmp(name, key)==0) {
            skey = (char*)name;
            spec = NULL;
            goto dumpfunc;
        }
        assert(csi);
        do {
            int i;
            for (i=0; csi->spec[i].name; i++) {
                Jsi_DSSetLength(&dStr, 0);
                spec = csi->spec+i;
                if (i==0 && spec->flags&JSI_CMD_IS_CONSTRUCTOR && !all) /* ignore constructor name. */
                    continue;
                if (key[0])
                    Jsi_DSAppend(&dStr, key, ".", NULL);
                Jsi_DSAppend(&dStr, spec->name, NULL);
                skey = Jsi_DSValue(&dStr);
                if (isglob) {
                    if (!(((key[0]==0 && dots == 0) || (key[0] && dots == 1)) &&
                        Jsi_GlobMatch(name, skey, 0)))
                    continue;
                }
                if (name && isglob == 0 && Jsi_Strcmp(name,skey) == 0) {
dumpfunc:
                    nobj = Jsi_ObjNew(interp);
                    Jsi_ValueMakeObject(interp, ret, nobj);
                    if (spec == NULL)
                        jsi_DumpCmdItem(interp, nobj, csi, skey);
                    else
                        jsi_DumpCmdSpec(interp, nobj, spec, skey);
                    Jsi_DSFree(&dStr);
                    return JSI_OK;
                    
                } else if (isglob == 0 && isreg == 0)
                    continue;
                if (isreg) {
                    int ismat;
                    Jsi_RegExpMatch(interp, arg, skey, &ismat, NULL);
                    if (!ismat)
                        continue;
                }
                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, skey), curlen++);
                ninc++;
            }
            csi = csi->next;
        } while (csi);
    }
    Jsi_DSFree(&dStr);
    if (sort && (*ret)->vt != JSI_VT_UNDEF)
        Jsi_ValueArraySort(interp, *ret, JSI_SORT_ASCII);
    return JSI_OK;    
}

static int InfoCmdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Bool b = 0;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vbool = Jsi_ValueArrayIndex(interp, args, 1);
    if (vbool && Jsi_ValueGetBoolean(interp, vbool, &b) != JSI_OK) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);

    return InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, b, 1, nobj);
}

static int InfoCompletionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int slen, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 0);
    char *key, *substr, *str = Jsi_ValueString(interp, arg1, &slen);
    int start = 0, end = slen-1;

    if (argc>1) {
        Jsi_Number n1;
        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n1) != JSI_OK)
            return JSI_ERROR;
        start = (int)n1;
        if (start<0) start = 0;
        if (start>=slen) start=slen-1;
    }
    if (argc>2) {
        Jsi_Number n2;
        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 2), &n2) != JSI_OK)
            return JSI_ERROR;
        end = (int)n2;
        if (end<0) end = slen-1;
        if (end>=slen) end=slen-1;
    }

    Jsi_DString dStr = {};
    Jsi_DSAppendLen(&dStr, str?str+start:"", end-start+1);
    Jsi_DSAppend(&dStr, "*", NULL);
    substr = Jsi_DSValue(&dStr);
    Jsi_Value *arg = Jsi_ValueNewStringDup(interp, substr);
    Jsi_IncrRefCount(interp, arg);
    
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);

    int rc = InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 0, nobj);
    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))
        goto done;
    rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 0x7, nobj);
    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))
        goto done;
    if (str) {
        substr[end-start+1] = 0;
        slen = Jsi_Strlen(substr);
    }
    if (str == NULL || !Jsi_Strchr(substr, '.')) {
        Jsi_HashEntry *hPtr;
        Jsi_HashSearch search;
        int n = Jsi_ValueGetLength(interp, *ret);
        for (hPtr = Jsi_HashEntryFirst(interp->lexkeyTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
            key = (char*)Jsi_HashKeyGet(hPtr);
            if (str == NULL || !Jsi_Strncmp(substr, key, slen))
                Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewStringKey(interp, key), n++);
        }
    }
    Jsi_ValueArraySort(interp, *ret, 0);
done:
    Jsi_DSFree(&dStr);
    Jsi_DecrRefCount(interp, arg);
    return rc;
}

Jsi_Value * Jsi_LookupCS(Jsi_Interp *interp, const char *name, int *ofs)
{
    const char *csdot = strrchr(name, '.');
    int len;
    *ofs = 0;
    if (csdot == name)
        return NULL;
    if (!csdot)
        return interp->csc;
    if (!csdot[1])
        return NULL;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppendLen(&dStr, name, len=csdot-name);
    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    *ofs = len+1;
    return cs;
}

static void ValueObjDeleteStr(Jsi_Interp *interp, Jsi_Value *target, const char *key, int force)
{
    const char *kstr = key;
    if (target->vt != JSI_VT_OBJECT) return;

    Jsi_TreeEntry *hPtr;
    Jsi_HashEntry *hePtr = Jsi_HashEntryFind(target->d.obj->tree->interp->strKeyTbl, key);
    if (hePtr)
        kstr = (const char*)Jsi_HashKeyGet(hePtr);
    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);
    if (hPtr == NULL || ( hPtr->f.bits.dontdel && !force))
        return;
    Jsi_TreeEntryDelete(hPtr);
}

int Jsi_CommandDelete(Jsi_Interp *interp, const char *name) {
    int ofs;
    Jsi_Value *fv = Jsi_NameLookup(interp, name);
    Jsi_Value *cs = Jsi_LookupCS(interp, name, &ofs);
    if (cs) {
        const char *key = name + ofs;
        ValueObjDeleteStr(interp, cs, key, 1);
    }
    if (fv)
        Jsi_DecrRefCount(interp, fv);
    return JSI_OK;
}


Jsi_Value * Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData)
{
    Jsi_Value *n = NULL;
    const char *csdot = strrchr(name, '.');
    if (0 && csdot) {
        Jsi_LogBug("commands with dot unsupported: %s", name);
        return NULL;
    }
    if (csdot == name) {
        name = csdot+1;
        csdot = NULL;
    }
    if (!csdot) {
        n = jsi_MakeFuncValue(interp, cmdProc, name);
        Jsi_IncrRefCount(interp, n);
        Jsi_ObjDecrRefCount(interp, n->d.obj);
        Jsi_Func *f = n->d.obj->d.fobj->func;
        f->privData = privData;
        f->name = Jsi_KeyAdd(interp, name);
        Jsi_ValueInsertFixed(interp, interp->csc, f->name, n);
        return n;
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppendLen(&dStr, name, csdot-name);
    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);
    if (cs) {
    
        n = jsi_MakeFuncValue(interp, cmdProc, csdot+1);
        Jsi_IncrRefCount(interp, n);
        Jsi_ObjDecrRefCount(interp, n->d.obj);
        Jsi_Func *f = n->d.obj->d.fobj->func;
        
        f->name = Jsi_KeyAdd(interp, csdot+1);
        f->privData = privData;
        Jsi_ValueInsertFixed(interp, cs, f->name, n);
        //Jsi_ObjDecrRefCount(interp, n->d.obj);
    }
    return n;
}

static Jsi_Value *CommandCreateWithSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Value *proto, void *privData, const char *parent)
{
    int iscons = (cmdSpec->flags&JSI_CMD_IS_CONSTRUCTOR);
    Jsi_Value *func;
    Jsi_Func *f;
    if (cmdSpec->name)
        Jsi_KeyAdd(interp, cmdSpec->name);
    if (cmdSpec->proc == NULL)
    {
        Jsi_Value *func = jsi_ProtoObjValueNew1(interp, cmdSpec->name);
        Jsi_ValueInsertFixed(interp, NULL, cmdSpec->name, func);
        f = func->d.obj->d.fobj->func;
    } else {
    
        func = jsi_MakeFuncValueSpec(interp, cmdSpec, privData);
    #ifdef JSI_MEM_DEBUG
        func->VD.label = "CMDspec";
        func->VD.label2 = cmdSpec->name;
    #endif
        //Jsi_IncrRefCount(interp, func);
        //Jsi_HashSet(interp->genValueTbl, func, func);
        Jsi_ValueInsertFixed(interp, (iscons?NULL:proto), cmdSpec->name, func);
        f = func->d.obj->d.fobj->func;
    
        if (cmdSpec->name)
            f->name = cmdSpec->name;
        f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);
        f->f.bits.hasattr = 1;
        if (iscons) {
            f->f.bits.iscons = 1;
            Jsi_ValueInsertFixed(interp, func, "prototype", proto);
            Jsi_PrototypeObjSet(interp, "Function", Jsi_ValueGetObj(interp, func));
        }
    }
    if (cmdSpec->argStr && interp->typeCheck >= jsi_TypeChk_Static) { // Sanity check args signature.
        Jsi_DString dStr = {};
        Jsi_DSAppend(&dStr, cmdSpec->argStr, NULL);
        const char *elips = strstr(cmdSpec->argStr, "...");
        if (cmdSpec->maxArgs<0 && !elips)
            Jsi_DSAppend(&dStr, ", ...", NULL);
        int aCnt = 0, i = -1, mis = 0;
        char *cp = Jsi_DSValue(&dStr);
        while (cp[++i]) if (cp[i]==',') aCnt++;
        
        if (cmdSpec->maxArgs>=0) {
            aCnt++;
            if (cmdSpec->minArgs<0 || cmdSpec->minArgs>cmdSpec->maxArgs || 
                cmdSpec->minArgs>aCnt || cmdSpec->maxArgs>aCnt || elips) {
                mis = 1;
            }                    
        } else {
            if (cmdSpec->minArgs<0 || cmdSpec->minArgs>aCnt) {
                mis = 1;
            }                    
        }
        Jsi_DSFree(&dStr);
        if (mis)
            Jsi_LogWarn("inconsistent arg string for \"%s.%s(%s)\" [%d,%d]",
                parent, cmdSpec->name, cmdSpec->argStr, cmdSpec->minArgs, cmdSpec->maxArgs);
        if (f->argnames==NULL && cmdSpec->argStr) {
            // At least give a clue where the problem is.
            const char *ocfile = interp->curFile;
            jsi_Pline *opl = interp->parseLine, pline;
            interp->parseLine = &pline;
            pline.first_line = 1;
            interp->curFile = cmdSpec->name;
            f->argnames = jsi_ParseArgStr(interp, cmdSpec->argStr);
            interp->curFile = ocfile;
            interp->parseLine = opl;
        }
    }

    f->retType = cmdSpec->retType;
    return func;
}


Jsi_Value *Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs,
    void *privData, int flags)
{
    int i = 0;
    Jsi_Value *proto;
    if (!cmdSpecs[0].name)
        return NULL;
    if (!name)
        name = cmdSpecs[0].name;
    name = Jsi_KeyAdd(interp, name);
    if (flags & JSI_CMDSPEC_PROTO) {
        proto = (Jsi_Value*)privData;
        privData = NULL;
        i++;
    } else if (name[0] == 0)
        proto = NULL;
    else {
        if ((flags & JSI_CMDSPEC_NOTOBJ)) {
            proto = Jsi_CommandCreate(interp, name, NULL, privData);
        } else {
            proto = jsi_ProtoValueNew(interp, name, NULL);
        }
    }
    for (; cmdSpecs[i].name; i++) {
        CommandCreateWithSpec(interp,  cmdSpecs+i, proto, privData, name);
        /*Jsi_Value *fc = CommandCreateWithSpec(interp,  cmdSpecs+i, proto, privData);
        if (fc && i>0 && flags & JSI_CMDSPEC_GENVALUE) {
            Jsi_HashSet(interp->genValueTbl, fc, fc);
        }*/
    }

    int isNew;
    Jsi_HashEntry *hPtr;
    hPtr = Jsi_HashEntryNew(interp->cmdSpecTbl, name, &isNew);
    if (!hPtr) {
        Jsi_LogBug("failed cmdspec register: %s", name);
        return NULL;
    }
    Jsi_CmdSpecItem *op, *p = (Jsi_CmdSpecItem*)Jsi_Calloc(1,sizeof(*p));
    SIGINIT(p,CMDSPECITEM);
    p->spec = cmdSpecs;
    p->flags = flags;
    p->proto = proto;
    p->privData = privData;
    p->name = (const char*)Jsi_HashKeyGet(hPtr);
    p->hPtr = hPtr;
    Jsi_CmdSpec *csi = cmdSpecs;
    p->isCons = (csi && csi->flags&JSI_CMD_IS_CONSTRUCTOR);
    while (csi->name)
        csi++;
    p->help = csi->help;
    p->info = csi->info;
    if (!isNew) {
        op = (Jsi_CmdSpecItem*)Jsi_HashValueGet(hPtr);
        p->next = op;
    }
    Jsi_HashValueSet(hPtr, p);
    return proto;
}

void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr)
{
    Jsi_CmdSpecItem *cs = (Jsi_CmdSpecItem*)ptr;
    Jsi_CmdSpec *p;
    SIGASSERT(cs,CMDSPECITEM);
    //return;
    while (cs) {
        p = cs->spec;
        Jsi_Value *proto = cs->proto;
        if (proto)
            Jsi_DecrRefCount(interp, proto);
        while (0 && p && p->name) {
            /*Jsi_Value *proto = p->proto;
            if (proto)
                Jsi_DecrRefCount(interp, proto);*/
            p++;
        }
        ptr = cs;
        cs = cs->next;
        Jsi_Free(ptr);
    }
}

static int SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc=JSI_OK, i, n=1, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Wide diff, start, end;
    if(!Jsi_ValueIsFunction(interp, func)){
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)
        return JSI_ERROR;
    if (n<=0) {
        Jsi_LogError("count not > 0: %d", n);
        return JSI_ERROR;
    }
    struct timeval tv;
    gettimeofday(&tv, NULL);
    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;
    for (i=0; i<n; i++) {
        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);
    }
    gettimeofday(&tv, NULL);
    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;
    diff = (end - start);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);
    return rc;
}

static int SysFormatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    Jsi_DString dStr;
    rc = Jsi_FormatString(interp, args, &dStr);
    if (rc != JSI_OK)
        return rc;
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(Jsi_DSValue(&dStr)));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static int quoteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_DString dStr = {};
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    const char *str = Jsi_ValueGetDString(interp, arg, &dStr, 1);
    Jsi_ValueMakeString(interp, ret, Jsi_Strdup(str));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static const char ev[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static int atend;

static int
getidx(char *buffer, int len, int *posn) {
    char c;
    char *idx;
    if (atend) return -1;
    do {
    if ((*posn)>=len) {
        atend = 1;
        return -1;
    }
    c = buffer[(*posn)++];
    if (c<0 || c=='=') {
        atend = 1;
        return -1;
    }
    idx = Jsi_Strchr(ev, c);
    } while (!idx);
    return idx - ev; 
} 

static int B64Decode(Jsi_Interp *interp, char *inbuffer, int ilen, Jsi_Value **ret)
{
    int olen, pos, tlen=1024, tpos=0;
    char outbuffer[3], *tbuf;
    int c[4];
    
    tbuf=(char*)Jsi_Malloc(tlen);
    pos = 0; 
    atend = 0;
    while (!atend) {
        if (inbuffer[pos]=='\n' ||inbuffer[pos]=='\r') { pos++; continue; }
        c[0] = getidx(inbuffer, ilen, &pos);
        c[1] = getidx(inbuffer, ilen, &pos);
        c[2] = getidx(inbuffer, ilen, &pos);
        c[3] = getidx(inbuffer, ilen, &pos);

        olen = 0;
        if (c[0]>=0 && c[1]>=0) {
            outbuffer[0] = ((c[0]<<2)&0xfc)|((c[1]>>4)&0x03);
            olen++;
            if (c[2]>=0) {
                outbuffer[1] = ((c[1]<<4)&0xf0)|((c[2]>>2)&0x0f);
                olen++;
                if (c[3]>=0) {
                    outbuffer[2] = ((c[2]<<6)&0xc0)|((c[3])&0x3f);
                    olen++;
                }
            }
        }

        if (olen>0) {
            if ((tpos+olen+1)>=tlen) {
                tbuf=(char*)Jsi_Realloc(tbuf,tlen+1024);
                tlen+=1024;
            }
            memcpy(tbuf+tpos,outbuffer,olen);
            tpos+=olen;
        }
    }
    tbuf[tpos] = 0;
    Jsi_ValueMakeStringDup(interp, ret, tbuf);
    free(tbuf);
    return JSI_OK;
}

static int
B64Encode(Jsi_Interp *interp, char *ib, int ilen, Jsi_Value **ret)
{
    int i=0, pos=0;
    char c[74];
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);

    while (pos<ilen) {
#define P(n,s) ((pos+n)>ilen?'=':ev[s])
        c[i++]=ev[(ib[pos]>>2)&0x3f];
        c[i++]=P(1,((ib[pos]<<4)&0x30)|((ib[pos+1]>>4)&0x0f));
        c[i++]=P(2,((ib[pos+1]<<2)&0x3c)|((ib[pos+2]>>6)&0x03));
        c[i++]=P(3,ib[pos+2]&0x3f);
        if (i>=72) {
            c[i++]='\n';
            c[i]=0;
            Jsi_DSAppendLen(&dStr, c, i);
            i=0;
        }
        pos+=3;
    }
    if (i) {
        /*    c[i++]='\n';*/
        c[i]=0;
        Jsi_DSAppendLen(&dStr, c, i);
        i=0;
    }
    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));
    return JSI_OK;
}

static int B64DecodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int ilen;
    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    return B64Decode(interp, inbuffer, ilen, ret);
}

static int B64EncodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int ilen;
    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    return B64Encode(interp, inbuffer, ilen, ret);
}

static int B64DecodeFileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *b = NULL, buf[BUFSIZ];
    Jsi_Value *fn = Jsi_ValueArrayIndex(interp, args, 0);
    int rc, n, siz = 0;
    Jsi_Channel chan = Jsi_Open(interp, fn, "rb");
    if (!chan) {
        Jsi_LogError("open failed");
        return JSI_ERROR;
    }
    while ((n=Jsi_Read(chan, buf, BUFSIZ)) > 0) {
        b = (char*)Jsi_Realloc(b, siz+n);
        memcpy(b+siz, buf, n);
        siz += n;
    }
    Jsi_Close(chan);
    rc = B64Decode(interp, b, siz, ret);
    Jsi_Free(b);
    return rc;
}

static int B64EncodeFileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    char *b = NULL, buf[BUFSIZ];
    Jsi_Value *fn = Jsi_ValueArrayIndex(interp, args, 0);
    int rc, n, siz = 0;
    Jsi_Channel chan = Jsi_Open(interp, fn, "rb");
    if (!chan) {
        Jsi_LogError("open failed");
        return JSI_ERROR;
    }
    while ((n=Jsi_Read(chan, buf, BUFSIZ)) > 0) {
        b = (char*)Jsi_Realloc(b, siz+n);
        memcpy(b+siz, buf, n);
        siz += n;
    }
    Jsi_Close(chan);
    rc = B64Encode(interp, b, siz, ret);
    Jsi_Free(b);
    return rc;
}


static int SysB64EncodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int n;
    if (arg && Jsi_GetBoolFromValue(interp, arg, &n) == JSI_OK && n)
        return B64EncodeFileCmd(interp, args, _this, ret, funcPtr);
    return B64EncodeCmd(interp, args, _this, ret, funcPtr);
}


static int SysB64DecodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int n;
    if (arg && Jsi_GetBoolFromValue(interp, arg, &n) == JSI_OK && n)
        return B64DecodeFileCmd(interp, args, _this, ret, funcPtr);
    return B64DecodeCmd(interp, args, _this, ret, funcPtr);
}

static int SysMd5Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    int n;
    if (arg && Jsi_GetBoolFromValue(interp, arg, &n) == JSI_OK && n)
        return jsi_Md5File(interp, args, _this, ret, funcPtr);
    char buf[33];
    Jsi_Md5Str(interp, buf, str, -1);
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static int SysSha1Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int ilen;
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);
    int n;
    if (arg && Jsi_GetBoolFromValue(interp, arg, &n) == JSI_OK && n)
        return jsi_Sha1File(interp, args, _this, ret, funcPtr);
    char buf[41];
    Jsi_Sha1Str(interp, buf, str, ilen);
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static int SysSha256Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    char buf[65];
    Jsi_Sha256Str(interp, buf, str, -1);
    Jsi_ValueMakeStringDup(interp, ret, buf);
    return JSI_OK;
}

static int _SysEnDecryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int decrypt)
{
    Jsi_Value *keyVal = Jsi_ValueArrayIndex(interp, args, 0);
    int ilen;
    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 1, &ilen);
    char *key = Jsi_ValueString(interp, keyVal, NULL);
    if (!key) {
        Jsi_LogError("key must be a string");
        return JSI_ERROR;
    }
    Jsi_DString dStr = {};
    Jsi_DSAppendLen(&dStr, str, ilen);
    while (ilen<=4 || (ilen%4)) {
        Jsi_DSAppendLen(&dStr, "\0", 1);
        ilen++;
    }
    if (JSI_OK != Jsi_EncryptBuf(interp, key, (int*)Jsi_DSValue(&dStr), ilen/4, decrypt))
        return JSI_ERROR;
    Jsi_ValueMakeDStringObject(interp, ret, &dStr);
    return JSI_OK;
}

#define FN_decrypt JSI_INFO("\
Xxtea decrypt data using key string.")
static int SysDecryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _SysEnDecryptCmd(interp, args, _this, ret, funcPtr, 1);
}

#define FN_encrypt JSI_INFO("\
Xxtea encryption data using key string.  \
Input data is first padded with NULLs making the length a multiple of 4. \
If this is a problem, data can be b64encoded.")
static int SysEncryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return _SysEnDecryptCmd(interp, args, _this, ret, funcPtr, 0);
}

/* Commands only visible at the toplevel. */

static Jsi_CmdSpec cDataCmds[] = {
    { "get",      cDataGetCmd,       2,  3, "name:string, index:number, field:string=void", .help="Return struct data for one or all fields", .retType=(uint)JSI_TT_ANY },
    { "info",     cDataInfoCmd,      1,  1, "name:string", .help="Return struct details", .retType=(uint)JSI_TT_OBJECT },
    { "names",    cDataNamesCmd,     0,  0, "",     .help="Return name of all defined Cdata items", .retType=(uint)JSI_TT_ARRAY },
    { "schema",   cDataSchemaCmd,    1,  1, "name:string", .help="Return a DB schema compatible with struct", .retType=(uint)JSI_TT_STRING },
    { "schemaMd5",cDataSchemaMd5Cmd, 1,  1, "name:string", .help="Calculate md5 of schema (ignores comments from .help)", .retType=(uint)JSI_TT_STRING },
    { "struct",   cDataStructCmd,    1,  1, "name:string", .help="Return the C struct for mydata", .retType=(uint)JSI_TT_STRING },
    { "set",      cDataSetCmd,       3,  3, "name:string, index:number, dataobj:string|object|null,", .help="Update/get struct data", .retType=(uint)JSI_TT_ANY },
    { "size",     cDataSizeCmd,      1,  1, "name:string", .help="Return allocated size of data array", .retType=(uint)JSI_TT_NUMBER },
    { NULL,   .help="Access commands for Cdata" }
};

static Jsi_CmdSpec consoleCmds[] = {
    { "input",  consoleInputCmd,    0,  0, "", .help="Read input from the console", .retType=(uint)JSI_TT_STRING },
    { "log",    consoleLogCmd,      1, -1, "val, ...", .help="Output one or more values to stderr", .info=FN_conslog, .retType=(uint)JSI_TT_VOID },
    { "puts",   SysPutsCmd,         1, -1, "val, ...", .help="Output one or more values to stdout", .info=FN_puts, .retType=(uint)JSI_TT_VOID },
    { NULL,   .help="Console input and output" }
};

static Jsi_CmdSpec eventCmds[] = {
    { "clearInterval",clearIntervalCmd, 1,  1, "id:number", .help="Delete an event (created with setInterval/setTimeout)", .retType=(uint)JSI_TT_VOID },
    { "info",       eventInfoCmd,       1,  1, "id:number", .help="Return info for the given event id", .retType=(uint)JSI_TT_OBJECT },
    { "names",      eventInfoCmd,       0,  0, "", .help="Return list event ids (created with setTimeout/setInterval)", .retType=(uint)JSI_TT_ARRAY },
    { "setInterval",setIntervalCmd,     2,  2, "callback:function, millisecs:number", .help="Setup recurring function to run every given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "setTimeout", setTimeoutCmd,      2,  2, "callback:function, millisecs:number", .help="Setup function to run after given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "update",     SysUpdateCmd,       0,  1, "options:number|object=void", .help="Execute interval/timer tasks",.info=FN_update, .opts=UpdateOptions, .retType=(uint)JSI_TT_NUMBER },
    { NULL,   .help="Event management" }
};

static Jsi_CmdSpec infoCmds[] = {
    { "argv0",      InfoArgv0Cmd,       0,  0, "", .help="Return initial start script file name", .retType=(uint)JSI_TT_STRING },
    { "cmds",       InfoCmdsCmd,        0,  2, "val:string|regexp='*', all:boolean=false", .help="Return details or list of matching commands", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },
    { "completions",InfoCompletionsCmd,  1,  3, "str:string, start:number=0, end:number=void", .help="Return command completions for string", .retType=(uint)JSI_TT_ARRAY },
    { "data",       InfoDataCmd,        0,  1, "val:string|regexp|object=void", .help="Return list of matching data (non-functions)", .info=FN_infodata, .retType=(uint)JSI_TT_ARRAY },
    { "error",      InfoErrorCmd,       0,  0, "", .help="Return file and line number of error (used inside catch", .retType=(uint)JSI_TT_OBJECT },
    { "event",      InfoEventCmd,       0,  1, "id:number=void", .help="List events or info for 1 event (setTimeout/setInterval)", .info=FN_infoevent, .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },
    { "executable", InfoExecutableCmd,  0,  0, "", .help="Return name of executable", .retType=(uint)JSI_TT_STRING },
    { "execZip",    InfoExecZipCmd,     0,  0, "", .help="If executing a .zip file, return file name", .retType=(uint)JSI_TT_STRING },
    { "funcs",      InfoFuncsCmd,       0,  1, "string|regexp|object=void", .help="Return details or list of matching functions", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },
    { "interp",     jsi_InterpInfo,     0,  1, "interp:userobj=void", .help="Return info on given or current interp", .retType=(uint)JSI_TT_OBJECT },
    { "isMain",     InfoIsMainCmd,      0,  0, "", .help="Return true if current script was the main script invoked from command-line", .retType=(uint)JSI_TT_BOOL },
    { "keywords",   InfoKeywordsCmd,    0,  0, "", .help="Return list of reserved jsi keywords", .retType=(uint)JSI_TT_ARRAY },
    { "lookup",     InfoLookupCmd,      1,  1, "name:string", .help="Given string name, lookup and return value (eg. function).", .retType=(uint)JSI_TT_ANY },
    { "named",      InfoNamedCmd,       0,  1, "name:string", .help="Returns command names for builtin Objects (eg. 'File', 'Sqlite') or their new'ed names", .retType=(uint)JSI_TT_ARRAY },
//    { "now",        DateNowCmd,         0,  0, "",  .help="Return current time (in ms) since unix epoch (ie. 1970)", .retType=(uint)JSI_TT_NUMBER },
    { "options",    InfoOptionsCmd,     0,  1, "ctype:boolean=false", .help="Return Option type name, or with true the C type)", .retType=(uint)JSI_TT_STRING },
    { "platform",   InfoPlatformCmd,    0,  0, "", .help="N/A. Returns general platform information for JSI", .retType=(uint)JSI_TT_OBJECT  },
    { "script",     InfoScriptCmd,      0,  1, "func:function|regexp=void", .help="Get current script file name, or file containing function", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT },
    { "scriptDir",  InfoScriptDirCmd,   0,  0, "", .help="Get directory of current script", .retType=(uint)JSI_TT_STRING },
    { "vars",       InfoVarsCmd,        0,  1, "val:string|regexp|object=void", .help="Return details or list of matching variables", .info=FN_infovars, .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },
    { "version",    InfoVersionCmd,     0,  1, "getObj:boolean=false", .help="Return JSI version double (or object with true arg)", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT  },
    { NULL,  .help="Commands for inspecting internal state information in JSI"  }
};

static Jsi_CmdSpec sysCmds[] = {
    { "assert",     jsi_AssertCmd,   2,  2, "expr:boolean|number|function, msg:string",  .help="Generate an with msg error if expr evaluates to false/zero, and return arg 1", .retType=(uint)JSI_TT_ANY },
    { "b64decode",  SysB64DecodeCmd, 1,  2, "val:string, isfile:boolean=false",.help="Decode string/file", .retType=(uint)JSI_TT_STRING },
    { "b64encode",  SysB64EncodeCmd, 1,  2, "val:string, isfile:boolean=false",.help="Encode string/file", .retType=(uint)JSI_TT_STRING },
    { "clearInterval",clearIntervalCmd, 1,  1, "id:number", .help="Delete event id returned from setInterval/setTimeout/info.events()", .retType=(uint)JSI_TT_VOID },
    { "decodeURI",  DecodeURICmd,       1,  1, "val:string", .help="Decode an HTTP URL", .retType=(uint)JSI_TT_STRING },
    { "decrypt",    SysDecryptCmd,   2,  2, "key:string, val:string", .help="Return decryption of string", .info=FN_decrypt, .retType=(uint)JSI_TT_STRING },
    { "encodeURI",  EncodeURICmd,       1,  1, "val:string", .help="Encode an HTTP URL", .retType=(uint)JSI_TT_STRING },
    { "encrypt",    SysEncryptCmd,   2,  2, "key,string, val:string", .help="Return encryption of string", .info=FN_encrypt, .retType=(uint)JSI_TT_STRING },
    { "exec",       SysExecCmd,      1,  2, "val:string, options:null|string|object=void", .help="Execute an OS command", .info=FN_exec, .retType=(uint)JSI_TT_ANY, .opts=ExecOptions},
    { "exit",       SysExitCmd,      0,  1, "code:number=0", .help="Exit the current interpreter", .retType=(uint)JSI_TT_VOID },
    { "format",     SysFormatCmd,    1, -1, "format:string, ...", .help="Implement printf style formatting", .retType=(uint)JSI_TT_STRING },
    { "getenv",     SysGetEnvCmd,    0,  1, "name:string=void", .help="Get one or all environment", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT  },
    { "getpid",     SysGetPidCmd,    0,  1, "", .help="Get process id", .retType=(uint)JSI_TT_NUMBER },
    { "getppid",    SysGetPpidCmd,   0,  1, "", .help="Get parent process id", .retType=(uint)JSI_TT_NUMBER },
    { "isFinite",   isFiniteCmd,        1,  1, "val:string", .help="Return true if is a finite number", .retType=(uint)JSI_TT_BOOL },
    { "isNaN",      isNaNCmd,           1,  1, "val:string", .help="Return true if not a number", .retType=(uint)JSI_TT_BOOL },
    { "md5",        SysMd5Cmd,       1,  2, "val:string, isfile:boolean=false",.help="Compute md5 hash of string/file", .retType=(uint)JSI_TT_STRING },
    { "noOp",       SysNoOpCmd,      0,  0, "", .help="Do nothing; useful for measuring function call overhead", .retType=(uint)JSI_TT_VOID },
    { "parseInt",   parseIntCmd,        1,  2, "val:any, base:number=10", .help="Convert string to an integer", .retType=(uint)JSI_TT_NUMBER },
    { "parseFloat", parseFloatCmd,      1,  1, "val", .help="Convert string to a double", .retType=(uint)JSI_TT_NUMBER },
    { "puts",       SysPutsCmd,      1, -1, "val, ...", .help="Output one or more values to stdout", .info=FN_puts, .retType=(uint)JSI_TT_VOID },
    { "quote",      quoteCmd,           1,  1, "val:string", .help="Return quoted string", .retType=(uint)JSI_TT_STRING },
    { "setenv",     SysSetEnvCmd,    2,  2, "name:string, value:string", .help="Set an environment var"  },
    { "sha1",       SysSha1Cmd,      1,  2, "val:string, isfile:boolean=false", .help="Return sha1 of string/file", .retType=(uint)JSI_TT_STRING },
    { "sha256",     SysSha256Cmd,    1,  2, "val:string, isfile:boolean=false", .help="Return sha256 of string/file", .retType=(uint)JSI_TT_STRING },
    { "sleep",      SysSleepCmd,     0,  1, "secs:number=1.0",  .help="sleep for N milliseconds, minimum .001", .retType=(uint)JSI_TT_VOID },
    { "setInterval",setIntervalCmd,     2,  2, "callback:function, ms:number", .help="Setup recurring function to run every given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "setTimeout", setTimeoutCmd,      2,  2, "callback:function, ms:number", .help="Setup function to run after given millisecs", .retType=(uint)JSI_TT_NUMBER },
    { "source",     SysSourceCmd,    1, 2, "val:string|array, options:object=void",  .help="Load and evaluate source files", .opts=SourceOptions, .retType=(uint)JSI_TT_VOID},
    { "strftime",   DateStrftimeCmd, 1,  2, "num:number, options:string|object=void",  .help="Format numeric time (in ms) to a string", .opts=DateOptions,.info=FN_strftime, .retType=(uint)JSI_TT_STRING },
    { "strptime",   DateStrptimeCmd, 1,  2, "val:string, options:string|object=void",  .help="Parse time from string and return time (in ms) since 1970", .opts=DateOptions, .retType=(uint)JSI_TT_NUMBER },
    { "times",      SysTimesCmd,     1,  2, "callback:function, count:number=1", .help="Call function count times and return execution time in microseconds", .retType=(uint)JSI_TT_NUMBER },
    { NULL, .help="Builtin system commands. All are callable from the either the top level or as System.XXX()" }
};

int jsi_CmdsInit(Jsi_Interp *interp)
{
    interp->console = Jsi_CommandCreateSpecs(interp, "console", consoleCmds, NULL, JSI_CMDSPEC_NOTOBJ);
    Jsi_IncrRefCount(interp, interp->console);
    Jsi_ValueInsertFixed(interp, interp->console, "args", interp->args);
        
    Jsi_CommandCreateSpecs(interp, "",       sysCmds,    NULL, JSI_CMDSPEC_NOTOBJ);
    Jsi_CommandCreateSpecs(interp, "System", sysCmds,    NULL, JSI_CMDSPEC_NOTOBJ);
    Jsi_CommandCreateSpecs(interp, "Info",   infoCmds,   NULL, JSI_CMDSPEC_NOTOBJ);
    Jsi_CommandCreateSpecs(interp, "Cdata",  cDataCmds,  NULL, JSI_CMDSPEC_NOTOBJ);
    Jsi_CommandCreateSpecs(interp, "Event",  eventCmds,  NULL, JSI_CMDSPEC_NOTOBJ);
    return JSI_OK;
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_OMIT_FILESYS
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <errno.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <dirent.h>
#include <signal.h>
#include <unistd.h>
#ifndef __WIN32
#include <pwd.h>
#else
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <fcntl.h>
#endif
#include <limits.h>

#define HAVE_UNISTD_H
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#elif defined(_MSC_VER)
#include <direct.h>
#define F_OK 0
#define W_OK 2
#define R_OK 4
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

#define GSVal(s) GetStringVal(interp, s)
static const char *GetStringVal(Jsi_Interp *interp, Jsi_Value *s) {
    const char *cp = Jsi_ValueString(interp, s, 0);
    return cp ? cp : "";
}

#define SAFEACCESS(fname, writ)  \
if (interp->isSafe && Jsi_InterpAccess(interp, fname, writ) != JSI_OK) { \
        Jsi_LogError("%s access denied", writ?"write":"read"); \
        return JSI_ERROR;\
    }

int jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int islstat)
{
    int rc;
    Jsi_StatBuf st;
    SAFEACCESS(fnam, 0)
    if (islstat)
        rc = Jsi_Lstat(interp, fnam, &st);
    else
        rc = Jsi_Stat(interp, fnam, &st);
    if (rc != 0) {
        Jsi_LogError("file not found: %s", GSVal(fnam));
        return JSI_ERROR;
    }
   /* Single object containing result members. */
    Jsi_Value *vres;
    Jsi_Obj  *ores;
    Jsi_Value *nnv;
    vres = Jsi_ValueMakeObject(interp, NULL, ores = Jsi_ObjNew(interp));
    Jsi_IncrRefCount(interp, vres);
#define MKDBL(nam,val) \
    nnv = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)val); \
    Jsi_ObjInsert(interp, ores, nam, nnv, 0);
    
    MKDBL("dev",st.st_dev); MKDBL("ino",st.st_ino); MKDBL("mode",st. st_mode);
    MKDBL("nlink",st.st_nlink); MKDBL("uid",st.st_uid); MKDBL("gid",st.st_gid);
    MKDBL("rdev",st.st_rdev);
#ifndef __WIN32
    MKDBL("blksize",st.st_blksize); MKDBL("blocks",st.st_blocks);
#endif
    MKDBL("atime",st.st_atime); MKDBL("mtime",st.st_mtime); MKDBL("ctime",st.st_ctime);    
    MKDBL("size",st.st_size);
    Jsi_ValueDup2(interp, ret, vres);
    Jsi_DecrRefCount(interp, vres);
    return JSI_OK;
}


static int FileStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return jsi_FileStatCmd(interp, Jsi_ValueArrayIndex(interp, args, 0), _this, ret, funcPtr, 0);
}

static int FileLstatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return jsi_FileStatCmd(interp, Jsi_ValueArrayIndex(interp, args, 0), _this, ret, funcPtr, 1);
}

static const char *getFileType(int mode, int lmode)
{
#ifdef S_ISLNK
    if (S_ISLNK(mode) || S_ISLNK(lmode)) {
        return "link";
    }
#endif
    if (S_ISDIR(mode)) {
        return "directory";
    }
#ifdef S_ISCHR
    else if (S_ISCHR(mode)) {
        return "characterSpecial";
    }
#endif
#ifdef S_ISBLK
    else if (S_ISBLK(mode)) {
        return "blockSpecial";
    }
#endif
#ifdef S_ISFIFO
    else if (S_ISFIFO(mode)) {
        return "fifo";
    }
#endif
#ifdef S_ISSOCK
    else if (S_ISSOCK(mode)) {
        return "socket";
    }
#endif
    else if (S_ISREG(mode)) {
        return "file";
    }
    return "unknown";
}

enum { FSS_Exists, FSS_Atime, FSS_Mtime, FSS_Writable, FSS_Readable, FSS_Executable, FSS_Type, 
FSS_Owned, FSS_Isdir, FSS_Isfile };

static int _FileSubstat(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int sub)
{
    Jsi_Value *fnam = Jsi_ValueArrayIndex(interp, args, 0);
    int rc;
    Jsi_StatBuf st, lst;
    rc = Jsi_Stat(interp, fnam, &st) | Jsi_Lstat(interp, fnam, &lst);
    if (rc != 0 && sub != FSS_Exists) {
        if (!interp->fileStrict)
            return JSI_OK;
        Jsi_LogError("file not found: %s", GSVal(fnam));
        return JSI_ERROR;
    }
    switch (sub) {
        case FSS_Exists: Jsi_ValueMakeBool(interp, ret, (rc == 0)); break;
        case FSS_Atime: Jsi_ValueMakeNumber(interp, ret, st.st_atime); break;
        case FSS_Mtime: Jsi_ValueMakeNumber(interp, ret, st.st_mtime); break;
        case FSS_Writable: Jsi_ValueMakeBool(interp, ret, (Jsi_Access(interp, fnam, W_OK) != -1));  break;
        case FSS_Readable: Jsi_ValueMakeBool(interp, ret, (Jsi_Access(interp, fnam, R_OK) != -1));  break;
        case FSS_Executable:
#ifdef X_OK
            Jsi_ValueMakeBool(interp, ret, Jsi_Access(interp, fnam, X_OK) != -1);
#else
            Jsi_ValueMakeBool(interp, ret, 1);
#endif
            break;
        case FSS_Type: Jsi_ValueMakeStringKey(interp, ret, (char*)getFileType((int)st.st_mode, (int)lst.st_mode)); break;
        case FSS_Owned:
#ifndef __WIN32
            Jsi_ValueMakeBool(interp, ret, geteuid() == st.st_uid);
#endif
            break;
        case FSS_Isdir: Jsi_ValueMakeBool(interp, ret, S_ISDIR(st.st_mode));  break;
        case FSS_Isfile: Jsi_ValueMakeBool(interp, ret, S_ISREG(st.st_mode));  break;
        
    }
    return JSI_OK;
}
#define MAKE_FSS_SUB(nam) \
static int File##nam##Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, \
    Jsi_Value **ret, Jsi_Func *funcPtr) \
{\
    return _FileSubstat(interp, args, _this, ret, funcPtr, FSS_##nam);\
}
MAKE_FSS_SUB(Exists) MAKE_FSS_SUB(Atime) MAKE_FSS_SUB(Writable) MAKE_FSS_SUB(Readable)
MAKE_FSS_SUB(Executable) MAKE_FSS_SUB(Type) MAKE_FSS_SUB(Owned)
MAKE_FSS_SUB(Isdir) MAKE_FSS_SUB(Isfile) MAKE_FSS_SUB(Mtime)
#ifndef __WIN32
#define MKDIR_DEFAULT(PATHNAME) mkdir(PATHNAME, 0755)
#else
#define MKDIR_DEFAULT(PATHNAME) mkdir(PATHNAME)
#endif

static int mkdir_all(Jsi_Interp *interp, Jsi_Value *file)
{
    int ok = 1;
    char *path = Jsi_ValueString(interp, file, NULL);
    if (!path) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }

    /* First time just try to make the dir */
    goto first;

    while (ok--) {
        /* Must have failed the first time, so recursively make the parent and try again */
        {
            char *slash = strrchr(path, '/');

            if (slash && slash != path) {
                *slash = 0;
                if (mkdir_all(interp, file) != 0) {
                    return -1;
                }
                *slash = '/';
            }
        }
      first:
        if (MKDIR_DEFAULT(path) == 0) {
            return 0;
        }
        if (errno == ENOENT) {
            /* Create the parent and try again */
            continue;
        }
        /* Maybe it already exists as a directory */
        if (errno == EEXIST) {
            Jsi_StatBuf sb;

            if (Jsi_Stat(interp, file, &sb) == 0 && S_ISDIR(sb.st_mode)) {
                return 0;
            }
            /* Restore errno */
            errno = EEXIST;
        }
        /* Failed */
        break;
    }
    return -1;
}

static int FilePwdCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_DString dStr = {};
    Jsi_ValueMakeStringDup(interp, ret, Jsi_GetCwd(interp, &dStr));
    Jsi_DSFree(&dStr);
    return JSI_OK;
}

static int FileChdirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    if (!path) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    int rc = Jsi_Chdir(interp, path);
    if (rc != 0) {
        Jsi_LogError("can't change to directory \"%s\": %s", GSVal(path), strerror(errno));
        return JSI_ERROR;
    }    
    return JSI_OK;
}

static int FileMkdirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 1);
    char *spath =  Jsi_ValueString(interp, path,0);
    int rc, force = 0; 

    if (!spath) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    if (vf)
        force = vf->d.val;
    if (force==0)
        rc = MKDIR_DEFAULT(spath);
    else {
        Jsi_Value *npath = Jsi_ValueNewStringDup(interp, spath);
        rc = mkdir_all(interp, npath);
        Jsi_ValueFree(interp, npath);
    }
    if (rc != 0) {
        Jsi_LogError("can't create directory \"%s\": %s", spath, strerror(errno));
        return JSI_ERROR;
    }    
    return JSI_OK;
}

static int FileTempfileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *vt = Jsi_ValueArrayIndex(interp, args, 0);
    char *filename;
    const char *tp, *templ = "/tmp/jsiXXXXXX";

    if (vt && (tp = Jsi_ValueString(interp, vt, NULL))) {
        templ = tp;
    }
#ifndef __WIN32
    filename = Jsi_Strdup(templ);
    int fd = mkstemp(filename);
    if (fd < 0)
        goto fail;
    close(fd);
#else
#ifndef MAX_PATH
#define MAX_PATH 1024
#endif
   char name[MAX_PATH];
    HANDLE handle;

    if (!GetTempPath(MAX_PATH, name) || !GetTempFileName(name, "JSI", 0, name)) {
        Jsi_LogError("failed to get temp file");
        return JSI_ERROR;
    }
    filename = Jsi_Strdup(name);
#endif
    Jsi_ValueMakeString(interp, ret, filename);
    return JSI_OK;
    
fail:
    Jsi_LogError("Failed to create tempfile");
    Jsi_Free(filename);
    return JSI_ERROR;
}

static int FileTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{   
    int rc;
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *sizv = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number siz;
    if (Jsi_GetNumberFromValue(interp, sizv, &siz) != JSI_OK)
        return JSI_ERROR;
    SAFEACCESS(fname, 1)
    Jsi_Channel ch = Jsi_Open(interp, fname, "rb+");
    if (!ch)
        return JSI_ERROR;
    rc = Jsi_Truncate(ch, (unsigned int)siz);
    Jsi_Close(ch);
    return rc;
}


static int FileChmodCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *modv = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number fmod;
    if (Jsi_GetNumberFromValue(interp, modv, &fmod) != JSI_OK)
        return JSI_ERROR;
    SAFEACCESS(fname, 1)
    return Jsi_Chmod(interp, fname, (unsigned int)fmod);
}

static int FileReadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr) /* TODO limit. */
{   
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 1);
    const char *mode = (vmode ? Jsi_ValueString(interp, vmode, NULL) : NULL);
    SAFEACCESS(fname, 0)

    Jsi_Channel chan = Jsi_Open(interp, fname, (mode ? mode : "rb"));
    int n, sum = 0;
    if (!chan) {
        Jsi_LogError("failed open for read: %s", GSVal(fname));
        return JSI_ERROR;
    }
    Jsi_DString dStr = {};
    char buf[BUFSIZ];
    while (sum < MAX_LOOP_COUNT && (n = Jsi_Read(chan, buf, sizeof(buf))) > 0) {
        Jsi_DSAppendLen(&dStr, buf, n);
        sum += n;
    }
    Jsi_Close(chan);
    Jsi_ValueMakeDStringObject(interp, ret, &dStr);
    return JSI_OK;
}


static int FileWriteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{   
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);
    const char *data;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 2);
    const char *mode = (vmode ? Jsi_ValueString(interp, vmode, NULL) : NULL);
    Jsi_Channel chan;
    int n, len, cnt = 0, sum = 0;
    SAFEACCESS(fname, 1)
    if (!(data = Jsi_ValueGetStringLen(interp, v, &len))) {
        return JSI_ERROR;
    }
    chan = Jsi_Open(interp, fname, (mode ? mode : "wb+"));
    if (!chan) {
        Jsi_LogError("failed open for write: %s", GSVal(fname));
        return JSI_ERROR;
    }
    while (cnt < MAX_LOOP_COUNT && len > 0 && (n = Jsi_Write(chan, data, len)) > 0) {
        len -= n;
        sum += n;
        cnt++;
    }
    Jsi_Close(chan);
    /* TODO: handle nulls. */
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sum);
    return JSI_OK;
}

static int FileRenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{   
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *dest = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 2);
    int force = 0; 

    SAFEACCESS(source, 1)
    SAFEACCESS(dest, 1)
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    if (vf)
        force = vf->d.val;
    if (force==0 && Jsi_Access(interp, dest, F_OK) == 0) {
        Jsi_LogError("error renaming \"%s\" to \"%s\": target exists", GSVal(source), GSVal(dest));
        return JSI_ERROR;
    }

    if (Jsi_Rename(interp, source, dest) != 0) {
        Jsi_LogError( "error renaming \"%s\" to \"%s\": %s", GSVal(source),
            GSVal(dest), strerror(errno));
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int FileCopy(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value* dest) {
    Jsi_Channel ich = Jsi_Open(interp, src, "rb");
    if (!ich)
        return -1;
    Jsi_Channel och = Jsi_Open(interp, dest, "wb+");
    if (!och)
        return -1;
    while (1) {
        char buf[BUFSIZ];
        int n;
        n = Jsi_Read(ich, buf, BUFSIZ);
        if (n<=0)
            break;
        if (Jsi_Write(och, buf, n) != n) {
            Jsi_Close(ich);
            Jsi_Close(och);
            return -1;
        }
    }
    /* TODO: set perms. */
#ifndef __WIN32
    Jsi_StatBuf sb;
    Jsi_Stat(interp, src, &sb);
    Jsi_Chmod(interp, dest, sb.st_mode);
#endif
    Jsi_Close(ich);
    Jsi_Close(och);
    return 0;
}

#define FN_copy JSI_INFO("\
Directories are not handled. \
The third argument if given is a boolean force value \
which if true allows overwrite of an existing file. ")
static int FileCopyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *dest = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 2);
    int force = 0; 
    SAFEACCESS(source, 0)
    SAFEACCESS(dest, 1)
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    if (vf)
        force = vf->d.val;
    if (force==0 && Jsi_Access(interp, dest, F_OK) == 0) {
        Jsi_LogError("error copying \"%s\" to \"%s\": target exists", GSVal(source), GSVal(dest));
        return JSI_ERROR;
    }

    if (FileCopy(interp, source, dest) != 0) {
        Jsi_LogError( "error copying \"%s\" to \"%s\": %s", GSVal(source),
            GSVal(dest), strerror(errno));
        return JSI_ERROR;
    }
    return JSI_OK;
}

#define FN_link JSI_INFO("\
The second argument is the destination file to be created. "\
"If a third bool argument is true, a hard link is created.")
static int FileLinkCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *dest = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 2);
    int hard = 0; 
    SAFEACCESS(source, 1)
    SAFEACCESS(dest, 1)
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    if (vf)
        hard = vf->d.val;

    if (Jsi_Link(interp, source, dest, hard) != 0) {
        Jsi_LogError( "error linking \"%s\" to \"%s\": %s", GSVal(source),
            GSVal(dest), strerror(errno));
        return JSI_ERROR;
    }
    return JSI_OK;
}

/* TODO: switch to MatchesInDir */
static int RmdirAll(Jsi_Interp *interp, Jsi_Value *path, int force)
{
    DIR *dir;
    struct dirent *entry;
    char spath[PATH_MAX];
    int erc = JSI_OK;
    char *dirname = Jsi_ValueString(interp, path, 0);
    if (!dirname) {
        Jsi_LogError("expected string");
        return JSI_ERROR;
    }

    /* TODO: change to Jsi_Scandir */
    dir = opendir(dirname);
    if (dir == NULL) {
        if (force)
            return JSI_OK;
        Jsi_LogError("opening directory: %s", dirname);
        return JSI_ERROR;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") && strcmp(entry->d_name, "..")) {
            snprintf(spath, (size_t) PATH_MAX, "%s/%s", dirname, entry->d_name);
            Jsi_Value *tpPtr = Jsi_ValueNew1(interp);
            Jsi_ValueMakeStringDup(interp, &tpPtr, spath);
#ifndef __WIN32
            if (entry->d_type == DT_DIR) {
                int rc = RmdirAll(interp, tpPtr, force);
                if (rc != JSI_OK)
                    erc = rc;
            } else 
#endif
            {
                if (Jsi_Remove(interp, tpPtr, force) != 0) {
                    if (force)
                        Jsi_LogError("deleting file: %s", GSVal(tpPtr));
                    erc = JSI_ERROR;
                }
            }
            Jsi_DecrRefCount(interp, tpPtr);
        }
    }
    closedir(dir);
    Jsi_Remove(interp, path, force);
    return erc;
}

static int FileRemoveCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *source = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vf = Jsi_ValueArrayIndex(interp, args, 1);
    const char *spath = GSVal(source);
    int rc, force = 0; 
    SAFEACCESS(source, 1)

    Jsi_StatBuf st;
    if (vf && !Jsi_ValueIsBoolean(interp, vf)) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    if (vf)
        force = vf->d.val;
    rc = Jsi_Stat(interp, source, &st);
    if (strcmp(spath,"/")==0)
        return JSI_ERROR;
    if (rc != 0) {
        if (force)
            return JSI_OK;
        Jsi_LogError("error deleting \"%s\": target not found", spath);
        return JSI_ERROR;
    }

    if (Jsi_Remove(interp, source, force) != 0) {
        if (!S_ISDIR(st.st_mode)) {
            if (force)
                return JSI_OK;
            Jsi_LogError("error deleting \"%s\"", spath);
            return JSI_ERROR;
        }
        if (force==0) {
            Jsi_LogError("error deleting \"%s\": directory not empty", spath);
            return JSI_ERROR;
        }
        return RmdirAll(interp, source, force);
    }
    return JSI_OK;
}

static int FileReadlinkCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    SAFEACCESS(path, 1)

    char *linkValue = (char*)Jsi_Malloc(MAXPATHLEN + 1);

    int linkLength = Jsi_Readlink(interp, path, linkValue, MAXPATHLEN);

    if (linkLength == -1) {
        Jsi_Free(linkValue);
        Jsi_LogError("couldn't readlink \"%s\": %s", GSVal(path), strerror(errno));
        return JSI_ERROR;
    }
    linkValue[linkLength] = 0;
    Jsi_ValueMakeString(interp, ret, linkValue);
    return JSI_OK;
}

static int FileDirnameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *p = strrchr(path, '/');

    if (!p && path[0] == '.' && path[1] == '.' && path[2] == '\0') {
        Jsi_ValueMakeStringKey(interp, ret, "..");
    } else if (!p) {
        Jsi_ValueMakeStringKey(interp, ret, ".");
    }
    else if (p == path) {
        Jsi_ValueMakeStringKey(interp, ret, "/");
    }
#if defined(__MINGW32__) || defined(_MSC_VER)
    else if (p[-1] == ':') {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(path, 0, p-path+1));
    }
#endif
    else {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(path, 0, p-path));
    }
    return JSI_OK;
}

static int FileRootnameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *lastSlash = strrchr(path, '/');
    const char *p = strrchr(path, '.');

    if (p == NULL || (lastSlash != NULL && lastSlash > p)) {
        Jsi_ValueMakeStringDup(interp, ret, path);
    }
    else {
        Jsi_ValueMakeString(interp, ret, jsi_SubstrDup(path,0, p-path));
    }
    return JSI_OK;
}
static int FileExtensionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *lastSlash = strrchr(path, '/');
    const char *p = strrchr(path, '.');

    if (p == NULL || (lastSlash != NULL && lastSlash >= p)) {
        p = "";
    }
    Jsi_ValueMakeStringDup(interp, ret, p);
    return JSI_OK;

}
static int FileTailCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *lastSlash = strrchr(path, '/');

    if (lastSlash) {
        Jsi_ValueMakeStringDup(interp, ret, lastSlash+1);
    }
    else {
        Jsi_ValueMakeStringDup(interp, ret, path);
    }
    return JSI_OK;
}

static int FileRealpathCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    char *newname = Jsi_FileRealpath(interp, path, NULL);
    if (newname)
        Jsi_ValueMakeString(interp, ret, (char*)newname);
    return JSI_OK;

}

static int FileJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    const char *path1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *path2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    Jsi_Value *p2 = Jsi_ValueArrayIndex(interp, args, 1);

    char *newname;
    if (*path2 == '/' || *path2 == '~')
        newname = Jsi_FileRealpath(interp, p2, NULL);
    else {
        Jsi_DString dStr = {};
        Jsi_DSAppend(&dStr, path1, "/", path2, NULL);
        Jsi_Value *tpPtr = Jsi_ValueNew1(interp);
        Jsi_ValueMakeStringDup(interp, &tpPtr, Jsi_DSValue(&dStr));
        newname = Jsi_FileRealpath(interp, tpPtr, NULL);
        Jsi_DSFree(&dStr);
        Jsi_DecrRefCount(interp, tpPtr);
    }
    if (newname ==  NULL)
        return JSI_ERROR;
    Jsi_ValueMakeString(interp, ret, (char*)newname);
    return JSI_OK;
}

static int FileSizeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *path = Jsi_ValueArrayIndex(interp, args, 0);
    int rc;
    Jsi_StatBuf st;
    SAFEACCESS(path, 0)
    if (Jsi_ValueArrayIndex(interp, args, 1))
        rc = Jsi_Lstat(interp, path, &st);
    else
        rc = Jsi_Stat(interp, path, &st);
    if (rc != 0) {
        Jsi_LogError("bad file");
        return JSI_ERROR;
    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)st.st_size);
    return JSI_OK;
}

typedef struct {
    int max;            /* Max number of results to return. */
    Jsi_Bool recurse;        /* Recurse into directories. */
    Jsi_Bool tails;          /* Return only the tails. */
    int maxDepth;       /* For recursive */
    int flags;
    int (*filter)(const Jsi_Dirent *);
    int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**);
    Jsi_Value *types;   /* File types to include */
    Jsi_Value *notypes; /* File types to exclude */
    Jsi_Value *func;    /* Function that returns true to keep. */
    Jsi_Value *dirfunc;    /* Function that returns true to recurse into dir. */
    Jsi_Value *dir;
    const char *prefix;
   // Jsi_Value *perms;
} GlobData;

static Jsi_OptionSpec GlobOptions[] = {
    JSI_OPT(VALUE,  GlobData, dir,      .help="Directory"),
    JSI_OPT(INT,    GlobData, maxDepth, .help="Max depth to recurse to"),
    JSI_OPT(FUNC,   GlobData, dirfunc,  .help="Returns true to recurse into dir"),
    JSI_OPT(FUNC,   GlobData, func,     .help="Function that returns true to keep"),
    JSI_OPT(INT,    GlobData, max,      .help="Max results to return"),
    JSI_OPT(VALUE,  GlobData, notypes,  .help="File types to exclude, one or more of chars 'fdlpsbc' for file, directory, link, etc"),
//  JSI_OPT(STRING, GlobData, perms,    .help="File permissions"),
    JSI_OPT(STRKEY, GlobData, prefix,   .help="String prefix to add to each file in list"),
    JSI_OPT(BOOL,   GlobData, recurse,  .help="Recurse into directories"),
    JSI_OPT(BOOL,   GlobData, tails,    .help="Return only the tails"),
    JSI_OPT(VALUE,  GlobData, types,    .help="File types to include, one or more of chars 'fdlpsbc' for file, directory, link, etc"),
    JSI_OPT_END(GlobData)
};

static int SubGlobDirectory(Jsi_Interp *interp, Jsi_Obj *obj, char *zPattern, Jsi_Value *
pattern,  int isreg, char *path, const char *prefix, GlobData *opts, int deep)
{
    struct dirent **namelist;
    int i, n, rc = JSI_OK, flags = opts->flags;
    Jsi_DString tStr = {};
    Jsi_Value *rpPath = Jsi_ValueNew1(interp);
    Jsi_ValueMakeStringDup(interp, &rpPath, path);
    
    if ((n=Jsi_Scandir(interp, rpPath, &namelist, 0, 0)) < 0) {
        Jsi_LogError("bad directory");
        Jsi_DecrRefCount(interp, rpPath);
        return JSI_ERROR;
    }

    for (i=0; i<n && rc == JSI_OK; i++)
    {
        int ftyp;
        const char *z = namelist[i]->d_name;
        if (*z == '.') {
            if (!(flags&JSI_FILE_TYPE_HIDDEN))
                continue;
            else if ((z[1] == 0 || (z[1] == '.' && z[2] == 0)))
                continue;
        }
#ifdef __WIN32
        /* HACK in scandir(): if is directory then inode set to 1. */
        ftyp = (namelist[i]->d_ino? DT_DIR : DT_REG);
#else
        ftyp = namelist[i]->d_type;
#endif
        if (ftyp == DT_DIR) {
            if (opts->recurse && (opts->maxDepth<=0 || (deep+1) <= opts->maxDepth)) {
                Jsi_DString sStr = {}, pStr = {};
                Jsi_DSAppend(&sStr, path, "/", z, NULL);
                if (opts->tails==0)
                    Jsi_DSAppend(&pStr, prefix?prefix:"", prefix?"/":"", z, NULL);
                if (opts->dirfunc) {
                    if (!Jsi_FunctionInvokeBool(interp, opts->dirfunc,
                        Jsi_ValueNewStringDup(interp, Jsi_DSValue(&pStr))))
                        continue;
                }       
                rc = SubGlobDirectory(interp, obj, zPattern, pattern,
                    isreg, Jsi_DSValue(&sStr), Jsi_DSValue(&pStr), opts, deep+1);
                Jsi_DSFree(&sStr);
                Jsi_DSFree(&pStr);
                if (rc != JSI_OK)
                    goto done;
            }
            if (opts->types==0 && opts->notypes && (!(flags&JSI_FILE_TYPE_DIRS)))
                continue;
        } else {
            if (!(flags&JSI_FILE_TYPE_FILES))
                continue;
        }
        if (opts->types) {
            const char *cp = Jsi_ValueString(interp, opts->types, 0);
            int mat = 0;
            while (cp && *cp && !mat) {
                mat = 0;
                switch (*cp) {
                    case 'd': mat = (ftyp == DT_DIR); break;
                    case 'f': mat = (ftyp == DT_REG); break;
#ifndef __WIN32
                    case 'p': mat = (ftyp == DT_FIFO); break;
                    case 's': mat = (ftyp == DT_SOCK); break;
                    case 'l': mat = (ftyp == DT_LNK); break;
                    case 'c': mat = (ftyp == DT_CHR); break;
                    case 'b': mat = (ftyp == DT_BLK); break;
#endif
                }
                cp++;
            }
            if (!mat)
                continue;
        }
        if (opts->notypes) {
            const char *cp = Jsi_ValueString(interp, opts->notypes, 0);
            int mat = 0;
            while (cp && *cp && !mat) {
                mat = 0;
                switch (*cp) {
                    case 'd': mat = (ftyp == DT_DIR); break;
                    case 'f': mat = (ftyp == DT_REG); break;
#ifndef __WIN32
                    case 'p': mat = (ftyp == DT_FIFO); break;
                    case 's': mat = (ftyp == DT_SOCK); break;
                    case 'l': mat = (ftyp == DT_LNK); break;
                    case 'c': mat = (ftyp == DT_CHR); break;
                    case 'b': mat = (ftyp == DT_BLK); break;
#endif
                }
                cp++;
            }
            if (mat)
                continue;
        }

        if (isreg) {
           int ismat;
            Jsi_RegExpMatch(interp, pattern, z, &ismat, NULL);
            if (!ismat)
                continue;
        } else if (zPattern != NULL && Jsi_GlobMatch(zPattern, z, 0) == 0)
            continue;
        if (prefix) {
            Jsi_DSInit(&tStr);
            Jsi_DSAppend(&tStr, prefix, "/", z, NULL);
            z = Jsi_DSValue(&tStr);
        }
        if (opts->func) {
            if (!Jsi_FunctionInvokeBool(interp, opts->func,
                Jsi_ValueNewStringDup(interp, z)))
                continue;
        }       
        rc = Jsi_ObjArrayAdd(interp, obj, Jsi_ValueNewStringDup(interp, z));
        if (prefix)
            Jsi_DSFree(&tStr);
        if (opts->max>0 && obj->arrCnt >= opts->max)
            break;
            
    }

done:
    if (rpPath)
        Jsi_DecrRefCount(interp, rpPath);
    if (namelist) {
        while (--n >= 0)
            Jsi_Free(namelist[n]);
        Jsi_Free(namelist);
    }
    return rc;     
}
#define FN_glob JSI_INFO("\
With no arguments (or null) returns all files/directories in current directory. \
If first argument is a pattern (either a glob or regexp) just files are returned. \
If second argument is a string, it denotes the directory to search in. \
If second argument is a function, this function is called with each path. \
Otherwise second arugment is a set of options.")
static int FileGlobCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int fo = 1, isOpts = 0, rc = JSI_OK;
    Jsi_Value *pat = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *dir = NULL;
    Jsi_Value *tvPtr = Jsi_ValueNew1(interp);
    Jsi_Value *pvPtr = Jsi_ValueNew1(interp);
    GlobData Data;
    Jsi_Obj *obj;
    int len, isreg = 0;
    char *zPattern = NULL, *pathPtr;

    memset(&Data, 0, sizeof(Data));
    Data.flags = JSI_FILE_TYPE_FILES;

    if (pat == NULL || Jsi_ValueIsNull(interp, pat)) {
        Jsi_ValueMakeStringKey(interp, &pvPtr, "*");
        pat = pvPtr;
        Data.flags = JSI_FILE_TYPE_DIRS|JSI_FILE_TYPE_FILES;
    } else if (Jsi_ValueIsString(interp, pat)) {
        char *cpp, *pstr = Jsi_ValueString(interp, pat, NULL);
        if (pstr && ((cpp=strrchr(pstr, '/')))) {
            Jsi_DString dStr = {};
            Jsi_DSAppendLen(&dStr, pstr, (cpp-pstr));
            Jsi_ValueMakeStringKey(interp,  &tvPtr, Jsi_DSValue(&dStr));
            dir = tvPtr;
            
            Jsi_DSSetLength(&dStr, 0);
            Jsi_DSAppend(&dStr, cpp+1, NULL);
            Jsi_ValueMakeStringKey(interp,  &pvPtr, Jsi_DSValue(&dStr));
            pat = pvPtr;
            Jsi_DSFree(&dStr);
        }
    }
    if (arg)
        switch (arg->vt) {
        case JSI_VT_NULL: break;
        case JSI_VT_STRING: dir = arg; break;
        case JSI_VT_OBJECT:
        {
            Jsi_Obj *obj = arg->d.obj;
            switch (obj->ot) {
                case JSI_VT_STRING: dir = arg; break;
                case JSI_VT_OBJECT:
                    if (Jsi_ValueIsFunction(interp, arg)) {
                        Data.func = arg;
                        break;
                    } else if (!obj->isarrlist) {
                        isOpts = 1;
                        break;
                    }
                default: fo = 0;
            }
            if (fo) break;
        }
        default:
            Jsi_LogError("expected string, function or options for arg2");
            rc = JSI_ERROR;
            goto done;
    }
    if (isOpts && Jsi_OptionsProcess(interp, GlobOptions, arg, &Data, 0) < 0) {
        rc = JSI_ERROR;
        goto done;
    }
    if (Data.dir) {
        if (dir) {
            Jsi_LogError("multiple dirs specified");
            rc = JSI_ERROR;
            goto done;
        }
        dir = Data.dir;
    }
    if (dir == NULL) {
        Jsi_ValueMakeStringKey(interp, &tvPtr, ".");
        dir = tvPtr;
    } else {
        char *dcp = Jsi_ValueString(interp, dir, NULL);
        if (dcp && *dcp == '~') {
            dcp = Jsi_FileRealpath(interp, dir, NULL);
            if (dcp) {
                Jsi_ValueMakeString(interp, &tvPtr, dcp);
                dir = tvPtr;
            }
        }
    }
    if (interp->isSafe && Jsi_InterpAccess(interp, dir, 0) != JSI_OK) {
        Jsi_LogError("read access denied");
        rc = JSI_ERROR;
        goto done;
    }

    if (!(isreg=Jsi_ValueIsObjType(interp, pat, JSI_OT_REGEXP)))
        zPattern = Jsi_ValueString(interp, pat, &len);
    pathPtr = Jsi_ValueString(interp, dir, &len);
    if (!pathPtr) { rc = JSI_ERROR; goto done; }
    if (len && pathPtr[len-1] == '/')
        len--;
    obj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, obj);
    rc = SubGlobDirectory(interp, obj, zPattern, pat, isreg, pathPtr, Data.prefix, &Data, 0);
    if (rc != JSI_OK)
        Jsi_ValueMakeUndef(interp, ret);   
done:
    if (pvPtr)
        Jsi_DecrRefCount(interp, pvPtr);
    if (tvPtr)
        Jsi_DecrRefCount(interp, tvPtr);
    if (isOpts)
        Jsi_OptionsFree(interp, GlobOptions, &Data, 0);
    return rc;
}

static Jsi_CmdSpec fileCmds[] = {
    { "atime",      FileAtimeCmd,       1,  1, "file:string",  .help="Return file Jsi_Access time", .retType=(uint)JSI_TT_NUMBER },
    { "chdir",      FileChdirCmd,       1,  1, "file:string",  .help="Change current directory" },
    { "chmod",      FileChmodCmd,       2,  2, "file:string, mode:string",  .help="Set file permissions" },
    { "copy",       FileCopyCmd,        2,  3, "src:string, dest:string, force:boolean=false",  .help="Copy a file to destination", .info=FN_copy },
    { "dirname",    FileDirnameCmd,     1,  1, "file:string",  .help="Return directory path", .retType=(uint)JSI_TT_STRING },
    { "executable", FileExecutableCmd,  1,  1, "file:string",  .help="Return true if file is executable", .retType=(uint)JSI_TT_BOOL },
    { "exists",     FileExistsCmd,      1,  1, "file:string",  .help="Return true if file exists", .retType=(uint)JSI_TT_BOOL },
    { "extension",  FileExtensionCmd,   1,  1, "file:string",  .help="Return file extension", .retType=(uint)JSI_TT_STRING },
    { "join",       FileJoinCmd,        2,  2, "path:string, path:string",  .help="Join two file realpaths, or just second if an absolute path", .retType=(uint)JSI_TT_STRING },
    { "isdir",      FileIsdirCmd,       1,  1, "file:string",  .help="Return true if file is a directory", .retType=(uint)JSI_TT_BOOL },
    { "isfile",     FileIsfileCmd,      1,  1, "file:string",  .help="Return true if file is a normal file", .retType=(uint)JSI_TT_BOOL },
    { "glob",       FileGlobCmd,        0,  2, "pattern:regexp|string|null='*', options:string|boolean|object=void", .help="Return list of files in dir with optional pattern match", .opts=GlobOptions, .info=FN_glob, .retType=(uint)JSI_TT_ARRAY },
    { "link",       FileLinkCmd,        2,  3, "src:string, dest:string, ishard:boolean=false",  .help="Link a file", .info=FN_link },
    { "lstat",      FileLstatCmd,       1,  1, "file:string",  .help="Return status info for file", .retType=(uint)JSI_TT_OBJECT },
    { "mkdir",      FileMkdirCmd,       1,  1, "file:string",  .help="Create a directory" },
    { "mtime",      FileMtimeCmd,       1,  1, "file:string",  .help="Return file modified time", .retType=(uint)JSI_TT_NUMBER },
    { "owned",      FileOwnedCmd,       1,  1, "file:string",  .help="Return true if file is owned by user", .retType=(uint)JSI_TT_BOOL },
    { "pwd",        FilePwdCmd,         0,  0, "",  .help="Return current directory", .retType=(uint)JSI_TT_STRING },
    { "remove",     FileRemoveCmd,      1,  2, "file:string, force:boolean=false",  .help="Delete a file or direcotry" },
    { "rename",     FileRenameCmd,      2,  3, "src:string, dest:string, force:boolean=false",  .help="Rename a file, with possible overwrite" },
    { "read",       FileReadCmd,        1,  2, "file:string, mode:string='rb'",  .help="Read a file", .retType=(uint)JSI_TT_STRING },
    { "readable",   FileReadableCmd,    1,  1, "file:string",  .help="Return true if file is readable", .retType=(uint)JSI_TT_BOOL },
    { "readlink",   FileReadlinkCmd,    1,  1, "file:string",  .help="Read file link destination", .retType=(uint)JSI_TT_STRING },
    { "realpath",   FileRealpathCmd,    1,  1, "file:string",  .help="Return absolute file name minus .., ./ etc.", .retType=(uint)JSI_TT_STRING },
    { "rootname",   FileRootnameCmd,    1,  1, "file:string",  .help="Return file name minus extension", .retType=(uint)JSI_TT_STRING },
    { "size",       FileSizeCmd,        1,  1, "file:string",  .help="Return size for file", .retType=(uint)JSI_TT_NULL },
    { "stat",       FileStatCmd,        1,  1, "file:string",  .help="Return status info for file", .retType=(uint)JSI_TT_OBJECT },
    { "tail",       FileTailCmd,        1,  1, "file:string",  .help="Return file name minus dirname", .retType=(uint)JSI_TT_STRING },
    { "tempfile",   FileTempfileCmd,    1,  1, "file:string",  .help="Create a temp file", .retType=(uint)JSI_TT_ANY },
    { "truncate",   FileTruncateCmd,    2,  2, "file:string, size:number",  .help="Truncate file" },
    { "type",       FileTypeCmd,        1,  1, "file:string",  .help="Return type of file", .retType=(uint)JSI_TT_STRING },
    { "write",      FileWriteCmd,       2,  3, "file:string, str:string, mode:string='wb+'",  .help="Write a file", .retType=(uint)JSI_TT_NUMBER },
    { "writable",   FileWritableCmd,    1,  1, "file:string",  .help="Return true if file is writable", .retType=(uint)JSI_TT_BOOL },
    { NULL, .help="Commands for accessing the filesystem" }
};

int jsi_FileCmdsInit(Jsi_Interp *interp)
{
    Jsi_CommandCreateSpecs(interp, "File",   fileCmds,   NULL, JSI_CMDSPEC_NOTOBJ);
    return JSI_OK;
}
#endif
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

/******************* TREE ACCESS **********************/

Jsi_Value *Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey) {
    Jsi_Tree *treePtr = obj->tree;
    
    if (!isstrkey) {
        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(treePtr->interp->strKeyTbl, key);
        if (!hPtr)
            return NULL;
        key = (const char*)Jsi_HashKeyGet(hPtr);
    }
    Jsi_Value *v = (Jsi_Value*)Jsi_TreeGet(treePtr, (void*)key);
    return v;
}

Jsi_TreeEntry *Jsi_TreeObjSetValue(Jsi_Obj *obj, const char *key, Jsi_Value *val, int isstrkey) {
    Jsi_Tree *treePtr = obj->tree;
    int isNew;
    Jsi_TreeEntry *hPtr;
    Jsi_Interp *interp = treePtr->interp;
    if (!isstrkey) {
        Jsi_HashEntry *hePtr = Jsi_HashEntryNew(interp->strKeyTbl, key, &isNew);
        key = (const char*)Jsi_HashKeyGet(hePtr);
    }
    //return Jsi_TreeSet(treePtr, key, val);
    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);
    if (!hPtr)
        return NULL;
    if (val)
        SIGASSERT(val,VALUE);
    if (!isNew)
        Jsi_ValueReplace(interp, (Jsi_Value**)&(hPtr->value), val);
    else {
        hPtr->value = val;
        if (val)
            Jsi_IncrRefCount(interp, val);
    }
//    Jsi_Value *oldVal;  /* FYI: This let kitty.breed() work in tests/proto2.js */
//    Assert(val->refCnt>0);
//    if (!isNew) {
//        oldVal = Jsi_TreeValueGet(hPtr);
//        if (oldVal) {
//            Jsi_ValueReset(interp, &oldVal);
//            Jsi_ValueCopy(interp, oldVal, val);
//        }
//    }
//    else
//        hPtr->value = val;

    return hPtr;
}

/*****************************************/

int Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o)  {
    return ((o)->ot == JSI_OT_OBJECT && o->isarrlist);
}

static int ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    Jsi_Interp *interp = tree->interp;
    Jsi_Obj *obj = (Jsi_Obj*)data;
    int n;
    if (!hPtr->f.bits.dontenum) {
        char *cp = (char*)Jsi_TreeKeyGet(hPtr), *ocp = cp;
        /* TODO: accept hex??? */
        while (*cp && isdigit(*cp))
            cp++;
        if (*cp)
            return JSI_OK;
        n = atoi(ocp);
        if (n >= tree->interp->maxArrayList)
            return JSI_OK;
        hPtr->f.bits.isarrlist = 1;
        if (Jsi_ObjArraySizer(tree->interp, obj, n) <= 0) {
            Jsi_LogError("too long");
            return JSI_ERROR;
        }
        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
       // obj->arrCnt++;
    }
    return JSI_OK;
}

static int ObjListifyArrayCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)
{
    if (hPtr->f.bits.isarrlist) {
        Jsi_TreeEntryDelete(hPtr);
        tree->interp->delRBCnt++;
        return JSI_ERROR;
    }
    return JSI_OK;
}

void Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj)
{
    if (!obj->isarrlist) {
        Jsi_LogBug("Can not listify a non-array\n");
        return;
    }
    if (obj->arr) return;
    Jsi_TreeWalk(obj->tree, ObjListifyCallback, obj, 0);

    do {
        interp->delRBCnt = 0;
        Jsi_TreeWalk(obj->tree, ObjListifyArrayCallback, obj, 0);
    } while (interp->delRBCnt);
}

void jsi_IterObjFree(Jsi_IterObj *iobj)
{
    if (!iobj->isArrayList) {
        int i;
        for (i = 0; i < iobj->count; i++) {
            if (iobj->keys[i]) {
                /*Jsi_TreeDecrRef(iobj->keys[i]); TODO: ??? */
            }
        }
        Jsi_Free(iobj->keys);
    }
    Jsi_Free(iobj);
}

Jsi_IterObj *jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterCmd)
{
    Jsi_IterObj *o = (Jsi_IterObj*)Jsi_Calloc(1,sizeof(Jsi_IterObj));
    o->interp = interp;
    SIGINIT(o,OBJ);
    o->iterCmd = iterCmd;
    return o;
}

static int DeleteTreeValue(Jsi_Interp *interp, void *p) {
    /* Cleanup tree value. */
    Jsi_TreeEntry* ti = (Jsi_TreeEntry*)p;
    SIGASSERT(ti,TREEENTRY);
    Jsi_Value *v = (Jsi_Value*)ti->value;
    SIGASSERT(v,VALUE);
    Jsi_DecrRefCount(interp, v);
    ti->value = NULL;
    return JSI_OK;
}

Jsi_Obj *jsi_ObjNew_(Jsi_Interp *interp)
{
    Jsi_Obj *obj = (Jsi_Obj*)Jsi_Calloc(1,sizeof(*obj));
    SIGINIT(obj,OBJ);
    jsi_DebugObj(obj,"New", jsi_DebugValueCallIdx(), interp);
    obj->ot = JSI_OT_OBJECT;
    obj->tree = Jsi_TreeNew(interp, JSI_KEYS_STRINGKEY, NULL);
    obj->tree->freeProc = DeleteTreeValue;
    obj->tree->flags.valuesonly = 1;
    obj->__proto__ = interp->Object_prototype;
    interp->dbPtr->objCnt++;
    interp->dbPtr->objAllocCnt++;
   return obj;
}

#ifndef JSI_MEM_DEBUG
Jsi_Obj * Jsi_ObjNew(Jsi_Interp *interp) {
    return jsi_ObjNew_(interp);
}
#else
Jsi_Obj * jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {
    Jsi_Obj *obj = jsi_ObjNew_(interp);
    jsi_ValueDebugUpdate(interp, obj, objDebugTbl, fname, line, func);
    return obj;
}

#ifndef JSI_OMIT_STUBS
#undef Jsi_ObjNew
Jsi_Obj *Jsi_ObjNew(Jsi_Interp *interp) { return jsi_ObjNew_(interp); }
#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)
#endif

#endif

Jsi_Obj *Jsi_ObjNewType(Jsi_Interp *interp, Jsi_otype otype)
{
    Jsi_Obj *obj = Jsi_ObjNew(interp);
    obj->ot = (otype==JSI_OT_ARRAY?JSI_OT_OBJECT:otype);
    switch (otype) {
        case JSI_OT_OBJECT: obj->__proto__ = interp->Object_prototype; break;
        case JSI_OT_BOOL:   obj->__proto__ = interp->Boolean_prototype; break;
        case JSI_OT_NUMBER: obj->__proto__ = interp->Number_prototype; break;
        case JSI_OT_STRING: obj->__proto__ = interp->String_prototype; break;
        case JSI_OT_FUNCTION:obj->__proto__ = interp->Function_prototype; break;
        case JSI_OT_REGEXP: obj->__proto__ = interp->RegExp_prototype; break;
        case JSI_OT_ARRAY:  obj->__proto__ = interp->Array_prototype;
            obj->isarrlist = 1;
            break;
        default: assert(0); break;
    }
    return obj;
}

void Jsi_ObjFree(Jsi_Interp *interp, Jsi_Obj *obj)
{
    interp->dbPtr->objCnt--;
    //assert(obj->refcnt == 0);
#ifdef JSI_MEM_DEBUG
    jsi_DebugObj(obj,"Free", jsi_DebugValueCallIdx(), interp);
    if (obj->VD.hPtr)
        Jsi_HashEntryDelete(obj->VD.hPtr);
#endif
    /* printf("Free obj: %x\n", (int)obj); */
    switch (obj->ot) {
        case JSI_OT_STRING:
            if (!obj->isstrkey)
                Jsi_Free(obj->d.s.str);
            obj->d.s.str = 0;
            obj->isstrkey = 0;
            break;
        case JSI_OT_FUNCTION:
            jsi_FuncObjFree(obj->d.fobj);
            break;
        case JSI_OT_ITER:
            jsi_IterObjFree(obj->d.iobj);
            break;
        case JSI_OT_USEROBJ:
            jsi_UserObjFree(interp, obj->d.uobj);
            break;
        case JSI_OT_REGEXP:
            if ((obj->d.robj->eflags&JSI_REG_STATIC)==0) {
                regfree(&obj->d.robj->reg);
                Jsi_Free(obj->d.robj);
            }
            break;
        default:
            break;
    }
    if (obj->tree)
        Jsi_TreeDelete(obj->tree);
    if (obj->arr) {
        int i = -1;
        while (++i < obj->arrCnt)
            if (obj->arr[i])
                Jsi_DecrRefCount(interp, obj->arr[i]);
        Jsi_Free(obj->arr);
        obj->arr = NULL;
    }
    obj->tree = NULL;
    if (obj->clearProto)
        Jsi_DecrRefCount(interp, obj->__proto__);
    MEMCLEAR(obj);
    Jsi_Free(obj);
}


/**************************** ARRAY ******************************/

Jsi_Value *jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key) {
    const char *cp = key;
    int n;
    /* TODO: accept hex??? */
    if (!obj->arr)
        return NULL;
    while (*cp && isdigit(*cp))
        cp++;
    if (*cp)
        return NULL;
    n = atoi(key);
    if (n >= obj->arrCnt)
        return NULL;
    Jsi_Value *v = obj->arr[n];
    return v;
}

int Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v)
{
    if (o->isarrlist == 0)
        return JSI_ERROR;
    if (!o->arr)
        Jsi_ObjListifyArray(interp, o);
    int len = o->arrCnt;
    if (Jsi_ObjArraySizer(interp, o, len+1) <= 0)
        return JSI_ERROR;
    o->arr[len] = v;
    if (v)
        Jsi_IncrRefCount(interp, v);
    assert(o->arrCnt<=o->arrMaxSize);
    return JSI_OK;
}

int Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)
{
    int m, n = arrayindex;
    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)
        return JSI_ERROR;
    if (obj->arr[n] == value)
        return JSI_OK;
    if (obj->arr[n])
        Jsi_DecrRefCount(interp, obj->arr[n]);
    Assert(obj->arrCnt<=obj->arrMaxSize);
    obj->arr[n] = value;
    if (value)
        Jsi_IncrRefCount(interp, value);
    m = Jsi_ObjGetLength(interp, obj);
    if ((n+1) > m)
       Jsi_ObjSetLength(interp, obj, n+1);
    return JSI_OK;
}

// Copying version of above.
Jsi_Value *jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int n)
{
    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)
        return NULL;
    if (obj->arr[n])
    {
        Jsi_ValueCopy(interp, obj->arr[n], value);
        return obj->arr[n];
    }
    Assert(obj->arrCnt<=obj->arrMaxSize);
    Jsi_Value *v = Jsi_ValueNew1(interp);
    int m;
    Jsi_ValueCopy(interp,v, value);
    obj->arr[n] = v;
    m = Jsi_ObjGetLength(interp, obj);
    if ((n+1) > m)
       Jsi_ObjSetLength(interp, obj, n+1);
    return v;
}

int Jsi_ObjIncrRefCount(Jsi_Interp *interp, Jsi_Obj *obj) {
    jsi_DebugObj(obj,"Incr", jsi_DebugValueCallIdx(), interp);
    SIGASSERT(obj,OBJ);
    Assert(obj->refcnt>=0);
    return ++obj->refcnt;
}

int Jsi_ObjDecrRefCount(Jsi_Interp *interp, Jsi_Obj *obj)  {
    SIGASSERT(obj,OBJ);
    if (obj->refcnt<0) {
        //Jsi_LogBug("Obj double free: %p", obj);
        return -2;
    }
    jsi_DebugObj(obj,"Decr", jsi_DebugValueCallIdx(), interp);
    int nref;
    if ((nref = --obj->refcnt) <= 0) {
        obj->refcnt = -1;
        Jsi_ObjFree(interp, obj);
    }
    return nref;
}


int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, int len)
{
    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;
    assert(obj->isarrlist);
    if (mod>1)
        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);
    if (nsiz > MAX_ARRAY_LIST) {
        Jsi_LogError("array size too large");
        return 0;
    }
    if (len >= obj->arrMaxSize) {
        int oldsz = (nsiz-obj->arrMaxSize);
        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));
        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));
        obj->arrMaxSize = nsiz;
    }
    if (len>obj->arrCnt)
        obj->arrCnt = len;
    return nsiz;
}

Jsi_Obj *Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copyflag)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
    if (count>=0) {
        int i;
        if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {
            Jsi_ObjFree(interp, obj);
            return NULL;
        }
        for (i = 0; i < count; ++i) {
            if (!copyflag) {
                obj->arr[i] = items[i];
                Jsi_IncrRefCount(interp, items[i]);
            } else {
                obj->arr[i] = Jsi_ValueNew1(interp);
                Jsi_ValueCopy(interp, obj->arr[i], items[i]);
            }
        }
    }
    obj->arrCnt = count;
    assert(obj->arrCnt<=obj->arrMaxSize);
    return obj;
}

/****** END ARRAY ************/

static Jsi_TreeEntry* ObjInsertFromValue(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *keyVal, Jsi_Value *nv)
{
    const char *key = NULL;
    int flags = 0;
    Jsi_DString dStr = {};
    if (keyVal->vt == JSI_VT_STRING) {
        flags = (keyVal->f.bits.isstrkey ? JSI_OM_ISSTRKEY : 0);
        key = keyVal->d.s.str;
    } else if (keyVal->vt == JSI_VT_OBJECT && keyVal->d.obj->ot == JSI_OT_STRING) {
        Jsi_Obj *o = keyVal->d.obj;
        flags = (o->isstrkey ? JSI_OM_ISSTRKEY : 0);
        key = o->d.s.str;
    }
    if (key == NULL)
        key = Jsi_ValueGetDString(interp, keyVal, &dStr, 0);
    return Jsi_ObjInsert(interp, obj, key, nv, flags);
}

Jsi_Obj *Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count)
{
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    int i;
    for (i = 0; i < count; i += 2) {
        Jsi_Value *v = Jsi_ValueDup(interp, items[i+1]);
        ObjInsertFromValue(interp, obj, items[i], v);
        Jsi_DecrRefCount(interp, v);
    }
    return obj;
}

void Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, int len)
{
    if (obj->isarrlist) {
        assert(len<=obj->arrMaxSize);
        obj->arrCnt = len;
        return;
    }
    Jsi_Value *r = Jsi_TreeObjGetValue(obj,"length", 0);
    if (!r) {
        Jsi_Value *n = Jsi_ValueMakeNumber(interp, NULL, len);
        Jsi_ObjInsert(interp, obj, "length", n, JSI_OM_DONTDEL | JSI_OM_DONTENUM | JSI_OM_READONLY);
    } else {
        Jsi_ValueReset(interp, &r);
        Jsi_ValueMakeNumber(interp, &r, len);
    }
}

int Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj)
{
    if (obj->tree && obj->tree->numEntries) {
        Jsi_Value *r = Jsi_TreeObjGetValue(obj, "length", 0);
        Jsi_Number nr;
        if (r && Jsi_GetNumberFromValue(interp,r, &nr) == JSI_OK) {
            if (jsi_is_integer(nr))
                return nr;
        }
    }
    if (obj->arr)
        return obj->arrCnt;

    return 0;
}

Jsi_Value *jsi_ObjValueNew(Jsi_Interp *interp)
{
    return Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNew(interp));
}


/* Set result string into obj. */
void Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj) {
    int len = dsPtr->len;
    if (obj->ot == JSI_OT_STRING && obj->d.s.str && !obj->isstrkey)
        Jsi_Free(obj->d.s.str);
    if (dsPtr->str == dsPtr->staticSpace) {
        obj->d.s.str = (char*)Jsi_Malloc(len+1);
        memcpy(obj->d.s.str, dsPtr->str, len+1);
    } else {
        obj->d.s.str = dsPtr->str;
    }
    obj->d.s.len = len;
    dsPtr->str = dsPtr->staticSpace;
    dsPtr->spaceAvl = dsPtr->staticSize;
    dsPtr->staticSpace[0] = 0;
    dsPtr->len = 0;
}
#endif
#ifndef JSI_LITE_ONLY
#include <signal.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#ifndef JSI_AMALGAMATION
/* Adapted to update so "signal.handle(func) gets called back like setInterval/setTimeout */
#include "jsiInt.h"
#endif
#ifndef JSI_OMIT_SIGNAL

enum { SIGNAL_ACTION_IGNORE=-1,  SIGNAL_ACTION_DEFAULT=0, SIGNAL_ACTION_HANDLE=1, MAX_SIGNALS = (sizeof(Jsi_Wide) * 8)};

static Jsi_Wide *sigloc;
static Jsi_Wide sigsblocked;
static struct sigaction *saOldPtr[MAX_SIGNALS] = {NULL};
static struct sigaction saOld[MAX_SIGNALS];
static int signal_handling[MAX_SIGNALS] = {0};

/* Make sure to do this as a wide, not int */
#define sig_to_bit(SIG) ((Jsi_Wide)1 << (SIG))

static void signal_handler(int sig)
{
    /* We just remember which signals occurred. Jsi_Eval() will
     * notice this as soon as it can and throw an error
     */
    *sigloc |= sig_to_bit(sig);
}

static void signal_ignorer(int sig)
{
    /* We just remember which signals occurred */
    sigsblocked |= sig_to_bit(sig);
}

#define CASESIGNAL(name) case SIG##name: return "SIG" #name;

const char *Jsi_SignalId(int sig)
{
    switch (sig) {
    CASESIGNAL(ABRT); CASESIGNAL(ALRM); CASESIGNAL(BUS);  CASESIGNAL(CONT);   CASESIGNAL(FPE);
    CASESIGNAL(HUP);  CASESIGNAL(ILL);  CASESIGNAL(INT);  CASESIGNAL(KILL);   CASESIGNAL(PIPE);
    CASESIGNAL(PROF); CASESIGNAL(QUIT); CASESIGNAL(SEGV); CASESIGNAL(STOP);   CASESIGNAL(SYS);
    CASESIGNAL(TERM); CASESIGNAL(TRAP); CASESIGNAL(TSTP); CASESIGNAL(TTIN);   CASESIGNAL(TTOU);
    CASESIGNAL(URG);  CASESIGNAL(USR1); CASESIGNAL(USR2); CASESIGNAL(VTALRM); CASESIGNAL(WINCH);
    CASESIGNAL(XCPU);
    CASESIGNAL(XFSZ);
#ifdef SIGPWR
    CASESIGNAL(PWR);
#endif
#ifdef SIGCLD
    CASESIGNAL(CLD);
#endif
#ifdef SIGEMT
    CASESIGNAL(EMT);
#endif
#ifdef SIGLOST
    CASESIGNAL(LOST);
#endif
#ifdef SIGIO
    CASESIGNAL(IO);
#endif
#if defined(SIGPOLL) && (SIGPOLL != SIGIO)
    CASESIGNAL(POLL);
#endif
#ifdef SIGINFO
    CASESIGNAL(INFO);
#endif
    }
    return NULL;
}

const char *Jsi_SignalName(int sig)
{
    const char *cp;
#ifdef HAVE_SYS_SIGLIST
    if (sig >= 0 && sig < NSIG) {
        return sys_siglist[sig];
    }
#endif
    cp = Jsi_SignalId(sig);
    if (cp == NULL)
        cp = "unknown signal";
    return cp;
}

/**
 * Given the name of a signal, returns the signal value if found,
 * or returns -1 (and sets an error) if not found.
 * We accept -SIGINT, SIGINT, INT or any lowercase version or a number,
 * either positive or negative.
 */
static int find_signal_by_name(Jsi_Interp *interp, const char *name)
{
    int i;
    const char *pt = name;

    /* Remove optional - and SIG from the front of the name */
    if (*pt == '-') {
        pt++;
    }
    if (strncasecmp(name, "sig", 3) == 0) {
        pt += 3;
    }
    if (isdigit(UCHAR(pt[0]))) {
        i = atoi(pt);
        if (i > 0 && i < MAX_SIGNALS) {
            return i;
        }
    }
    else {
        for (i = 1; i < MAX_SIGNALS; i++) {
            /* Jsi_SignalId() returns names such as SIGINT, and
             * returns "unknown signal id" if unknown, so this will work
             */
            if (Jsi_Strncasecmp(Jsi_SignalName(i) + 3, pt, -1) == 0) {
                return i;
            }
        }
    }
    return -1;
}

void jsi_SignalClear(Jsi_Interp *interp, int sigNum) {
    Jsi_Wide nsig = sig_to_bit(sigNum);
    (*sigloc) &= ~nsig;
}

int jsi_SignalIsSet(Jsi_Interp *interp, int sigNum) {
    return (((*sigloc) & sig_to_bit(sigNum)) != 0);
}

static void jsi_SignalSet(Jsi_Interp *interp, int sig) {
    struct sigaction sa;

    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sa.sa_handler = signal_handler;

    if (SIGNAL_ACTION_HANDLE != signal_handling[sig]) {

        if (signal_handling[sig] == SIGNAL_ACTION_DEFAULT) {
            saOldPtr[sig] = &saOld[sig];
            sigaction(sig, &sa, saOldPtr[sig]);
        }
        else {
            sigaction(sig, &sa, 0);
        }
        signal_handling[sig] = SIGNAL_ACTION_HANDLE;
    }
}

static int SignalSub(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int action)
{

    struct sigaction sa;
    int i, argc = Jsi_ValueGetLength(interp, args);
    
    if (&interp->sigmask != sigloc) {
        Jsi_LogWarn("not primary interp");
        return JSI_OK;
    }
    
    if (argc == 0) {
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        int m;
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
        for (i = 0, m = 0; i < MAX_SIGNALS; i++) {
            if (signal_handling[i] == action) {
                /* Add signal name to the list  */
                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, Jsi_SignalName(i)), m++);
            }
        }
        return JSI_OK;
    }

    /* Catch all the signals we care about */
    if (action != SIGNAL_ACTION_DEFAULT) {
        sa.sa_flags = 0;
        sigemptyset(&sa.sa_mask);
        if (action == SIGNAL_ACTION_HANDLE) {
            sa.sa_handler = signal_handler;
        }
        else {
            sa.sa_handler = signal_ignorer;
        }
    }

    /* Iterate through the provided signals */
    for (i = 0; i < argc; i++) {
        char *sstr;
        int sig = find_signal_by_name(interp, sstr=Jsi_ValueArrayIndexToStr(interp,args,i, NULL));

        if (sig < 0) {
            Jsi_LogError("unknown signal: %s", sstr);
            return JSI_ERROR;
        }
        if (action != signal_handling[sig]) {
            /* Need to change the action for this signal */
            switch (action) {
                case SIGNAL_ACTION_HANDLE:
                case SIGNAL_ACTION_IGNORE:
                    if (signal_handling[sig] == SIGNAL_ACTION_DEFAULT) {
                        saOldPtr[sig] = &saOld[sig];
                        sigaction(sig, &sa, saOldPtr[sig]);
                    }
                    else {
                        sigaction(sig, &sa, 0);
                    }
                    break;

                case SIGNAL_ACTION_DEFAULT:
                    /* Restore old handler */
                    sigaction(sig, saOldPtr[sig], NULL);
            }
            signal_handling[sig] = action;
        }
    }

    return JSI_OK;
}

static int SignalHandleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SignalSub(interp, args, _this, ret, funcPtr, SIGNAL_ACTION_HANDLE);
}

static int SignalIgnoreCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SignalSub(interp, args, _this, ret, funcPtr, SIGNAL_ACTION_IGNORE);
}

static int SignalDefaultCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return SignalSub(interp, args, _this, ret, funcPtr, SIGNAL_ACTION_DEFAULT);
}

static int SignalNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    int i, m;
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    for (i=0, m=0; i<MAX_SIGNALS; i++) {
        const char *nam;
        nam = Jsi_SignalId(i);
        if (nam)
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, nam), m++);
    }
    return JSI_OK;
}

static int SignalAlarmCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *sv = Jsi_ValueArrayIndex(interp, args, 0);
    uint rc;
    Jsi_Number dtim;
    
    if (Jsi_GetNumberFromValue(interp, sv, &dtim) != JSI_OK) {
        Jsi_LogError("bad time");
        return JSI_ERROR;
    }
    if (dtim<1)
        rc = ualarm(dtim * 1e6, 0);
    else
        rc = alarm((uint)dtim);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rc);
    return JSI_OK;
}

static int SignalKillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *vpid = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *sv = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Number npid;
    int rc, sigNum = SIGTERM;
    if (Jsi_GetNumberFromValue(interp, vpid, &npid) != JSI_OK) {
        Jsi_LogError("bad pid");
        return JSI_ERROR;
    }
    if (sv) {
        if (sv->vt == JSI_VT_NUMBER)
            sigNum = (int)sv->d.num;
        else {
            char *ts = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
            if ((sigNum = find_signal_by_name(interp, ts)) < 0) {
                Jsi_LogError("bad signal: %s", ts);
                return JSI_ERROR;
            }
        }
    }
    if (sigNum < 0 || sigNum >= MAX_SIGNALS) {
        Jsi_LogError("bad signal: %d", sigNum);
        return JSI_ERROR;
    }
    rc = kill((int)npid, sigNum);
    if (rc != 0) {
        Jsi_LogError("kill failure");
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int SignalCallbackCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int isNew;
    Jsi_Event *ev;
    uint id;
    int sigNum;
    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *sv = Jsi_ValueArrayIndex(interp, args, 1);
    
    if (!Jsi_ValueIsFunction(interp, fv)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    if (sv && sv->vt == JSI_VT_NUMBER)
        sigNum = (int)sv->d.num;
    else {
        char *ts = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
        if ((sigNum = find_signal_by_name(interp, ts)) < 0) {
            Jsi_LogError("expected signal");
            return JSI_ERROR;
        }
    }
    if (sigNum < 0 || sigNum >= MAX_SIGNALS) {
        Jsi_LogError("unknown signal: %d", sigNum);
        return JSI_ERROR;
    }
    while (1) {
        id = interp->eventIdx++;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));
        SIGINIT(ev,EVENT);
        ev->id = id;
        ev->funcVal = fv;
        Jsi_IncrRefCount(interp, fv);
        ev->hPtr = hPtr;
        ev->sigNum = sigNum;
        ev->evType = JSI_EVENT_SIGNAL;
        Jsi_HashValueSet(hPtr, ev);
        break;
    }
    jsi_SignalSet(interp, sigNum);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);
    return JSI_OK;
}


static Jsi_CmdSpec signalCmds[] = {
    { "alarm",      SignalAlarmCmd,       1, 1, "secs", .help="Setup alarm in seconds", .retType=(uint)JSI_TT_NUMBER },
    { "callback",   SignalCallbackCmd,    2, 2, "func:function, sig:number|string",  .help="Setup callback handler for signal", .retType=(uint)JSI_TT_NUMBER },
    { "default",    SignalDefaultCmd,     0,-1, "sig:number|string=void, ...", .help="Set named signals to default action", .retType=(uint)JSI_TT_ARRAY },
    { "handle",     SignalHandleCmd,      0,-1, "sig:number|string=void, ...", .help="Set named signals to handle action", .retType=(uint)JSI_TT_ANY },
    { "ignore",     SignalIgnoreCmd,      0,-1, "sig:number|string=void, ...", .help="Set named signals to ignore action", .retType=(uint)JSI_TT_ANY },
    { "kill",       SignalKillCmd,        1, 2, "pid:number, sig:number|string='SIGTERM'", .help="Send signal to process id", .retType=(uint)JSI_TT_VOID },
    { "names",      SignalNamesCmd,       0, 0, "", .help="Return names of all signals", .retType=(uint)JSI_TT_ARRAY },
    { NULL, .help="Commands for handling unix signals" }
};

int jsi_SignalInit(Jsi_Interp *interp)
{
    static int isinit = 0;
    if (!isinit) {
        sigloc = &interp->sigmask;
        isinit = 1;
    }
    Jsi_CommandCreateSpecs(interp, "Signal",    signalCmds,    NULL, JSI_CMDSPEC_NOTOBJ);
    return JSI_OK;
}

#endif
#endif
/* An implementation of Red-Black Trees with invariant node pointers. 
 * Nodes are allocated using single malloc that includes the key. 
 * This means that string keys (which are of varying length) can not be copied between nodes.
 * So instead of swapping node key/values, positions are swapped when balancing the tree. */

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

enum {_JSI_TREE_RED=0, _JSI_TREE_BLACK=1};

#define GETKEY(t,n) ((t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY) ? n->key.oneWordValue:n->key.string)

/********************** _JSI_TREE_RED/_JSI_TREE_BLACK HELPERS **************************/

static Jsi_TreeEntry* grandparent(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    Assert (n->parent != NULL);
    Assert (n->parent->parent != NULL);
    return n->parent->parent;
}

static Jsi_TreeEntry* sibling(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    Assert (n->parent != NULL);
    return (n == n->parent->left ? n->parent->right : n->parent->left);
}

static Jsi_TreeEntry* uncle(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    Assert (n->parent != NULL);
    Assert (n->parent->parent != NULL);
    return sibling(n->parent);
}

static int node_color(Jsi_TreeEntry* n) {
    return n == NULL ? _JSI_TREE_BLACK : n->f.bits.color;
}

static void set_color(Jsi_TreeEntry* n, int color) {
    if (color == _JSI_TREE_BLACK && n == NULL) return;
    n->f.bits.color = color;
}

static void replace_node(Jsi_TreeEntry* oldn, Jsi_TreeEntry* newn) {
    Assert(oldn);
    Jsi_Tree* t = oldn->treePtr;
    if (oldn->parent == NULL) {
        t->root = newn;
    } else {
        if (oldn == oldn->parent->left)
            oldn->parent->left = newn;
        else
            oldn->parent->right = newn;
    }
    if (newn != NULL) {
        newn->parent = oldn->parent;
    }
}

static void rotate_left(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* r;
    Assert(n);
    r = n->right;
    replace_node(n, r);
    n->right = r->left;
    if (r->left != NULL) {
        r->left->parent = n;
    }
    r->left = n;
    n->parent = r;
}

static void rotate_right(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* l;
    Assert(n);
    l = n->left;
    replace_node(n, l);
    n->left = l->right;
    if (l->right != NULL) {
        l->right->parent = n;
    }
    l->right = n;
    n->parent = l;
}

static void insert_case5(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* g = grandparent(n);
    set_color(n->parent, _JSI_TREE_BLACK);
    set_color(g, _JSI_TREE_RED);
    if (n == n->parent->left) {
        rotate_right(g);
    } else {
        Assert (n == n->parent->right);
        rotate_left(g);
    }
}

static void insert_case4(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* g = grandparent(n);
    if (n == n->parent->right && n->parent == g->left) {
        rotate_left(n->parent);
        n = n->left;
    } else if (n == n->parent->left && n->parent == g->right) {
        rotate_right(n->parent);
        n = n->right;
    }
    insert_case5(n);
}

static void insert_case1(Jsi_TreeEntry* n);

static void insert_case3(Jsi_TreeEntry* n) {
    Jsi_TreeEntry *g, *u = uncle(n);
    if (node_color(u) == _JSI_TREE_RED) {
        set_color(n->parent, _JSI_TREE_BLACK);
        set_color(u, _JSI_TREE_BLACK);
        g = grandparent(n);
        set_color(g, _JSI_TREE_RED);
        insert_case1(g);
    } else {
        insert_case4(n);
    }
}

static void insert_case2(Jsi_TreeEntry* n) {
    if (node_color(n->parent) == _JSI_TREE_BLACK)
        return;
    insert_case3(n);
}

static void insert_case1(Jsi_TreeEntry* n) {
    if (n->parent == NULL)
        set_color(n, _JSI_TREE_BLACK);
    else
        insert_case2(n);
}

static Jsi_TreeEntry* maximum_node(Jsi_TreeEntry* n) {
    Assert (n != NULL);
    while (n->right != NULL) {
        n = n->right;
    }
    return n;
}

static void delete_case6(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    set_color(s, node_color(n->parent));
    set_color(n->parent, _JSI_TREE_BLACK);
    if (n == n->parent->left) {
        Assert (node_color(s->right) == _JSI_TREE_RED);
        set_color(s->right, _JSI_TREE_BLACK);
        rotate_left(n->parent);
    }
    else
    {
        //Assert (node_color(s->left) == _JSI_TREE_RED);
        set_color(s->left, _JSI_TREE_BLACK);
        rotate_right(n->parent);
    }
}

static void delete_case5(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    if (node_color(s) == _JSI_TREE_BLACK ) {
        if (n == n->parent->left &&
                node_color(s->right) == _JSI_TREE_BLACK &&
                node_color(s->left) == _JSI_TREE_RED)
        {
            set_color(s, _JSI_TREE_RED);
            set_color(s->left, _JSI_TREE_BLACK);
            rotate_right(s);
        }
        else if (n == n->parent->right &&
                 node_color(s->right) == _JSI_TREE_RED &&
                 node_color(s->left) == _JSI_TREE_BLACK)
        {
            set_color(s, _JSI_TREE_RED);
            set_color(s->right, _JSI_TREE_BLACK);
            rotate_left(s);
        }
    }
    delete_case6(n);
}

static void delete_case4(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    if (node_color(n->parent) == _JSI_TREE_RED &&
            node_color(s) == _JSI_TREE_BLACK &&
            node_color(s->left) == _JSI_TREE_BLACK &&
            node_color(s->right) == _JSI_TREE_BLACK)
    {
        set_color(s, _JSI_TREE_RED);
        set_color(n->parent, _JSI_TREE_BLACK);
    }
    else
        delete_case5(n);
}

static void delete_case1(Jsi_TreeEntry* n);

static void delete_case3(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s  = sibling(n);
    if (node_color(n->parent) == _JSI_TREE_BLACK &&
        node_color(s) == _JSI_TREE_BLACK &&
        node_color(s->left) == _JSI_TREE_BLACK &&
        node_color(s->right) == _JSI_TREE_BLACK)
    {
        set_color(s, _JSI_TREE_RED);
        delete_case1(n->parent);
    } else
        delete_case4(n);
}

static void delete_case2(Jsi_TreeEntry* n) {
    Jsi_TreeEntry* s = sibling(n);
    if (node_color(s) == _JSI_TREE_RED) {
        set_color(n->parent, _JSI_TREE_RED);
        set_color(s, _JSI_TREE_BLACK);
        if (n == n->parent->left)
            rotate_left(n->parent);
        else
            rotate_right(n->parent);
    }
    delete_case3(n);
}

static void delete_case1(Jsi_TreeEntry* n) {
    if (n->parent != NULL)
        delete_case2(n);
}

/***********************************************************/

int jsi_treeHeight(Jsi_TreeEntry* hPtr, int n)
{
    int l = -1, r = -1;
    if (hPtr->right == NULL && hPtr->right == NULL )
        return n;
    if (hPtr->left)
        l = jsi_treeHeight(hPtr->left, n+1);
    if (hPtr->right)
        r = jsi_treeHeight(hPtr->right, n+1);
    return (r > l ? r : l);
}

int jsi_nodeDepth(Jsi_TreeEntry* hPtr) {
    int d = 0;
    while (hPtr->parent != NULL) {
        d++;
        hPtr = hPtr->parent;
    }
    return d;
}


static int StringPtrCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    //return (key1 - key2);
    if (key1 == key2) return 0;
    //return Jsi_DictionaryCompare((char*)key1, (char*)key2);
    return Jsi_Strcmp((char*)key1, (char*)key2);
}


static int StringCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    return Jsi_DictionaryCompare((char*)key1, (char*)key2);
    //return Jsi_Strcmp((char*)key1, (char*)key2);
}

static int OneWordCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    return ((uint)key1 - (uint)key2);
}

static int TreeArrayCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)
{
    return memcmp(key1, key2, treePtr->keyType);
}


static Jsi_TreeEntry *TreeStringCreate( Jsi_Tree *treePtr, const void *key, int *newPtr)
{
    Jsi_TreeEntry *hPtr;
    size_t size;

    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {
        if (newPtr)
            *newPtr = 0;
        return hPtr;
    }
    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_TreeEntry) + Jsi_Strlen((char*)key) /*- sizeof(jsi_TreeKey)*/ + 1;
    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);
    SIGINIT(hPtr,TREEENTRY);
    hPtr->typ = JSI_MAP_TREE;
    hPtr->treePtr = treePtr;
    hPtr->value = 0;
    Jsi_Strcpy(hPtr->key.string, (char*)key);
    treePtr->numEntries++;
    return hPtr;
}

static Jsi_TreeEntry *TreeArrayCreate(Jsi_Tree *treePtr, const void *key, int *newPtr)
{
    Jsi_TreeEntry *hPtr;
    size_t size;

    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {
        if (newPtr)
            *newPtr = 0;
        return hPtr;
    }
    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_TreeEntry) + treePtr->keyType; /*- sizeof(jsi_TreeKey);*/
    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);
    SIGINIT(hPtr,TREEENTRY);
    hPtr->typ = JSI_MAP_TREE;
    hPtr->treePtr = treePtr;
    hPtr->value = 0;
    memcpy(hPtr->key.string, key, treePtr->keyType);
    treePtr->numEntries++;
    return hPtr;
}

static Jsi_TreeEntry *OneWordCreate( Jsi_Tree *treePtr, const void *key, int *newPtr)
{
    Jsi_TreeEntry *hPtr;
    size_t size;
    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {
        if (newPtr)
            *newPtr = 0;
        return hPtr;
    }
    if (newPtr)
        *newPtr = 1;
    size = sizeof(Jsi_TreeEntry);
    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);
    SIGINIT(hPtr,TREEENTRY);
    hPtr->typ = JSI_MAP_TREE;
    hPtr->treePtr = treePtr;
    hPtr->value = 0;
    hPtr->key.oneWordValue = (void *)key;
    treePtr->numEntries++;
    return hPtr;
}


static Jsi_TreeEntry *StringPtrCreate( Jsi_Tree *treePtr, const void *key, int *newPtr)
{
    return OneWordCreate(treePtr, key, newPtr);
}

void *Jsi_TreeValueGet(Jsi_TreeEntry *hPtr)
{
    return hPtr->value;
}

void *Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr)
{
    Jsi_Tree *treePtr = hPtr->treePtr;
    switch (treePtr->keyType) {
        case JSI_KEYS_STRINGKEY:
        case JSI_KEYS_ONEWORD: return hPtr->key.oneWordValue;
    }
    return hPtr->key.string;
}


Jsi_TreeEntry *Jsi_TreeEntryFind (Jsi_Tree *treePtr, const void *key)
{
    Jsi_TreeEntry* hPtr = treePtr->root;
    int rc;
    if (treePtr->flags.destroyed)
        return NULL;
    while (hPtr != NULL) {
        rc = treePtr->compareProc(treePtr, GETKEY(treePtr, hPtr), key);
        if (rc == 0) {
            return hPtr;
        }
        hPtr = (rc < 0 ? hPtr->left : hPtr->right);
    }
    return hPtr;
}

Jsi_TreeEntry *Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, int *isNew)
{
    Jsi_TreeEntry* hPtr;
    int isn;
    if (treePtr->flags.destroyed)
        return NULL;
    treePtr->flags.inserting=1;
    if (treePtr->flags.internstr) {
        Assert(treePtr->keyType == JSI_KEYS_STRINGKEY);
        if (!treePtr->strHash)
            treePtr->strHash = Jsi_HashNew(treePtr->interp, JSI_KEYS_STRING, NULL);
        key = Jsi_HashEntryNew(treePtr->strHash, key, NULL);
    }
    hPtr = treePtr->createProc(treePtr, key, &isn);
    if (isNew)
        *isNew = isn;
    if (isn == 0 || treePtr->flags.nonredblack == 1 || !hPtr) {
        treePtr->flags.inserting=0;
        return hPtr;
    }
    treePtr->epoch++;
    hPtr->f.bits.color = _JSI_TREE_RED;
    if (treePtr->root == NULL) {
        treePtr->root = hPtr;
    } else {
        Jsi_TreeEntry* n = treePtr->root;
        while (1) {
            int rc = treePtr->compareProc(treePtr, GETKEY(treePtr,n) , key);
            if (rc == 0) {
                Assert(0);
            } else if (rc < 0) {
                if (n->left == NULL) {
                    n->left = hPtr;
                    break;
                } else {
                    n = n->left;
                }
            } else {
                if (n->right == NULL) {
                    n->right = hPtr;
                    break;
                } else {
                    n = n->right;
                }
            }
        }
        hPtr->parent = n;
    }
    insert_case1(hPtr);
    treePtr->flags.inserting = 0;
    return hPtr;
}

Jsi_Tree *Jsi_TreeNew(Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc *freeProc)
{
    Jsi_Tree* treePtr = (Jsi_Tree*)Jsi_Calloc(1,sizeof(Jsi_Tree));
    SIGINIT(treePtr,TREE);
    treePtr->typ = JSI_MAP_TREE;
    treePtr->root = NULL;
    treePtr->interp = interp;
    treePtr->numEntries = 0;
    treePtr->epoch = 0;
    treePtr->keyType = keyType;

    switch (keyType) {
    case JSI_KEYS_STRING:   /* NULL terminated string keys. */
        treePtr->compareProc = StringCompare;
        treePtr->createProc = TreeStringCreate;
        break;

    case JSI_KEYS_STRINGKEY: /*  */
        treePtr->compareProc = StringPtrCompare;
        treePtr->createProc = StringPtrCreate;
        break;
        
    case JSI_KEYS_ONEWORD: /* 32 or 64 bit atomic keys. */
        treePtr->compareProc = OneWordCompare;
        treePtr->createProc = OneWordCreate;
        break;


    default:            /* Struct. */
        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {
            Jsi_LogError("Jsi_TreeNew: Key size can't be %d, must be > %d\n", keyType, JSI_KEYS_STRUCT_MINSIZE);
            Jsi_Free(treePtr);
            return NULL;
        }
        treePtr->compareProc = TreeArrayCompare;
        treePtr->createProc = TreeArrayCreate;
        break;
    }
    return treePtr;
}

static void destroy_node(Jsi_Interp *interp, Jsi_TreeEntry* n)
{
    if (n == NULL) return;
    if (n->right != NULL) destroy_node(interp, n->right);
    if (n->left != NULL) destroy_node(interp, n->left);
    n->left = n->right = NULL;
    Jsi_TreeEntryDelete(n);
}

void Jsi_TreeDelete (Jsi_Tree *treePtr)
{
    SIGASSERT(treePtr, TREE);
    if (treePtr->flags.destroyed)
        return;
    treePtr->flags.destroyed = 1;
    /*if (treePtr->freeProc)
        treePtr->freeProc(treePtr);*/
    destroy_node(treePtr->interp, treePtr->root);
    MEMCLEAR(treePtr);
    Jsi_Free(treePtr);
}

/* Swap positions of nodes in tree.  This avoids moving the value, which we can't do for strings. */
static void SwapNodes(Jsi_TreeEntry* n, Jsi_TreeEntry* m)
{
    Jsi_Tree* t = n->treePtr;
    Jsi_TreeEntry *np, *nl, *nr, *mp, *ml, *mr;
    int mpc = 0, npc = 0, col = n->f.bits.color;
    n->f.bits.color = m->f.bits.color;  m->f.bits.color = col;
    np = n->parent; nl = n->left; nr = n->right;
    mp = m->parent; ml = m->left; mr = m->right;
    if (mp) mpc = (mp->left == m ?1 : 2);
    if (np) npc = (np->left == n ?1 : 2);

    n->parent = mp; n->left = ml; n->right = mr;
    m->parent = np; m->left = nl; m->right = nr;
    
    if (np == m) {
        m->parent = n;
        if (mr == n) n->right = m; else n->left = m;
    } else if (mp == n) {
        n->parent = m;
        if (nr == m) m->right = n; else m->left = n;
    }
    /* Fixup back pointers. */
    if (m->left)  m->left->parent  = m;
    if (m->right) m->right->parent = m;
    if (n->left)  n->left->parent  = n;
    if (n->right) n->right->parent = n;
    if (mpc) { if (mpc==1) n->parent->left = n; else  n->parent->right = n;}
    if (npc) { if (npc==1) m->parent->left = m; else  m->parent->right = m; }
    if (n->parent == NULL) {
        t->root = n;
    } else if (m->parent == NULL) {
        t->root = m;
    }
}

static void delete_one_child(Jsi_TreeEntry*n)
{
    Jsi_TreeEntry *child;
    Assert(n->left == NULL || n->right == NULL);
    child = n->right == NULL ? n->left  : n->right;
#if 1
    if (node_color(n) == _JSI_TREE_BLACK) {
        set_color(n, node_color(child));
        delete_case1(n);
    }
    replace_node(n, child);
    if (n->parent == NULL && child != NULL)
        set_color(child, _JSI_TREE_BLACK);
    
#else
    replace_node(n, child);
    if (node_color(n) == _JSI_TREE_BLACK) {
        if (node_color(child) == _JSI_TREE_RED)
            child->f.bits.color = _JSI_TREE_BLACK;
        else
            delete_case1(n);
    }
#endif
}

int Jsi_TreeEntryDelete (Jsi_TreeEntry *entryPtr)
{
    int cnt = 0;
    Jsi_TreeEntry* n = entryPtr;
    Jsi_Tree* treePtr = n->treePtr;

    if (treePtr->flags.destroyed  || treePtr->flags.nonredblack == 1 /* || entryPtr->f.bits.deletesub */) {
        goto dodel;
    }
    /*printf("DEL(tree=%p,root=%p): (%p)%s\n", treePtr, treePtr->root, entryPtr,(char*)entryPtr->key.string);*/
    /*dumpTree(treePtr);*/
    entryPtr->treePtr->epoch++;
    if (n->left != NULL && n->right != NULL) {
        /* swap key/values delete pred instead */
        Jsi_TreeEntry* pred = maximum_node(n->left);
        switch (treePtr->keyType) {
        case JSI_KEYS_STRING:
            SwapNodes(n,pred);
            break;
        case JSI_KEYS_STRINGKEY:
        case JSI_KEYS_ONEWORD: {
            void *nv = n->value;
            n->value = pred->value;
            pred->value = nv;
            nv = n->key.oneWordValue;
            n->key.oneWordValue = pred->key.oneWordValue;
            pred->key.oneWordValue = nv;
            n = pred;
            break;
        }
        default: {
            uint i;
            void *nv = n->value;
            n->value = pred->value;
            pred->value = nv;
            char ct, *cs = (char*)(n->key.string), *cd = (char*)(pred->key.string);
            for (i=0; i<treePtr->keyType; i++, cs++, cd++) {
                ct = *cd;
                *cd = *cs;
                *cs = ct;
            }
        }
                
        }
    }
    delete_one_child(n);
    cnt++;
    /*dumpTree(treePtr);*/
dodel:
    treePtr->numEntries--;
    n->treePtr = NULL;
    if (treePtr->freeProc)
        treePtr->freeProc(treePtr->interp, n);
    Jsi_Free(n);
    return cnt;
}

static void searchSpace(Jsi_TreeSearch *searchPtr, int n)
{
    if ((searchPtr->top+n) >= searchPtr->max) {
        int i, cnt = (searchPtr->max *= 2);
        if (searchPtr->Ptrs == searchPtr->staticPtrs)
            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Calloc(cnt, sizeof(Jsi_TreeEntry*));
        else
            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Realloc(searchPtr->Ptrs, cnt* sizeof(Jsi_TreeEntry*));
        for (i=0; i<cnt; i++)
            SIGINIT((searchPtr->Ptrs[i]),TREEENTRY);

    }
}

static Jsi_TreeEntry *searchAdd(Jsi_TreeSearch *searchPtr,  Jsi_TreeEntry *hPtr)
{
    int order = (searchPtr->flags & JSI_TREE_ORDER_MASK);
    searchSpace(searchPtr, 2);
    switch (order) {
        case JSI_TREE_LEVELORDER:
            if (hPtr) {
                if (hPtr->right)
                    searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
                if (hPtr->left)
                    searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
                return hPtr;
            }
            if (searchPtr->top<=0)
                return NULL;
            hPtr = searchPtr->Ptrs[0];
            searchPtr->top--;
            if (searchPtr->top > 0) {
                /* Not very efficient way to implement a queue, but works for now. */
                memmove(searchPtr->Ptrs, searchPtr->Ptrs+1, sizeof(Jsi_TreeEntry*)*searchPtr->top);
            }
            if (hPtr->right)
                searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
            if (hPtr->left)
                searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
            return hPtr;
            break;
            
        case JSI_TREE_POSTORDER:
            if (hPtr)
                searchPtr->Ptrs[searchPtr->top++] = searchPtr->current = hPtr;
            while (searchPtr->top>0) {
                hPtr = searchPtr->Ptrs[searchPtr->top-1];
                if (hPtr->right == searchPtr->current || hPtr->left == searchPtr->current ||
                    (hPtr->left == NULL && hPtr->right == NULL)) {
                    searchPtr->top--;
                    searchPtr->current = hPtr;
                    return hPtr;
                } else {
                    searchSpace(searchPtr, 2);
                    if (hPtr->left)
                        searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
                    if (hPtr->right)
                        searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
                }
            }
            return NULL;
            break;
            
        case JSI_TREE_PREORDER:
            if (!hPtr) {
                if (searchPtr->top<=0) return NULL;
                hPtr = searchPtr->Ptrs[--searchPtr->top];
            }
            searchPtr->Ptrs[searchPtr->top++] = hPtr;
            if (hPtr->left) searchPtr->Ptrs[searchPtr->top++] = hPtr->left;
            if (hPtr->right) searchPtr->Ptrs[searchPtr->top++] = hPtr->right;
            break;
            
        case JSI_TREE_INORDER:
            while (1) {
                searchSpace(searchPtr, 2);
                if (searchPtr->current) {
                    searchPtr->Ptrs[searchPtr->top++] = searchPtr->current;
                    searchPtr->current = searchPtr->current->right;
                } else {
                    if (searchPtr->top<=0)
                        return NULL;
                    hPtr = searchPtr->Ptrs[--searchPtr->top] ;
                    searchPtr->current = hPtr->left;
                    return hPtr;
                }
            }
            break;
            
        default:
            if (hPtr) {
                Jsi_Interp *interp = hPtr->treePtr->interp;
                JSI_NOTUSED(interp);
                Jsi_LogError("Invalid order: %d", order);    
            }    
    }
    return searchPtr->Ptrs[--searchPtr->top];
}

Jsi_TreeEntry *Jsi_TreeEntryFirst (Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags)
{
    Jsi_TreeEntry *hPtr;
    if (!treePtr) return NULL;
    memset(searchPtr, 0, sizeof(Jsi_TreeSearch));
    searchPtr->treePtr = treePtr;
    searchPtr->flags = flags;
    searchPtr->Ptrs = searchPtr->staticPtrs;
    searchPtr->max = sizeof(searchPtr->staticPtrs)/sizeof(searchPtr->staticPtrs[0]);
    searchPtr->epoch = treePtr->epoch;
    searchPtr->current = hPtr = treePtr->root;
    return searchAdd(searchPtr, hPtr);
}

void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value)
{
    Jsi_Value *v = (Jsi_Value*)value;
#ifdef JSI_DEBUG_MEMORY
    SIGASSERT(hPtr, TREEENTRY);
    if (hPtr->treePtr->flags.valuesonly)
        SIGASSERT(v,VALUE);
#endif
    hPtr->value = value;
}

#ifndef JSI_LITE_ONLY

Jsi_Tree *Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v)
{
    if (!Jsi_ValueIsObjType(interp, v, JSI_OT_OBJECT))
        return NULL;
    return v->d.obj->tree;
}

#endif 

Jsi_TreeEntry *Jsi_TreeEntryNext(Jsi_TreeSearch *searchPtr)
{
    Jsi_TreeEntry *hPtr = NULL;
    if (searchPtr->epoch == searchPtr->treePtr->epoch)
        hPtr = searchAdd(searchPtr, NULL);
    if (!hPtr)
        Jsi_TreeSearchDone(searchPtr);
    return hPtr;
}

void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr)
{
    if (searchPtr->Ptrs != searchPtr->staticPtrs)
        Jsi_Free(searchPtr->Ptrs);
    searchPtr->Ptrs = searchPtr->staticPtrs;
    searchPtr->top = 0;
}

Jsi_TreeEntry *Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value)
{
    Jsi_TreeEntry *hPtr;
    int isNew;
    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);
    if (!hPtr) return hPtr;
    Jsi_TreeValueSet(hPtr, value);
    return hPtr;
}

void *Jsi_TreeGet(Jsi_Tree *treePtr, void *key)
{
    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);
    if (!hPtr)
        return NULL;
    return Jsi_TreeValueGet(hPtr);
}

static int tree_inorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (hPtr->right != NULL) {
        if (tree_inorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
        return JSI_ERROR;
    Assert(hPtr->treePtr);
    if (hPtr->left != NULL) {
        if (tree_inorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    return JSI_OK;
}


static int tree_preorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
        return JSI_ERROR;
    if (hPtr->right != NULL) {
        if (tree_preorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (hPtr->left != NULL) {
        if (tree_preorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    return JSI_OK;
}


static int tree_postorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (hPtr->right != NULL) {
        if (tree_postorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (hPtr->left != NULL) {
        if (tree_postorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
        return JSI_ERROR;
    return JSI_OK;
}


static int tree_levelorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback,
    void *data, int curlev, int level, int *cnt) {
    uint epoch = treePtr->epoch;
    if (hPtr == NULL) return JSI_OK;
    if (curlev > level) return JSI_OK;
    if (curlev == level) {
        if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
        (*cnt)++;
    }
    if (hPtr->right != NULL) {
        if (tree_levelorder(treePtr, hPtr->right, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    if (hPtr->left != NULL) {
        if (tree_levelorder(treePtr, hPtr->left, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)
            return JSI_ERROR;
    }
    return JSI_OK;
}


int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags) {
    Jsi_Interp *interp = treePtr->interp;
    JSI_NOTUSED(interp);
    int n = 0, m, lastm, order;
    order = flags & JSI_TREE_ORDER_MASK;
    switch (order) {
    case JSI_TREE_PREORDER:
        return tree_preorder(treePtr, treePtr->root, callback, data);
    case JSI_TREE_POSTORDER:
        return tree_postorder(treePtr, treePtr->root, callback, data);
    case JSI_TREE_INORDER:
        return tree_inorder(treePtr, treePtr->root, callback, data);
    case JSI_TREE_LEVELORDER:
        while (1) {
            lastm = m;
            if (tree_levelorder(treePtr, treePtr->root, callback, data, 0, n, &m) != JSI_OK)
                return JSI_ERROR;
            if (lastm == m)
                return JSI_OK;
            n++;
        }
            
    default:
        Jsi_LogError("Invalid order: %d", order);
    }
    return JSI_ERROR;
}

#ifdef JSI_TEST_RBTREE

int mycall(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data)
{
    printf("CALL: %s(%d) : %d\n", (char*)Jsi_TreeKeyGet(hPtr), jsi_nodeDepth(hPtr), (int)Jsi_TreeValueGet(hPtr));
    return JSI_OK;
}
static void TreeTest(Jsi_Interp* interp) {
    Jsi_Tree *st, *wt, *mt;
    Jsi_TreeEntry *hPtr, *hPtr2;
    int isNew, i;
    Jsi_TreeSearch srch;
    struct tdata {
        int n;
        int m;
    } t1, t2;
    char nbuf[100];
    
    wt = Jsi_TreeNew(interp, JSI_KEYS_ONEWORD, NULL);
    mt = Jsi_TreeNew(interp, sizeof(struct tdata), NULL);

    Jsi_TreeSet(wt, wt,(void*)0x88);
    Jsi_TreeSet(wt, mt,(void*)0x99);
    printf("WT: %p\n", Jsi_TreeGet(wt, mt));
    printf("WT2: %p\n", Jsi_TreeGet(wt, wt));
    Jsi_TreeDelete(wt);

    t1.n = 0; t1.m = 1;
    t2.n = 1; t2.m = 2;
    Jsi_TreeSet(mt, &t1,(void*)0x88);
    Jsi_TreeSet(mt, &t2,(void*)0x99);
    Jsi_TreeSet(mt, &t2,(void*)0x98);
    printf("CT: %p\n", Jsi_TreeGet(mt, &t1));
    printf("CT2: %p\n", Jsi_TreeGet(mt, &t2));
    Jsi_TreeDelete(mt);

    st = Jsi_TreeNew(interp, JSI_KEYS_STRING, NULL);
    hPtr = Jsi_TreeEntryNew(st, "bob", &isNew);
    Jsi_TreeValueSet(hPtr, (void*)99);
    Jsi_TreeSet(st, "zoe",(void*)77);
    hPtr2 = Jsi_TreeSet(st, "ted",(void*)55);
    Jsi_TreeSet(st, "philip",(void*)66);
    Jsi_TreeSet(st, "alice",(void*)77);
    puts("SRCH");
    for (hPtr=Jsi_TreeEntryFirst(st,&srch,  JSI_TREE_INORDER); hPtr; hPtr=Jsi_TreeEntryNext(&srch))
        mycall(st, hPtr, NULL);
    Jsi_TreeSearchDone(&srch);
    puts("IN");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_INORDER);
    puts("PRE");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_PREORDER);
    puts("POST");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_POSTORDER);
    puts("LEVEL");
    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_LEVELORDER);
    Jsi_TreeEntryDelete(hPtr2);
    puts("INDEL");
    Jsi_TreeWalk(st, mycall, NULL, 0);

    for (i=0; i<1000; i++) {
        sprintf(nbuf, "name%d", i);
        Jsi_TreeSet(st, nbuf,(void*)i);
    }
    Jsi_TreeWalk(st, mycall, NULL, 0);
    for (i=0; i<1000; i++) {
        Jsi_TreeEntryDelete(st->root);
    }
    puts("OK");
    Jsi_TreeWalk(st, mycall, NULL, 0);
    Jsi_TreeDelete(st);

}

int jsi_TreeInit(Jsi_Interp *interp)
{
    TreeTest(interp);
    return JSI_OK;
}

#else

int jsi_TreeInit(Jsi_Interp *interp)
{
    /* TODO: maintain hash table of trees created per interp? */
    return JSI_OK;
}
#endif
int Jsi_TreeSize(Jsi_Tree *treePtr) { return treePtr->numEntries; }
void* Jsi_TreeConf(Jsi_Tree *treePtr, int op, ...) { return NULL; }

#ifndef JSI_LITE_ONLY
int Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *tablePtr, Jsi_Value **ret, int flags) {
    char *key;
    int n = 0;
    Jsi_TreeEntry *hPtr;
    Jsi_TreeSearch search;
    Jsi_Obj *nobj;
    
    if (tablePtr->keyType != JSI_KEYS_STRING && tablePtr->keyType != JSI_KEYS_STRINGKEY)
        return JSI_ERROR;
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    for (hPtr = Jsi_TreeEntryFirst(tablePtr, &search, flags);
        hPtr != NULL; hPtr = Jsi_TreeEntryNext(&search)) {
        key = (char*)Jsi_TreeKeyGet(hPtr);
        Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n++);
    }
    Jsi_TreeSearchDone(&search);
    return JSI_OK;
}
#endif

#ifndef JSI_LITE_ONLY
/* Origin: SQLITE.
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <string.h>
#include <stdlib.h>
#include <memory.h>
#include <stddef.h>
#include <stdint.h>

struct _MD5_Context {
    uint buf[4];
    uint bits[2];
    unsigned char in[64];
};
typedef char MD5Context[88];

/*
 * Note: this code is harmless on little-endian machines.
 */
static void byteReverse (unsigned char *buf, unsigned longs) {
    uint t;
    do {
        t = (uint)((unsigned)buf[3]<<8 | buf[2]) << 16 |
            ((unsigned)buf[1]<<8 | buf[0]);
        *(uint *)buf = t;
        buf += 4;
    } while (--longs);
}
/* The four core functions - _JSI_F1 is optimized somewhat */

/* #define _JSI_F1(x, y, z) (x & y | ~x & z) */
#define _JSI_F1(x, y, z) (z ^ (x & (y ^ z)))
#define _JSI_F2(x, y, z) _JSI_F1(z, x, y)
#define _JSI_F3(x, y, z) (x ^ y ^ z)
#define _JSI_F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define _JSI_MD5STEP(f, w, x, y, z, data, s) \
        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void MD5Transform(uint buf[4], const uint in[16]) {
    register uint a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[ 0]+0xd76aa478,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[ 2]+0x242070db, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);
    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[ 5]+0x4787c62a, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[ 6]+0xa8304613, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[ 7]+0xfd469501, 22);
    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[ 8]+0x698098d8,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[10]+0xffff5bb1, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[11]+0x895cd7be, 22);
    _JSI_MD5STEP(_JSI_F1, a, b, c, d, in[12]+0x6b901122,  7);
    _JSI_MD5STEP(_JSI_F1, d, a, b, c, in[13]+0xfd987193, 12);
    _JSI_MD5STEP(_JSI_F1, c, d, a, b, in[14]+0xa679438e, 17);
    _JSI_MD5STEP(_JSI_F1, b, c, d, a, in[15]+0x49b40821, 22);

    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[ 1]+0xf61e2562,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[ 6]+0xc040b340,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[11]+0x265e5a51, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);
    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[ 5]+0xd62f105d,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[10]+0x02441453,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[15]+0xd8a1e681, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);
    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[14]+0xc33707d6,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[ 8]+0x455a14ed, 20);
    _JSI_MD5STEP(_JSI_F2, a, b, c, d, in[13]+0xa9e3e905,  5);
    _JSI_MD5STEP(_JSI_F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);
    _JSI_MD5STEP(_JSI_F2, c, d, a, b, in[ 7]+0x676f02d9, 14);
    _JSI_MD5STEP(_JSI_F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);

    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[ 5]+0xfffa3942,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[ 8]+0x8771f681, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[11]+0x6d9d6122, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[14]+0xfde5380c, 23);
    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[ 1]+0xa4beea44,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[10]+0xbebfbc70, 23);
    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[13]+0x289b7ec6,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[ 6]+0x04881d05, 23);
    _JSI_MD5STEP(_JSI_F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);
    _JSI_MD5STEP(_JSI_F3, d, a, b, c, in[12]+0xe6db99e5, 11);
    _JSI_MD5STEP(_JSI_F3, c, d, a, b, in[15]+0x1fa27cf8, 16);
    _JSI_MD5STEP(_JSI_F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);

    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[ 0]+0xf4292244,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[ 7]+0x432aff97, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[14]+0xab9423a7, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[ 5]+0xfc93a039, 21);
    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[12]+0x655b59c3,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[10]+0xffeff47d, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[ 1]+0x85845dd1, 21);
    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[ 6]+0xa3014314, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[13]+0x4e0811a1, 21);
    _JSI_MD5STEP(_JSI_F4, a, b, c, d, in[ 4]+0xf7537e82,  6);
    _JSI_MD5STEP(_JSI_F4, d, a, b, c, in[11]+0xbd3af235, 10);
    _JSI_MD5STEP(_JSI_F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);
    _JSI_MD5STEP(_JSI_F4, b, c, d, a, in[ 9]+0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
static void MD5Init(MD5Context *pCtx) {
    struct _MD5_Context *ctx = (struct _MD5_Context *)pCtx;
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;
    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
static
void MD5Update(MD5Context *pCtx, const unsigned char *buf, unsigned int len) {
    struct _MD5_Context *ctx = (struct _MD5_Context *)pCtx;
    uint t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint)len << 3)) < t)
        ctx->bits[1]++; /* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if ( t ) {
        unsigned char *p = (unsigned char *)ctx->in + t;

        t = 64-t;
        if (len < t) {
            memcpy(p, buf, len);
            return;
        }
        memcpy(p, buf, t);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint *)ctx->in);
        buf += t;
        len -= t;
    }

    /* Process data in 64-byte chunks */

    while (len >= 64) {
        memcpy(ctx->in, buf, 64);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint *)ctx->in);
        buf += 64;
        len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
static void MD5Final(unsigned char digest[16], MD5Context *pCtx) {
    struct _MD5_Context *ctx = (struct _MD5_Context *)pCtx;
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
        /* Two lots of padding:  Pad the first block to 64 bytes */
        memset(p, 0, count);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint *)ctx->in);

        /* Now fill the next block with 56 bytes */
        memset(ctx->in, 0, 56);
    } else {
        /* Pad block to 56 bytes */
        memset(p, 0, count-8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint *)ctx->in)[ 14 ] = ctx->bits[0];
    ((uint *)ctx->in)[ 15 ] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint *)ctx->in);
    byteReverse((unsigned char *)ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(ctx));    /* In case it's sensitive */
}

/*
** Convert a digest into base-16.  digest should be declared as
** "unsigned char digest[16]" in the calling function.  The MD5
** digest is stored in the first 16 bytes.  zBuf should
** be "char zBuf[33]".
*/
static void DigestToBase16(unsigned char *digest, char *zBuf, int len) {
    static char const zEncode[] = "0123456789abcdef";
    int i, j;

    for(j=i=0; i<len; i++) {
        int a = digest[i];
        zBuf[j++] = zEncode[(a>>4)&0xf];
        zBuf[j++] = zEncode[a & 0xf];
    }
    zBuf[j] = 0;
}

void jsi_Md5Digest(Jsi_Interp *interp, unsigned char digest[16], const char *str, int len)
{
    MD5Context ctx;
    MD5Init(&ctx);
    if (len<0)
        len = strlen(str);
    MD5Update(&ctx, (unsigned char*)str, len);
    MD5Final(digest, &ctx);
}

void Jsi_Md5Str(Jsi_Interp *interp, char outbuf[33], const char *str, int len)
{
    unsigned char digest[16];
    jsi_Md5Digest(interp, digest, str, len);
    DigestToBase16(digest, outbuf, 16);
}

int jsi_Md5File(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MD5Context ctx;
    unsigned char digest[16];
    char zBuf[1000];
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);

    Jsi_Channel in = Jsi_Open(interp, arg, "rb");
    if( in==0 ) {
        char *fn = Jsi_ValueString(interp, arg, 0);
        Jsi_LogError("unable to open file \"%s\"", fn ? fn : "");
        return JSI_ERROR;
    }
    MD5Init(&ctx);
    for(;;) {
        int n;
        n = Jsi_Read(in, zBuf, sizeof(zBuf));
        if( n<=0 ) break;
        MD5Update(&ctx, (unsigned char*)zBuf, (unsigned)n);
    }
    Jsi_Close(in);
    MD5Final(digest, &ctx);
    DigestToBase16(digest, zBuf, 16);
    Jsi_ValueMakeStringDup(interp, ret, zBuf);
    return JSI_OK;
}

/*********************************************************************
* Author:     Brad Conte (brad AT bradconte.com) (copyright AS-IS)
* Source:     https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c
*********************************************************************/

typedef struct {
    uchar data[64];
    uint datalen;
    unsigned long long bitlen;
    uint state[5];
    uint k[4];
} SHA1_CTX;


/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

/*********************** FUNCTION DEFINITIONS ***********************/
void sha1_transform(SHA1_CTX *ctx, const uchar data[])
{
    uint a, b, c, d, e, i, j, t, m[80];

    for (i = 0, j = 0; i < 16; ++i, j += 4)
        m[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 8) + (data[j + 3]);
    for ( ; i < 80; ++i) {
        m[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]);
        m[i] = (m[i] << 1) | (m[i] >> 31);
    }

    a = ctx->state[0];
    b = ctx->state[1];
    c = ctx->state[2];
    d = ctx->state[3];
    e = ctx->state[4];

    for (i = 0; i < 20; ++i) {
        t = ROTLEFT(a, 5) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }
    for ( ; i < 40; ++i) {
        t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[1] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }
    for ( ; i < 60; ++i) {
        t = ROTLEFT(a, 5) + ((b & c) ^ (b & d) ^ (c & d))  + e + ctx->k[2] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }
    for ( ; i < 80; ++i) {
        t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[3] + m[i];
        e = d;
        d = c;
        c = ROTLEFT(b, 30);
        b = a;
        a = t;
    }

    ctx->state[0] += a;
    ctx->state[1] += b;
    ctx->state[2] += c;
    ctx->state[3] += d;
    ctx->state[4] += e;
}

void sha1_init(SHA1_CTX *ctx)
{
    ctx->datalen = 0;
    ctx->bitlen = 0;
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xEFCDAB89;
    ctx->state[2] = 0x98BADCFE;
    ctx->state[3] = 0x10325476;
    ctx->state[4] = 0xc3d2e1f0;
    ctx->k[0] = 0x5a827999;
    ctx->k[1] = 0x6ed9eba1;
    ctx->k[2] = 0x8f1bbcdc;
    ctx->k[3] = 0xca62c1d6;
}

void sha1_update(SHA1_CTX *ctx, const uchar data[], size_t len)
{
    size_t i;

    for (i = 0; i < len; ++i) {
        ctx->data[ctx->datalen] = data[i];
        ctx->datalen++;
        if (ctx->datalen == 64) {
            sha1_transform(ctx, ctx->data);
            ctx->bitlen += 512;
            ctx->datalen = 0;
        }
    }
}

void sha1_final(SHA1_CTX *ctx, uchar hash[])
{
    uint i;

    i = ctx->datalen;

    // Pad whatever data is left in the buffer.
    if (ctx->datalen < 56) {
        ctx->data[i++] = 0x80;
        while (i < 56)
            ctx->data[i++] = 0x00;
    }
    else {
        ctx->data[i++] = 0x80;
        while (i < 64)
            ctx->data[i++] = 0x00;
        sha1_transform(ctx, ctx->data);
        memset(ctx->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    ctx->bitlen += ctx->datalen * 8;
    ctx->data[63] = ctx->bitlen;
    ctx->data[62] = ctx->bitlen >> 8;
    ctx->data[61] = ctx->bitlen >> 16;
    ctx->data[60] = ctx->bitlen >> 24;
    ctx->data[59] = ctx->bitlen >> 32;
    ctx->data[58] = ctx->bitlen >> 40;
    ctx->data[57] = ctx->bitlen >> 48;
    ctx->data[56] = ctx->bitlen >> 56;
    sha1_transform(ctx, ctx->data);

    // Since this implementation uses little endian byte ordering and MD uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for (i = 0; i < 4; ++i) {
        hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    }
}
void Jsi_Sha1Str(Jsi_Interp *interp, char outbuf[41], const char *str, int len)
{
#ifdef WITHOUT_SHA1
    Jsi_LogWarn("SHA1 support requires websockets");
    outbuf[0] = 0;
#else
    SHA1_CTX ctx;
    unsigned char digest[64];
    sha1_init(&ctx);
    if (len<0)
        len = strlen(str);
    sha1_update(&ctx, (unsigned char*)str, len);
    sha1_final(&ctx, digest);
    DigestToBase16(digest, outbuf, 20);
#endif
}

int jsi_Sha1File(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifdef WITHOUT_SHA1
    Jsi_LogWarn("SHA1 support requires websockets");
#else
    char buf[100] = "";
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Channel in = Jsi_Open(interp, arg, "rb");
    
    if( in==0 ) {
        char *fn = Jsi_ValueString(interp, arg, 0);
        Jsi_LogError("unable to open file \"%s\"", fn ? fn : "");
        return JSI_ERROR;
    }
    Jsi_DString dStr = {};
    char zBuf[1000];
    for(;;) {
        int n;
        n = Jsi_Read(in, zBuf, sizeof(zBuf));
        if( n<=0 ) break;
        Jsi_DSAppendLen(&dStr, zBuf, n);;
    }
    {
        char *cp = Jsi_DSValue(&dStr);
        SHA1_CTX ctx;
        unsigned char digest[65];
        sha1_init(&ctx);
        sha1_update(&ctx, (unsigned char*)cp, Jsi_Strlen(cp));
        sha1_final(&ctx, digest);
        DigestToBase16(digest, buf, 20);
    }
    Jsi_Close(in);
    Jsi_ValueMakeStringDup(interp, ret, buf);
#endif
    return JSI_OK;
}

#ifndef WITHOUT_SHA256

typedef struct {
    uchar data[64];
    uint datalen;
    unsigned long long bitlen;
    uint state[8];
} SHA256_CTX;

/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

/**************************** VARIABLES *****************************/
static const uint k[64] = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
static void sha256_transform(SHA256_CTX *ctx, const uchar data[])
{
    uint a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for (i = 0, j = 0; i < 16; ++i, j += 4)
        m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    for ( ; i < 64; ++i)
        m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

    a = ctx->state[0];
    b = ctx->state[1];
    c = ctx->state[2];
    d = ctx->state[3];
    e = ctx->state[4];
    f = ctx->state[5];
    g = ctx->state[6];
    h = ctx->state[7];

    for (i = 0; i < 64; ++i) {
        t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
        t2 = EP0(a) + MAJ(a,b,c);
        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    ctx->state[0] += a;
    ctx->state[1] += b;
    ctx->state[2] += c;
    ctx->state[3] += d;
    ctx->state[4] += e;
    ctx->state[5] += f;
    ctx->state[6] += g;
    ctx->state[7] += h;
}

static void sha256_init(SHA256_CTX *ctx)
{
    ctx->datalen = 0;
    ctx->bitlen = 0;
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
}

static void sha256_update(SHA256_CTX *ctx, const uchar data[], size_t len)
{
    uint i;

    for (i = 0; i < len; ++i) {
        ctx->data[ctx->datalen] = data[i];
        ctx->datalen++;
        if (ctx->datalen == 64) {
            sha256_transform(ctx, ctx->data);
            ctx->bitlen += 512;
            ctx->datalen = 0;
        }
    }
}

static void sha256_final(SHA256_CTX *ctx, uchar hash[])
{
    uint i;

    i = ctx->datalen;

    // Pad whatever data is left in the buffer.
    if (ctx->datalen < 56) {
        ctx->data[i++] = 0x80;
        while (i < 56)
            ctx->data[i++] = 0x00;
    }
    else {
        ctx->data[i++] = 0x80;
        while (i < 64)
            ctx->data[i++] = 0x00;
        sha256_transform(ctx, ctx->data);
        memset(ctx->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    ctx->bitlen += ctx->datalen * 8;
    ctx->data[63] = ctx->bitlen;
    ctx->data[62] = ctx->bitlen >> 8;
    ctx->data[61] = ctx->bitlen >> 16;
    ctx->data[60] = ctx->bitlen >> 24;
    ctx->data[59] = ctx->bitlen >> 32;
    ctx->data[58] = ctx->bitlen >> 40;
    ctx->data[57] = ctx->bitlen >> 48;
    ctx->data[56] = ctx->bitlen >> 56;
    sha256_transform(ctx, ctx->data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for (i = 0; i < 4; ++i) {
        hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    }
}
#undef ROTLEFT
#undef ROTRIGHT
#undef CH
#undef MAJ
#undef EP0
#undef EP1
#undef SIG0
#undef SIG1

#endif

void Jsi_Sha256Str(Jsi_Interp *interp, char outbuf[65], const char *str, int len)
{
#ifdef WITHOUT_SHA256
    Jsi_LogWarn("SHA256 not supported");
    outbuf[0] = 0;
#else
    SHA256_CTX ctx;
    unsigned char digest[64];
    sha256_init(&ctx);
    if (len<0)
        len = strlen(str);
    sha256_update(&ctx, (unsigned char*)str, len);
    sha256_final(&ctx, digest);
    DigestToBase16(digest, outbuf, 32);
#endif
}

int jsi_Sha256File(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifdef WITHOUT_SHA256
    Jsi_LogWarn("SHA256 not supported");
#else
    char buf[100] = "";
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Channel in = Jsi_Open(interp, arg, "rb");
    
    if( in==0 ) {
        char *fn = Jsi_ValueString(interp, arg, 0);
        Jsi_LogError("unable to open file \"%s\"", fn ? fn : "");
        return JSI_ERROR;
    }
    Jsi_DString dStr = {};
    char zBuf[1000];
    for(;;) {
        int n;
        n = Jsi_Read(in, zBuf, sizeof(zBuf));
        if( n<=0 ) break;
        Jsi_DSAppendLen(&dStr, zBuf, n);;
    }
    {
        char *cp = Jsi_DSValue(&dStr);
        SHA256_CTX ctx;
        unsigned char digest[65];
        sha256_init(&ctx);
        sha256_update(&ctx, (unsigned char*)cp, Jsi_Strlen(cp));
        sha256_final(&ctx, digest);
        DigestToBase16(digest, buf, 32);
    }
    Jsi_Close(in);
    Jsi_ValueMakeStringDup(interp, ret, buf);
#endif
    return JSI_OK;
}


/* XXTEA encryption. Source the Wikipedia page. */
#define _JSI_BTEA_MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))

static void jsi_btea(uint32_t *v, int n, uint32_t const key[4]) {
    const uint32_t DELTA = 0x9e3779b9;
    uint32_t y, z, sum;
    uint p, rounds, e;
    if (n > 1) {          /* Coding Part */
        rounds = 6 + 52/n;
        sum = 0;
        z = v[n-1];
        do {
            sum += DELTA;
            e = (sum >> 2) & 3;
            for (p=0; p<(uint)(n-1); p++) {
                y = v[p+1];
                z = v[p] += _JSI_BTEA_MX;
            }
            y = v[0];
            z = v[n-1] += _JSI_BTEA_MX;
        } while (--rounds);
    } else if (n < -1) {  /* Decoding Part */
        n = -n;
        rounds = 6 + 52/n;
        sum = rounds*DELTA;
        y = v[0];
        do {
            e = (sum >> 2) & 3;
            for (p=n-1; p>0; p--) {
                z = v[p-1];
                y = v[p] -= _JSI_BTEA_MX;
            }
            z = v[n-1];
            y = v[0] -= _JSI_BTEA_MX;
            sum -= DELTA;
        } while (--rounds);
    }
}

/* Encrypt/decrypt string using key.  The len must be a multiple of 4. */
int Jsi_EncryptBuf(Jsi_Interp *interp, const char *key, int *buf, int nlen, int decrypt)
{
#ifdef WITHOUT_ENCRYPT
    Jsi_LogWarn("ENCRYPT not supported");
#else
    unsigned char digest[16];
    uint32_t *skey = (uint32_t*)digest;
    jsi_Md5Digest(interp, digest, key, Jsi_Strlen(key));
    jsi_btea((uint32_t*)buf, (decrypt ? -nlen : nlen), skey);
    return JSI_OK;
#endif
}

/* Encrypt file: pads source with NULLs so length is greater than, and divisible by 4. */
int jsi_EncryptFile(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                 Jsi_Value **ret, Jsi_Func *funcPtr, int decrypt)
{
#ifdef WITHOUT_ENCRYPT
    Jsi_LogWarn("ENCRYPT not supported");
#else
    int keyLen, n, sum = 0;
    Jsi_Value *key = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    char *keyStr = Jsi_ValueString(interp, key, &keyLen);
    if (!keyStr)
    {
        Jsi_LogError("key must be a string");
        return JSI_ERROR;
    }

    Jsi_Channel chan = Jsi_Open(interp, arg, "rb");
    if( chan==0 ) {
        char *fn = Jsi_ValueString(interp, arg, NULL);
        Jsi_LogError("unable to open file \"%s\"", fn ? fn : "");
        return JSI_ERROR;
    }
    Jsi_DString dStr = {};
    char buf[BUFSIZ];
    while (sum < MAX_LOOP_COUNT && (n = Jsi_Read(chan, buf, sizeof(buf))) > 0) {
        Jsi_DSAppendLen(&dStr, buf, n);
        sum += n;
    }
    Jsi_Close(chan);
    int ilen = Jsi_DSLength(&dStr);
    while (ilen<=4 || (ilen%4)) {
        Jsi_DSAppendLen(&dStr, "\0", 1);
        ilen++;
    }
    if (JSI_OK != Jsi_EncryptBuf(interp, keyStr, (int*)Jsi_DSValue(&dStr), ilen/4, decrypt)) {
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    Jsi_ValueMakeDStringObject(interp, ret, &dStr);
#endif
    return JSI_OK;
}

#endif
/* Support for Jsi_DString: Dynamic Strings in C */
/* Can be used either within Jsi or standalone by including jsi.h */

#ifndef JSI_AMALGAMATION
#ifdef JSI_STANDALONE
#include "jsiInt.h"
#else
/* Not being used within JSI */
#include "jsi.h"
#ifndef JSI_MAX_ALLOC_BUF
#define JSI_MAX_ALLOC_BUF 100000000
#endif
#define Jsi_Realloc realloc
#define Jsi_Free free
#define Jsi_Strdup strdup
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#endif /* JSI_STANDALONE */
#endif /* !JSI_AMALGAMATION */

#ifndef LogError
#define LogError(fmt,...) fprintf(stderr, fmt "%s %s:%d\n", __VA_ARGS__, __FUNCTION__, __FILE__, __LINE__)
#endif

#define DSNotInit(dsPtr) (dsPtr->spaceAvl<=0 || dsPtr->str == NULL)

/* Initialize an uninitialized string. */
static void InitStr(Jsi_DString *dsPtr)
{
    char *str = dsPtr->str;
    dsPtr->len = 0;
    if (dsPtr->staticSize<=0)
        dsPtr->staticSize = JSI_DSTRING_STATIC_SIZE;
    dsPtr->spaceAvl = dsPtr->staticSize;
    dsPtr->staticSpace[0] = 0;
    dsPtr->str = dsPtr->staticSpace;
    if (str)
        Jsi_DSAppendLen(dsPtr, str, -1);
}

/* RETURNS: string value. */
char* Jsi_DSValue(Jsi_DString *dsPtr)  {
    if (DSNotInit(dsPtr))
        InitStr(dsPtr);
    return dsPtr->str;
}

/* RETURNS: string length. */
int Jsi_DSLength(Jsi_DString *dsPtr) {
    return dsPtr->len;
}

/* Initialize string. */
void Jsi_DSInit(Jsi_DString *dsPtr)
{
    dsPtr->staticSize = 0;
    dsPtr->str = NULL;
    InitStr(dsPtr);
}

/* 
 * Frees any allocated space and sets the DString back to empty such that it is safe to exit the scope.
 * Alternatively, the DString may be immediately reused. However in that case a call to Jsi_DSReset might
 * be more appropriate. 
 */
void
Jsi_DSFree(Jsi_DString *dsPtr)
{
    if (!dsPtr->str)
        return;
    if (dsPtr->str != dsPtr->staticSpace && dsPtr->spaceAvl>0)
        Jsi_Free(dsPtr->str);
    dsPtr->str = NULL;
    dsPtr->staticSpace[0] = 0;
    dsPtr->spaceAvl = dsPtr->staticSize;
}

/* 
 * Append length bytes to the string. If length is less than 0,
 * the value of strlen is used.  If required, the DString is realloced to
 * be large enough to contain bytes, plus an extra null byte that is added to the end.
 * RETURNS: The string starting at the first appended character.
*/
char *Jsi_DSAppendLen(Jsi_DString *dsPtr, const char *string, int length)
{
    if (DSNotInit(dsPtr))
        InitStr(dsPtr);        
    int len = dsPtr->len;
    if (string) {
        if (length < 0)
            length = strlen(string);
        int nsiz = length + len+1;
    
        if (nsiz >= dsPtr->spaceAvl) {
            if (nsiz < dsPtr->spaceAvl*2)
                nsiz = dsPtr->spaceAvl*2;
            if (Jsi_DSSetLength(dsPtr, nsiz) < nsiz)
                return Jsi_DSValue(dsPtr);
        }
        char * dst = dsPtr->str + dsPtr->len;
        memcpy(dst, string, length);
        dst[length] = 0;
        dsPtr->len += length;
    }
    return dsPtr->str+len;
}

/* 
 * Calls Jsi_DSAppendLen for each string value argument, passing in -1 for the length.
 * Each string is assumed to be null terminated and the final argument must be a NULL.
 * RETURNS: The string starting at the first appended character.
*/
char *
Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)
{
    va_list argList;
    char *elem;
    if (DSNotInit(dsPtr))
        InitStr(dsPtr);
    int len = dsPtr->len;
    if (!str)
        return dsPtr->str;
    Jsi_DSAppendLen(dsPtr, str, -1);
    va_start(argList, str);
    while ((elem = va_arg(argList, char *)) != NULL) {
        Jsi_DSAppendLen(dsPtr, elem, -1);
    }
    va_end(argList);
    return dsPtr->str+len;
}

/*
 * Format output and append to the end of dsPtr.
 * RETURNS: The string starting at the first appended character.
 */
char *
Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)
{
    va_list argList;
#ifndef JSI_PRINTF_BUFSIZ
#define JSI_PRINTF_BUFSIZ BUFSIZ
#endif
    char buf[JSI_PRINTF_BUFSIZ], *bPtr = buf;
    int n, bsiz = sizeof(buf), needAppend = 1;
    if (DSNotInit(dsPtr))
        InitStr(dsPtr);
    int len = dsPtr->len;
    char *send = dsPtr->str + len;
    uint avail = (dsPtr->spaceAvl - len);
    if (avail >= sizeof(buf)) { /* Format directly into string. */
        bPtr = dsPtr->str+len;
        bsiz = avail;
        needAppend = 0;
    }
    va_start(argList, fmt);
    n = vsnprintf(bPtr, bsiz, fmt, argList);
    if (n<0 || (n+len)>JSI_MAX_ALLOC_BUF) {
        LogError("vsnprintf error: rc=%d, len=%d", n, len);
        va_end(argList);
        return send;
    }
    if (n >= bsiz) {
        int m = len+n+1;
        if (Jsi_DSSetLength(dsPtr, m) < m) {
            va_start(argList, fmt);
            return send;
        }
        m = vsnprintf(dsPtr->str+len, len+1, fmt, argList);
        if (m != n) {
            LogError("len mismatch: %d != %d",  m, n);
            va_end(argList);
            return send;
        }
    } else if (needAppend) {
        Jsi_DSAppendLen(dsPtr, buf, n);
    }
    va_end(argList);
    return send;
}

/* 
 * Set the minimum allocated space and/or the maximum string length. 
 * If length < current dsPtr->len truncates string, else sets minimum allocated space.
 * RETURNS: currently allocated space. 
 */
int
Jsi_DSSetLength(Jsi_DString *dsPtr, int length)
{
    if (DSNotInit(dsPtr))
        InitStr(dsPtr);
    if (length < 0)
        return dsPtr->spaceAvl;
    if (length >= JSI_MAX_ALLOC_BUF) {
        LogError("max alloc exceeded %d", length);
        length = JSI_MAX_ALLOC_BUF-1;
    }

    if (length >= dsPtr->spaceAvl) {
        int isStatic = (dsPtr->staticSpace == dsPtr->str);

        dsPtr->spaceAvl = length;
        if (isStatic == 0 || length >= dsPtr->staticSize) {
            char *newString = (char *) Jsi_Realloc((isStatic?NULL:dsPtr->str), (unsigned) (dsPtr->spaceAvl+1));
            if (!newString) {
                LogError("malloc failed %d", dsPtr->spaceAvl+1);
                return -1;
            }
            dsPtr->str = newString;
            if (isStatic && dsPtr->len>0)
                memcpy(dsPtr->str, dsPtr->staticSpace, (size_t) (dsPtr->len+1));
        }
    }
    if (length < dsPtr->len) {
        dsPtr->str[length] = 0;
        dsPtr->len = length;
    }
    return dsPtr->spaceAvl;
}

char *
Jsi_DSSet(Jsi_DString *dsPtr, const char *str)
{
    Jsi_DSSetLength(dsPtr, 0);
    if (str)
        Jsi_DSAppendLen(dsPtr, str, -1);
    return Jsi_DSValue(dsPtr);
}

/*
 * Returns the strdup of the string value and resets the DString in the same way as Jsi_DSFree.
 * This just avoids the user having to do an extra malloc/free when the DString was already malloced.
 * It is the responsibility of the caller to free the returned value.
 * RETURNS: previous string value malloced.
 */
char*  Jsi_DSFreeDup(Jsi_DString *dsPtr)
{
    char *cp;
    if (DSNotInit(dsPtr))
        InitStr(dsPtr);
    if (dsPtr->staticSpace == dsPtr->str) {
        cp = Jsi_Strdup(dsPtr->str);
        Jsi_DSSetLength(dsPtr, 0);
        return cp;
    }
    cp = dsPtr->str;
    dsPtr->str = dsPtr->staticSpace;
    dsPtr->staticSpace[0] = 0;
    dsPtr->spaceAvl = dsPtr->staticSize;
    dsPtr->len = 0;
    dsPtr->str = NULL;
    return cp;
}

#ifdef JSI_DSTRING_SELFTEST

void Jsi_DString_SelfTest() {
    {
        Jsi_DString d1 = {}, d2 = {"Here is"};
        Jsi_DSAppend(&d2 ," your score: ", NULL);
        Jsi_DSPrintf(&d2, " -> %d/%d", 99, 100);
        char *cp = Jsi_DSValue(&d2);
        puts(cp);     // "Here is your score: -> 99/100"
        Jsi_DSAppend(&d1, cp, NULL);
        Jsi_DSFree(&d1);  Jsi_DSFree(&d2);
    }
    {
        Jsi_DString d = {};;
        Jsi_DSPrintf(&d , "%0300d", 1); // Malloc
        Jsi_DSSetLength(&d, 0);
        Jsi_DSPrintf(&d , "%0300d", 1); // No-malloc
        Jsi_DSFree(&d);
        Jsi_DSPrintf(&d , "%0300d", 1); // Malloc
        Jsi_DSFree(&d);
    }
    {
        Jsi_DString d;
        Jsi_DSInit(&d);
        Jsi_DSAppend(&d , " some stuff: ", NULL);
        Jsi_DSFree(&d);
    }
    {
        JSI_DSTRING_VAR(dPtr,301);
        Jsi_DSPrintf(dPtr , "%0300d", 1); // No-malloc
        Jsi_DSSetLength(dPtr, 0);
        Jsi_DSPrintf(dPtr , "%0300d", 1); // No-malloc
        Jsi_DSFree(dPtr);
        Jsi_DSPrintf(dPtr , "%0400d", 1); // Malloc
        Jsi_DSFree(dPtr);
    }
}
#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <math.h>

#define MFUNC1(fname, func)  \
static int fname (Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\
    Jsi_Value **ret, Jsi_Func *funcPtr)\
{\
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\
    Jsi_Number num;\
    if (Jsi_GetNumberFromValue(interp, val, &num) != JSI_OK)\
        return JSI_ERROR;\
    Jsi_ValueMakeNumber(interp, ret, func (num));\
    return JSI_OK;\
}

#define MFUNC2(fname, func)  \
static int fname (Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\
    Jsi_Value **ret, Jsi_Func *funcPtr)\
{\
    Jsi_Value *val1 = Jsi_ValueArrayIndex(interp, args, 0);\
    Jsi_Number num1;\
    if (Jsi_GetNumberFromValue(interp, val1, &num1) != JSI_OK)\
        return JSI_ERROR;\
    Jsi_Value *val2 = Jsi_ValueArrayIndex(interp, args, 1);\
    Jsi_Number num2;\
    if (Jsi_GetNumberFromValue(interp, val2, &num2) != JSI_OK)\
        return JSI_ERROR;\
    Jsi_ValueMakeNumber(interp, ret, func (num1,num2));\
    return JSI_OK;\
}

static int MathMinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int i, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *val;
    Jsi_Number n, num;
    if (argc<=0)
        return JSI_OK;
    for (i=0; i<argc; i++) {
        val = Jsi_ValueArrayIndex(interp, args, i);
        if (Jsi_GetNumberFromValue(interp, val, &num) != JSI_OK)
            return JSI_ERROR;
        if (i==0)
            n = num;
        else
            n =  (num>n ? n : num);
    }
    Jsi_ValueMakeNumber(interp, ret, n);
    return JSI_OK;
}


static int MathMaxCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int i, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *val;
    Jsi_Number n, num;
    if (argc<=0)
        return JSI_OK;
    for (i=0; i<argc; i++) {
        val = Jsi_ValueArrayIndex(interp, args, i);
        if (Jsi_GetNumberFromValue(interp, val, &num) != JSI_OK)
            return JSI_ERROR;
        if (i==0)
            n = num;
        else
            n =  (num<n ? n : num);
    }
    Jsi_ValueMakeNumber(interp, ret, n);
    return JSI_OK;
}

static int MathRandomCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    static int init = 0;
#ifndef __WIN32
    if (!init) {
        init = 1;
        srand48((long)time(NULL));
    }
    Jsi_ValueMakeNumber(interp, ret, drand48());
#else
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rand());
#endif
    return JSI_OK;
}

MFUNC1(MathAbsCmd,  abs)
MFUNC1(MathAcosCmd, acos)
MFUNC1(MathAsinCmd, asin)
MFUNC1(MathAtanCmd, atan)
MFUNC1(MathCeilCmd, ceil)
MFUNC1(MathCosCmd,  cos)
MFUNC1(MathExpCmd,  exp)
MFUNC1(MathFloorCmd,floor)
MFUNC1(MathLogCmd,  log)
MFUNC1(MathRoundCmd,round)
MFUNC1(MathSinCmd,  sin)
MFUNC1(MathSqrtCmd, sqrt)
MFUNC1(MathTanCmd,  tan)
MFUNC2(MathAtan2Cmd,atan2)
MFUNC2(MathPowCmd,  pow)

static Jsi_CmdSpec mathCmds[] = {
    { "abs",    MathAbsCmd,     1, 1, "num:number", .help="Returns the absolute value of x", .retType=(uint)JSI_TT_NUMBER },
    { "acos",   MathAcosCmd,    1, 1, "num:number", .help="Returns the arccosine of x, in radians", .retType=(uint)JSI_TT_NUMBER },
    { "asin",   MathAsinCmd,    1, 1, "num:number", .help="Returns the arcsine of x, in radians", .retType=(uint)JSI_TT_NUMBER },
    { "atan",   MathAtanCmd,    1, 1, "num:number", .help="Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians", .retType=(uint)JSI_TT_NUMBER },
    { "atan2",  MathAtan2Cmd,   2, 2, "x:number, y:number", .help="Returns the arctangent of the quotient of its arguments", .retType=(uint)JSI_TT_NUMBER },
    { "ceil",   MathCeilCmd,    1, 1, "num:number", .help="Returns x, rounded upwards to the nearest integer", .retType=(uint)JSI_TT_NUMBER },
    { "cos",    MathCosCmd,     1, 1, "num:number", .help="Returns the cosine of x (x is in radians)", .retType=(uint)JSI_TT_NUMBER },
    { "exp",    MathExpCmd,     1, 1, "num:number", .help="Returns the value of Ex", .retType=(uint)JSI_TT_NUMBER },
    { "floor",  MathFloorCmd,   1, 1, "num:number", .help="Returns x, rounded downwards to the nearest integer", .retType=(uint)JSI_TT_NUMBER },
    { "log",    MathLogCmd,     1, 1, "num:number", .help="Returns the natural logarithm (base E) of x", .retType=(uint)JSI_TT_NUMBER },
    { "max",    MathMaxCmd,     2,-1, "x:number, y:number, ...", .help="Returns the number with the highest value", .retType=(uint)JSI_TT_NUMBER },
    { "min",    MathMinCmd,     2,-1, "x:number, y:number, ...", .help="Returns the number with the lowest value", .retType=(uint)JSI_TT_NUMBER },
    { "pow",    MathPowCmd,     2, 2, "x:number, y:number", .help="Returns the value of x to the power of y", .retType=(uint)JSI_TT_NUMBER },
    { "random", MathRandomCmd,  0, 0, "", .help="Returns a random number between 0 and 1", .retType=(uint)JSI_TT_NUMBER },
    { "round",  MathRoundCmd,   1, 1, "num:number", .help="Rounds x to the nearest integer", .retType=(uint)JSI_TT_NUMBER },
    { "sin",    MathSinCmd,     1, 1, "num:number", .help="Returns the sine of x (x is in radians)", .retType=(uint)JSI_TT_NUMBER },
    { "sqrt",   MathSqrtCmd,    1, 1, "num:number", .help="Returns the square root of x", .retType=(uint)JSI_TT_NUMBER },
    { "tan",    MathTanCmd,     1, 1, "num:number", .help="Returns the tangent of an angle", .retType=(uint)JSI_TT_NUMBER },
    { NULL, .help="Commands performing math operations on numbers" }
};

    
int jsi_MathInit(Jsi_Interp *interp)
{
    Jsi_Value *val = Jsi_CommandCreateSpecs(interp, "Math",    mathCmds,    NULL, JSI_CMDSPEC_NOTOBJ);
#define MCONST(name,v) Jsi_ValueInsert(interp, val, name, Jsi_ValueNewNumber(interp, v), JSI_OM_READONLY)
    MCONST("PI", M_PI);
    MCONST("LN2", M_LN2);
    MCONST("LN10", M_LN10);
    MCONST("LOG2E", M_LOG2E);
    MCONST("LOG10E", M_LOG10E);
    MCONST("SQRT2", M_SQRT2);
    MCONST("SQRT1_2", M_SQRT1_2);
    MCONST("E", M_E);
    return JSI_OK;
}

#endif
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#include "jsmn.h"
#endif
#ifndef JSMN_FREE
#define JSMN_FREE(p) free(p)
#define JSMN_MALLOC(l) malloc(l)
#define JSMN_REALLOC(p,l) realloc(p,l)
#endif
static jsmnerr_t jsmn_error(jsmn_parser *parser, jsmnerr_t err, const char *str) {
    switch (err) {
        case JSMN_ERROR_NOMEM: str = "out of memory"; break;
        case JSMN_ERROR_PART: str = "expected more bytes"; break;
        default: break;
    }
    parser->errStr = str;
    return err;
}
/**
 * Allocates a fresh unused token from the token pull.
 */
static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, int *indexPtr) {
    jsmntok_t *tok;
    uint index, oldsz;
    if (parser->toknext >= parser->num_tokens) {
        if (parser->no_malloc) return NULL;
        oldsz = parser->num_tokens;
        parser->num_tokens *= 2;
        if (parser->tokens != parser->static_tokens || parser->static_tokens == NULL)
            parser->tokens = (jsmntok_t*)JSMN_REALLOC(parser->tokens, sizeof(jsmntok_t)*parser->num_tokens);
        else {
            parser->tokens = (jsmntok_t*)JSMN_MALLOC(sizeof(jsmntok_t)*parser->num_tokens);
            memcpy(parser->tokens, parser->static_tokens, sizeof(jsmntok_t)*oldsz);
        }
    }
    index = parser->toknext++;
    tok = &parser->tokens[index];
    tok->start = tok->end = -1;
    tok->size = 0;
    if (indexPtr) *indexPtr = index;
#ifdef JSMN_PARENT_LINKS
    tok->parent = -1;
#endif
    return tok;
}

void jsmn_free(jsmn_parser* parser) {
    if (parser->tokens != parser->static_tokens && parser->tokens) 
        JSMN_FREE(parser->tokens);
    parser->tokens = NULL;
}

/**
 * Fills token type and boundaries.
 */
static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type, 
                            int start, int end) {
    token->type = type;
    token->start = start;
    token->end = end;
    token->size = 0;
}

/**
 * Fills next available token with JSON primitive.
 */
static jsmnerr_t jsmn_parse_primitive(jsmn_parser *parser, const char *js) {
    jsmntok_t *token;
    int start, index;

    start = parser->pos;

    for (; js[parser->pos] != '\0'; parser->pos++) {
        switch (js[parser->pos]) {
            /* In strict mode primitive must be followed by "," or "}" or "]" */
            case ':':
                if (parser->strict) break;
            case '\t' : case '\r' : case '\n' : case ' ' :
            case ','  : case ']'  : case '}' :
                goto found;
        }
        if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
            parser->pos = start;
            return jsmn_error(parser,JSMN_ERROR_INVAL, "invalid char");
        }
    }
    if (parser->strict) {
        /* In strict mode primitive must be followed by a comma/object/array */
        parser->pos = start;
        return jsmn_error(parser,JSMN_ERROR_PART, "expected comma/object/array");
    }

found:
    token = jsmn_alloc_token(parser, &index);
    if (token == NULL) {
        parser->pos = start;
        return jsmn_error(parser,JSMN_ERROR_NOMEM, "");
    }
    jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
#ifdef JSMN_PARENT_LINKS
    token->parent = parser->toksuper;
#endif
    parser->pos--;
    return JSMN_SUCCESS;
}

/**
 * Fills next token with JSON string.
 */
static jsmnerr_t jsmn_parse_string(jsmn_parser *parser, const char *js) {
    jsmntok_t *token;

    int index, start = parser->pos;

    parser->pos++;

    /* Skip starting quote */
    for (; js[parser->pos] != '\0'; parser->pos++) {
        char c = js[parser->pos];

        /* Quote: end of string */
        if (c == '\"') {
            token = jsmn_alloc_token(parser, &index);
            if (token == NULL) {
                parser->pos = start;
                return jsmn_error(parser,JSMN_ERROR_NOMEM, "");
            }
            jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
#ifdef JSMN_PARENT_LINKS
            token->parent = parser->toksuper;
#endif
            return JSMN_SUCCESS;
        }

        /* Backslash: Quoted symbol expected */
        if (c == '\\') {
            parser->pos++;
            switch (js[parser->pos]) {
                /* Allowed escaped symbols */
                case '\"': case '/' : case '\\' : case 'b' :
                case 'f' : case 'r' : case 'n'  : case 't' :
                    break;
                /* Allows escaped symbol \uXXXX */
                case 'u':
                    if (!(isxdigit(js[parser->pos+1]) && isxdigit(js[parser->pos+2]) &&
                    isxdigit(js[parser->pos+3]) && isxdigit(js[parser->pos+4]))) {
                        parser->pos = start;
                        return jsmn_error(parser,JSMN_ERROR_INVAL,"expected X digit in \\uXXXX escape");
                    }
                    break;
                /* Unexpected symbol */
                default:
                    parser->pos = start;
                    return jsmn_error(parser,JSMN_ERROR_INVAL, "unexpected symbol");
            }
        }
    }
    parser->pos = start;
    return jsmn_error(parser,JSMN_ERROR_PART,"");
}

/**
 * Parse JSON string and fill tokens.
 */
jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js) {
    jsmnerr_t r;
    int i, index = -1;
    jsmntok_t *token = NULL;

    for (; js[parser->pos] != '\0'; parser->pos++) {
        char c;
        int match;
        jsmntype_t type;

        c = js[parser->pos];
        match = 0;
        switch (c) {
            case '{': case '[':
                token = jsmn_alloc_token(parser, &index);
                if (token == NULL)
                    return jsmn_error(parser,JSMN_ERROR_NOMEM,"");
                if (parser->toksuper != -1) {
                    parser->tokens[parser->toksuper].size++;
#ifdef JSMN_PARENT_LINKS
                    token->parent = parser->toksuper;
#endif
                }
                token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
                token->start = parser->pos;
                parser->toksuper = parser->toknext - 1;
                break;
            case '}': case ']':
                type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
#ifdef JSMN_PARENT_LINKS
                if (parser->toknext < 1) {
                    return jsmn_error(parser,JSMN_ERROR_INVAL,"expected more");
                }
                token = &tokens[parser->toknext - 1];
                for (;;) {
                    if (token->start != -1 && token->end == -1) {
                        if (token->type != type) {
                            return jsmn_error(parser,JSMN_ERROR_INVAL,"type mismatch");
                        }
                        token->end = parser->pos + 1;
                        parser->toksuper = token->parent;
                        break;
                    }
                    if (token->parent == -1) {
                        break;
                    }
                    token = &parser->tokens[token->parent];
                }
#else
                for (i = parser->toknext - 1; i >= 0; i--) {
                    token = &parser->tokens[i];
                    if (token->start != -1 && token->end == -1) {
                        if (token->type != type) {
                            return jsmn_error(parser,JSMN_ERROR_INVAL,"type mismatch");
                        }
                        parser->toksuper = -1;
                        token->end = parser->pos + 1;
                        break;
                    }
                }
                /* Error if unmatched closing bracket */
                if (i == -1)
                    return jsmn_error(parser,JSMN_ERROR_INVAL, "unmatched closing bracket");
                for (; i >= 0; i--) {
                    token = &parser->tokens[i];
                    if (token->start != -1 && token->end == -1) {
                        parser->toksuper = i;
                        break;
                    }
                }
#endif
                break;
            case '\"':
                r = jsmn_parse_string(parser, js);
                if (r < 0) return r;
                if (index>=0) token = &parser->tokens[index];
                if (parser->toksuper != -1)
                    parser->tokens[parser->toksuper].size++;
                break;
            case ':' :
                if (parser->strict && token->type != JSMN_OBJECT)
                    if (parser->toksuper<0 || parser->tokens[parser->toksuper].type != JSMN_OBJECT)
                    return jsmn_error(parser,JSMN_ERROR_INVAL,"got ':' in a non-object");
            case ',': 
                if (parser->strict == 0 || token->type == JSMN_ARRAY)
                    break;
                if (token->type != JSMN_OBJECT)
                    return jsmn_error(parser,JSMN_ERROR_INVAL,"expected object");
            case '\t' : case '\r' : case '\n' : case ' ': 
                break;

            /* In strict mode primitives are: numbers and booleans */
            case '-': case '0': case '1' : case '2': case '3' : case '4':
            case '5': case '6': case '7' : case '8': case '9':
            case 't': case 'f': case 'n' :
                match = 1;
                
            default:
                if (parser->strict && !match)   /* Unexpected char in strict mode */
                    return jsmn_error(parser,JSMN_ERROR_INVAL, "unexpected char in strict mode");
                r = jsmn_parse_primitive(parser, js);
                if (r < 0) return r;
                if (index>=0) token = &parser->tokens[index];
                if (parser->toksuper != -1)
                    parser->tokens[parser->toksuper].size++;
                break;

        }
    }

    for (i = parser->toknext - 1; i >= 0; i--) {
        /* Unmatched opened object or array */
        if (parser->tokens[i].start != -1 && parser->tokens[i].end == -1) {
            return jsmn_error(parser,JSMN_ERROR_PART,"");
        }
    }

    return JSMN_SUCCESS;
}

/**
 * Initialize parser based over a given  buffer with an array of tokens 
 * available.
 */
void jsmn_init(jsmn_parser *parser, jsmntok_t *tokens, 
        unsigned int num_tokens) {
    parser->pos = 0;
    parser->toknext = 0;
    parser->toksuper = -1;
    parser->tokens = parser->static_tokens = tokens;
    if (tokens == NULL && num_tokens==0)
        num_tokens = 100;
    if (tokens == NULL)
        parser->tokens = (jsmntok_t*)malloc(sizeof(jsmntok_t)*num_tokens);
    parser->num_tokens = num_tokens;
    parser->no_malloc = 0;  /* Can set this to zero after call to suppress malloc. */
}

void jsmn_reset(jsmn_parser* parser) {
    parser->pos = 0;
    parser->toknext = 0;
    parser->toksuper = -1;
}

/* Helper functions */

void jsmn_dump(jsmn_parser *parser, const char *js) {
    uint i;
    for (i=0; i<parser->toknext; i++)
        printf("TOK(%s): %.*s\n", jsmn_typename(parser->tokens[i].type),
            (parser->tokens[i].end-parser->tokens[i].start),
            js+parser->tokens[i].start);
}
jsmntok_t *jsmn_token(jsmn_parser *parser, unsigned int index) {
    if (index>=parser->toknext)
        return NULL;
    return parser->tokens+index;
}
jsmntype_t jsmn_type(jsmn_parser *parser, unsigned int index) {
    if (index>=parser->toknext)
        return JSMN_INVALID;
    return parser->tokens[index].type;
}
int jsmn_toklen(jsmn_parser *parser, unsigned int index) {
    if (index>=parser->toknext)
        return -1;
    return (parser->tokens[index].end-parser->tokens[index].start);
}

const char* jsmn_tokstr(jsmn_parser *parser, const char *js, uint index, uint *lenPtr) {
    int len;
    if (index>=parser->toknext)
        return NULL;
    len = (parser->tokens[index].end-parser->tokens[index].start);
    if (lenPtr)
        *lenPtr = len;
    return (js + parser->tokens[index].start);
}
const char* jsmn_typename(int type) {
    static const char *types[] = { "PRIMITIVE", "OBJECT", "ARRAY", "STRING", "<INVALID>" };
    if (type < JSMN_PRIMITIVE || type > JSMN_STRING)
        type = JSMN_STRING+1;
    return types[type];
}

const char* jsmn_errname(int code) {
    static const char *codes[] = { "SUCCESS", "NOMEM", "INVAL", "PART", "<BADCODE>" };
    code = -code;
    if (code < 0 || code > 3)
        code = 4;
    return codes[code];
}
#ifndef JSI_LITE_ONLY
#ifndef JSI_OMIT_ZVFS
/*
** Copyright (c) 2000 D. Richard Hipp
** Copyright (c) 2007 Peter MacDonald
**
** This file is now released under the BSD style license
** outlined in the included file COPYING.
**
*************************************************************************
** A ZIP archive virtual filesystem for Jsi.
**
** This package of routines enables Jsi to use a Zip file as
** a virtual file system.  Each of the content files of the Zip
** archive appears as a real file to Jsi.
**
** NOTE: could be compiled without jsiInt.h
*/
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

#include <ctype.h>
#ifndef USE_MINIZ
#include <zlib.h>
#else
#include "miniz/zlib.h"
#endif
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#define StrnCpy(d,s) strncpy(d,s,sizeof(d)), d[sizeof(d)-1] = 0

#define SS(s) Jsi_ValueString(interp, s, 0)

/*
** Size of the decompression input buffer
*/
#define COMPR_BUF_SIZE   8192
#ifdef __WIN32
static int maptolower=0;
#endif

typedef enum { ZVFS_SIG_PINFO = 0xbeefbeed, ZVFS_SIG_ARCHIVE, ZVFS_SIG_FILE, ZVFS_SIG_ZFILE } ZVFS_Sig;
#define ZVFSSIGASSERT(s,n) assert(s->sig == ZVFS_SIG_##n)
/*
** All static variables are collected into a structure named "zvfslocal".
** That way, it is clear in the code when we are using a static
** variable because its name begins with "zvfslocal.".
*/
static struct {
    Jsi_Hash* fileHash;     /* One entry for each file in the ZVFS.  The
                              ** The key is the virtual filename.  The data
                              ** an an instance of the ZvfsFile structure. */
    Jsi_Hash *archiveHash;  /* One entry for each archive.  Key is the name.
                              ** data is the ZvfsArchive structure */
    int isInit;                 /* True after initialization */
    Jsi_Interp *interp;
} zvfslocal;

/*
** Each ZIP archive file that is mounted is recorded as an instance
** of this structure
*/
typedef struct ZvfsArchive {
    Jsi_Value *Name;           /* Name of the archive */
    Jsi_Value *MountPoint;     /* Where this archive is mounted */
    struct ZvfsFile *pFiles;  /* List of files in that archive */
    Jsi_HashEntry *pEntry;
    Jsi_Channel chan;
} ZvfsArchive;

/*
** Particulars about each virtual file are recorded in an instance
** of the following structure.
*/
typedef struct ZvfsFile {
    char *zName;              /* The full pathname of the virtual file */
    ZvfsArchive *pArchive;    /* The ZIP archive holding this file data */
    int iOffset;              /* Offset into the ZIP archive of the data */
    int nByte;                /* Uncompressed size of the virtual file */
    int nByteCompr;           /* Compressed size of the virtual file */
    time_t timestamp;            /* Modification time */
    int isdir;            /* Set to 2 if directory, or 1 if mount */
    int depth;            /* Number of slashes in path. */
    int permissions;          /* File permissions. */
    struct ZvfsFile *pNext;      /* Next file in the same archive */
    struct ZvfsFile *pNextName;  /* A doubly-linked list of files with the same */
    struct ZvfsFile *pPrevName;  /*  name.  Only the first is in zvfslocal.fileHash */
} ZvfsFile;

/*
** Information about each file within a ZIP archive is stored in
** an instance of the following structure.  A list of these structures
** forms a table of contents for the archive.
*/
typedef struct ZFile {
    char *zName;         /* Name of the file */
    int isSpecial;       /* Not really a file in the ZIP archive */
    int dosTime;         /* Modification time (DOS format) */
    int dosDate;         /* Modification date (DOS format) */
    int iOffset;         /* Offset into the ZIP archive of the data */
    int nByte;           /* Uncompressed size of the virtual file */
    int nByteCompr;      /* Compressed size of the virtual file */
    int nExtra;          /* Extra space in the TOC header */
    int iCRC;            /* Cyclic Redundancy Check of the data */
    int permissions;     /* File permissions. */
    int flags;            /* Deletion = bit 0. */
    struct ZFile *pNext;        /* Next file in the same archive */
} ZFile;

/*
** Whenever a ZVFS file is opened, an instance of this structure is
** attached to the open channel where it will be available to the
** ZVFS I/O routines below.  All state information about an open
** ZVFS file is held in this structure.
*/
typedef struct ZvfsChannelInfo {
    ZVFS_Sig sig;
    unsigned int nByte;       /* number of bytes of read uncompressed data */
    unsigned int nByteCompr;  /* number of bytes of unread compressed data */
    unsigned int nData;       /* total number of bytes of compressed data */
    int readSoFar;            /* Number of bytes read so far */
    long startOfData;         /* File position of start of data in ZIP archive */
    int isCompressed;         /* True -> data is compressed */
    int curPos;               /* Current pos. */
    Jsi_Channel chan;         /* Open to the archive file */
    unsigned char *zBuf;      /* buffer used by the decompressor */
    z_stream stream;          /* state of the decompressor */
    ZvfsFile *pFile;
    int bpos;
    int bsiz;                 /* Amount of data in buf. */
    char buf[BUFSIZ];
    int iCRC;            /* Cyclic Redundancy Check of the data */
    char emuGzip;
    char useGzip;
} ZvfsChannelInfo;


/*
** Macros to read 16-bit and 32-bit big-endian integers into the
** native format of this local processor.  B is an array of
** characters and the integer begins at the N-th character of
** the array.
*/
#define INT16(B, N) (B[N] + (B[N+1]<<8))
#define INT32(B, N) (INT16(B,N) + (B[N+2]<<16) + (B[N+3]<<24))


/*
** Make a new ZFile structure with space to hold a name of the number of
** characters given.  Return a pointer to the new structure.
*/
static ZFile *newZFile(int nName, ZFile **ppList) {
    ZFile *pNew;

    pNew = (ZFile*)Jsi_Calloc(1, sizeof(*pNew) + nName + 1 );
    pNew->zName = (char*)&pNew[1];
    pNew->pNext = *ppList;
    *ppList = pNew;
    return pNew;
}

/*
** Delete an entire list of ZFile structures
*/
static void deleteZFileList(ZFile *pList) {
    ZFile *pNext;
    while( pList ) {
        pNext = pList->pNext;
        Jsi_Free((char*)pList);
        pList = pNext;
    }
}

/* Convert DOS time to unix time. */
static void UnixTimeDate(struct tm *tm, int *dosDate, int *dosTime) {
    *dosDate = ((((tm->tm_year-80)<<9)&0xfe00) | (((tm->tm_mon+1)<<5)&0x1e0) | (tm->tm_mday&0x1f));
    *dosTime = (((tm->tm_hour<<11)&0xf800) | ((tm->tm_min<<5)&0x7e0) | (tm->tm_sec&0x1f));
}

/* Convert DOS time to unix time. */
static time_t DosTimeDate(int dosDate, int dosTime) {
    time_t now;
    struct tm *tm;
    now=time(NULL);
    tm = localtime(&now);
    tm->tm_year=(((dosDate&0xfe00)>>9) + 80);
    tm->tm_mon=((dosDate&0x1e0)>>5);
    tm->tm_mday=(dosDate & 0x1f);
    tm->tm_hour=(dosTime&0xf800)>>11;
    tm->tm_min=(dosTime&0x7e0)>>5;
    tm->tm_sec=(dosTime&0x1f);
    return mktime(tm);
}

/* Return count of char ch in str */
static int strchrcnt(char *str, char ch) {
    int cnt=0;
    char *cp=str;
    while ((cp=strchr(cp,ch))) {
        cp++;
        cnt++;
    }
    return cnt;
}


/* TODO: merge back into jsiFilesys.c
** Concatenate zTail onto zRoot to form a pathname.  zRoot will begin
** with "/".  After concatenation, simplify the pathname be removing
** unnecessary ".." and "." directories.  Under windows, make all
** characters lower case.
**
** Resulting pathname is returned.  Space to hold the returned path is
** obtained form Jsi_Alloc() and should be freed by the calling function.
*/
static char *CanonicalPath(const char *zRoot, const char *zTail) {
    char *zPath;
    int i, j, c;

#ifdef __WIN32__
    if( isalpha(zTail[0]) && zTail[1]==':' ) {
        zTail += 2;
    }
    if( zTail[0]=='\\' ) {
        zRoot = "";
        zTail++;
    }
#endif
    if( zTail[0]=='/' ) {
        zRoot = "";
        zTail++;
    }
    zPath = (char*)Jsi_Malloc( strlen(zRoot) + strlen(zTail) + 2 );
    if( zPath==0 ) return 0;
    if (zTail[0]) {
        sprintf(zPath, "%s/%s", zRoot, zTail);
    } else {
        strcpy(zPath, zRoot);
    }
    for(i=j=0; (c = zPath[i])!=0; i++) {
#ifdef __WIN32__
        if( isupper(c) ) {
            if (maptolower) c = tolower(c);
        }
        else if( c=='\\' ) c = '/';
#endif
        if( c=='/' ) {
            int c2 = zPath[i+1];
            if( c2=='/' ) continue;
            if( c2=='.' ) {
                int c3 = zPath[i+2];
                if( c3=='/' || c3==0 ) {
                    i++;
                    continue;
                }
                if( c3=='.' && (zPath[i+3]=='.' || zPath[i+3]==0) ) {
                    i += 2;
                    while( j>0 && zPath[j-1]!='/' ) {
                        j--;
                    }
                    continue;
                }
            }
        }
        zPath[j++] = c;
    }
    if( j==0 ) {
        zPath[j++] = '/';
    }

    zPath[j] = 0;
    return zPath;
}

static int ZvfsReadTOCStart(
    Jsi_Interp *interp,    /* Leave error messages in this interpreter */
    Jsi_Channel chan,
    ZFile **pList,
    int *iStart
) {
// char *zArchiveName = 0;    /* A copy of zArchive */
    int nFile;                 /* Number of files in the archive */
    int iPos;                  /* Current position in the archive file */
    //ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    //Jsi_HashEntry *pEntry;     /* Hash table entry */
    //int isNew;                 /* Flag to tell use when a hash entry is new */
    unsigned char zBuf[100];   /* Space into which to read from the ZIP archive */
    //Jsi_HashSearch zSearch;   /* Search all mount points */
    ZFile *p;
    int zipStart;

    if (!chan) {
        return JSI_ERROR;
    }
    /* TODO: if we ever support utf8 properly, these might do something. */
    if (Jsi_SetChannelOption(interp, chan, "-translation", "binary") != JSI_OK) {
        return JSI_ERROR;
    }
    if (Jsi_SetChannelOption(interp, chan, "-encoding", "binary") != JSI_OK) {
        return JSI_ERROR;
    }

    /* Read the "End Of Central Directory" record from the end of the
    ** ZIP archive.
    */
    Jsi_Seek(chan, -22, SEEK_END);
    iPos = Jsi_Tell(chan);
    Jsi_Read(chan, (char*)zBuf, 22);
    if (memcmp(zBuf, "\120\113\05\06", 4)) {
        /* Jsi_LogError("not a ZIP archive"); */
        return JSI_BREAK;
    }

    /* Compute the starting location of the directory for the ZIP archive
    ** in iPos then seek to that location.
    */
    zipStart = iPos;
    nFile = INT16(zBuf,8);
    iPos -= INT32(zBuf,12);
    Jsi_Seek(chan, iPos, SEEK_SET);

    while(1) {
        int lenName;            /* Length of the next filename */
        int lenExtra;           /* Length of "extra" data for next file */
        int iData;              /* Offset to start of file data */
        // int dosTime;
        //int dosDate;
        //int isdir;
        //ZvfsFile *pZvfs;        /* A new virtual file */
        // char *zFullPath;        /* Full pathname of the virtual file */
        //char zName[1024];       /* Space to hold the filename */

        if (nFile-- <= 0 ) {
            break;
        }
        /* Read the next directory entry.  Extract the size of the filename,
        ** the size of the "extra" information, and the offset into the archive
        ** file of the file data.
        */
        Jsi_Read(chan, (char*)zBuf, 46);
        if (memcmp(zBuf, "\120\113\01\02", 4)) {
            Jsi_LogError("ill-formed central directory entry");
            return JSI_ERROR;
        }
        lenName = INT16(zBuf,28);
        lenExtra = INT16(zBuf,30) + INT16(zBuf,32);
        iData = INT32(zBuf,42);
        if (iData<zipStart) {
            zipStart = iData;
        }

        p = newZFile(lenName, pList);
        if (!p) break;

        Jsi_Read(chan, p->zName, lenName);
        p->zName[lenName] = 0;
        if (lenName>0 && p->zName[lenName-1] == '/') {
            p->isSpecial = 1;
        }
        p->dosDate = INT16(zBuf, 14);
        p->dosTime = INT16(zBuf, 12);
        p->nByteCompr = INT32(zBuf, 20);
        p->nByte = INT32(zBuf, 24);
        p->nExtra = INT32(zBuf, 28);
        p->iCRC = INT32(zBuf, 32);

        if (nFile < 0)
            break;

        /* Skip over the extra information so that the next read will be from
        ** the beginning of the next directory entry.
        */
        Jsi_Seek(chan, lenExtra, SEEK_CUR);
    }
    *iStart = zipStart;
    return JSI_OK;
}

static int ZvfsReadTOC(
    Jsi_Interp *interp,    /* Leave error messages in this interpreter */
    Jsi_Channel chan,
    ZFile **pList
) {
    int iStart;
    return ZvfsReadTOCStart( interp, chan, pList, &iStart);
}


static ZvfsArchive* ZvfsLookupMount(Jsi_Interp *interp, const char *path) {
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */

    ZvfsArchive* match=0;
    if( zvfslocal.isInit==0 ) return 0;
    pEntry=Jsi_HashEntryFirst(zvfslocal.archiveHash,&zSearch);
    while (pEntry) {
        if ((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry))) {
            if (!strcmp(Jsi_ValueToString(interp, pArchive->MountPoint, NULL), path)) {
                match=(ZvfsArchive*)Jsi_HashValueGet(pEntry);
                break;
            }
        }
        pEntry=Jsi_HashEntryNext(&zSearch);
    }

    return match;
}

#define FN_info JSI_INFO("\
Given an mount point argument, returns the archive for it. \
Otherwise, returns an array of mount points")

static int ZvfsNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                       Jsi_Value **ret, Jsi_Func *funcPtr)
{
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */
    Jsi_DString pStr, mStr;
    Jsi_Value *mount = Jsi_ValueArrayIndex(interp, args, 0);
    int rc = JSI_OK;
    
    Jsi_DSInit(&pStr);
    Jsi_DSInit(&mStr);
    if( !zvfslocal.isInit ) return JSI_ERROR;
    /* If null archive name, return all current mounts. */
    if (!mount) {
        if (!ret)
            return JSI_OK;
        Jsi_Obj* obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);
        pEntry=Jsi_HashEntryFirst(zvfslocal.archiveHash,&zSearch);
        while (pEntry) {
            if ((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry))) {
                Jsi_ObjArrayAdd(interp, obj, pArchive->MountPoint);
            }
            pEntry=Jsi_HashEntryNext(&zSearch);
        }
        Jsi_ValueMakeObject(interp, ret, obj);
        return JSI_OK;
    }
    const char *zMountPoint = Jsi_ValueToString(interp, mount, NULL);

    pArchive = ZvfsLookupMount(interp, zMountPoint);
    if (pArchive) {
        if (ret)
            Jsi_ValueDup2(interp, ret, pArchive->Name);
        else
            rc = JSI_ERROR;
    }
    Jsi_DSFree(&pStr);
    return rc;
}

#define FN_mount JSI_INFO("\
Read a ZIP archive and make entries in the virutal file hash table for all \
files contained therein.")
int Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)
{
    Jsi_Channel chan;          /* Used for reading the ZIP archive file */
    char *zArchiveName = 0;    /* A copy of zArchive */
    int nFile;                 /* Number of files in the archive */
    int iPos;                  /* Current position in the archive file */
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    int isNew;                 /* Flag to tell use when a hash entry is new */
    unsigned char zBuf[100];   /* Space into which to read from the ZIP archive */
    unsigned int startZip;
    Jsi_DString pStr, mStr;
    const char *zMountPoint;
    char mbuf[100];

    Jsi_DSInit(&pStr);
    Jsi_DSInit(&mStr);
    if( !zvfslocal.isInit ) return JSI_ERROR;
    /* If NULL mount, generate a mount point. */
    // TODO: cleanup allocations of Absolute() path.
    if (mount == NULL || Jsi_ValueIsNull(interp, mount)) {
        int n = 0;
        while (n++ < 1000) {
            sprintf(mbuf, "%s%d", JSI_ZVFS_DIR, n);
            if (!ZvfsLookupMount(interp, mbuf))
                break;
        }
        zMountPoint = mbuf;
    } else {
        zMountPoint = Jsi_ValueToString(interp, mount, NULL);
    }
    chan = Jsi_Open(interp, archive, "rb");
    if (!chan) {
        return JSI_ERROR;
    }
    /* Read the "End Of Central Directory" record from the end of the
    ** ZIP archive.
    */
    if (Jsi_Seek(chan, -22, SEEK_END) != 0) {
        if (ret && *ret)
            Jsi_LogError("not a ZIP archive");
        goto bail;
    }
    iPos = Jsi_Tell(chan);
    Jsi_Read(chan, (char*)zBuf, 22);
    if (memcmp(zBuf, "\120\113\05\06", 4)) {
        if (ret && *ret)
            Jsi_LogError("not a ZIP archive");
        goto bail;
    }

    /* Construct the archive record
    */
    zArchiveName = Jsi_ValueNormalPath(interp, archive, &pStr);
    pEntry = Jsi_HashEntryNew(zvfslocal.archiveHash, zArchiveName, &isNew);
    if( !isNew ) {
        pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry);
        Jsi_LogError("already mounted at %s", SS(pArchive->MountPoint));
        Jsi_DSFree(&pStr);
        goto bail;
    }
    if (!*zMountPoint) {
        /* Empty string is the special case of mounting on itself. */
        zMountPoint = Jsi_ValueNormalPath(interp, archive, &mStr);
    } else if (zMountPoint != mbuf) {
        zMountPoint = Jsi_ValueNormalPath(interp, mount, &mStr);
    }
    pArchive = (ZvfsArchive*)Jsi_Calloc(1, sizeof(*pArchive));
    pArchive->Name = Jsi_ValueNewStringDup(interp, zArchiveName);
    Jsi_IncrRefCount(interp, pArchive->Name);
    Jsi_DSFree(&pStr);
    pArchive->MountPoint = Jsi_ValueNewStringDup(interp, zMountPoint);
    Jsi_IncrRefCount(interp, pArchive->MountPoint);
    pArchive->pFiles = 0;
    Jsi_HashValueSet(pEntry, pArchive);
    pArchive->pEntry = pEntry;

    /* Compute the starting location of the directory for the ZIP archive
    ** in iPos then seek to that location.
    */
    nFile = INT16(zBuf,8);
    iPos -= INT32(zBuf,12);
    Jsi_Seek(chan, iPos, SEEK_SET);
    startZip = iPos;

    while(1) {
        int lenName;            /* Length of the next filename */
        int lenExtra = 0;           /* Length of "extra" data for next file */
        int iData;              /* Offset to start of file data */
        int dosTime;
        int dosDate;
        int isdir;
        int rb;
        ZvfsFile *pZvfs;        /* A new virtual file */
        char *zFullPath;        /* Full pathname of the virtual file */
        char zName[1024];       /* Space to hold the filename */

        if (nFile-- <= 0 ) {
            isdir = 1;
            zFullPath = CanonicalPath(zMountPoint, "");
            iData = startZip;
            goto addentry;
        }
        /* Read the next directory entry.  Extract the size of the filename,
        ** the size of the "extra" information, and the offset into the archive
        ** file of the file data.
        */
        Jsi_Read(chan, (char*)zBuf, 46);
        if (memcmp(zBuf, "\120\113\01\02", 4)) {
            Jsi_LogError("ill-formed central directory entry");
            //TODO: cleanup.
            goto bail;
        }
        lenName = INT16(zBuf,28);
        lenExtra = INT16(zBuf,30) + INT16(zBuf,32);
        iData = INT32(zBuf,42);


        /* If the virtual filename is too big to fit in zName[], then skip
        ** this file
        */
        if( lenName >= (int)sizeof(zName) ) {
            Jsi_Seek(chan, lenName + lenExtra, SEEK_CUR);
            continue;
        }

        /* Construct an entry in zvfslocal.fileHash for this virtual file.
        */
        rb = Jsi_Read(chan, zName, lenName);
        if (rb != lenName)
            goto bail;
        isdir=0;
        if (lenName>0 && zName[lenName-1] == '/') {
            lenName--;
            isdir=2;
        }
        zName[lenName] = 0;
        zFullPath = CanonicalPath(zMountPoint, zName);
addentry:
        pZvfs = (ZvfsFile*)Jsi_Calloc(1, sizeof(*pZvfs) );
        pZvfs->zName = zFullPath;
        pZvfs->pArchive = pArchive;
        pZvfs->isdir = isdir;
        pZvfs->depth=strchrcnt(zFullPath,'/');
        pZvfs->iOffset = iData;
        if (iData<(int)startZip) {
            startZip = iData;
        }
        dosDate = INT16(zBuf, 14);
        dosTime = INT16(zBuf, 12);
        pZvfs->timestamp = DosTimeDate(dosDate, dosTime);
        pZvfs->nByte = INT32(zBuf, 24);
        pZvfs->nByteCompr = INT32(zBuf, 20);
        pZvfs->pNext = pArchive->pFiles;
        pZvfs->permissions = (0xffff&(INT32(zBuf, 38) >> 16));
        pArchive->pFiles = pZvfs;
        pEntry = Jsi_HashEntryNew(zvfslocal.fileHash, zFullPath, &isNew);
        if( isNew ) {
            pZvfs->pNextName = 0;
        } else {
            ZvfsFile *pOld = (ZvfsFile*)Jsi_HashValueGet(pEntry);
            pOld->pPrevName = pZvfs;
            pZvfs->pNextName = pOld;
        }
        pZvfs->pPrevName = 0;
        Jsi_HashValueSet(pEntry, (void*) pZvfs);

        if (nFile < 0)
            break;

        /* Skip over the extra information so that the next read will be from
        ** the beginning of the next directory entry.
        */
        Jsi_Seek(chan, lenExtra, SEEK_CUR);
    }
    pArchive->chan = chan;

    if (ret && *ret)
        Jsi_ValueMakeStringDup(interp, ret, zMountPoint);
    Jsi_DSFree(&mStr);
    Jsi_DSFree(&pStr);
//done:
    return JSI_OK;

bail:
    if (chan)
        Jsi_Close(chan);
    return JSI_ERROR;
}

/*
** Locate the ZvfsFile structure that corresponds to the file named.
** Return NULL if there is no such ZvfsFile.
*/
static ZvfsFile *ZvfsLookup(Jsi_Interp *interp, Jsi_Value *path) {
    char *zt;
    Jsi_HashEntry *pEntry;
    ZvfsFile *pFile;
    Jsi_DString dStr = {};
    int len, isdir = 0;
    if( zvfslocal.isInit==0 ) return 0;
    zt = Jsi_ValueNormalPath(interp, path, &dStr);
    len = dStr.len;
    if (len && zt[len-1] == '/') {
        isdir = 1;
        zt[len-1] = 0;
    }
    pEntry = Jsi_HashEntryFind(zvfslocal.fileHash, zt);
    pFile = (ZvfsFile*)(pEntry ? Jsi_HashValueGet(pEntry) : 0);
    Jsi_DSFree(&dStr);
    if (isdir && pFile && !pFile->isdir)
        return NULL;
    return pFile;
}

/*
** Unmount zip given its mount point.
*/
static int Zvfs_Unmount(Jsi_Interp *interp, Jsi_Value *path) {
    char *zPath;
    ZvfsArchive *pArchive;
    ZvfsFile *pFile, *pNextFile;
    Jsi_HashEntry *pEntry;
    Jsi_DString pStr;
    // TODO: use jsiMain interp for mount/unmount.
    // TODO: if pwd in mount, change it.
    zPath = Jsi_ValueNormalPath(interp, path, &pStr);
    if (!(pArchive = ZvfsLookupMount(interp, zPath)))
        return JSI_ERROR;

    Jsi_Close(pArchive->chan);
    if (pArchive->pEntry)
        Jsi_HashEntryDelete(pArchive->pEntry);
    Jsi_DecrRefCount(interp, pArchive->Name);
    Jsi_DecrRefCount(interp, pArchive->MountPoint);
    for(pFile=pArchive->pFiles; pFile; pFile=pNextFile) {
        pNextFile = pFile->pNext;
        if( pFile->pNextName ) {
            pFile->pNextName->pPrevName = pFile->pPrevName;
        }
        if( pFile->pPrevName ) {
            pFile->pPrevName->pNextName = pFile->pNextName;
        } else {
            pEntry = Jsi_HashEntryFind(zvfslocal.fileHash, pFile->zName);
            if( pEntry==0 ) {
                /* This should never happen */
            } else if( pFile->pNextName ) {
                Jsi_HashValueSet(pEntry, pFile->pNextName);
            } else {
                Jsi_HashEntryDelete(pEntry);
            }
        }
        Jsi_Free(pFile->zName);
        Jsi_Free((char*)pFile);
    }
    return 1;
}

/*
** zvfs::mount  Zip-archive-name  mount-point
**
** Create a new mount point on the given ZIP archive.  After this
** command executes, files contained in the ZIP archive will appear
** to Jsi to be regular files at the mount point.
**
** With no mount-point, return mount point for archive.
** With no archive, return all archive/mount pairs.
** If mount-point is specified as an empty string, mount on file path.
**
*/
static int ZvfsMountCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_Value* File = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value* Mount = Jsi_ValueArrayIndex(interp, args, 1);
    int rc = Zvfs_Mount(interp, File, Mount, ret);
    if (rc != JSI_OK) {
        Jsi_LogError("mount failed for %s on %s", SS(File), SS(Mount));
    }
    return rc;
}

static int ZvfsUnmountCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value* Mount = Jsi_ValueArrayIndex(interp, args, 0);
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */

    if (Zvfs_Unmount(interp, Mount)) {
        return JSI_OK;
    }

    if( !zvfslocal.isInit ) return JSI_ERROR;
    char *zMountPoint;
    char *zMount = SS(Mount);
    pEntry=Jsi_HashEntryFirst(zvfslocal.archiveHash,&zSearch);
    while (pEntry) {
        if (((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry)))
                && ((zMountPoint = SS(pArchive->MountPoint)))
                && zMountPoint[0]
                && (strcmp(zMountPoint, zMount) == 0)) {
            if (Zvfs_Unmount(interp, pArchive->Name)) {
                return JSI_OK;
            }
            break;
        }
        pEntry=Jsi_HashEntryNext(&zSearch);
    }

    Jsi_LogError("unknown zvfs mount point or file: %s", zMount);
    return JSI_ERROR;
}

#define FN_stat JSI_INFO("\
Return details about the given file in the ZVFS.  The information \
consists of (1) the name of the ZIP archive that contains the file, \
(2) the size of the file after decompressions, (3) the compressed \
size of the file, and (4) the offset of the compressed data in the archive.")
static int ZvfsStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                       Jsi_Value **ret, Jsi_Func *funcPtr)
{
    ZvfsFile *pFile;

    Jsi_Value *Filename = Jsi_ValueArrayIndex(interp, args, 0);
    pFile = ZvfsLookup(interp, Filename);
    if (pFile) 
    {
        Jsi_Obj *sobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeObject(interp, ret, sobj);
        
        Jsi_ObjInsert(interp, sobj, "archive", pFile->pArchive->Name, 0);
        Jsi_ObjInsert(interp, sobj, "offset", Jsi_ValueNewNumber(interp, (Jsi_Number)pFile->iOffset), 0);
        Jsi_ObjInsert(interp, sobj, "size", Jsi_ValueNewNumber(interp, (Jsi_Number)pFile->nByte), 0);
        Jsi_ObjInsert(interp, sobj, "compressedSize", Jsi_ValueNewNumber(interp, (Jsi_Number)pFile->nByteCompr), 0);

    }
    return JSI_OK;
}

/*
** The JSI I/O system calls this function to actually read information
** from a ZVFS file.
*/
static int vfsInput (
    ZvfsChannelInfo* pInfo,  /* The channel to read from */
    char *buf,               /* Buffer to fill */
    int toRead,              /* Requested number of bytes */
    int *pErrorCode          /* Location of error flag */
) {

    if( toRead > (int)pInfo->nByte ) {
        toRead = pInfo->nByte;
    }
    if( toRead == 0 ) {
        return 0;
    }
    Jsi_Seek(pInfo->chan, pInfo->curPos, SEEK_SET);
    if (!pInfo->isCompressed ) {
        toRead = Jsi_Read(pInfo->chan, buf, toRead);
    } else {
        int err = Z_OK;
        z_stream *stream = &pInfo->stream;
        stream->next_out = (unsigned char*)buf;
        stream->avail_out = toRead;
        while (stream->avail_out) {
            if (!stream->avail_in) {
                int len = pInfo->nByteCompr;
                if (len > COMPR_BUF_SIZE) {
                    len = COMPR_BUF_SIZE;
                }
                len = Jsi_Read(pInfo->chan, (char*)pInfo->zBuf, len);
                if (len==0) break;
                if (len<0) { err = Z_STREAM_END+1; break; }
                pInfo->nByteCompr -= len;
                stream->next_in = pInfo->zBuf;
                stream->avail_in = len;
            }
            err = inflate(stream, Z_NO_FLUSH);
            if (err) break;
        }
        if (err == Z_STREAM_END) {
            if ((stream->avail_out != 0)) {
                *pErrorCode = err; /* premature end */
                return -1;
            }
        } else if( err ) {
            *pErrorCode = err; /* some other zlib error */
            return -1;
        }
    }
    pInfo->curPos = Jsi_Tell(pInfo->chan);

    if (toRead<0)
        *pErrorCode = Z_STREAM_END;
    else {
        pInfo->nByte -= toRead;
        pInfo->readSoFar += toRead;
        *pErrorCode = 0;
    }
    return toRead;
}

/*
** Move the file pointer so that the next byte read will be "offset".
*/
static int vfsSeek(
    ZvfsChannelInfo* pInfo,    /* The file structure */
    long offset,                /* Offset to seek to */
    int mode,                   /* One of SEEK_CUR, SEEK_SET or SEEK_END */
    int *pErrorCode             /* Write the error code here */
) {
    Jsi_Seek(pInfo->chan, pInfo->curPos, SEEK_SET);
    switch( mode ) {
    case SEEK_CUR: {
        offset += pInfo->readSoFar;
        break;
    }
    case SEEK_END: {
        offset += pInfo->readSoFar + pInfo->nByte;
        break;
    }
    default: {
        /* Do nothing */
        break;
    }
    }
    if (offset < 0) offset = 0;
    if( !pInfo->isCompressed ) {
        Jsi_Seek(pInfo->chan, offset + pInfo->startOfData, SEEK_SET);
        pInfo->nByte = pInfo->nData;
        pInfo->readSoFar = offset;
    } else {
        if( offset<pInfo->readSoFar ) {
            z_stream *stream = &pInfo->stream;
            inflateEnd(stream);
            stream->zalloc = (alloc_func)0;
            stream->zfree = (free_func)0;
            stream->opaque = (voidpf)0;
            stream->avail_in = 2;
            stream->next_in = pInfo->zBuf;
            pInfo->zBuf[0] = 0x78;
            pInfo->zBuf[1] = 0x01;
            inflateInit(&pInfo->stream);
            Jsi_Seek(pInfo->chan, pInfo->startOfData, SEEK_SET);
            pInfo->nByte += pInfo->readSoFar;
            pInfo->nByteCompr = pInfo->nData;
            pInfo->readSoFar = 0;
        }
        while( pInfo->readSoFar < offset ) {
            int toRead, errCode;
            char zDiscard[100];
            toRead = offset - pInfo->readSoFar;
            if( toRead>(int)sizeof(zDiscard) ) toRead = (int)sizeof(zDiscard);
            vfsInput(pInfo, zDiscard, toRead, &errCode);
        }
    }
    pInfo->curPos = Jsi_Tell(pInfo->chan);
    return pInfo->readSoFar;
}

static void put32(char *z, int v);

/***************** Compressed files ******************/

static Jsi_Channel Jfz_FSOpenProc (Jsi_Interp *interp, Jsi_Value *path, const char *modes)
{
    ZvfsChannelInfo *pInfo;
    Jsi_Channel chan;
    int mode = 0, rc, i, n, zLevel = Z_DEFAULT_COMPRESSION, useGzip = 1;
    char Mode[JSI_FSMODESIZE];
    const char *s = (modes ? modes : "r");
    
    for (i=0, n = 0; s[i]; i++) {
        switch (s[i]) {
            case '+': Jsi_LogError("+ is unsupported with z: %s", s); return NULL; break;
            case 'b': break;
            case 'r': mode |= JSI_FS_READONLY; break;
            case 'a': mode |= (JSI_FS_APPEND|JSI_FS_WRITEONLY); break;
            case 'w': mode |= JSI_FS_WRITEONLY; break;
            case 'Z': useGzip = 0; 
            case 'z': mode |= JSI_FS_COMPRESS; continue; break;
            case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
                zLevel = s[i]-'1'+1; continue; break;
            default: Jsi_LogError("unknown mode char: %c", s[i]); return NULL;
        }
        Mode[n++] = s[i];
    }
    Mode[n] = 0;
    if (mode&JSI_FS_READONLY && mode&JSI_FS_WRITEONLY) {
        Jsi_LogError("simultaneous read and write is unsupported with z mode");
        return NULL; 
    }
    Jsi_Channel achan = Jsi_Open(interp, path, Mode);
    if (!achan) {
        return NULL;
    }
    pInfo = (ZvfsChannelInfo*)Jsi_Calloc(1, sizeof(*pInfo) );
    pInfo->isCompressed = 1;
    pInfo->sig = ZVFS_SIG_PINFO;
    pInfo->pFile = NULL;
    pInfo->chan = achan;
    pInfo->useGzip = useGzip;
    //TODO: Jsi_CreateExitHandler(vfsExit, pInfo);
#ifdef MZ_DEFAULT_WINDOW_BITS
    int winBits = (useGzip?-MZ_DEFAULT_WINDOW_BITS:0);
    pInfo->emuGzip = useGzip;
#else
    int winBits = (useGzip?15+16:0);;
#endif
    z_stream *stream = &pInfo->stream;
    if (mode & JSI_FS_READONLY) {
        stream->next_in = (unsigned char *)pInfo->buf;
        Jsi_Seek(achan, 0, SEEK_END);
        pInfo->nByte = Jsi_Tell(achan);
        Jsi_Seek(achan, 0, SEEK_SET);
        if (!winBits)
            rc = inflateInit(stream);
        else
            rc = inflateInit2(stream, winBits);
    } else {
        if (mode&JSI_FS_APPEND)
            Jsi_Seek(achan, 0, SEEK_END);
        if (!winBits)
            rc = deflateInit(stream, zLevel);
        else
            rc = deflateInit2(stream, zLevel, Z_DEFLATED, winBits, 9, Z_DEFAULT_STRATEGY);
    }
    if (rc) {
        Jsi_Free(pInfo->zBuf);
        Jsi_Free(pInfo);
        Jsi_LogError("zinit failure");
        Jsi_Close(achan);
        return NULL;
    }
    
    chan = (Jsi_Chan*)Jsi_Calloc(1,sizeof(Jsi_Chan));
    chan->fname = Jsi_ValueString(interp, path, NULL);
    chan->interp = interp;
    chan->data = pInfo;
    Jsi_Strcpy(chan->modes, modes);
    chan->flags = (mode | (zLevel<<16)); 
    return chan;
}

static int Jfz_FSWriteProc(Jsi_Channel chan, const char *buf, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    Jsi_Interp *interp = chan->interp;
    ZVFSSIGASSERT(pInfo, PINFO);
    char obuf[BUFSIZ];
    if (size<0) size = 0;
    int n, cnt = size;
    if (!buf) size = 0;
    z_stream *stream = &pInfo->stream;
    stream->next_out = (unsigned char*)obuf;
    stream->avail_out = sizeof(obuf);
    stream->next_in = (unsigned char*)buf;
    stream->avail_in = n = size;
    while (stream->avail_in > 0 || buf == NULL) {
        stream->total_out = 0;
        int status = deflate(stream, (buf?(size==0?Z_FULL_FLUSH:0):Z_FINISH));
        int out = stream->total_out;
        if (pInfo->emuGzip && buf && (status == Z_STREAM_END || status == Z_OK))
            pInfo->iCRC = crc32(pInfo->iCRC, (unsigned char*)buf, size - stream->avail_in);
        if ((status == Z_STREAM_END || status == Z_OK) && out>0)
        {
            if (pInfo->emuGzip && pInfo->readSoFar == 0 && /* Add gzip header */
                Jsi_Write(pInfo->chan, "\37\213\10\0\0\0\0\0\0\3", 10) != 10)
                goto writefail;
            if (out != Jsi_Write(pInfo->chan, obuf, out)) {
writefail:
                Jsi_LogError("write failed");
                cnt = -1;
                break;
            }
            cnt += out;
            pInfo->curPos = (pInfo->readSoFar += cnt);
            stream->next_out = (unsigned char*)(obuf+cnt);
            stream->avail_out = sizeof(obuf);
            if (pInfo->emuGzip && !buf) { /* Add gzip size and crc. */
                char psp[8];
                put32(psp, pInfo->iCRC);
                put32(psp+4, pInfo->nByte);
                if (Jsi_Write(pInfo->chan, (char*)psp, 8) != 8)
                    goto writefail;
            }
            //cnt += out;
        }
        pInfo->nByte += (size - stream->avail_in);
        if (status == Z_STREAM_END)
            break;
        if (status != Z_OK) {
            Jsi_LogError("unzip failed: %s", stream->msg);
            cnt = -1;
            break;
        }
        if (!buf)
            break;
    }
    return cnt;
    
}

static int Jfz_FSFlushProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    ZVFSSIGASSERT(pInfo, PINFO);
    Jfz_FSWriteProc(chan, NULL, 0);
    return 0;
}

static int Jfz_FSStatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    return Jsi_Stat(interp, path, buf);
}

static int Jfz_FSLstatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    return Jsi_Lstat(interp, path, buf);
}

static int Jfz_FSTellProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    return pInfo->curPos;
}

static int Jfz_FSReadProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    Jsi_Interp *interp = chan->interp;
    ZVFSSIGASSERT(pInfo, PINFO);
    z_stream *stream = &pInfo->stream;
    int cnt = 0;
    *s = 0;
    int rem = (pInfo->nByte - pInfo->readSoFar);
    int bsize = sizeof(pInfo->buf);
    stream->next_out = (unsigned char*)s;
    int oaout = stream->avail_out = size;
    if (rem <= 0)
        return 0;
    
    while (cnt<size)
    {
      int status;
      if (!stream->avail_in)
      {
        // Input buffer is empty, so read more bytes from input file.
        int n = (rem<bsize? rem : bsize);

        if (pInfo->emuGzip && pInfo->readSoFar == 0) { /* Strip gzip header */
            if (Jsi_Read(pInfo->chan, pInfo->buf, 10) != 10)
                goto readFail;
            n -= 10;
            const char *cp = pInfo->buf;
            if (cp[0] != '\37' || cp[1] != '\213' || cp[2] != '\10') {
                Jsi_LogError("not a gzip file");
                return -1;
            }
        }
            
        if (Jsi_Read(pInfo->chan, pInfo->buf, n) != n)
        {
readFail:
            Jsi_LogError("Failed reading from input file!");
            return -1;
        }
        pInfo->curPos = (pInfo->readSoFar += n);

        stream->next_in = (unsigned char*)pInfo->buf;
        stream->avail_in = n;

        rem -= n;
      }

      status = inflate(stream, Z_SYNC_FLUSH);

      if ((status == Z_STREAM_END) || (!stream->avail_out))
      {
        uint n = oaout - stream->avail_out;
        cnt += n;
        stream->next_out = (unsigned char*)(s+cnt);
        stream->avail_out = (size-cnt);
      }

      if (status == Z_STREAM_END)
        break;
      else if (status != Z_OK)
      {
        Jsi_LogError("inflate failed: %s", stream->msg);
        return -1;
      }
    }

    return cnt;
}


static int Jfz_FSCloseProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    ZVFSSIGASSERT(pInfo, PINFO);
    if( pInfo->zBuf ) {
        Jsi_Free(pInfo->zBuf);
    }
    int mode = chan->flags;
    if (mode & JSI_FS_READONLY) {
        if (inflateEnd(&pInfo->stream) != Z_OK)
        {
          fprintf(stderr, "inflateEnd() failed!\n");
          return -1;
        }
    } else {
        Jfz_FSWriteProc(chan, NULL, 0);
        if (deflateEnd(&pInfo->stream) != Z_OK)
        {
          fprintf(stderr, "deflateEnd() failed!\n");
          return -1;
        }
    }
    if (pInfo->chan)
        Jsi_Close(pInfo->chan);
    Jsi_Free((char*)pInfo);
    return 0;
}


static char * Jfz_FSGetsProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    char *cp = s;
    int n = 0;
    *s = 0;
    while (n<(size-1)) {
        int m = Jfz_FSReadProc(chan, pInfo->buf, 1);
        if (m <= 0)
            break;
        *cp = pInfo->buf[0];
        if (*cp == '\n') {
            n++;
            break;
        }
        n++;
        cp++;
    }
    if (n>0)
        s[n]=0;
    return s;
}

/************** Zip Archive filesystem ******************/

static int Jaz_FSCloseProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    if( pInfo->zBuf ) {
        Jsi_Free(pInfo->zBuf);
        inflateEnd(&pInfo->stream);
    }
    Jsi_Free((char*)pInfo);
    return 0;
}

static Jsi_Channel Jaz_FSOpenProc (Jsi_Interp *interp, Jsi_Value *path, const char *mode)
{
    ZvfsFile *pFile;
    ZvfsChannelInfo *pInfo;
    Jsi_Channel chan;
    static int count = 1;
    char zName[50];
    unsigned char zBuf[50];
    if (*mode != 'r') {
        Jsi_LogError("readonly");
        return NULL;
    }
    pFile = ZvfsLookup(interp, path);
    if (!pFile)
        return NULL;

    /*if (Jsi_SetChannelOption(interp, chan, "-translation", "binary")
            || Jsi_SetChannelOption(interp, chan, "-encoding", "binary")
      ) {
    } */
    Jsi_Channel achan;
    achan = pFile->pArchive->chan;
    if (!achan) {
        Jsi_LogError("archive not found");
        return NULL;
    }
    Jsi_Seek(achan, pFile->iOffset, SEEK_SET);
    Jsi_Read(achan, (char*)zBuf, 30);
    if( memcmp(zBuf, "\120\113\03\04", 4) ) {
        Jsi_LogError("local header mismatch: ");
        return NULL;
    }
    pInfo = (ZvfsChannelInfo*)Jsi_Calloc(1, sizeof(*pInfo) );
    pInfo->pFile = pFile;
    pInfo->chan = achan;
    //Jsi_CreateExitHandler(vfsExit, pInfo);
    pInfo->isCompressed = INT16(zBuf, 8);
    if( pInfo->isCompressed ) {
        z_stream *stream = &pInfo->stream;
        pInfo->zBuf = (unsigned char*)Jsi_Calloc(1, COMPR_BUF_SIZE);
        stream->avail_in = 2;
        stream->next_in = pInfo->zBuf;
        pInfo->zBuf[0] = 0x78;
        pInfo->zBuf[1] = 0x01;
        inflateInit(&pInfo->stream);
    } else {
        pInfo->zBuf = 0;
    }
    pInfo->nByte = INT32(zBuf,22);
    pInfo->nByteCompr = pInfo->nData = INT32(zBuf,18);
    pInfo->readSoFar = 0;
    Jsi_Seek(achan, INT16(zBuf,26)+INT16(zBuf,28), SEEK_CUR);
    pInfo->curPos = pInfo->startOfData = Jsi_Tell(achan);
    sprintf(zName,"vfs_%x_%x",((int)pFile)>>12,count++);
    chan = (Jsi_Channel)Jsi_Calloc(1,sizeof(Jsi_Chan));
    chan->fname = pFile->zName;
    chan->data = pInfo;
    return chan;
}

/*
** This routine does a stat() system call for a ZVFS file.
*/
static int Jaz_FSStatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    ZvfsFile *pFile;

    pFile = ZvfsLookup(zvfslocal.interp, path);
    if( pFile==0 ) {
        return -1;
    }
    memset(buf, 0, sizeof(*buf));
    if (pFile->isdir)
        buf->st_mode = 040555;
    else
        buf->st_mode = (0100000|pFile->permissions);
    buf->st_ino = 0;
    buf->st_size = pFile->nByte;
    buf->st_mtime = pFile->timestamp;
    buf->st_ctime = pFile->timestamp;
    buf->st_atime = pFile->timestamp;
    return 0;
}

/*
** This routine does an access() system call for a ZVFS file.
*/
static int Jaz_FSAccessProc(Jsi_Interp *interp, Jsi_Value *path, int mode) {
    ZvfsFile *pFile;

    if( mode & 3 ) {
        return -1;
    }
    pFile = ZvfsLookup(zvfslocal.interp, path);
    if( pFile==0 ) {
        return -1;
    }
    return 0;
}

static int Jaz_FSScandirProc(Jsi_Interp *interp, Jsi_Value *dirpath, Jsi_Dirent ***namelist,
   int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**))
{

    Jsi_HashEntry *pEntry;
    Jsi_HashSearch sSearch;
    int len, n = 0, rc = JSI_OK, deSpace;
    Jsi_Dirent deS[deSpace = 100], *de = deS;
    Jsi_Dirent **dep;
    *namelist = NULL;
    Jsi_DString pStr;

    const char *zp=Jsi_ValueNormalPath(interp, dirpath, &pStr);
    len = strlen(zp);

    for(pEntry = Jsi_HashEntryFirst(zvfslocal.fileHash, &sSearch);
            pEntry && rc == JSI_OK;
            pEntry = Jsi_HashEntryNext(&sSearch)
       ) {
        ZvfsFile *pFile = (ZvfsFile*)Jsi_HashValueGet(pEntry);
        char *z = pFile->zName;
        int zlen = strlen(z);
        if (zlen<len || strncmp(z,zp,len) || z[len] != '/' || !z[len+1])
            continue;
        z = z + len + 1;
        if (strchr(z,'/'))
            continue;
        if (n >= deSpace) {
            deSpace += 50;
            if (de == deS)
                de = (Jsi_Dirent*)Jsi_Calloc(deSpace, sizeof(Jsi_Dirent));
            else
                de = (Jsi_Dirent*)Jsi_Realloc(de, deSpace * sizeof(Jsi_Dirent));
        }
#ifndef __WIN32
        de[n].d_type = (pFile->isdir ? DT_DIR : DT_REG);
#endif
        strncpy(de[n].d_name,  z, sizeof(de[n].d_name));
        if (filter && !(filter)(de+n))
            continue;
        n++;
    }
    if (n>0) {
        Jsi_Dirent *vdp;
        int i, sz = n * (sizeof(Jsi_Dirent*) + sizeof(Jsi_Dirent)+3);
        if (de != deS) {
            dep = (Jsi_Dirent**)Jsi_Realloc(de,sz);
            vdp = (Jsi_Dirent*)(dep+n);
            memmove(vdp, dep, sizeof(Jsi_Dirent)*n);
        } else {
            dep = (Jsi_Dirent**)Jsi_Malloc(sz);
            vdp = (Jsi_Dirent*)(dep+n);
            memcpy(vdp, de, sizeof(Jsi_Dirent)*n);
        }
        for (i=0; i<n; i++) {
            dep[i] = vdp+i;
        }
        if (compar && n>1)
#if (defined(__WIN32) || defined(HAVE_MUSL))
            qsort(dep, n, sizeof(Jsi_Dirent*), compar);
#else
            qsort(dep, n, sizeof(Jsi_Dirent*), (__compar_fn_t)compar);
#endif
        *namelist = dep;
    }
    Jsi_DSFree(&pStr);
    return n;
}
/*
int Jaz_FSMatchInDirectoryProc (Jsi_Interp* interp, Jsi_Value *result, Jsi_Value *path,
                                Jsi_Value *pattern, int flags, Jsi_FSGlobOpts *opts)
{
    Jsi_HashEntry *pEntry;
    Jsi_HashSearch sSearch;
    int len, isreg = 0, rc = JSI_OK;
    char *zPattern = NULL;
    char *pathPtr = Jsi_ValueString(interp, path, &len);
    if (!(isreg=Jsi_ValueIsObjType(interp, pattern, JSI_OT_REGEXP)))
        zPattern = Jsi_ValueString(interp, pattern, NULL);
    const char *zp=pathPtr;
    if (!zp) return JSI_ERROR;
    if (len && zp[len-1] == '/')
        len--;
    Jsi_Obj *obj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, result, obj);
    for(pEntry = Jsi_HashEntryFirst(zvfslocal.fileHash, &sSearch);
            pEntry && rc == JSI_OK;
            pEntry = Jsi_HashEntryNext(&sSearch)
       ) {
        ZvfsFile *pFile = Jsi_HashValueGet(pEntry);
        char *z = pFile->zName;
        int zlen = strlen(z);
        if (zlen<len || strncmp(z,zp,len) || z[len] != '/' || !z[len+1])
            continue;
        z = z + len + 1;
        if (strchr(z,'/'))
            continue;
        if (isreg) {
           int ismat;
            Jsi_RegExpMatch(interp, pattern, z, &ismat);
            if (!ismat)
                continue;
        } else if (zPattern != NULL && Jsi_GlobMatch(zPattern, z, 0) == 0)
            continue;
        if (pFile->isdir) {
            if (!(flags&JSI_FILE_TYPE_DIRS))
                continue;
        } else {
            if (!(flags&JSI_FILE_TYPE_FILES))
                continue;
        }
        rc = Jsi_ObjArrayAdd(interp, obj, Jsi_ValueNewStringKey(interp, z));
    }
    return JSI_OK;
}
*/

/* Functionto check whether a path is in
* this filesystem.  This is the most
* important filesystem procedure. */
static int Jaz_FSPathInFilesystemProc (Jsi_Interp *interp, Jsi_Value *path, void* *clientDataPtr) {
    ZvfsFile *zFile;
    if (zvfslocal.archiveHash->numEntries<=0)
        return 0;
    /*if (ZvfsLookupMount(zvfslocal.interp, path)==0)
        return 0;*/
    //  TODO: also check this is the archive.
    zFile = ZvfsLookup(zvfslocal.interp, path);
    if (zFile!=NULL && strcmp(SS(path), SS(zFile->pArchive->Name)))
        return 1;
    return 0;
}

static Jsi_Value *Jaz_FSListVolumesProc (Jsi_Interp *interp) {
    Jsi_HashEntry *pEntry;     /* Hash table entry */
    Jsi_HashSearch zSearch;   /* Search all mount points */
    ZvfsArchive *pArchive;     /* The ZIP archive being mounted */
    Jsi_Value *pVols = Jsi_ValueNew(interp);
    Jsi_Obj* obj = Jsi_ObjNew(interp);
    pEntry=Jsi_HashEntryFirst(zvfslocal.archiveHash,&zSearch);
    while (pEntry) {
        if ((pArchive = (ZvfsArchive*)Jsi_HashValueGet(pEntry))) {
            Jsi_ObjArrayAdd(interp, obj, pArchive->MountPoint);
        }
        pEntry=Jsi_HashEntryNext(&zSearch);
    }
    return pVols;
}

static int Jaz_FSLstatProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_StatBuf *buf) {
    return Jaz_FSStatProc(interp, path, buf);
}

static int Jaz_FSFlushProc(Jsi_Channel chan) {
    return 0;
}

static int Jaz_FSTellProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    return pInfo->curPos;
}

static int Jaz_FSEofProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    return (pInfo->curPos >= pInfo->pFile->nByte);
}

static int Jaz_FSRewindProc(Jsi_Channel chan) {
    int rc = 0;
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    vfsSeek(pInfo, 0, SEEK_SET, &rc);
    return rc;
}

static int Jaz_FSSeekProc(Jsi_Channel chan, Jsi_Wide offset, int mode) {
    int rc = 0;
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    vfsSeek(pInfo, offset, mode, &rc);
    return rc;
}

/*static int Jaz_FSWriteProc(Jsi_Channel chan, const char *buf, int size) { return -1;}*/

static int Jaz_FSReadProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    char *cp = s;
    int n = 0, rc = 0;
    *s = 0;
    while (n<size) {
        if (pInfo->bpos >= pInfo->bsiz) {
            if (!(pInfo->bsiz = vfsInput(pInfo, pInfo->buf, sizeof(pInfo->buf), &rc))) {
                break;
            }
            pInfo->bpos = 0;
        }
        *cp = pInfo->buf[pInfo->bpos++];
        n++;
        cp++;
    }
    if (n>0 && n<size)
        s[n]=0;
    return n;
}

static int Jaz_FSGetcProc(Jsi_Channel chan) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    int rc = 0;
    if (pInfo->bpos >= pInfo->bsiz) {
        if (!(pInfo->bsiz = vfsInput(pInfo, pInfo->buf, sizeof(pInfo->buf), &rc))) {
            return 0;
        }
        pInfo->bpos = 0;
    }
    return pInfo->buf[pInfo->bpos++];
}

static int Jaz_FSUngetcProc(Jsi_Channel chan, int ch) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    if (pInfo->bpos > 0 && pInfo->buf[pInfo->bpos-1] == ch)
        pInfo->bpos--;
    else {
        /* TODO: go back */
        return -1;
    }
    return ch;
}

static char * Jaz_FSGetsProc(Jsi_Channel chan, char *s, int size) {
    ZvfsChannelInfo *pInfo = (ZvfsChannelInfo*)chan->data;
    char *cp = s;
    int n = 0, rc = 0;
    *s = 0;
    while (n<(size-1)) {
        if (pInfo->bpos >= pInfo->bsiz) {
            if ((int)pInfo->stream.total_out >= pInfo->pFile->nByte)
                return NULL;
            if ((pInfo->bsiz = vfsInput(pInfo, pInfo->buf, sizeof(pInfo->buf), &rc))<=0) {
                if (n==0)
                    return NULL;
                break;
            }
            pInfo->bpos = 0;
        }
        *cp = pInfo->buf[pInfo->bpos++];
        if (*cp == '\n') {
            n++;
            break;
        }
        n++;
        cp++;
    }
    if (n>0)
        s[n]=0;
    return s;
}



/*
** Write a 16- or 32-bit integer as little-endian into the given buffer.
*/
static void put16(char *z, int v) {
    z[0] = v & 0xff;
    z[1] = (v>>8) & 0xff;
}
static void put32(char *z, int v) {
    z[0] = v & 0xff;
    z[1] = (v>>8) & 0xff;
    z[2] = (v>>16) & 0xff;
    z[3] = (v>>24) & 0xff;
}

/*
** Translate a DOS time and date stamp into a human-readable string.
*/
static void translateDosTimeDate(char *zStr, int dosDate, int dosTime) {
    static const char *zMonth[] = { "nil",
                              "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
                            };

    sprintf(zStr, "%02d-%s-%d %02d:%02d:%02d",
            dosDate & 0x1f,
            zMonth[ ((dosDate&0x1e0)>>5) ],
            ((dosDate&0xfe00)>>9) + 1980,
            (dosTime&0xf800)>>11,
            (dosTime&0x7e)>>5,
            dosTime&0x1f
           );
}


#define FN_list JSI_INFO("\
Return contents of zip directory as an array of arrays. The first element \
contains the labels, ie: \
\n\
[ 'Name', 'Special', 'Offset', 'Bytes', 'BytesCompressed' ] \
")
static int ZvfsListCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Channel chan;
    ZFile *pList = NULL;
    int rc;
    Jsi_Obj *nobj;
    Jsi_Obj *sobj;
    Jsi_Value *sval;
 
    Jsi_Value *Filename = Jsi_ValueArrayIndex(interp, args, 0);;
    chan = Jsi_Open(interp, Filename, "rb");
    if (chan==0)
        return JSI_ERROR;
    rc = ZvfsReadTOC(interp, chan, &pList);
    if( rc==JSI_ERROR ) {
        deleteZFileList(pList);
        return rc;
    }
    Jsi_Close( chan);
    nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeArrayObject(interp, ret, nobj);
    sobj = Jsi_ObjNew(interp);
    sval = Jsi_ValueNew(interp);
    Jsi_ValueMakeArrayObject(interp, &sval, sobj);
    static const char *keys[] = {"Name", "Special", "Offset", "Bytes", "BytesCompressed", 0 };
    int i;
    for (i=0; keys[i]; i++)
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringKey(interp, keys[i]));
    Jsi_ObjArrayAdd(interp, nobj, Jsi_ValueMakeObject(interp, NULL, sobj));
    while( pList ) {
        sobj = Jsi_ObjNew(interp);
        sval = Jsi_ValueMakeArrayObject(interp, NULL, sobj);
        ZFile *pNext;
        char zDateTime[100];
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringDup(interp, pList->zName));
        translateDosTimeDate(zDateTime, pList->dosDate, pList->dosTime);
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringDup(interp, zDateTime));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->isSpecial));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->iOffset));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->nByte));
        Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewNumber(interp, (Jsi_Number)pList->nByteCompr));
        pNext = pList->pNext;
        Jsi_Free((char*)pList);
        pList = pNext;
        Jsi_ObjArrayAdd(interp, nobj, Jsi_ValueMakeObject(interp, NULL, sobj));
    }
    return JSI_OK;
}

/*
** Write a file record into a ZIP archive at the current position of
** the write cursor for channel "chan".  Add a ZFile record for the file
** to *ppList.  If an error occurs, leave an error message on interp
** and return JSI_ERROR.  Otherwise return JSI_OK.
*/

static int writeFile(
    Jsi_Interp *interp,     /* Leave an error message here */
    Jsi_Channel out,        /* Write the file here */
    Jsi_Channel in,         /* Read data from this file */
    Jsi_Value *Src,         /* Name of file entry */
    Jsi_Value *Dest,        /* Name of new ZIP file entry */
    ZFile **ppList          /* Put a ZFile struct for the new file here */
) {
    z_stream stream;
    ZFile *p;
    int iEndOfData;
    int nameLen;
    int skip;
    int toOut;
    char zHdr[30];
    char zInBuf[BUFSIZ*1];
    char zOutBuf[BUFSIZ*1];
    struct tm *tm;
    time_t now;
    struct stat stat;
    const char *zDest = Jsi_ValueToString(interp, Dest, NULL);
    int isdir = (in == NULL);
    nameLen = Jsi_Strlen(zDest);

    /* Create a new ZFile structure for this file.
     * TODO: fill in date/time etc.
    */
    nameLen+=isdir;
    p = newZFile(nameLen, ppList);
    strcpy(p->zName, zDest);
    if (isdir)
        strcat(p->zName, "/");
    p->isSpecial = 0;
    Jsi_Stat(interp, Src, &stat);
    now=stat.st_mtime;
    tm = localtime(&now);
    UnixTimeDate(tm, &p->dosDate, &p->dosTime);
    p->iOffset = Jsi_Tell(out);
    p->nByte = 0;
    p->nByteCompr = 0;
    p->nExtra = 0;
    p->iCRC = 0;
    p->permissions = stat.st_mode;

    /* Fill in as much of the header as we know.
    */
    put32(&zHdr[0], 0x04034b50);
    put16(&zHdr[4], 0x0014);
    put16(&zHdr[6], 0);
    put16(&zHdr[8], 8);
    put16(&zHdr[10], p->dosTime);
    put16(&zHdr[12], p->dosDate);
    put16(&zHdr[26], nameLen);
    put16(&zHdr[28], 0);

    /* Write the header and filename.
    */
    Jsi_Write(out, zHdr, 30);
    Jsi_Write(out, zDest, nameLen);

    /* The first two bytes that come out of the deflate compressor are
    ** some kind of header that ZIP does not use.  So skip the first two
    ** output bytes.
    */
    skip = 2;

    /* Write the compressed file.  Compute the CRC as we progress.
    */
    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = 0;
    stream.avail_in = 0;
    stream.next_in = (uchar*)zInBuf;
    stream.avail_out = sizeof(zOutBuf);
    stream.next_out = (uchar*)zOutBuf;
#if 1
    deflateInit(&stream, 9);
#else
    {
        int i, err, WSIZE = 0x8000, windowBits, level=6;
        for (i = ((unsigned)WSIZE), windowBits = 0; i != 1; i >>= 1, ++windowBits);
        err = deflateInit2(&stream, level, Z_DEFLATED, -windowBits, 8, 0);

    }
#endif
    if (in) {
    p->iCRC = crc32(0, 0, 0);
    while(!Jsi_Eof(in) ) {
        if( stream.avail_in==0 ) {
            int amt = Jsi_Read(in, zInBuf, sizeof(zInBuf));
            if( amt<=0 ) break;
            p->iCRC = crc32(p->iCRC, (uchar*)zInBuf, amt);
            stream.avail_in = amt;
            stream.next_in = (uchar*)zInBuf;
        }
        deflate(&stream, 0);
        toOut = sizeof(zOutBuf) - stream.avail_out;
        if( toOut>skip ) {
            Jsi_Write(out, &zOutBuf[skip], toOut - skip);
            skip = 0;
        } else {
            skip -= toOut;
        }
        stream.avail_out = sizeof(zOutBuf);
        stream.next_out = (uchar*)zOutBuf;
    }
    do {
        stream.avail_out = sizeof(zOutBuf);
        stream.next_out = (uchar*)zOutBuf;
        deflate(&stream, Z_FINISH);
        toOut = sizeof(zOutBuf) - stream.avail_out;
        if( toOut>skip ) {
            Jsi_Write(out, &zOutBuf[skip], toOut - skip);
            skip = 0;
        } else {
            skip -= toOut;
        }
    } while( stream.avail_out==0 );
    p->nByte = stream.total_in;
    p->nByteCompr = stream.total_out - 2;
    deflateEnd(&stream);
    Jsi_Flush(out);
    }

    /* Remember were we are in the file.  Then go back and write the
    ** header, now that we know the compressed file size.
    */
    iEndOfData = Jsi_Tell(out);
    Jsi_Seek(out, p->iOffset, SEEK_SET);
    put32(&zHdr[14], p->iCRC);
    put32(&zHdr[18], p->nByteCompr);
    put32(&zHdr[22], p->nByte);
    Jsi_Write(out, zHdr, 30);
    Jsi_Seek(out, iEndOfData, SEEK_SET);

    /* Close the input file.
    */
    if (in)
        Jsi_Close(in);

    /* Finished!
    */
    return JSI_OK;
}

/*
** The arguments are two lists of ZFile structures sorted by iOffset.
** Either or both list may be empty.  This routine merges the two
** lists together into a single sorted list and returns a pointer
** to the head of the unified list.
**
** This is part of the merge-sort algorithm.
*/
static ZFile *mergeZFiles(ZFile *pLeft, ZFile *pRight) {
    ZFile fakeHead;
    ZFile *pTail;

    pTail = &fakeHead;
    while( pLeft && pRight ) {
        ZFile *p;
        if( pLeft->iOffset <= pRight->iOffset ) {
            p = pLeft;
            pLeft = p->pNext;
        } else {
            p = pRight;
            pRight = p->pNext;
        }
        pTail->pNext = p;
        pTail = p;
    }
    if( pLeft ) {
        pTail->pNext = pLeft;
    } else if( pRight ) {
        pTail->pNext = pRight;
    } else {
        pTail->pNext = 0;
    }
    return fakeHead.pNext;
}

/*
** Sort a ZFile list so in accending order by iOffset.
*/
static ZFile *sortZFiles(ZFile *pList) {
# define NBIN 30
    int i;
    ZFile *p;
    ZFile *aBin[NBIN+1];

    for(i=0; i<=NBIN; i++) aBin[i] = 0;
    while( pList ) {
        p = pList;
        pList = p->pNext;
        p->pNext = 0;
        for(i=0; i<NBIN && aBin[i]; i++) {
            p = mergeZFiles(aBin[i],p);
            aBin[i] = 0;
        }
        aBin[i] = aBin[i] ? mergeZFiles(aBin[i], p) : p;
    }
    p = 0;
    for(i=0; i<=NBIN; i++) {
        if( aBin[i]==0 ) continue;
        p = mergeZFiles(p, aBin[i]);
    }
    return p;
}

/*
** Write a ZIP archive table of contents to the given
** channel.
*/
static void writeTOC(Jsi_Channel chan, ZFile *pList) {
    int iTocStart, iTocEnd;
    int nEntry = 0;
    int i;
    char zBuf[100];

    iTocStart = Jsi_Tell(chan);
    for(; pList; pList=pList->pNext) {
        if( pList->isSpecial ) continue;
        put32(&zBuf[0], 0x02014b50);
        put16(&zBuf[4], 0x0317);
        put16(&zBuf[6], 0x0014);
        put16(&zBuf[8], 0);
        put16(&zBuf[10], pList->nByte>pList->nByteCompr ? 0x0008 : 0x0000);
        put16(&zBuf[12], pList->dosTime);
        put16(&zBuf[14], pList->dosDate);
        put32(&zBuf[16], pList->iCRC);
        put32(&zBuf[20], pList->nByteCompr);
        put32(&zBuf[24], pList->nByte);
        put16(&zBuf[28], strlen(pList->zName));
        put16(&zBuf[30], 0);
        put16(&zBuf[32], pList->nExtra);
        put16(&zBuf[34], 1);
        put16(&zBuf[36], 0);
        put32(&zBuf[38], pList->permissions<<16);
        put32(&zBuf[42], pList->iOffset);
        Jsi_Write(chan, zBuf, 46);
        Jsi_Write(chan, pList->zName, strlen(pList->zName));
        for(i=pList->nExtra; i>0; i-=40) {
            int toWrite = i<40 ? i : 40;
            Jsi_Write(chan,"                                             ",toWrite);
        }
        nEntry++;
    }
    iTocEnd = Jsi_Tell(chan);
    put32(&zBuf[0], 0x06054b50);
    put16(&zBuf[4], 0);
    put16(&zBuf[6], 0);
    put16(&zBuf[8], nEntry);
    put16(&zBuf[10], nEntry);
    put32(&zBuf[12], iTocEnd - iTocStart);
    put32(&zBuf[16], iTocStart);
    put16(&zBuf[20], 0);
    Jsi_Write(chan, zBuf, 22);
    Jsi_Flush(chan);
}

static const char *
GetExtension( const char *name)
{
    const char *p, *lastSep;
#ifdef __WIN32__
    lastSep = NULL;
    for (p = name; *p != '\0'; p++) {
        if (strchr("/\\:", *p) != NULL) {
            lastSep = p;
        }
    }
#else
    lastSep = strrchr(name, '/');
#endif
    p = strrchr(name, '.');
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
        p = NULL;
    }
    return p;
}

static int CreateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr, int append)
{
    Jsi_Value *Archive;
    Jsi_Channel chan = 0;
    ZFile *pList = NULL, *pToc;
    int rc = JSI_OK, i, k, create = 0, argc, alen = Jsi_ValueGetLength(interp, args);
    Jsi_Value *flist = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_Value *prefix, *nSrc = NULL;
    const char *ext;
    Jsi_DString dStr = {};

    for (i=1; i<alen; i++) {
        flist = Jsi_ValueArrayIndex(interp, args, i);
        if (!Jsi_ValueIsArray(interp, flist)) {
            Jsi_LogError("expected array of files");
            return JSI_ERROR;
        }
        if (++i<alen) {
            prefix = Jsi_ValueArrayIndex(interp, args, i);
            if (Jsi_ValueIsString(interp, prefix)==0 && Jsi_ValueIsNull(interp, prefix)==0) {
                Jsi_LogError("expected string or null");
                return JSI_ERROR;
            }
        }
                
    }
    
    /* Open the archive and read the table of contents
    */

    Archive = Jsi_ValueArrayIndex(interp, args, 0);
    chan = Jsi_Open(interp, Archive, "rb+");
    if (chan==0 ) {
        if (append) {
            Jsi_LogError("archive must exists: %s", SS(Archive));
            rc = JSI_ERROR;
            goto doexit;
        }
        chan = Jsi_Open(interp, Archive, "wb+");
        create = 1;
    }
    if (chan==0 ) {
        Jsi_LogError("archive create failed for: %s", SS(Archive));
        rc = JSI_ERROR;
        goto doexit;
    }
    Jsi_Seek(chan, 0, SEEK_END);

    if (Jsi_Tell(chan) != 0) {
        /* Null file is ok, we're creating new one. */
        Jsi_Seek(chan, 0, SEEK_SET);
        rc = ZvfsReadTOC(interp, chan, &pList);
        if( rc==JSI_ERROR ) {
            goto doexit;
        } else rc=JSI_OK;
    }

    /* Find TOC */
    for(pToc=pList; pToc; pToc=pToc->pNext) {
        if( pToc->isSpecial && strcmp(pToc->zName,"*TOC*")==0 ) break;
    }
    if( pToc ) {
        Jsi_Seek(chan, pToc->iOffset, SEEK_SET);
    } else {
        Jsi_Seek(chan, 0, SEEK_END);
    }
    if (pToc && !append) {
        Jsi_LogError("already an archive: use zvfs.truncate() first or zvfs.append().");
        rc = JSI_ERROR;
        goto doexit;
    }
    Jsi_Seek(chan, 0, SEEK_END);
    /* Add new files to the end of the archive. */
    for (k=1; k<alen; k++) {
        flist = Jsi_ValueArrayIndex(interp, args, k);
        argc = Jsi_ValueGetLength(interp, flist);
        prefix = NULL;
        if (++k<alen)
            prefix = Jsi_ValueArrayIndex(interp, args, k);
        
        for(i=0; rc==JSI_OK && i<argc; i++) {
            Jsi_Value *Src = Jsi_ValueArrayIndex(interp, flist, i), *fSrc = Src;
            Jsi_Channel in;
            char *fname = Jsi_ValueString(interp, Src, 0);
            
            ext = (fname?GetExtension(fname):NULL);
            if (ext && *ext == '.' && (ext[1] == 0 || (ext[1] == '.' && ext[2] == 0)))
                continue;
            if (prefix && !Jsi_ValueIsNull(interp, prefix)) {
                char *pstr = SS(prefix);
                if (*pstr) {
                    Jsi_DSSetLength(&dStr, 0);
                    Jsi_DSAppend(&dStr, pstr, "/", SS(Src), NULL);
                    fSrc = nSrc = Jsi_ValueNewStringDup(interp, Jsi_DSValue(&dStr));
                    Jsi_IncrRefCount(interp, nSrc);
                }
            }
            /* Open the file that is to be added to the ZIP archive
             */
            in = NULL;
            Jsi_StatBuf sb;
            if (Jsi_Stat(interp, fSrc, &sb) == 0 && S_ISDIR(sb.st_mode)) {
            } else {
                in = Jsi_Open(interp, fSrc, "rb");
                if( in==0 ) {
                    Jsi_LogError("open failed on: %s", SS(fSrc));
                    rc = JSI_ERROR;
                    break;
                }
            }
            if (rc == JSI_OK) {
                rc = writeFile(interp, chan, in, fSrc, Src, &pList);
                if (rc != JSI_OK)
                    Jsi_LogError("write failed on: %s", SS(Src));
            }
            if (nSrc) {
                Jsi_DecrRefCount(interp, nSrc);
                nSrc = NULL;
            }
        }
    }
    /* Write the table of contents at the end of the archive.
    */
    if (rc == JSI_OK) {
        pList = sortZFiles(pList);
        writeTOC(chan, pList);
    }
doexit:
    /* Close the channel and exit */
    if (pList)
        deleteZFileList(pList);
    if (chan)
        Jsi_Close(chan);
    if (nSrc)
        Jsi_DecrRefCount(interp, nSrc);
    Jsi_DSFree(&dStr);
    if (rc != JSI_OK && create)
        Jsi_Remove(interp, Archive, 0);

    return rc;
}

#define FN_create JSI_INFO("\
This command creates a zip archive and adds files to it. Files are relative \
the given 'path', or the current directory. \
If the destignation file already exist but is not an archive (eg. an executable), \
zip data is appended to the end of the file. \
If the existing file is already an archive, an error will be kicked. \
To truncate an existing archive, use zvfs.truncate(). Or use zvfs.append() instead. \
\n\
   zvfs.create('foo.zip',['main.js', 'bar.js'], 'src', ['a.html', 'css/a.css'], 'html');")

static int ZvfsCreateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return CreateCmd(interp, args, _this, ret, funcPtr, 0);
}

static int ZvfsAppendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    return CreateCmd(interp, args, _this, ret, funcPtr, 1);
}

#define FN_truncate JSI_INFO("\
Opens and scans the file to determine start of zip data \
and truncate this off the end of the file.  \
For ordinary zip archives, the resulting truncated file will be of zero length. \
If an optional bool argument can disable errors. \
In any case, the start offset of zip data (or 0) is returned.")

static int ZvfsTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Channel chan;
    ZFile *pList = NULL;
    int rc = JSI_OK;
    Jsi_Bool noerror = 1; 
    int zipStart;

    Jsi_Value *Archive = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *vbool = Jsi_ValueArrayIndex(interp, args, 1);
    if (vbool && Jsi_ValueGetBoolean(interp, vbool, &noerror) != JSI_OK) {
        Jsi_LogError("expected boolean");
        return JSI_ERROR;
    }
    chan = Jsi_Open(interp, Archive, "rb+");
    if( chan==0 ) return JSI_ERROR;

    if (Jsi_Seek(chan, 0, SEEK_END) != 0) {
        Jsi_Close(chan);
        Jsi_ValueMakeNumber(interp, ret, 0.0);
        return JSI_OK;
    }
    Jsi_Seek(chan, 0, SEEK_SET);
    rc = ZvfsReadTOCStart(interp, chan, &pList, &zipStart);
    if( rc!=JSI_OK ) {
        deleteZFileList(pList);
        Jsi_Close(chan);
        if (noerror)
            return JSI_OK;
        Jsi_LogError("not an archive");
        return JSI_ERROR;
    }

    /* Close the channel and exit */
    deleteZFileList(pList);
    Jsi_Truncate(chan, zipStart);
    Jsi_Close(chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)zipStart);
    return JSI_OK;
}

static int ZvfsOffsetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                        Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Channel chan;
    ZFile *pList = NULL;
    int rc = JSI_OK; 
    int zipStart;

    Jsi_Value *Archive = Jsi_ValueArrayIndex(interp, args, 0);
    chan = Jsi_Open(interp, Archive, "rb");
    if( chan==0 ) return JSI_ERROR;

    if (Jsi_Seek(chan, 0, SEEK_END) != 0) {
        Jsi_Close(chan);
        Jsi_ValueMakeNumber(interp, ret, 0.0);
        return JSI_OK;
    }
    Jsi_Seek(chan, 0, SEEK_SET);
    rc = ZvfsReadTOCStart(interp, chan, &pList, &zipStart);
    if( rc!=JSI_OK ) {
        deleteZFileList(pList);
        Jsi_Close(chan);
        Jsi_LogError("not an archive");
        return JSI_ERROR;
    }

    /* Close the channel and exit */
    deleteZFileList(pList);
    Jsi_Close(chan);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)zipStart);
    return JSI_OK;
}

static Jsi_Filesystem Jaz_Filesystem = {
    .typeName="jaz",
    .structureLength=sizeof(Jsi_Filesystem),
    .version=1,
    .pathInFilesystemProc=Jaz_FSPathInFilesystemProc,
    .statProc=Jaz_FSStatProc,
    .lstatProc=Jaz_FSLstatProc,
    .accessProc=Jaz_FSAccessProc,
    .openProc=Jaz_FSOpenProc,
    .scandirProc=Jaz_FSScandirProc,
    .readProc=Jaz_FSReadProc,
    .getsProc=Jaz_FSGetsProc,
    .getcProc=Jaz_FSGetcProc,
    .ungetcProc=Jaz_FSUngetcProc,
    .flushProc=Jaz_FSFlushProc,
    .seekProc=Jaz_FSSeekProc,
    .tellProc=Jaz_FSTellProc,
    .eofProc=Jaz_FSEofProc,
    .rewindProc=Jaz_FSRewindProc,
    .closeProc=Jaz_FSCloseProc,
    .listVolumesProc=Jaz_FSListVolumesProc,
};

static Jsi_Filesystem Jfz_Filesystem = {
    .typeName="jfz",
    .structureLength=sizeof(Jsi_Filesystem),
    .version=1,
    .closeProc=Jfz_FSCloseProc,
    .openProc=Jfz_FSOpenProc,
    .readProc=Jfz_FSReadProc,
    .writeProc=Jfz_FSWriteProc,
    .flushProc=Jfz_FSFlushProc,
    .statProc=Jfz_FSStatProc,
    .lstatProc=Jfz_FSLstatProc,
    .tellProc=Jfz_FSTellProc,
    .getsProc=Jfz_FSGetsProc,
    /*.pathInFilesystemProc=Jfz_FSPathInFilesystemProc,
    .accessProc=Jfz_FSAccessProc,
    .scandirProc=Jfz_FSScandirProc,
    .getcProc=Jfz_FSGetcProc,
    .ungetcProc=Jfz_FSUngetcProc,
    .seekProc=Jfz_FSSeekProc,
    .eofProc=Jfz_FSEofProc,
    .rewindProc=Jfz_FSRewindProc,
    .listVolumesProc=Jfz_FSListVolumesProc,*/
};

void (*Zvfs_PostInit)(Jsi_Interp *)=0;

static Jsi_CmdSpec zvfsCmds[] = {
    { "append",     ZvfsAppendCmd,      2, -1, "archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...",  .help="Like 'create()', but appends to an existing archive (with no dup checking)", .info=FN_create, .retType=(uint)JSI_TT_VOID },
    { "create",     ZvfsCreateCmd,      2, -1, "archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...",  .help="Create a zip with the given files in prefix path", .info=FN_create, .retType=(uint)JSI_TT_VOID },
    { "list",       ZvfsListCmd,        1,  1, "archive:string",  .help="List files in archive",.info=FN_list, .retType=(uint)JSI_TT_ARRAY },
    { "mount",      ZvfsMountCmd,       1,  2, "archive:string, mountdir:string=void",  .help="Mount zip on mount point", .info=FN_mount, .retType=(uint)JSI_TT_STRING },
    { "names",      ZvfsNamesCmd,       0,  1, "mountdir:string=void",  .help="Return all zvfs mounted zips, or archive for specified mount", .info=FN_info, .retType=(uint)JSI_TT_ARRAY },
    { "offset",     ZvfsOffsetCmd,      1,  1, "archive:string",  .help="Return the start offset of zip data", .info=FN_truncate, .retType=(uint)JSI_TT_NUMBER },
    { "stat",       ZvfsStatCmd,        1,  1, "filename:string",  .help="Return details on file in zvfs mount", .info=FN_stat, .retType=(uint)JSI_TT_OBJECT },
    { "truncate",   ZvfsTruncateCmd,    1,  2, "archive:string, noerror:boolean=false",  .help="Truncate zip data from archive", .info=FN_truncate, .retType=(uint)JSI_TT_NUMBER },
    { "unmount",    ZvfsUnmountCmd,     1,  1, "archive:string",  .help="Unmount zip", .retType=(uint)JSI_TT_VOID },
    { NULL, .help="Commands for mounting and accessing .zip files as a filesystem" }
};

static int zvfsInterpDelete(Jsi_Interp *interp, void *ptr) {
    /* Unmount filesystems. */
    return JSI_OK;
}

static int freeFileHashTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    Jsi_Free(ptr);
    return JSI_OK;
}

static int freeArchiveHashTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {
    if (!ptr) return JSI_OK;
    ZvfsArchive *pArchive = (ZvfsArchive*)ptr;
    pArchive->pEntry = NULL;
    Zvfs_Unmount(interp, pArchive->MountPoint);
    Jsi_Free(pArchive);
    return JSI_OK;
}

int Jsi_InitZvfs(Jsi_Interp *interp) {
    if( !zvfslocal.isInit ) {
        if (Jsi_FSRegister(&Jaz_Filesystem, NULL) != JSI_OK ||
            Jsi_FSRegister(&Jfz_Filesystem, NULL) != JSI_OK)
            return JSI_ERROR;
        zvfslocal.fileHash = Jsi_HashNew(interp, JSI_KEYS_STRING, freeFileHashTbl);
        zvfslocal.archiveHash = Jsi_HashNew(interp, JSI_KEYS_STRING, freeArchiveHashTbl);
        zvfslocal.isInit = 1;
        zvfslocal.interp = interp;
    }
    Jsi_CommandCreateSpecs(interp, "Zvfs",  zvfsCmds,   NULL, JSI_CMDSPEC_NOTOBJ);
    if (Zvfs_PostInit) Zvfs_PostInit(interp);
    Jsi_InterpOnDelete(interp, zvfsInterpDelete, NULL);
    return JSI_OK;
}


int Jsi_DoneZvfs(Jsi_Interp *interp) {
    /* TODO: cleanup on last interp. */
    if (interp == jsiMainInterp && zvfslocal.isInit)
    {
        Jsi_FSUnregister(&Jaz_Filesystem);
        Jsi_FSUnregister(&Jfz_Filesystem);
        Jsi_HashDelete(zvfslocal.archiveHash);
        Jsi_HashDelete(zvfslocal.fileHash);
        zvfslocal.isInit = 0;
    }
    return JSI_OK;
}

#endif
#endif
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#ifndef JSI_AMALGAMATION
#include "jsiUtf8.h"
#include "jsiInt.h"
#endif

#if 0
/* BEGIN: Code extracted from sqlite */
static const unsigned char Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};


#define WRITE_UTF8(zOut, c) {                          \
  if( c<0x00080 ){                                     \
    *zOut++ = (u8)(c&0xFF);                            \
  }                                                    \
  else if( c<0x00800 ){                                \
    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
  else if( c<0x10000 ){                                \
    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }else{                                               \
    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \
    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
}

#define WRITE_UTF16LE(zOut, c) {                                    \
  if( c<=0xFFFF ){                                                  \
    *zOut++ = (u8)(c&0x00FF);                                       \
    *zOut++ = (u8)((c>>8)&0x00FF);                                  \
  }else{                                                            \
    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \
    *zOut++ = (u8)(c&0x00FF);                                       \
    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \
  }                                                                 \
}

#define WRITE_UTF16BE(zOut, c) {                                    \
  if( c<=0xFFFF ){                                                  \
    *zOut++ = (u8)((c>>8)&0x00FF);                                  \
    *zOut++ = (u8)(c&0x00FF);                                       \
  }else{                                                            \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \
    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \
    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \
    *zOut++ = (u8)(c&0x00FF);                                       \
  }                                                                 \
}

#define READ_UTF16LE(zIn, TERM, c){                                   \
  c = (*zIn++);                                                       \
  c += ((*zIn++)<<8);                                                 \
  if( c>=0xD800 && c<0xE000 && TERM ){                                \
    int c2 = (*zIn++);                                                \
    c2 += ((*zIn++)<<8);                                              \
    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \
  }                                                                   \
}

#define READ_UTF16BE(zIn, TERM, c){                                   \
  c = ((*zIn++)<<8);                                                  \
  c += (*zIn++);                                                      \
  if( c>=0xD800 && c<0xE000 && TERM ){                                \
    int c2 = ((*zIn++)<<8);                                           \
    c2 += (*zIn++);                                                   \
    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \
  }                                                                   \
}

#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }
  
static u32 Utf8Read(
  const unsigned char **pz    /* Pointer to string from which to read char */
){
  unsigned int c;

  /* Same as READ_UTF8() above but without the zTerm parameter.
  ** For this routine, we assume the UTF8 string is always zero-terminated.
  */
  c = *((*pz)++);
  if( c>=0xc0 ){
    c = Utf8Trans1[c-0xc0];
    while( (*(*pz) & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & *((*pz)++));
    }
    if( c<0x80
        || (c&0xFFFFF800)==0xD800
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }
  }
  return c;
}
/* END */
#endif

int jsi_utf8_fromunicode(char *p, unsigned uc)
{
    if (uc <= 0x7f) {
        *p = uc;
        return 1;
    }
    else if (uc <= 0x7ff) {
        *p++ = 0xc0 | ((uc & 0x7c0) >> 6);
        *p = 0x80 | (uc & 0x3f);
        return 2;
    }
    else if (uc <= 0xffff) {
        *p++ = 0xe0 | ((uc & 0xf000) >> 12);
        *p++ = 0x80 | ((uc & 0xfc0) >> 6);
        *p = 0x80 | (uc & 0x3f);
        return 3;
    }
    else {
        *p++ = 0xf0 | ((uc & 0x1c0000) >> 18);
        *p++ = 0x80 | ((uc & 0x3f000) >> 12);
        *p++ = 0x80 | ((uc & 0xfc0) >> 6);
        *p = 0x80 | (uc & 0x3f);
        return 4;
    }
}

int jsi_utf8_charlen(int c)
{
#ifndef JSI_UTF8
    return 1;
#else
    if ((c & 0x80) == 0) return 1;
    if ((c & 0xe0) == 0xc0) return 2;
    if ((c & 0xf0) == 0xe0) return 3;
    if ((c & 0xf8) == 0xf0) return 4;
    return -1;
#endif
}

int jsi_utf8_strlen(const char *s) {
#ifndef JSI_UTF8
    return strlen(s);
#else
    int i = 0;
    while (*s)
        if ((*s++ & 0xc0) != 0x80)
            i++;
    return i;
#endif
}

int jsi_utf8_index(const char *str, int index)
{
#ifndef JSI_UTF8
    return str[index];
#else
    const char *s = str;
    while (index--) {
        int c;
        s += jsi_utf8_tounicode(s, &c);
    }
    return s - str;
#endif
}

int jsi_utf8_charequal(const char *s1, const char *s2)
{
#ifndef JSI_UTF8
    return (*s1 == *s2);
#else
    int c1, c2;
    jsi_utf8_tounicode(s1, &c1);
    jsi_utf8_tounicode(s2, &c2);
    return c1 == c2;
#endif
}

int jsi_utf8_prev_len(const char *str, int len)
{
#ifndef JSI_UTF8
    return 1;
#else
    int n = 1;
    if(len <= 0) return -1;
    while (--len) {
        if ((str[-n] & 0x80) == 0)
            break;
        if ((str[-n] & 0xc0) == 0xc0)
            break;
        n++;
    }
    return n;
#endif
}

int jsi_utf8_tounicode_case(const char *s, int *uc, int upper)
{
#ifndef JSI_UTF8
    if (upper)
        *uc = (int)toupper(*s);
    else
        *uc = (int)(*s);
    return 1;
#else
    int l = jsi_utf8_tounicode(s, uc);
    if (upper)
        *uc = jsi_utf8_upper(*uc);
    return l;
#endif
}

int jsi_utf8_tounicode(const char *str, int *uc)
{
#ifndef JSI_UTF8
    *uc = (char)*str;
    return 1;
#else
    unsigned const char *s = (unsigned const char *)str;

    if (s[0] < 0xc0) {
        *uc = s[0];
        return 1;
    }
    if (s[0] < 0xe0) {
        if ((s[1] & 0xc0) == 0x80) {
            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);
            return 2;
        }
    }
    else if (s[0] < 0xf0) {
        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80)) {
            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);
            return 3;
        }
    }
    else if (s[0] < 0xf8) {
        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80) && ((str[3] & 0xc0) == 0x80)) {
            *uc = ((s[0] & ~0xf0) << 18) | ((s[1] & ~0x80) << 12) | ((s[2] & ~0x80) << 6) | (s[3] & ~0x80);
            return 4;
        }
    }

    /* Invalid sequence, so just return the byte */
    *uc = *s;
    return 1;
#endif
}

#ifdef JSI_UTF8
struct casemap {
    unsigned short code;
    unsigned short altcode;
};

#include "jsiUniMap.c"

#define ARRAYSIZE(A) sizeof(A) / sizeof(*(A))

static int cmp_casemap(const void *key, const void *cm)
{
    return *(int *)key - (int)((const struct casemap *)cm)->code;
}

static int map_case(const struct casemap *mapping, int num, int ch)
{
    /* 16 bit case mapping only */
    if (ch <= 0xffff) {
        const struct casemap *cm =
            bsearch(&ch, mapping, num, sizeof(*mapping), cmp_casemap);

        if (cm) {
            return cm->altcode;
        }
    }
    return ch;
}
#endif

int jsi_utf8_upper(int ch)
{
#ifndef JSI_UTF8
    return toupper(ch);
#else
    if (isascii(ch)) {
        return toupper(ch);
    }
    return map_case(unicode_case_mapping_upper, ARRAYSIZE(unicode_case_mapping_upper), ch);
#endif
}

int jsi_utf8_lower(int ch)
{
#ifndef JSI_UTF8
    return tolower(ch);
#else
    if (isascii(ch)) {
        return tolower(ch);
    }
    return map_case(unicode_case_mapping_lower, ARRAYSIZE(unicode_case_mapping_lower), ch);
#endif
}

int jsi_utf8_title(int ch)
{
#ifndef JSI_UTF8
    return toupper(ch);
#else
    int newch = map_case(unicode_case_mapping_title, ARRAYSIZE(unicode_case_mapping_title), ch);
    if (newch != ch) {
        return newch ? newch : ch;
    }
    return jsi_utf8_upper(ch);
#endif
}

#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif

int Jsi_UserObjUnregister(Jsi_Interp *interp, Jsi_UserObjReg *udreg)
{
    Jsi_HashEntry *hPtr;
    if (interp->deleting) return JSI_ERROR;
    hPtr = Jsi_HashEntryFind(interp->userdataTbl, udreg->name);
    if (hPtr == NULL)
        return JSI_ERROR;
    
    Jsi_HashEntryDelete(hPtr);
    UserObjReg* ptr = (UserObjReg*)Jsi_HashValueGet(hPtr);
    SIGASSERT(ptr, USER_REG);
    Jsi_Free(ptr);
    return JSI_OK;
}

int jsi_UserObjDelete(Jsi_Interp *interp, void *data)
{
    UserObjReg* ptr = (UserObjReg*)data;
    SIGASSERT(ptr, USER_REG);
    Jsi_Hash *tblPtr = ptr->hashPtr;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    for (hPtr = Jsi_HashEntryFirst(tblPtr, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        void *dptr;
        Jsi_Obj *obj = (Jsi_Obj*)Jsi_HashValueGet(hPtr);
        SIGASSERT(obj, OBJ);
        assert(obj && obj->ot == JSI_OT_USEROBJ);
        Jsi_UserObj *uobj = obj->d.uobj;
        dptr = uobj->data;
        if (hPtr == uobj->hPtr)
            uobj->hPtr = NULL;
        Jsi_HashEntryDelete(hPtr);
        if (dptr && ptr->reg->freefun)
            ptr->reg->freefun(interp, dptr);
            uobj->data = NULL;
    }
    Jsi_HashDelete(tblPtr);
    Jsi_Free(ptr);
    return JSI_OK;
}

Jsi_Hash* Jsi_UserObjRegister(Jsi_Interp *interp, Jsi_UserObjReg *udreg)
{
    UserObjReg* ptr = (UserObjReg*)Jsi_Calloc(1, sizeof(*ptr));
    Jsi_HashEntry *hPtr;
    SIGINIT(ptr, USER_REG);
    int isNew;
    ptr->reg = udreg;
    ptr->hashPtr = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);
    //ptr->data = data;
    hPtr = Jsi_HashEntryNew(interp->userdataTbl, udreg->name, &isNew);
    if (hPtr == NULL || !isNew)
        return NULL;
    Jsi_HashValueSet(hPtr, ptr);
    
    //Jsi_InterpSetData(interp, udreg->name, UserObjDelete, ptr);
    return ptr->hashPtr;
}

void jsi_UserObjFree(Jsi_Interp *interp, Jsi_UserObj *uobj)
{
    Jsi_UserObjReg *udr =uobj->reg;
    if (interp != uobj->interp) {
        Jsi_LogError("UDID bad interp");
        return;
    }
    if (uobj->hPtr)
        Jsi_HashEntryDelete(uobj->hPtr);
    if (udr->freefun && uobj->data) {
        udr->freefun(interp, uobj->data);
        uobj->data = NULL;
    }
    MEMCLEAR(uobj);
    Jsi_Free(uobj);
}

static Jsi_UserObj *UserObjNew(Jsi_Interp *interp, Jsi_Hash* id, void *data)
{
    Jsi_UserObj *ud = (Jsi_UserObj*)Jsi_Calloc(1,sizeof(Jsi_UserObj));
    ud->interp = interp;
    SIGINIT(ud,USERDATA);
    ud->id = id;
    ud->data = data;
    return ud;
}

int Jsi_UserObjNew(Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data)
{
    if (obj->ot != JSI_OT_OBJECT) {
        Jsi_LogBug("jsi_userdata_assign to a non raw object");
        return -1;
    }
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->userdataTbl, reg->name);
    if (!hPtr) {
        Jsi_LogBug("no such registered object");
        return -1;
    }
    UserObjReg* ureg = (UserObjReg*)Jsi_HashValueGet(hPtr);
    interp->userObjCnt++;
    Jsi_UserObj * uobj = UserObjNew(interp, ureg->hashPtr, data);
    obj->d.uobj = uobj;
    uobj->reg = reg;
    uobj->ureg = ureg;
    obj->ot = JSI_OT_USEROBJ;
    uobj->idx = ++ureg->idx;
    int isNew;
    uobj->hPtr = Jsi_HashEntryNew(ureg->hashPtr, (void*)uobj->idx, &isNew);
    assert(uobj->hPtr && isNew==1);
    Jsi_HashValueSet(uobj->hPtr, obj);
    return uobj->idx;
}

static void *UserObjGet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Hash* id)
{
    Jsi_UserObj *ud = obj->d.uobj;
    if (!ud)
        return NULL;
    if (obj->ot != JSI_OT_USEROBJ || ud->interp != interp) {
        if (ud->interp != interp)
            Jsi_LogWarn("Jsi_Obj not userobj type");
        return NULL;
    }
    if (ud->id != id) {
        Jsi_LogWarn("Get_userdata, id not match");
        return NULL;
    }
    return ud->data;
}

void *Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr)
{
    if (value == NULL || value->vt != JSI_VT_OBJECT || value->d.obj->ot != JSI_OT_USEROBJ)
        return NULL;
    if (!funcPtr)
        return value->d.obj->d.uobj->data;
    Jsi_Obj *obj = Jsi_ValueGetObj(interp, value);
    if (!obj)
        return NULL;
    if (obj->ot != JSI_OT_USEROBJ)
        return NULL;
    void *privData = funcPtr->privData;
    return UserObjGet(interp, obj, (Jsi_Hash*)privData);
}


void *Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var) {
    Jsi_Value *vObj = Jsi_NameLookup(interp, var);
    if (!vObj)
        return NULL;
    return Jsi_UserObjGetData(interp, vObj, NULL);
}

int jsi_UserObjIsTrue(Jsi_Interp *interp, Jsi_UserObj *uobj)
{
    Jsi_UserObjReg *udr = uobj->reg;
    if (udr->istrue) {
        return udr->istrue(uobj->data);
    }
    return 1;
}

void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr)
{
    const char * uname = "userdata";
    char ubuf[50];
    Jsi_UserObjReg *reg = uobj->reg;
    uname = reg->name;
    sprintf(ubuf, "%d", uobj->idx);
    Jsi_DSAppend(dStr, "#", uname, "_", ubuf, NULL);
}

Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name)
{
    if (*name != '#')
        return NULL;
    const char *cp = strrchr(name, '_');
    if (cp==0 || !*cp)
        return NULL;
    int id = atoi(cp+1);
    Jsi_DString dStr = {};
    Jsi_DSAppendLen(&dStr, name+1, cp-name-1);
    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->userdataTbl, Jsi_DSValue(&dStr));
    Jsi_DSFree(&dStr);

    UserObjReg *rdata = (UserObjReg*)Jsi_HashValueGet(hPtr);
    if (!rdata)
        return NULL;
    Jsi_Hash *tPtr = rdata->hashPtr;
    if (tPtr==0)
        return NULL;

    hPtr = Jsi_HashEntryFind(tPtr, (void*)id);
    if (!hPtr)
        return NULL;
    return (Jsi_Obj*)Jsi_HashValueGet(hPtr);
}


int jsi_UserObjDump(Jsi_Interp *interp, const char *argStr, Jsi_Obj *nobj)
{
    char *key;
    int n = 0;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Hash *tPtr;
    
    if (argStr == NULL) {
        for (hPtr = Jsi_HashEntryFirst(interp->userdataTbl, &search);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
            key = (char*)Jsi_HashKeyGet(hPtr);
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n++);
        }
        return JSI_OK;
    }
    hPtr = Jsi_HashEntryFind(interp->userdataTbl, argStr);
    if (hPtr == NULL) {
        Jsi_LogError("no such user object: %s", argStr);
        return JSI_ERROR;
    }
    UserObjReg *rdata = (UserObjReg*)Jsi_HashValueGet(hPtr);
    if (!rdata)
        return JSI_OK;
    tPtr = rdata->hashPtr;
    if (tPtr==0)
        return JSI_OK;
    for (hPtr = Jsi_HashEntryFirst(tPtr, &search);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
        Jsi_Obj *fobj;
        if (!(fobj = (Jsi_Obj*)Jsi_HashValueGet(hPtr)))
            continue;
        assert(fobj->ot == JSI_OT_USEROBJ);
        /* TODO: incr refcount??? */
        Jsi_ObjArraySet(interp, nobj, Jsi_ValueMakeObject(interp, NULL, fobj), n++);
    }

    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
#ifndef JSI_OMIT_SOCKET

#include "jsiInt.h"

#ifndef __WIN32
#include <time.h>
#include <sys/time.h>
#endif /* !__WIN32 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <assert.h>

#ifdef WIN32
#define _GET_TIME_OF_DAY_H
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stddef.h>

//#include "sock-w32.h"

#else /* WIN32 */
#include <syslog.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#endif /* WIN32 */

#include <signal.h>
#include <errno.h>

typedef enum {  PSS_DEAD, PSS_HTTP, PSS_CONNECTED, PSS_RECV, PSS_SENT, PSS_SENDERR } pss_state;

typedef enum {
    SOCK_CALLBACK_RECEIVE,
    SOCK_CALLBACK_WRITEABLE,
    SOCK_CALLBACK_CLOSED,
    SOCK_CALLBACK_OPEN,
} callback_reasons;

typedef struct { /* Interp wide data. */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    Jsi_Interp *interp;
    Jsi_Hash *wsTable;
    int wIdx;
} SocketObjInterpData;

//#define HAVE_IPV6
typedef union {
    struct sockaddr_in sin;
#ifdef HAVE_IPV6
    struct sockaddr_in6 sin6;
#endif
} SockAddrAll;

struct SocketObj;

typedef struct SocketPss { /* Per session connection to server */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    struct SocketObj *cmdPtr;
    pss_state state;
    int sentCnt, recvCnt, sentErrCnt;
    time_t sentLast, recvLast, sentErrLast;
    Jsi_HashEntry *hPtr;
    Jsi_Stack *stack;
    int id;
    int fd;
    int offset;
    SockAddrAll sa;
    SockAddrAll recvAddr;
    uint siLen;
} SocketPss;

typedef struct SocketObj { /* Per server (or client) data. */
#ifdef JSI_HAS_SIG
    jsi_Sig sig;
#endif
    SocketObjInterpData *interpData;
    Jsi_Interp *interp;
    Jsi_Hash *pssTable;
    Jsi_Value *onRecv;
    Jsi_Value *onCloseLast;
    Jsi_Value *onClose;
    Jsi_Value *onConnect;
    Jsi_Value *onOpen;
    Jsi_Value *defaultUrl;
    Jsi_Value *interface;
    Jsi_Value *address;
    char client_name[128];
    char client_ip[128];
    int idx;
    int port;
    int family;
    int saLen;
    char *iface;
    unsigned int oldus;
    Jsi_Bool udp;
    Jsi_Bool server;
    Jsi_Bool noUpdate;
    int hasOpts;
    int debug;
    int maxConnects;
    int deleted;
    int close_test;
    int connectCnt;
    int createCnt;
    int redirCnt;
    time_t createLast;
    time_t startTime;
    struct timeval tv;
    char *cmdName;

    Jsi_Event *event;
    Jsi_Obj *fobj;
    int objId;
    int rx_buffer_size;
    char *ssl_cert_filepath;
    char *ssl_private_key_filepath;
    int ws_uid;
    int ws_gid;
    char *cl_host;
    char *cl_origin;
    int maxfd;
    fd_set exceptSet, readSet, writeSet;
    int sendFlags;
    int recvFlags;
    SocketPss pss; // Server/non-async client pss.
} SocketObj;


/* Scanning function */
static int ValueToSockAddrOpt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record )
{
#if 0
    int n, *s = (SockAddrAll*)(((char*)record) + spec->offset)
    //int flags = (spec->flags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);
    if (!si) {
        Jsi_LogError("custom enum spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }
    if (inStr) {
        if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, "enum", flags, &n))
            return JSI_ERROR;
        *s = n;
        return JSI_OK;
    }
    if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, "enum", flags, &n))
        return JSI_ERROR;
    *s = n;
#endif
    return JSI_OK;

}

/* Printing function. */
static int SockAddrOptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record)
{
    SockAddrAll* sin = (SockAddrAll*)(((char*)record) + spec->offset);
    int rc = JSI_OK;
   /* const char **list = spec->data;
    if (!list) {
        Jsi_LogError("custom enum spec did not set data: %s", spec->name);
        return JSI_ERROR;
    }*/
    if (outStr) {
        /*n = *s;
        Jsi_DSAppendLen(outStr, list[i], -1);*/
        return JSI_OK;
    }
#ifndef JSI_LITE_ONLY
    Jsi_DString dStr = {};
    Jsi_DSPrintf(&dStr, "{port: %d, address:\"%s\"}",
        ntohs(sin->sin.sin_port), inet_ntoa(sin->sin.sin_addr));
    rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), outValue, 0);
    Jsi_DSFree(&dStr);
    return rc;
#endif
    return JSI_ERROR;

}

static Jsi_OptionCustom socketAddOption = {
    .name="sockAddr", .parseProc=ValueToSockAddrOpt, .formatProc=SockAddrOptToValue
};

#define IIOF .flags=JSI_OPT_INIT_ONLY

static Jsi_OptionSpec PSSOptions[] =
{
    JSI_OPT(INT,        SocketPss, recvCnt,      .help="Number of recieves"),
    JSI_OPT(TIMESTAMP,  SocketPss, recvLast,     .help="Time of last recv"),
    JSI_OPT(INT,        SocketPss, sentCnt,      .help="Number of sends"),
    JSI_OPT(TIMESTAMP,  SocketPss, sentLast,     .help="Time of last send"),
    JSI_OPT(INT,        SocketPss, sentErrCnt,   .help="Number of sends"),
    JSI_OPT(TIMESTAMP,  SocketPss, sentErrLast,  .help="Time of last sendErr"),
    JSI_OPT(CUSTOM,     SocketPss, recvAddr,     .help="Incoming port and address", .custom=&socketAddOption),
    JSI_OPT_END(SocketPss)
};

static Jsi_OptionSpec SockOptions[] =
{
    JSI_OPT(VALUE,  SocketObj, address,    .help="Client destination address", .init="127.0.0.0", IIOF ),
    JSI_OPT(INT,    SocketObj, connectCnt, .help="Counter for number of active connections", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,    SocketObj, debug,      .help="Debugging level"),
    JSI_OPT(VALUE,  SocketObj, interface,  .help="Interface for server to listen on, eg. 'eth0' or 'lo'", IIOF),
    JSI_OPT(INT,    SocketObj, maxConnects,.help="In server mode, max number of client connections accepted"),
    JSI_OPT(BOOL,   SocketObj, noUpdate,   .help="Stop processing update events (eg. to exit)"),
    JSI_OPT(FUNC,   SocketObj, onClose,    .help="Function to call when connection closes"),
    JSI_OPT(FUNC,   SocketObj, onCloseLast,.help="Function to call when last connection closes"),
    JSI_OPT(FUNC,   SocketObj, onConnect,  .help="Function to call when connection starts"),
    JSI_OPT(FUNC,   SocketObj, onOpen,     .help="Function to call when connection opens"),
    JSI_OPT(FUNC,   SocketObj, onRecv,     .help="Function to call with recieved data"),
    JSI_OPT(INT,    SocketObj, port,       .help="Port for client dest or server listen", IIOF, .init="9000" ),
    JSI_OPT(BOOL,   SocketObj, server,     .help="Enable server mode", IIOF),
    JSI_OPT(TIMESTAMP, SocketObj, startTime,     .help="Time of start", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(TIMESTAMP, SocketObj, createLast,     .help="Time of last create", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(BOOL,   SocketObj, udp,        .help="Protocol is udp", IIOF),
    JSI_OPT_END(SocketObj)
};

static int sockService(SocketObj *cmdPtr);

static int socketObjFree(Jsi_Interp *interp, void *data);
static int socketObjIsTrue(void *data);
static int socketObjEqual(void *data1, void *data2);

static int sockAddrSize(SockAddrAll* sa) {
#ifdef HAVE_IPV6
    if (sa->sin.sin_family == AF_INET6)
        return sizeof(sa->sin6);
#endif
    return sizeof(sa->sin);
}

static SocketPss*
sockGetPss(SocketObj *cmdPtr, int fd, int create)
{
    if (fd == cmdPtr->pss.fd)
        return &cmdPtr->pss;
    Jsi_HashEntry *hPtr;
    SocketPss* pss;
    int isNew;
    if (create)
        hPtr = Jsi_HashEntryNew(cmdPtr->pssTable, (void*)fd, &isNew);
    else
        hPtr = Jsi_HashEntryFind(cmdPtr->pssTable, (void*)fd);
    if (!hPtr)
        return NULL;
    if (create == 0 || isNew == 0) {
        pss = (SocketPss*)Jsi_HashValueGet(hPtr);
        SIGASSERT(pss, SOCKETPSS);
        return pss;
    }
    pss = (SocketPss*)Jsi_Calloc(1, sizeof(*pss));
    SIGINIT(pss, SOCKETPSS);
    pss->hPtr = hPtr;
    cmdPtr->connectCnt++;
    cmdPtr->createCnt++;
    cmdPtr->createLast = time(NULL);
    Jsi_HashValueSet(hPtr, pss);
    pss->cmdPtr = cmdPtr;
    pss->fd = fd;
    pss->state = PSS_CONNECTED;
    pss->id = ++cmdPtr->idx;
    pss->stack = Jsi_StackNew();
    return pss;
}


static SocketPss *sockFindPss(SocketObj *cmdPtr, int id) {
    if (id == 0) 
        return &cmdPtr->pss;
    SocketPss *tpss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
        tpss = (SocketPss*)Jsi_HashValueGet(hPtr);
        SIGASSERT(tpss, SOCKETPSS);
        if (tpss->id == id)
            return tpss;
    }
    return NULL;
}

static int sockFreeStackPss(Jsi_Interp *interp, void *data) {
    if (!data) return JSI_OK;
    Jsi_Value *v = (Jsi_Value*)data;
    SIGASSERT(v, VALUE);
    Jsi_DecrRefCount(interp, v);
    return JSI_OK;
}

static void
sockDeletePss(SocketPss *pss)
{
    if (pss == &pss->cmdPtr->pss)
        return;
    if (pss->hPtr) {
        Jsi_HashEntryDelete(pss->hPtr);
        pss->hPtr = NULL;
    }
    Jsi_StackFreeElements(pss->cmdPtr->interp, pss->stack, sockFreeStackPss);
    Jsi_StackFree(pss->stack);
    pss->cmdPtr->connectCnt--;
    /*Jsi_ObjDecrRefCount(pss->msgs);*/
    pss->state = PSS_DEAD;
}

static int SocketConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
  
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-sock object");
        return JSI_ERROR;
    }
    return Jsi_OptionsConf(interp, SockOptions, Jsi_ValueArrayIndex(interp, args, 0), cmdPtr, ret, 0);

}

static int sockGetPssId(SocketObj* cmdPtr, Jsi_Value* darg, int *idPtr) {
    Jsi_Interp *interp = cmdPtr->interp;
    Jsi_Number dnum = 0;
    int id;
    if (Jsi_ValueGetNumber(interp, darg, &dnum) != JSI_OK) {
        Jsi_LogError("invalid id");
        return JSI_ERROR;
    }
    id = (int)dnum;
    if (id < 0 && !cmdPtr->server)
        id = 0;
    if (id > 0 && !cmdPtr->server) {
        Jsi_LogError("invalid id");
        return JSI_ERROR;
    }
    *idPtr = id;
    return JSI_OK;
}

#define FN_wssend JSI_INFO("\
Send a message to 1 (or all connections if -1). If not already a string, msg is format as JSON prior to the send.")

static int SocketSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-sock object");
        return JSI_ERROR;
    }
    SIGASSERT(cmdPtr, SOCKET);
    SocketPss *pss;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    int aLen = 0;
    char *str = Jsi_ValueString(interp, arg, &aLen);
    
    if (str == NULL || aLen <= 0) return JSI_OK;
    int id = 0, argc = Jsi_ValueGetLength(interp, args);
    Jsi_DString eStr = {};
    if (argc>1) {
        if (sockGetPssId(cmdPtr, Jsi_ValueArrayIndex(interp, args, 1), &id) != JSI_OK)
            return JSI_ERROR;
    }
    if (!str) {
        Jsi_Value *narg = Jsi_ValueDup(interp, arg);
        Jsi_ValueToString(interp, narg, NULL);
        arg = narg;
    }
   /* if (cmdPtr->udp) {
        Jsi_IncrRefCount(interp, arg);
        str = Jsi_ValueString(interp, arg, &aLen);
        int rc = sendto(cmdPtr->pss.fd, str, aLen, 0, &cmdPtr->pss.sa.sa, 0);
    }*/
    if (id == 0) {
        if (!cmdPtr->pss.stack)
            cmdPtr->pss.stack = Jsi_StackNew();
        Jsi_StackPush(cmdPtr->pss.stack, arg);
        Jsi_IncrRefCount(interp, arg);
        if (cmdPtr->pss.fd>=0)
            FD_SET(cmdPtr->pss.fd, &cmdPtr->writeSet);
    } else {
        for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
            pss = (SocketPss *)Jsi_HashValueGet(hPtr);
            SIGASSERT(pss, SOCKETPSS);
            if ((id==-1 || pss->id == id) && pss->state != PSS_DEAD) {
                Jsi_StackPush(pss->stack, arg);
                Jsi_IncrRefCount(interp, arg);
                FD_SET (pss->fd, &cmdPtr->writeSet);
                if (id != -1)
                    break;
            }
        }
    }
    Jsi_DSFree(&eStr);
    return JSI_OK;
}

static int SocketRecvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-sock object");
        return JSI_ERROR;
    }
    SIGASSERT(cmdPtr, SOCKET);

    SocketPss *pss = &cmdPtr->pss;
    int id = 0, argc = Jsi_ValueGetLength(interp, args);
    if (argc>1) {
        if (sockGetPssId(cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), &id) != JSI_OK)
            return JSI_ERROR;
    }
    char buf[BUFSIZ];
    int n;
    pss->siLen = sockAddrSize(&pss->recvAddr);
    if (cmdPtr->udp)
        n = recvfrom(pss->fd, buf, sizeof(buf)-1, cmdPtr->sendFlags, (struct sockaddr*)&pss->recvAddr.sin, &pss->siLen);
    else
        n = recv(pss->fd, buf, sizeof(buf)-1, cmdPtr->recvFlags);
    if (n>0)
        buf[n] = 0;
    else {
        Jsi_LogError("read failed");
        return JSI_ERROR;
    }
    unsigned char *uptr = (unsigned char*)Jsi_Malloc(n+1);
    memcpy(uptr, buf, n+1);
    Jsi_ValueMakeBlob(interp, ret, (unsigned char*)buf, n);
    return JSI_OK;
}

static int SocketCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-sock object");
        return JSI_ERROR;
    }
    SIGASSERT(cmdPtr, SOCKET);
    SocketPss *pss;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    int id = 0, argc = Jsi_ValueGetLength(interp, args);
    if (argc>1) {
        if (sockGetPssId(cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), &id) != JSI_OK)
            return JSI_ERROR;
    }
    if (id == 0) {
        if (cmdPtr->pss.fd>=0) {
            close(cmdPtr->pss.fd);
            FD_CLR(cmdPtr->pss.fd, &cmdPtr->writeSet);
            FD_CLR(cmdPtr->pss.fd, &cmdPtr->readSet);
            cmdPtr->pss.fd = -1;
        }
    } else {
        for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
            hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
            pss = (SocketPss *)Jsi_HashValueGet(hPtr);
            SIGASSERT(pss, SOCKETPSS);
            if ((id==-1 || pss->id == id) && pss->state != PSS_DEAD) {
                if (pss->fd>=0) {
                    close(pss->fd);
                    FD_CLR(pss->fd, &cmdPtr->writeSet);
                    FD_CLR(pss->fd, &cmdPtr->readSet);
                    pss->fd = -1;
                }
            }
        }
    }
    return JSI_OK;
}


#define FN_wsupdate JSI_INFO("\
Update socket queue.  This is used only in server mode to broadcast to clients.")

static int SocketUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Value *oldcb = cmdPtr->onRecv;
    if (!cmdPtr) {
        Jsi_LogError("Apply to non-socket object");
        return JSI_ERROR;
    }
    if (cmdPtr->noUpdate)
        return JSI_OK;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg) {
        if (Jsi_ValueIsType(interp, arg, JSI_VT_OBJECT)==0 || Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION)==0) {
            Jsi_LogError("arg is not a function");
            return JSI_ERROR;
        }
        cmdPtr->onRecv = arg;
    }
    sockService(cmdPtr);
    if (arg)
        cmdPtr->onRecv = oldcb;
    return JSI_OK;
}

static int sockUpdate(Jsi_Interp *interp, void *data)
{
    SocketObj *cmdPtr = (SocketObj *)data;
    SIGASSERT(cmdPtr,SOCKET);
    sockService(cmdPtr);
    return JSI_OK;
}

static void socketObjErase(SocketObj *cmdPtr)
{
    if (cmdPtr->pss.fd>=0)
        close(cmdPtr->pss.fd);
    cmdPtr->pss.fd = -1;
    if (cmdPtr->interp) {
        if (cmdPtr->event)
            Jsi_EventFree(cmdPtr->interp, cmdPtr->event);
        cmdPtr->event = NULL;
        if (cmdPtr->hasOpts)
            Jsi_OptionsFree(cmdPtr->interp, SockOptions, cmdPtr, 0);
        cmdPtr->hasOpts = 0;
        if (cmdPtr->pssTable)
            Jsi_HashDelete(cmdPtr->pssTable);
        cmdPtr->pssTable = NULL;
    }
    if (cmdPtr->pss.stack) {
        Jsi_StackFreeElements(cmdPtr->interp, cmdPtr->pss.stack, sockFreeStackPss);
        Jsi_StackFree(cmdPtr->pss.stack);
    }

    cmdPtr->interp = NULL;
}

static int socketObjFree(Jsi_Interp *interp, void *data)
{
    SocketObj *cmdPtr = (SocketObj *)data;
    SIGASSERT(cmdPtr,SOCKET);
    socketObjErase(cmdPtr);
    Jsi_Free(cmdPtr);
    return 0;
}

static int socketObjIsTrue(void *data)
{
    //SocketObj *cmdPtr = data;
    return 1;
   /* if (!fo->sockname) return 0;
    else return 1;*/
}

static int socketObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}


static int sockFreePss(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {
    SocketPss *pss = (SocketPss *)ptr;
    if (pss) {
        pss->hPtr = NULL;
        sockDeletePss(pss);
    }
    return JSI_OK;
}

static int sockParseHostname(const char *hostname, SockAddrAll *sa, int *saLen, int port) {
#ifndef WITHOUT_GETADDRINFO
    struct addrinfo req, *ai;
#ifdef HAVE_IPV6
    if (strchr(hostname, ':')) {
        if (inet_pton (AF_INET6, hostname, &sa->sin6.sin6_addr) != 1) {
            return JSI_ERROR;
        }
        sa->sin6.sin6_family = AF_INET6;
        sa->sin.sin_port = htons(port);
        *saLen = sizeof(sa->sin6);
        return JSI_OK;
    }
#endif

    memset(&req, 0, sizeof(req));
    req.ai_family = sa->sin.sin_family;

    if (getaddrinfo(hostname, NULL, &req, &ai))
        return JSI_ERROR;
    memcpy(&sa->sin, ai->ai_addr, ai->ai_addrlen);
    sa->sin.sin_port = htons(port);
    *saLen = ai->ai_addrlen;
    freeaddrinfo(ai);
#else
    struct hostent *he;

    if (!(he = gethostbyname(hostname)))
        return JSI_ERROR;
    if (he->h_length == sizeof(sa->sin.sin_addr)) {
        *saLen = sizeof(sa->sin);
        sa->sin.sin_family= he->h_addrtype;
        memcpy(&sa->sin.sin_addr, he->h_addr, he->h_length);
    }
#endif
    return JSI_OK;
}

static Jsi_Value*
dump_socket_info(SocketObj *cmdPtr, SocketPss *pss)
{
    Jsi_Interp *interp = cmdPtr->interp;
    Jsi_Value *ret = Jsi_ValueNew(interp);
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebugLabel(ret, "socket", "dump_socket");
#endif
    Jsi_JSONParseFmt(interp, &ret, "{address:\"%s\"}", inet_ntoa(pss->sa.sin.sin_addr));
    return ret;
}


static int
sock_handler(SocketObj *cmdPtr, callback_reasons reason,
      SocketPss *pss, char *inPtr, size_t len)
{
    Jsi_Interp *interp = cmdPtr->interp;
    int n, rc = JSI_OK;
   // char buf[BUFSIZ];//, *bufPtr = buf;
    //static char *statBuf = NULL;
    //static int statSize = 0;

    SIGASSERT(cmdPtr, SOCKET);
    SIGASSERT(pss, SOCKETPSS);
    switch (reason) {
        
    case SOCK_CALLBACK_OPEN:
        if (cmdPtr->debug)
            fprintf(stderr, "SOCK:CALLBACK_OPEN: %p\n", pss);
        if (cmdPtr->onOpen) {
            int killcon = 0;
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2], *ret = Jsi_ValueNew1(interp);
            
            vargs[0] = dump_socket_info(cmdPtr, pss);
            Jsi_IncrRefCount(interp, vargs[0]);
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 1));
            Jsi_DecrRefCount(interp, vargs[0]);
            Jsi_IncrRefCount(interp, vpargs);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return 1;
            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {
                if (cmdPtr->debug)
                    fprintf(stderr, "SOCK:KILLING CONNECTION: %p\n", pss);
                killcon = 1;
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("socket bad rcv eval");
                return JSI_ERROR;
            }
            if (killcon)
                return JSI_ERROR;
        }
        break;

    case SOCK_CALLBACK_CLOSED:
        if (cmdPtr->debug)
            fprintf(stderr, "SOCK:CALLBACK_CLOSE: %p\n", pss);
        if (!pss) break;
        if (cmdPtr->onClose) {
            /* Pass 2 args: data and id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onClose, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return JSI_ERROR;
            }
        }        
        sockDeletePss(pss);
        if (cmdPtr->connectCnt<=0 && cmdPtr->onCloseLast) {
            Jsi_FunctionInvokeBool(interp, cmdPtr->onCloseLast, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
        }
        break;
    case SOCK_CALLBACK_WRITEABLE:
        n=0;
        while (1) {
            Jsi_Value *dv = (Jsi_Value*)Jsi_StackPeek(pss->stack);
            char *data;
            int sLen;
            if (dv == NULL || (data=Jsi_ValueString(interp, dv, &sLen)) == NULL)
                break;
            pss->state = PSS_SENT;
        
            int osiz = sLen-pss->offset;
            int siLen = sockAddrSize(&pss->sa);
            if (cmdPtr->udp)
                n = sendto(pss->fd, data + pss->offset, osiz, cmdPtr->sendFlags, (struct sockaddr*)&cmdPtr->pss.sa.sin, siLen);
            else
                n = send(pss->fd, data + pss->offset, osiz, cmdPtr->sendFlags);
            if (n<=0) {
                perror("failed");
                if (cmdPtr->debug)
                    fprintf(stderr, "error on write\n");
                return JSI_ERROR;
            }
            if (n >= osiz) {
                Jsi_StackPop(pss->stack);
                pss->offset = 0;
            } else {
                if (cmdPtr->debug)
                    fprintf(stderr, "more to write: %d\n", (osiz-n));
                pss->offset += n;
            }
            if (cmdPtr->debug)
                fprintf(stderr, "SOCK:CLIENT WRITE(%d): %d=>%d: %s\n", pss->id, sLen, n, data);
            Jsi_DecrRefCount(interp, dv);                                   
            if (n >= 0) {
                pss->sentCnt++;
                pss->sentLast = time(NULL);
            } else {
                if (cmdPtr->debug)
                    fprintf(stderr, "ERROR %d writing to socket\n", n);
                pss->state = PSS_SENDERR;
                pss->sentErrCnt++;
                pss->sentErrLast = time(NULL);
                return JSI_ERROR;
            }
        }
        break;
        
    case SOCK_CALLBACK_RECEIVE:
    {
        int src;
        if (cmdPtr->debug)
            fprintf(stderr, "SOCK:RECV: %p\n", pss);

        pss->recvCnt++;
        pss->recvLast = time(NULL);

        if (cmdPtr->onRecv && !Jsi_ValueIsNull(interp, cmdPtr->onRecv)) {
            /* Pass 2 args: data and id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0]  = Jsi_ValueNewString(interp, Jsi_Strdup(inPtr), len);
            vargs[1] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 2, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            src = Jsi_FunctionInvoke(interp, cmdPtr->onRecv, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
            if (src == JSI_OK && Jsi_ValueIsUndef(interp, ret)==0) {
                /* TODO: handle callback return data??? */
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (src != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return rc;
            }
        }

        break;
 
    }
    default:
        break;
    }
    return rc;
}


static int sockService(SocketObj *cmdPtr)
{
    //Jsi_Interp *interp = cmdPtr->interp;
    char buf[BUFSIZ];
    struct sockaddr_in sin;
    fd_set writeSet, readSet;
    int i, n, cnt = 0;
    readSet = cmdPtr->readSet;
    writeSet = cmdPtr->writeSet;
    int maxfd = cmdPtr->maxfd+1;
    maxfd = FD_SETSIZE;
    if (cmdPtr->debug)
        fprintf(stderr, "selecting\n");
    struct timeval tv;
    tv = cmdPtr->tv;
    if ((n=select(maxfd, &readSet, &writeSet, NULL, &tv)) < 0 && errno!=EINTR) {
        perror("Select");
        return JSI_ERROR;
    }
    if (cmdPtr->debug)
        fprintf(stderr, "select done: %d\n", n);

    for (i = 0; i < maxfd && cnt < n; ++i) {
        if (FD_ISSET (i, &readSet)) {
            cnt++;
            if (cmdPtr->server && i == cmdPtr->pss.fd && cmdPtr->udp==0) {
                uint c = sizeof(sin);
                int csock = accept(cmdPtr->pss.fd, (struct sockaddr*)&sin, &c);
                if (csock < 0) {
                    perror("accept");
                    return JSI_ERROR;
                }
                SocketPss* pss = sockGetPss(cmdPtr, csock, 1);
                pss->sa.sin = sin;
                if (sock_handler(cmdPtr, SOCK_CALLBACK_OPEN, pss, NULL, 0) != JSI_OK) {
                    close(csock);
                    sockDeletePss(pss);
                    continue;
                }
                if (cmdPtr->debug)
                    fprintf (stderr, "Server: connect %d from host %s, port %d.\n",
                        csock, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
                FD_SET(csock, &cmdPtr->readSet);
            } else {
                SocketPss* pss = sockGetPss(cmdPtr, i, 0);
                if (!pss) {
                    if (cmdPtr->debug)
                        fprintf(stderr, "no pss for %d\n", i);
                    continue;
                }
                uint siLen = sockAddrSize(&pss->recvAddr);
                if (cmdPtr->udp)
                    n = recvfrom(pss->fd, buf, sizeof(buf)-1, cmdPtr->sendFlags, (struct sockaddr*)&pss->recvAddr.sin, &siLen);
                else
                    n = recv(i, buf, sizeof(buf)-1, cmdPtr->recvFlags);
                if (n<=0) {
                    if (cmdPtr->debug)
                        fprintf(stderr, "read failed %d\n", i);
                    close(i);
                    FD_CLR(i, &cmdPtr->readSet);
                    FD_CLR(i, &cmdPtr->writeSet);
                    sock_handler(cmdPtr, SOCK_CALLBACK_CLOSED, pss, NULL, 0);
                }
                buf[sizeof(buf)-1] = 0;
                if (cmdPtr->debug)
                    fprintf(stderr, "Read data(%d): %s\n", n, buf);
                if (n>0 && sock_handler(cmdPtr, SOCK_CALLBACK_RECEIVE, pss, buf, n) != JSI_OK) {
                    sockDeletePss(pss);
                    continue;
                }
            }
        }
        if (FD_ISSET(i, &writeSet)) {
            cnt++;
            SocketPss* pss = sockGetPss(cmdPtr, i, 0);
            if (!pss) {
                if (cmdPtr->debug)
                    fprintf(stderr, "no pss for %d\n", i);
                continue;
            }
            if (sock_handler(cmdPtr, SOCK_CALLBACK_WRITEABLE, pss, NULL, 0) != JSI_OK) {
                close(pss->fd);
                FD_CLR(pss->fd, &cmdPtr->writeSet);
                FD_CLR(pss->fd, &cmdPtr->readSet);
                pss->fd = -1;
                sockDeletePss(pss);
                if (cmdPtr->udp)
                    return JSI_ERROR;
                continue;
            }
            if (Jsi_StackLen(pss->stack)==0)
                FD_CLR(i, &cmdPtr->writeSet);
        }

    }
    return JSI_OK;
}

#define FN_Socket JSI_INFO("\
Create a socket server or client object.")
static int SocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr);

static int SocketIdConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-socket object");
        return JSI_ERROR;
    }
    SocketPss *pss = &cmdPtr->pss;
    int id = 0;
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc) {
        Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 0);
        Jsi_Number vid;
        if (Jsi_ValueGetNumber(interp, valPtr, &vid) != JSI_OK || vid < 0) {
            Jsi_LogError("Expected number id");
            return JSI_ERROR;
        }
        id = (int)vid;
        pss = sockFindPss(cmdPtr, id);
    }
    if (!pss) {
        Jsi_LogError("No such id: %d", id);
        return JSI_ERROR;
    }
    return Jsi_OptionsConf(interp, PSSOptions, argc>1?Jsi_ValueArrayIndex(interp, args, 1):NULL, pss, ret, 0);
}

static int SocketIdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr = (SocketObj *)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-socket object");
        return JSI_ERROR;
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppend(&dStr, "{", NULL);
    SocketPss *pss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    int cnt = 0;
    for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
        pss = (SocketPss *)Jsi_HashValueGet(hPtr);
        SIGASSERT(pss, SOCKETPSS);
        if (pss->state != PSS_DEAD) {
            Jsi_DSPrintf(&dStr, "%s%d", cnt++?",":"", pss->id);
        }
    }
    Jsi_DSAppend(&dStr, "}", NULL);
    int rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    return rc;
}


static Jsi_CmdSpec sockCmds[] = {
    { "Socket",     SocketConstructor, 0,  1, "options:object=void", JSI_CMD_IS_CONSTRUCTOR, .help="Create socket server/client object", .opts=SockOptions, .info=FN_Socket, .retType=(uint)JSI_TT_USEROBJ },
    { "close",      SocketCloseCmd,    0,  1, "", .help="Close socket(s)", .retType=(uint)JSI_TT_VOID },
    { "conf",       SocketConfCmd,     0,  1, "options:string|object=void",.help="Configure options" , .opts=SockOptions, .retType=(uint)JSI_TT_ANY },
    { "names",      SocketIdsCmd,      0,  0, "", .help="Return list of active ids on server", .retType=(uint)JSI_TT_ARRAY },
    { "idconf",     SocketIdConfCmd,   0,  2, "id:number=void, options:string|object=void",.help="Configure options for id" , .opts=PSSOptions, .retType=(uint)JSI_TT_ANY },
    { "recv",       SocketRecvCmd,     0,  1, "id:number=void", .help="Recieve data", .retType=(uint)JSI_TT_STRING },
    { "send",       SocketSendCmd,     1,  2, "data:any, id:number=void", .help="Send a socket message to id", .info=FN_wssend, .retType=(uint)JSI_TT_VOID },
    { "update",     SocketUpdateCmd,   0,  1, "callback:function=void", .help="Service just socket events", .info=FN_wsupdate, .retType=(uint)JSI_TT_VOID },
    { NULL, .help="Commands for managing Socket server/client connections"  }
};


static Jsi_UserObjReg sockobject = {
    "Socket",
    sockCmds,
    socketObjFree,
    socketObjIsTrue,
    socketObjEqual
};

    
static int SocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SocketObj *cmdPtr;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    cmdPtr = (SocketObj *)Jsi_Calloc(1, sizeof(*cmdPtr));
    SIGINIT(cmdPtr, SOCKET);
    SIGINIT(&cmdPtr->pss, SOCKETPSS);
    cmdPtr->pss.cmdPtr = cmdPtr;
    cmdPtr->port = 9000;
    cmdPtr->pss.fd = -1;
    cmdPtr->interp = interp;
    cmdPtr->rx_buffer_size = 50000;
    cmdPtr->ws_gid = -1;
    cmdPtr->ws_uid = -1;
    cmdPtr->startTime = time(NULL);
    cmdPtr->tv.tv_sec = 1;
    cmdPtr->tv.tv_usec = 10000;
    cmdPtr->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (cmdPtr->hasOpts && Jsi_OptionsProcess(interp, SockOptions, arg, cmdPtr, 0) < 0) {
        cmdPtr->deleted = 1;
        socketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
#if 0
    cmdPtr->info.port = (cmdPtr->client ? CONTEXT_PORT_NO_LISTEN : cmdPtr->port);
#endif

    cmdPtr->family = AF_INET;
    SockAddrAll *sap = &cmdPtr->pss.sa;
    memset(sap, 0, sizeof(*sap));
    const char *address = (cmdPtr->address ? Jsi_ValueString(interp, cmdPtr->address, NULL) : "127.0.0.1");
    sap->sin.sin_family = cmdPtr->family;
    sap->sin.sin_addr.s_addr = INADDR_ANY;
    sap->sin.sin_port = htons(cmdPtr->port); 
    
    if (sockParseHostname(address, sap, &cmdPtr->saLen, cmdPtr->port) != JSI_OK) {
        Jsi_LogError("hostname parse");
        socketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
    sap->sin.sin_port = htons(cmdPtr->port); 
    FD_ZERO(&cmdPtr->readSet);
    FD_ZERO(&cmdPtr->writeSet);
    FD_ZERO(&cmdPtr->exceptSet);
    int fd;
    if ((fd = socket(cmdPtr->family, cmdPtr->udp ? SOCK_DGRAM : SOCK_STREAM, 0)) < 0) {
        Jsi_LogError("sock create failed");
        socketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
    if (fd>cmdPtr->maxfd)
        cmdPtr->maxfd = fd;
    
    if (!cmdPtr->server) { // Client
        cmdPtr->pss.fd = fd;
        if (!cmdPtr->udp) {
            if (connect(fd , (struct sockaddr*)sap , sizeof(sap->sin)) < 0) {
                Jsi_LogError("sock connect failed");
                socketObjFree(interp, cmdPtr);
                return JSI_ERROR;
            }
            FD_SET(fd, &cmdPtr->readSet);
        }
    } else { // Server
        int lfd = cmdPtr->pss.fd = fd;
        if( bind(lfd, (struct sockaddr*)sap , sizeof(sap->sin)) < 0) {
            Jsi_LogError("sock bind failed");
            socketObjFree(interp, cmdPtr);
            return JSI_ERROR;
        }
        if (cmdPtr->udp == 0 && listen(lfd , 3)) {
            Jsi_LogError("sock listen failed");
            socketObjFree(interp, cmdPtr);
            return JSI_ERROR;
        }
        cmdPtr->pssTable = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, sockFreePss);
        FD_SET(lfd, &cmdPtr->readSet);
    }

    cmdPtr->event = Jsi_EventNew(interp, sockUpdate, cmdPtr);
    Jsi_Value *toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Socket", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &sockobject, fobj, cmdPtr))<0) {
        socketObjFree(interp, cmdPtr);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    cmdPtr->fobj = fobj;
    return JSI_OK;
}

int Jsi_DoneSocket(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &sockobject);
    return JSI_OK;
}

int Jsi_InitSocket(Jsi_Interp *interp)
{
    Jsi_Hash *wsys;
    if (!(wsys = Jsi_UserObjRegister(interp, &sockobject))) {
        Jsi_LogFatal("Can not init socket\n");
        return JSI_ERROR;
    }

    if (!Jsi_CommandCreateSpecs(interp, sockobject.name, sockCmds, wsys, 0))
        return JSI_ERROR;
    return JSI_OK;
}

#endif //JSI_OMIT_SOCKET
#endif //JSI_LITE_ONLY
#ifdef HAVE_SQLITE
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** A JSI (Javascript) Interface to SQLite.
*/
//#define _SQLITEN_(OMIT_TRACE)
//#define _SQLITEN_(OMIT_AUTHORIZATION)

typedef enum { SQLITE_SIG_DB = 0xbeefdead, SQLITE_SIG_FUNC, SQLITE_SIG_EXEC, SQLITE_SIG_STMT } Sqlite_Sig;

#define SQLSIGASSERT(s,n) assert(s->sig == SQLITE_SIG_##n)
#ifndef NDEBUG
#ifndef MEMCLEAR
#define MEMCLEAR(s) memset(s, 0, sizeof(*s));
#endif
#else
#define MEMCLEAR(s)
#endif
#ifndef JSI_DB_DSTRING_SIZE
#define JSI_DB_DSTRING_SIZE 2000
#endif

#ifndef JSI_DBQUERY_BEGIN_STR
#define JSI_DBQUERY_BEGIN_STR "BEGIN;"
#endif
#ifndef JSI_DBQUERY_ROLLBACK_STR
#define JSI_DBQUERY_ROLLBACK_STR "ROLLBACK;"
#endif
#ifndef JSI_DBQUERY_COMMIT_STR
#define JSI_DBQUERY_COMMIT_STR "COMMIT;"
#endif

#include <errno.h>

//#define USE_SQLITE_V4
#ifndef USE_SQLITE_V4

#define _SQL_LITE_N_(nam) sqlite3##nam
#define _SQLITEN_(nam) SQLITE_##nam
#define _SQLBIND_END_
#define _SQLITE_PENV_(n)

#else

#define _SQL_LITE_N_(nam) sqlite4##nam
#define _SQLITEN_(nam) SQLITE4_##nam
#define SQLITE_OK SQLITE4_OK
#define sqlite_uint64 sqlite4_uint64
#define sqlite_int64 sqlite4_int64
#define _SQLBIND_END_ ,NULL
#define _SQLITE_PENV_(n) n->pEnv,
#define OMIT_SQLITE_COLLATION
#define OMIT_SQLITE_HOOK_COMMANDS
#define SQLITE_OMIT_AUTHORIZATION
#define SQLITE_OMIT_LOAD_EXTENSION

#endif
/*
** Some additional include files are needed if this file is not
** appended to the amalgamation.
*/
#ifdef __WIN32
#ifdef USE_SQLITE_V4
#include "../sqlite4/sqlite4.h"
#else
#include "../sqlite3/sqlite3.h"
#endif
#endif

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <limits.h>

#ifndef SQLITE_AMALGAMATION
#ifdef USE_SQLITE_V4
#include "sqlite4.h"
#else
#include "sqlite3.h"
#endif
#endif
#include <ctype.h>
#include <stdio.h>

#ifndef JSI_AMALGAMATION
#ifdef JSI_MEM_DEBUG
#include "jsiInt.h"
#else
#include "jsi.h"
JSI_EXTENSION_INI
#endif
#endif

#ifndef NUM_PREPARED_STMTS
#define NUM_PREPARED_STMTS 100
#endif
#ifndef MAX_PREPARED_STMTS
#define MAX_PREPARED_STMTS 10000
#endif

#ifndef JSI_DBQUERY_PRINTF
#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#endif
/*
** When JSI uses UTF-8 and SQLite is configured to use iso8859, then we
** have to do a translation when going between the two.  Set the
** UTF_TRANSLATION_NEEDED macro to indicate that we need to do
** this translation.
*/
#if defined(JSI_UTF_MAX) && !defined(SQLITE_UTF8)
# define UTF_TRANSLATION_NEEDED 1
#endif

/*
** New SQL functions can be created as JSI scripts.  Each such function
** is described by an instance of the following structure.
*/
typedef struct SqlFunc SqlFunc;
struct SqlFunc {
    Sqlite_Sig sig;
    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */
    Jsi_Value   *tocall;    /* Callee */
    char        *pScript;   /* The char* representation of the script */
    Jsi_DString dScript;
    char        *zName;     /* Name of this function */
    SqlFunc     *pNext;     /* Next function on the list of them all */
};

/*
** New collation sequences function can be created as JSI scripts.  Each such
** function is described by an instance of the following structure.
*/
typedef struct SqlCollate SqlCollate;
struct SqlCollate {
    Sqlite_Sig sig;
    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */
    Jsi_Value   *zScript;  /* The function to be run */
    SqlCollate  *pNext;    /* Next function on the list of them all */
};

/*
** Prepared statements are cached for faster execution.  Each prepared
** statement is described by an instance of the following structure.
*/
typedef struct SqlPreparedStmt SqlPreparedStmt;
struct SqlPreparedStmt {
    Sqlite_Sig sig;
    int deleting;
    SqlPreparedStmt *pNext;  /* Next in linked list */
    SqlPreparedStmt *pPrev;  /* Previous on the list */
    _SQL_LITE_N_(_stmt)    *pStmt;  /* The prepared statement */
    int nSql;                /* chars in zSql[] */
    const char *zSql;        /* Text of the SQL statement */
    Jsi_HashEntry *entry;
    Jsi_ListEntry *elPtr;
    //int nParm;               /* Size of apParm array */
    //Jsi_Value **apParm;      /* Array of referenced object pointers */
};

static const char *execFmtStrs[] = {
    "rows", "arrays", "array1d", "list", "column", "json",
    "json2", "html", "csv", "insert", "line", "tabs", "none", NULL
};

typedef enum {
    _JSI_EF_ROWS, _JSI_EF_ARRAYS, _JSI_EF_ARRAY1D, _JSI_EF_LIST, _JSI_EF_COLUMN, _JSI_EF_JSON,
    _JSI_EF_JSON2, _JSI_EF_HTML, _JSI_EF_CSV, _JSI_EF_INSERT, _JSI_EF_LINE, _JSI_EF_TABS, _JSI_EF_NONE
} Output_Mode;

const char *dbTypeChkStrs[] = { "convert", "warn", "error", "disable", NULL };

typedef enum { dbTypeCheck_Cast, dbTypeCheck_Warn, dbTypeCheck_Error, dbTypeCheck_None } dbTypeCheck_Mode;

typedef struct QueryOpts {
    Sqlite_Sig sig;
    Jsi_Value *callback, *values;
    int limit;
    Output_Mode mode;
    dbTypeCheck_Mode typeCheck;
    Jsi_Bool mapundef, nocache, headers;
    const char *separator;
    const char *nullvalue;
    const char *table;
    const char *Cdata; // Name of cdata to use for query.
    char varName[100];
    Jsi_Value *width;
} QueryOpts;

static const char *mtxStrs[] = { "default", "none", "full", NULL };
typedef enum { MUTEX_DEFAULT, MUTEX_NONE, MUTEX_FULL } Mutex_Type;

static const char *trcModeStrs[] = {"eval", "delete", "prepare", "step", NULL}; // Bit-set packed into an int.
enum {TMODE_EVAL=0x1, TMODE_DELETE=0x2, TMODE_PREPARE=0x4, TMODE_STEP=0x4};

/*
** There is one instance of this structure for each SQLite database
** that has been opened by the SQLite JSI interface.
*/
typedef struct Jsi_Db_ {
    Sqlite_Sig sig;
    _SQL_LITE_N_() *db;               /* The "real" database structure. MUST BE FIRST */
    Jsi_Interp *interp;        /* The interpreter used for this database */
    Jsi_Value *zBusy;               /* The busy callback routine */
    Jsi_Value *zCommit;             /* The commit hook callback routine */
    Jsi_Value *zTrace;              /* The trace callback routine */
    Jsi_Value *zProfile;            /* The profile callback routine */
    Jsi_Value *zProgress;           /* The progress callback routine */
    Jsi_Value *zAuth;               /* The authorization callback routine */
    int disableAuth;           /* Disable the authorizer if it exists */
    char *zNull;               /* Text to substitute for an SQL NULL value */
    SqlFunc *pFunc;            /* List of SQL functions */
    Jsi_Value *pUpdateHook;      /* Update hook script (if any) */
    Jsi_Value *pRollbackHook;    /* Rollback hook script (if any) */
    Jsi_Value *pWalHook;        /* Wal hook script (if any) */
    Jsi_Value *pUnlockNotify;    /* Unlock notify script (if any) */
    SqlCollate *pCollate;      /* List of SQL collation functions */
    int rc;                    /* Return code of most recent _SQL_LITE_N_(_exec)() */
    Jsi_Value *pCollateNeeded;   /* Collation needed script */
    Jsi_Hash *stmtHash;        /* Hash table for statements. */
    Jsi_List *stmtCache;
    int maxStmts;               /* The next maximum number of stmtList */
    int numStmts;                 /* Number of statements in stmtList */
    /*IncrblobChannel *pIncrblob; * Linked list of open incrblob channels */
    Jsi_Hash *strKeyTbl;       /* Used with JSI_LITE_ONLY */
    Jsi_Bool bindWarn;
    Jsi_Bool forceInt:1;
    //Jsi_Bool forceInt;
    Jsi_Bool readonly;
    Jsi_Bool nocreate;
    int numStep, numSort;          /* Statistics for most recent operation */
    int nTransaction;          /* Number of nested [transaction] methods */
    int errorCnt;               /* Count of errors. */
    Jsi_Value *key;             /* Key, for codec. */
    Jsi_Value *vfs;
    int hasOpts;
    Jsi_Obj *userObjPtr;
    QueryOpts queryOpts, *optPtr;
    int objId;
    Mutex_Type mutex;
    int debug;
    //int trace;
    Jsi_DString name;
    Jsi_Hash *typeNameHash;
#ifdef USE_SQLITE_V4
    sqlite4_env *pEnv;
#endif
} Jsi_Db;

/*
** Structure used with dbEvalXXX() functions:
**
**   dbEvalInit(interp,)
**   dbEvalStep()
**   dbEvalFinalize()
**   dbEvalRowInfo()
**   dbEvalColumnValue()
*/
#define SQL_MAX_STATIC_TYPES 100
typedef struct DbEvalContext {
    Jsi_Db *jdb;                /* Database handle */
    Jsi_DString *dSql;               /* Object holding string zSql */
    const char *zSql;               /* Remaining SQL to execute */
    SqlPreparedStmt *pPreStmt;      /* Current statement */
    int nCol;                       /* Number of columns returned by pStmt */
    char **apColName;             /* Array of column names */
    int *apColType;
    char staticColNames[BUFSIZ];  /* Attempt to avoid mallocing space for name storage. */
    int staticColTypes[SQL_MAX_STATIC_TYPES];
    Jsi_Value *tocall;
    Jsi_Value *ret;
    /*OBS */
    Jsi_Value *pArray;              /* Name of array variable */
    Jsi_Value *pValVar;             /* Name of list for values. */
    int nocache;
} DbEvalContext;

#ifndef JSI_LITE_ONLY

static int dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value);
static int dbBitOp(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);


static Jsi_OptionSpec ExecFmtOptions[] =
{
    JSI_OPT(FUNC,   QueryOpts, callback, .help="Function to call with each row result" ),
    JSI_OPT(BOOL,   QueryOpts, headers, .help="First row returned contains column labels"),
    JSI_OPT(INT,    QueryOpts, limit, .help="Maximum number of returned values"),
    JSI_OPT(BOOL,   QueryOpts, mapundef, .help="In variable bind, map an 'undefined' var to null"),
    JSI_OPT(CUSTOM, QueryOpts, mode, .custom=Jsi_Opt_SwitchEnum,  .data=execFmtStrs, .help="Set output mode of returned data"),
    JSI_OPT(BOOL,   QueryOpts, nocache, .help="Query is not to be cached"),
    JSI_OPT(STRKEY, QueryOpts, nullvalue, .help="Null string output (for non js/json mode)"),
    JSI_OPT(STRKEY, QueryOpts, separator, .help="Separator string (for csv and text mode)"),
    JSI_OPT(STRKEY, QueryOpts, Cdata, .help="Name of Cdata object to use"),
    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help="Type check mode", .init="warn", .custom=Jsi_Opt_SwitchEnum, .data=dbTypeChkStrs),
    JSI_OPT(STRKEY, QueryOpts, table, .help="Table name for mode=insert"),
    JSI_OPT(ARRAY,  QueryOpts, values, .help="Values for ? bind parameters" ),
    JSI_OPT(STRBUF, QueryOpts, varName,  .help="Array var for ? bind parameters" ),
    JSI_OPT(CUSTOM, QueryOpts, width, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)dbIsNumArray, .help="In column mode, set column widths"),
    JSI_OPT_END(QueryOpts)
};

static Jsi_CmdSpec sqliteCmds[];

#define IIOF .flags=JSI_OPT_INIT_ONLY
static Jsi_OptionSpec SqlOptions[] =
{
    JSI_OPT(BOOL,   Jsi_Db, bindWarn, .help="Treat failed variable binds as a warning", IIOF, .init="false"),
    JSI_OPT(CUSTOM, Jsi_Db, debug,  .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs, .help="Enable debug trace for various operations"),
#ifdef SQLITE_HAS_CODEC
    JSI_OPT(VALUE,  Jsi_Db, key), .help="codec key", IIOF),
#endif
    JSI_OPT(INT,    Jsi_Db, errorCnt, .help="Count of errors", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(CUSTOM, Jsi_Db, queryOpts, .help="Default options for exec", .custom=Jsi_Opt_SwitchSuboption, .data=ExecFmtOptions),
    JSI_OPTI(CUSTOM,Jsi_Db, forceInt, .help="Bind float as int if possible", 
        .custom=Jsi_Opt_SwitchCBitField, .bitop=dbBitOp, .flags=JSI_OPT_BITFIELD_BOOL, .offset=1),
    //JSI_OPT(BOOL,   Jsi_Db, forceInt, .help="Bind float as int if possible"),
    JSI_OPT(INT,    Jsi_Db, maxStmts, .help="Max cache size for compiled statements"),
    JSI_OPT(CUSTOM, Jsi_Db, mutex,    .help="Mutex type to use", .custom=Jsi_Opt_SwitchEnum, .data=mtxStrs, IIOF),
    JSI_OPT(DSTRING,Jsi_Db, name,     .help="Name for this db handle"),
    JSI_OPT(BOOL,   Jsi_Db, nocreate, .help="Database is must already exist", IIOF, .init="false"),
    JSI_OPT(INT,    Jsi_Db, numSort,  .help="Number of sorts in most recent operation", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,    Jsi_Db, numStep,  .help="Number of steps in most recent operation", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,    Jsi_Db, numStmts, .help="Current size of compiled statement cache", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(BOOL,   Jsi_Db, readonly, .help="Database is readonly", IIOF, .init="false"),
    JSI_OPT(VALUE,  Jsi_Db, vfs,      .help="VFS to use", IIOF),
    JSI_OPT_END(Jsi_Db)
};

static int dbBitOp(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet) {
    Jsi_Db *db = (Jsi_Db*)data;
    int rc = JSI_OK;
    switch (spec->offset) {
        case 1:
            if (!isSet)
                *s = (Jsi_Wide)db->forceInt;
            else {
                db->forceInt = *s;
                if (db->forceInt != *s)
                    rc = JSI_ERROR;
            }
            break;
        default:
            Jsi_LogError("invalid index");
            return JSI_ERROR;
    }
    if (rc != JSI_OK)
        Jsi_LogError("invalid value");
    return rc;
}

#endif

void dbTypeNameHashInit(Jsi_Db *jdb) {
    Jsi_Interp *interp = jdb->interp;
    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    Jsi_HashSet(hPtr, (void*)"blob", (void*)JSI_OPTION_STRBUF);
    Jsi_HashSet(hPtr, (void*)"string", (void*)JSI_OPTION_STRING);
    Jsi_HashSet(hPtr, (void*)"double", (void*)JSI_OPTION_DOUBLE);
    Jsi_HashSet(hPtr, (void*)"integer", (void*)JSI_OPTION_WIDE);
    Jsi_HashSet(hPtr, (void*)"bool", (void*)JSI_OPTION_BOOL);
    Jsi_HashSet(hPtr, (void*)"date", (void*)JSI_OPTION_DATE);
    Jsi_HashSet(hPtr, (void*)"time", (void*)JSI_OPTION_TIME);
    Jsi_HashSet(hPtr, (void*)"timestamp", (void*)JSI_OPTION_TIMESTAMP);
    Jsi_HashSet(hPtr, (void*)"datetime", (void*)JSI_OPTION_DATETIME);
}

#define SQLITE_OMIT_INCRBLOB

// Return 1 if ok, else return 0 and set erc to -1 or -2 for timeout.
static int dbExecCmd(Jsi_Db *jdb, const char *zQuery, int *erc)
{
    int rc = _SQL_LITE_N_(_exec)(jdb->db, zQuery, 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
    );
    if (rc == _SQLITEN_(BUSY)) {
        if (erc) *erc = -2;
    } else if (rc != SQLITE_OK) {
        if (erc) *erc = -1;
    } else
        return 1;
    return 0;
}

static void dbEvalRowInfo(
    DbEvalContext *p,               /* Evaluation context */
    int *pnCol,                     /* OUT: Number of column names */
    char ***papColName,           /* OUT: Array of column names */
    int **papColType
) {
    /* Compute column names */
    // Jsi_Interp *interp = p->jdb->interp;

    if( 0==p->apColName ) {
        _SQL_LITE_N_(_stmt) *pStmt = p->pPreStmt->pStmt;
        int i;                        /* Iterator variable */
        int nCol;                     /* Number of columns returned by pStmt */
        char **apColName = 0;      /* Array of column names */
        int *apColType = 0;
        const char *zColName;         /* Column name */
        int numRid = 0;               /* Number of times rowid seen. */

        p->nCol = nCol = _SQL_LITE_N_(_column_count)(pStmt);
        if( nCol>0 && (papColName || p->pArray) ) {
            int cnLen = sizeof(char*)*nCol, cnStart = cnLen;
            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)
                cnLen += Jsi_Strlen(_SQL_LITE_N_(_column_name)(pStmt,i))+1;
            if (cnLen>=sizeof(p->staticColNames)) {
                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );
                cnStart = 0;
            } else {
                apColName = (char**)p->staticColNames;
            }
            if (papColType) {
                if (nCol < SQL_MAX_STATIC_TYPES)
                    apColType = p->staticColTypes;
                else
                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));
            }
            for(i=0; i<nCol; i++) {
                zColName = _SQL_LITE_N_(_column_name)(pStmt,i);
                if (cnStart==0)
                    apColName[i] = Jsi_Strdup(zColName);
                else {
                    apColName[i] = p->staticColNames+cnStart;
                    Jsi_Strcpy(apColName[i], zColName);
                    cnStart += Jsi_Strlen(zColName)+1;
                }
                if (apColType)
                    apColType[i] = _SQL_LITE_N_(_column_type)(pStmt,i);
                /* Check if rowid appears first, and more than once. */
                if ((i == 0 || numRid>0) &&
                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,"rowid") == 0)) {
                    numRid++;
                }
            }
            /* Change first rowid to oid. */
            if (numRid > 1) {
                if (apColName != (char**)p->staticColNames) {
                    Jsi_Free(apColName[0]);
                    apColName[0] = Jsi_Strdup("oid");
                } else {
                    Jsi_Strcpy(apColName[0], "oid");
                }
            }
            p->apColName = apColName;
            p->apColType = apColType;
        }
    }
    if( papColName ) {
        *papColName = p->apColName;
    }
    if( papColType ) {
        *papColType = p->apColType;
    }
    if( pnCol ) {
        *pnCol = p->nCol;
    }
}

#ifndef JSI_LITE_ONLY
static int dbPrepareAndBind( Jsi_Db *jdb, char const *zIn, char const **pzOut,  SqlPreparedStmt **ppPreStmt );
#endif
static void dbReleaseColumnNames(DbEvalContext *p);
static void dbReleaseStmt( Jsi_Db *jdb, SqlPreparedStmt *pPreStmt, int discard );


/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */
static int dbEvalStepSub(DbEvalContext *p, int release, int *erc) {
    int rcs;
    Jsi_Db *jdb = p->jdb;
    Jsi_Interp *interp = jdb->interp;
    JSI_NOTUSED(interp);
    SqlPreparedStmt *pPreStmt = p->pPreStmt;
    SQLSIGASSERT(pPreStmt, STMT);
    _SQL_LITE_N_(_stmt) *pStmt = pPreStmt->pStmt;

    if (jdb->debug & TMODE_STEP)
        JSI_DBQUERY_PRINTF( "DEBUG: step: %s\n", pPreStmt->zSql);
    rcs = _SQL_LITE_N_(_step)(pStmt);
    if( rcs==_SQLITEN_(BUSY) ) {
        if (erc) *erc = -2;
        return JSI_ERROR;
    }
    if( rcs==_SQLITEN_(ROW) ) {
        return JSI_OK;
    }
    if( p->pArray ) {
        dbEvalRowInfo(p, 0, 0, 0);
    }
    rcs = _SQL_LITE_N_(_reset)(pStmt);

    jdb->numStep = _SQL_LITE_N_(_stmt_status)(pStmt,_SQLITEN_(STMTSTATUS_FULLSCAN_STEP),1);
    jdb->numSort = _SQL_LITE_N_(_stmt_status)(pStmt,_SQLITEN_(STMTSTATUS_SORT),1);
    if (release==0 && rcs==SQLITE_OK)
        return JSI_BREAK;
    dbReleaseColumnNames(p);
    p->pPreStmt = 0;

    if( rcs!=SQLITE_OK ) {
        /* If a run-time error occurs, report the error and stop reading
        ** the SQL.  */
        Jsi_LogError("%s", _SQL_LITE_N_(_errmsg)(jdb->db));
        dbReleaseStmt(jdb, pPreStmt, 1);
        return JSI_ERROR;
    } else {
        dbReleaseStmt(jdb, pPreStmt, p->nocache);
    }
    return JSI_BREAK;
}

static int dbEvalInit(
    Jsi_Interp *interp,
    DbEvalContext *p,               /* Pointer to structure to initialize */
    Jsi_Db *jdb,                  /* Database handle */
    const char* zSql,                /* Value containing SQL script */
    Jsi_DString *dStr,
    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */
    Jsi_Obj *pValVar                  /* Name element in array for list. */
) {
    p->dSql = dStr;
    p->zSql = Jsi_DSAppend(p->dSql, zSql?zSql:"", NULL);
    p->jdb = jdb;
    return JSI_OK;
}

static void dbPrepStmtFree( Jsi_Db *jdb, SqlPreparedStmt *prep)
{
    if (prep->deleting)
        return;
    prep->deleting = 1;
    if (prep->pStmt)
        _SQL_LITE_N_(_finalize)( prep->pStmt );
    if (prep->entry) {
        Jsi_HashEntry *hPtr = prep->entry;
        prep->entry = NULL;
        Jsi_HashEntryDelete(hPtr);
    }
    if (prep->elPtr)
        Jsi_ListEntryDelete(prep->elPtr);
    Jsi_Free( (char*)prep );
    jdb->numStmts--;
}

/*
** Finalize and free a list of prepared statements
*/

static void dbPrepStmtLimit( Jsi_Db *jdb)
{
    while(jdb->numStmts>jdb->maxStmts ) {
        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);
        dbPrepStmtFree(jdb, (SqlPreparedStmt*)Jsi_ListEntryGetValue(l));
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
    }
}


static void dbStmtFreeProc(Jsi_List *list, Jsi_ListEntry *l) {
    Jsi_Db *jdb = (Jsi_Db*)Jsi_ListGetAttr(list, NULL);
    if (!l)
        Jsi_Free(list);
    else {
        SqlPreparedStmt *prep = (SqlPreparedStmt *)Jsi_ListEntryGetValue(l);
        prep->elPtr = NULL;
        dbPrepStmtFree(jdb, prep);
        Jsi_Free(l);
    }
}

#ifndef JSI_LITE_ONLY

/*
** Finalize and free a list of prepared statements
*/
static void dbFlushStmtCache( Jsi_Db *jdb ) {
    Jsi_ListClear(jdb->stmtCache);
    jdb->numStmts = 0;
}

#endif

/*
** Release a statement reference obtained by calling dbPrepareAndBind().
** There should be exactly one call to this function for each call to
** dbPrepareAndBind().
**
** If the discard parameter is non-zero, then the statement is deleted
** immediately. Otherwise it is added to the LRU list and may be returned
** by a subsequent call to dbPrepareAndBind().
*/
static void dbReleaseStmt(
    Jsi_Db *jdb,                  /* Database handle */
    SqlPreparedStmt *pPreStmt,      /* Prepared statement handle to release */
    int discard                     /* True to delete (not cache) the pPreStmt */
) {
    //int i;
    //Jsi_Interp *interp = jdb->interp;

    /* Free the bound string and blob parameters */
    /*for(i=0; i<pPreStmt->nParm; i++) {
        Jsi_DecrRefCount(interp, pPreStmt->apParm[i]);
    }*/
    //pPreStmt->nParm = 0;

    if( jdb->maxStmts<=0 || discard ) {
        /* If the cache is turned off, deallocated the statement */
        dbPrepStmtFree(jdb, pPreStmt);
    } else {
        /* Add the prepared statement to the beginning of the cache list, then limit. */
        if (!pPreStmt->elPtr)
            pPreStmt->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, pPreStmt);
        else
            Jsi_ListPushFront(jdb->stmtCache, pPreStmt->elPtr);
        dbPrepStmtLimit(jdb);
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
    }
}

/*
** Release any cache of column names currently held as part of
** the DbEvalContext structure passed as the first argument.
*/
static void dbReleaseColumnNames(DbEvalContext *p) {
    //Jsi_Interp *interp = p->jdb->interp;

    if( p->apColName && p->apColName != (char**)p->staticColNames) {
        int i;
        for(i=0; i<p->nCol; i++) {
            Jsi_Free(p->apColName[i]);
        }
        Jsi_Free((char *)p->apColName);
    }
    if( p->apColType && p->apColType != p->staticColTypes) {
        Jsi_Free((char *)p->apColType);
    }
    p->apColName = NULL;
    p->apColType = NULL;
    p->nCol = 0;
}

sqlite_uint64 dbLastInsertRowid(Jsi_Db* jdb)
{
#ifdef USE_SQLITE_V4
#warning "unimplemented last insert rowid"
    return 0;
#else
    return _SQL_LITE_N_(_last_insert_rowid)(jdb->db);
#endif
}

#ifdef USE_SQLITE_V4
static int sqlite4_prepare_v2(sqlite4 *db, const char *zSql, int nByte, sqlite4_stmt **ppStmt, const char **pzTail ) {
    int nUsed, rc;
    rc = sqlite4_prepare(db, zSql, nByte, ppStmt, &nUsed);
    if (rc == SQLITE4_OK)
        *pzTail = (zSql+nUsed);
    return rc;
}

#define sqlite4_open_v2(filename, ppDb, flags, zVfs) sqlite4_open(db->pEnv, filename, ppDb, flags, NULL) 

#define sqlite4_sql sqlite4_stmt_sql

#endif

/*
** Search the cache for a prepared-statement object that implements the
** first SQL statement in the buffer pointed to by parameter zIn. If
** no such prepared-statement can be found, allocate and prepare a new
** one. In either case, bind the current values of the relevant Jsi
** variables to any $var, :var or @var variables in the statement. Before
** returning, set *ppPreStmt to point to the prepared-statement object.
**
** Output parameter *pzOut is set to point to the next SQL statement in
** buffer zIn, or to the '\0' byte at the end of zIn if there is no
** next statement.
**
** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned
** and an error message loaded into interpreter jdb->interp.
*/
static int dbPrepareStmt(
    Jsi_Db *jdb,                  /* Database object */
    char const *zIn,                /* SQL to compile */
    char const **pzOut,             /* OUT: Pointer to next SQL statement */
    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */
) {
    const char *zSql = zIn;         /* Pointer to first SQL statement in zIn */
    _SQL_LITE_N_(_stmt) *pStmt;            /* Prepared statement object */
    SqlPreparedStmt *pPreStmt = 0;  /* Pointer to cached statement */
   // int nSql;                       /* Length of zSql in bytes */
    //int nVar;                       /* Number of variables in statement */
    //int iParm = 0;                  /* Next free entry in apParm */
    int rc = JSI_OK;
    Jsi_Interp *interp = jdb->interp;
    JSI_NOTUSED(interp);

    *ppPreStmt = 0;

    /* Trim spaces from the start of zSql and calculate the remaining length. */
    while( isspace(zSql[0]) ) {
        zSql++;
    }
    //nSql = Jsi_Strlen(zSql);
    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);
    if (entry && ((pPreStmt = (SqlPreparedStmt*)Jsi_HashValueGet(entry)))) {
        
        if (jdb->debug & TMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare cache-hit: %s\n", zSql);
        pStmt = pPreStmt->pStmt;
        *pzOut = &zSql[pPreStmt->nSql];

        /* When a prepared statement is found, unlink it from the
        ** cache list.  It will later be added back to the beginning
        ** of the cache list in order to implement LRU replacement.
        */
        Jsi_ListRemove(jdb->stmtCache, pPreStmt->elPtr);
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);

    }

    /* If no prepared statement was found. Compile the SQL text. Also allocate
    ** a new SqlPreparedStmt structure.  */
    if( pPreStmt==0 ) {
        int nByte;

        if( SQLITE_OK!=_SQL_LITE_N_(_prepare_v2)(jdb->db, zSql, -1, &pStmt, pzOut) )
        {
            Jsi_LogError("PREPARE: %s", _SQL_LITE_N_(_errmsg)(jdb->db));
            return JSI_ERROR;
        }
        if( pStmt==0 ) {
            if( SQLITE_OK!=_SQL_LITE_N_(_errcode)(jdb->db) ) {
                /* A compile-time error in the statement. */
                Jsi_LogError("PREP: %s", _SQL_LITE_N_(_errmsg)(jdb->db));
                return JSI_ERROR;
            } else {
                /* The statement was a no-op.  Continue to the next statement
                ** in the SQL string.
                */
                return JSI_OK;
            }
        }

        if (jdb->debug & TMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare new: %s\n", zSql);
        assert( pPreStmt==0 );
        //nVar = _SQL_LITE_N_(_bind_parameter_count)(pStmt);
        jdb->numStmts++;
        nByte = sizeof(SqlPreparedStmt); // + nVar*sizeof(Jsi_Obj *);
        pPreStmt = (SqlPreparedStmt*)Jsi_Calloc(1, nByte);
        pPreStmt->sig = SQLITE_SIG_STMT;

        pPreStmt->pStmt = pStmt;
        pPreStmt->nSql = (*pzOut - zSql);
        pPreStmt->zSql = _SQL_LITE_N_(_sql)(pStmt);
        int isNew = 0;
        pPreStmt->entry = Jsi_HashEntryNew(jdb->stmtHash, zSql, &isNew);
        if (!isNew)
            JSI_DBQUERY_PRINTF( "sqlite dup stmt entry");
        Jsi_HashValueSet(pPreStmt->entry, pPreStmt);
            
        //pPreStmt->apParm = (Jsi_Value **)&pPreStmt[1];
    }
    assert( pPreStmt );
    assert( Jsi_Strlen(pPreStmt->zSql)==pPreStmt->nSql );
    assert( 0==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql) );
    *ppPreStmt = pPreStmt;
    //pPreStmt->nParm = iParm; 
    return rc;
}


#ifndef JSI_LITE_ONLY

/*
** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is
** returned, then an error message is stored in the interpreter before
** returning.
**
** A return value of JSI_OK means there is a row of data available. The
** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This
** is analogous to a return of _SQLITEN_(ROW) from _SQL_LITE_N_(_step)(). If JSI_BREAK
** is returned, then the SQL script has finished executing and there are
** no further rows available. This is similar to _SQLITEN_(DONE).
*/
static int dbEvalStep(DbEvalContext *p) {
    while( p->zSql[0] || p->pPreStmt ) {
        int rc;
        if( p->pPreStmt==0 ) {
            rc = dbPrepareAndBind(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);
            if( rc!=JSI_OK ) return rc;
        }
        rc = dbEvalStepSub(p, 1, NULL);
        if (rc != JSI_BREAK)
            return rc;
    }
    
    /* Finished */
    return JSI_BREAK;
}

static int dbBindStmt(Jsi_Db *jdb, SqlPreparedStmt *prep)
{
    _SQL_LITE_N_(_stmt) *pStmt = prep->pStmt;    /* Object used to cache statement */
    Jsi_Interp *interp = jdb->interp;
    int i, rc = JSI_OK, btype = 0, n;
    Jsi_Number r;
    Jsi_Wide wv;
 
    Jsi_Value *pv = NULL, *apv = NULL;
    int nVar = _SQL_LITE_N_(_bind_parameter_count)(pStmt);
    char tname[50];
    
   /* Bind values to parameters that begin with @, $, :, or ? */
    for(i=1; i<=nVar; i++) {
        tname[0] = 0;
        int isInt = 0, isBlob = 0;
        const char *zVar = _SQL_LITE_N_(_bind_parameter_name)(pStmt, i);
        if (zVar == NULL) {
            if (!jdb->optPtr || (!jdb->optPtr->varName[0] && !jdb->optPtr->values)) {
                Jsi_LogError("? bind without varName/values for param %d", i);
                return JSI_ERROR;
            }
            if (!apv) {
                if (!(apv = jdb->optPtr->values))
                    apv = Jsi_NameLookup(interp, jdb->optPtr->varName);
            }
            if (apv == NULL || !Jsi_ValueIsArray(interp, apv)) {
                Jsi_LogError("can not find array var: %s", jdb->optPtr->varName);
                return JSI_ERROR;
            }
            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) {
                Jsi_LogError("array element %d missing", nVar);
                return JSI_ERROR;
            }
        }
        else if((zVar[0]=='$' || zVar[0]==':' || zVar[0]=='@') ) {
            int zvLen = strlen(zVar);
            char *zcp;
            if (zVar[0] =='$' && ((zcp = strchr(zVar,'('))) && zVar[zvLen-1] == ')')
            {
                Jsi_DString vStr;
                Jsi_DSInit(&vStr);
                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));
                int slen = Jsi_Strlen(zcp);
                const char *ttp;
                if ((ttp = Jsi_Strchr(zVar,':'))) { // Extract bind-type.
                    Jsi_DString tStr = {};
                    int tlen = Jsi_Strlen(ttp+1);
                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);
                    if (!jdb->typeNameHash)
                        dbTypeNameHashInit(jdb);
                    Jsi_HashEntry *htPtr = Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr));
                    int rc = ( htPtr != NULL);
                    if (!htPtr) {
                        Jsi_DString eStr = {};
                        Jsi_HashSearch search;
                        Jsi_Interp *interp = jdb->interp;
                        int n = 0;
                        Jsi_HashEntry *hPtr;
                        for (hPtr = Jsi_HashEntryFirst(jdb->typeNameHash, &search);
                            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
                            const char *key = (char*)Jsi_HashKeyGet(hPtr);
                            Jsi_DSAppend(&eStr, (n++?", ":""), key, NULL);
                        }
                        Jsi_LogWarn("bind type \"%s\" is not one of: %s", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));
                        Jsi_DSFree(&eStr);
                    }
                    Jsi_Strcpy(tname, Jsi_DSValue(&tStr));
                    Jsi_DSFree(&tStr);
                    if (!rc)
                        return JSI_ERROR;

                    btype = (int)Jsi_HashValueGet(htPtr);
                    Jsi_DSFree(&tStr);
                    slen -= tlen;
                }

                if (isdigit(zcp[1])) {
                    Jsi_DSAppendLen(&vStr, "[", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                    Jsi_DSAppendLen(&vStr, "]", 1);
                } else {
                    if (zcp[1] != '[')
                        Jsi_DSAppendLen(&vStr, ".", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                }
                pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));
                Jsi_DSFree(&vStr);
            } else
                pv = Jsi_VarLookup(interp, &zVar[1]);
        } else {
            Jsi_LogError("can not find bind var %s", zVar);
            return JSI_ERROR;
        }
            
        if(!pv ) {
            if (!jdb->bindWarn) {
                Jsi_LogError("unknown bind param: %s", zVar);
                rc = JSI_ERROR;
                break;
            } else
                Jsi_LogWarn("unknown bind param: %s", zVar);
        } else {
            int match = 1, cast = (jdb->optPtr->typeCheck==dbTypeCheck_Cast);
            if (btype && !Jsi_ValueIsUndef(interp, pv)) {
                switch (btype) {
                    case JSI_OPTION_STRBUF:
                        isBlob = 1;
                    case JSI_OPTION_STRING:
                        if (cast)
                            Jsi_ValueToString(interp, pv, &n);
                        else
                            match = Jsi_ValueIsString(interp, pv);
                        break;
                    case JSI_OPTION_DOUBLE:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    case JSI_OPTION_TIMESTAMP:
                    case JSI_OPTION_WIDE:
                        isInt = 1;
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    case JSI_OPTION_BOOL:
                        if (cast)
                            Jsi_ValueToBool(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    case JSI_OPTION_TIME:
                    case JSI_OPTION_DATE:
                    case JSI_OPTION_DATETIME:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv); //TODO: do something more for dates?
                        else
                            match = Jsi_ValueIsNumber(interp, pv);
                        break;
                    default:
                        Jsi_LogBug("Unhandled bind type: %s = %d", tname, btype);
                }
                if (cast == 0 && match == 0) {
                    int ltyp = (jdb->optPtr->typeCheck==dbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);
                    Jsi_LogMsg(interp, ltyp, "bind param \"%s\" type is not \"%s\"", zVar, tname);
                    if (ltyp == JSI_LOG_ERROR)
                        return JSI_ERROR;
                }
            }
            if (Jsi_ValueIsBoolean(interp, pv)) {
                Jsi_GetBoolFromValue(interp, pv, &n);
                _SQL_LITE_N_(_bind_int)(pStmt, i, n);
            } else if (Jsi_ValueIsNumber(interp, pv)) {
                Jsi_GetNumberFromValue(interp, pv, &r);
                wv = (Jsi_Wide)r;
                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0))
                    _SQL_LITE_N_(_bind_int64)(pStmt, i,wv);
                else
                    _SQL_LITE_N_(_bind_double)(pStmt, i,(double)r);
            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->queryOpts.mapundef)) {
                _SQL_LITE_N_(_bind_null)(pStmt, i);
            } else if (Jsi_ValueIsString(interp, pv)) {
                const char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);
                if (!sstr) sstr = "";
                if (isBlob)
                    _SQL_LITE_N_(_bind_blob)(pStmt, i, (char *)sstr, n, _SQLITEN_(TRANSIENT) _SQLBIND_END_);
                else
                    _SQL_LITE_N_(_bind_text)(pStmt, i, (char *)sstr, n, _SQLITEN_(TRANSIENT) _SQLBIND_END_);
            } else {
                if (!jdb->bindWarn) {
                    Jsi_LogError("bind param must be string/number/bool/null: %s", zVar);
                    rc = JSI_ERROR;
                    break;
                } else
                    Jsi_LogWarn("bind param must be string/number/bool/null: %s", zVar);
                _SQL_LITE_N_(_bind_null)(pStmt, i);
            }
        }
    }
    return rc;
}

static int dbPrepareAndBind(
    Jsi_Db *jdb,                  /* Database object */
    char const *zIn,                /* SQL to compile */
    char const **pzOut,             /* OUT: Pointer to next SQL statement */
    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */
) {
    if (dbPrepareStmt(jdb, zIn, pzOut, ppPreStmt) != JSI_OK)
        return JSI_ERROR;
    return dbBindStmt(jdb, *ppPreStmt);
}
#endif

/*
** Free all resources currently held by the DbEvalContext structure passed
** as the first argument. There should be exactly one call to this function
** for each call to dbEvalInit(interp,).
*/
static void dbEvalFinalize(DbEvalContext *p) {
//  Jsi_Interp *interp = p->jdb->interp;

    if( p->pPreStmt ) {
        _SQL_LITE_N_(_reset)(p->pPreStmt->pStmt);
        dbReleaseStmt(p->jdb, p->pPreStmt, p->nocache);
        p->pPreStmt = 0;
    }
    Jsi_DSFree(p->dSql);
    dbReleaseColumnNames(p);
}

static void DbClose(_SQL_LITE_N_() *db) {
#ifdef USE_SQLITE_V4
        _SQL_LITE_N_(_close)(db, 0);
#else
        _SQL_LITE_N_(_close)(db);
#endif
}

#ifndef JSI_LITE_ONLY

static int sqliteObjFree(Jsi_Interp *interp, void *data);
static int  sqliteObjEqual(void *data1, void *data2);
static int  sqliteObjIsTrue(void *data);

static Jsi_UserObjReg sqliteobject = {
    .name   = "Sqlite",
    .spec   = sqliteCmds,
    .freefun= sqliteObjFree,
    .istrue = sqliteObjIsTrue,
    .isequ  = sqliteObjEqual
};

static int dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value)
{
    if (!Jsi_ValueIsArray(interp, value)) {
        Jsi_LogError("expected array of numbers");
        return JSI_ERROR;
    }
    int i, argc = Jsi_ValueGetLength(interp, value);
    for (i=0; i<argc; i++) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);
        if (!Jsi_ValueIsNumber(interp, v)) {
            Jsi_LogError("expected array of numbers");
            return JSI_ERROR;
        }
    }
    return JSI_OK;
}


/*
** JSI calls this procedure when an _SQL_LITE_N_() database command is
** deleted.
*/
static void dbDeleteCmd(Jsi_Db *jdb)
{
    Jsi_Interp *interp = jdb->interp;
    if (jdb->debug & TMODE_DELETE)
        JSI_DBQUERY_PRINTF( "DEBUG: delete\n");
    dbFlushStmtCache(jdb);
    if (jdb->stmtHash)
        Jsi_HashDelete(jdb->stmtHash);
    //closeIncrblobChannels(jdb);
    if (jdb->db) {
        DbClose(jdb->db);
    }
    while( jdb->pFunc ) {
        SqlFunc *pFunc = jdb->pFunc;
        jdb->pFunc = pFunc->pNext;
        Jsi_DSFree(&pFunc->dScript);
        Jsi_DecrRefCount(interp, pFunc->tocall);
        Jsi_Free((char*)pFunc);
    }
    while( jdb->pCollate ) {
        SqlCollate *pCollate = jdb->pCollate;
        jdb->pCollate = pCollate->pNext;
        Jsi_Free((char*)pCollate);
    }
    if( jdb->zBusy ) {
        Jsi_DecrRefCount(interp, jdb->zBusy);
    }
    if( jdb->zTrace ) {
        Jsi_DecrRefCount(interp, jdb->zTrace);
    }
    if( jdb->zProfile ) {
        Jsi_DecrRefCount(interp, jdb->zProfile);
    }
    if( jdb->zAuth ) {
        Jsi_DecrRefCount(interp, jdb->zAuth);
    }
    if( jdb->zNull ) {
        Jsi_Free(jdb->zNull);
    }
    if( jdb->pUpdateHook ) {
        Jsi_DecrRefCount(interp, jdb->pUpdateHook);
    }
    if( jdb->pRollbackHook ) {
        Jsi_DecrRefCount(interp, jdb->pRollbackHook);
    }
    if( jdb->pCollateNeeded ) {
        Jsi_DecrRefCount(interp, jdb->pCollateNeeded);
    }
    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);
    if (jdb->stmtCache)
        Jsi_ListDelete(jdb->stmtCache);
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

static int dbGetIntBool(Jsi_Interp *interp, Jsi_Value* v)
{
    if (Jsi_ValueIsNumber(interp, v)) {
        double d;
        Jsi_ValueGetNumber(interp, v, &d);
        return (int)d;
    }
    if (Jsi_ValueIsBoolean(interp, v)) {
        Jsi_Bool n;
        Jsi_ValueGetBoolean(interp, v, &n);
        return n;
    }
    return 0;
}


/*
** This routine is called when a database file is locked while trying
** to execute SQL.
*/
static int dbBusyHandler(void *cd, int nTries) {
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *vpargs, *items[3] = {}, *ret;
    Jsi_Interp *interp = jdb->interp;

    items[0] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nTries);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zBusy, vpargs, &ret, NULL);
    if( JSI_OK!=rc ) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(interp, ret);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}

/*
** This routine is invoked as the 'progress callback' for the database.
*/
static int dbProgressHandler(void *cd) {
    int rc = 0;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *ret = Jsi_ValueNew1(interp);
    assert(jdb->zProgress);
    if( JSI_OK!=Jsi_FunctionInvoke(jdb->interp, jdb->zProgress, NULL, &ret, NULL) ) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(interp, ret);
    Jsi_DecrRefCount(interp, ret);

    return rc;
}
#endif

#ifndef SQLITE_OMIT_TRACE
/*
** This routine is called by the SQLite trace handler whenever a new
** block of SQL is executed.  The JSI script in jdb->zTrace is executed.
*/
static void dbTraceHandler(void *cd, const char *zSql)
{
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *vpargs, *items[2] = {}, *ret;
    Jsi_Interp *interp = jdb->interp;
    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zSql);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zTrace, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;
}
#endif

#ifndef SQLITEN_OMIT_TRACE
/*
** This routine is called by the SQLite profile handler after a statement
** SQL has executed.  The JSI script in jdb->zProfile is evaluated.
*/
static void dbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm) {
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *vpargs, *items[3] = {}, *ret;

    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zSql);
    items[1] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)tm);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zProfile, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;
}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS
/*
** This routine is called when a transaction is committed.  The
** JSI script in jdb->zCommit is executed.  If it returns non-zero or
** if it throws an exception, the transaction is rolled back instead
** of being committed.
*/
static int dbCommitHandler(void *cd) {
    int rc = 0;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *ret = Jsi_ValueNew1(jdb->interp);

    assert(jdb->zCommit);
    if( JSI_OK!=Jsi_FunctionInvoke(jdb->interp, jdb->zCommit, NULL, &ret, NULL) ) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(jdb->interp, ret);
    Jsi_DecrRefCount(jdb->interp, ret);

    return rc;
}

/*
** This procedure handles wal_hook callbacks.
*/
static int dbWalHandler( void *cd, _SQL_LITE_N_() *db, const char *zDb, int nEntry ){
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *vpargs, *items[3] = {}, *ret;

    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zDb);
    items[1] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nEntry);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->pWalHook, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (rc != JSI_OK) {
        jdb->errorCnt++;
        rc = 1;
    } else
        rc = dbGetIntBool(jdb->interp, ret);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}
 
static void dbRollbackHandler(void *cd) {
    Jsi_Db *jdb = (Jsi_Db*)cd;
    assert(jdb->pRollbackHook);
    if( JSI_OK!=Jsi_FunctionInvoke(jdb->interp, jdb->pRollbackHook, NULL, NULL, NULL) ) {
        jdb->errorCnt++;
    }
}
#endif

#if defined(SQLITE_TEST) && defined(SQLITE_ENABLE_UNLOCK_NOTIFY)
static void dbSetTestUnlockNotifyVars(Jsi_Interp *interp, int iArg, int nArg) {
    char zBuf[64];
    sprintf(zBuf, "%d", iArg);
    Jsi_SetVar(interp, "sqlite_unlock_notify_arg", zBuf, JSI_GLOBAL_ONLY);
    sprintf(zBuf, "%d", nArg);
    Jsi_SetVar(interp, "sqlite_unlock_notify_argcount", zBuf, JSI_GLOBAL_ONLY);
}
#else
# define dbSetTestUnlockNotifyVars(x,y,z)
#endif

#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
//TODO: unimpl
static void dbUnlockNotify(void **apArg, int nArg) {
    int i;
    for(i=0; i<nArg; i++) {
        const int flags = (JSI_EVAL_GLOBAL);
        Jsi_Db *jdb = (Jsi_Db *)apArg[i];
        dbSetTestUnlockNotifyVars(jdb->interp, i, nArg);
        assert( jdb->pUnlockNotify);
        Jsi_EvalObjEx(jdb->interp, jdb->pUnlockNotify, flags);
        Jsi_ObjDecrRefCount(jdb->pUnlockNotify);
        jdb->pUnlockNotify = 0;
    }
}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS
static void dbUpdateHandler(
    void *p,
    int op,
    const char *zDb,
    const char *zTbl,
    sqlite_int64 rowid
) {
    Jsi_Db *jdb = (Jsi_Db *)p;
    Jsi_Interp *interp = jdb->interp;
    int rc, i = 0;
    Jsi_Value *vpargs, *items[5] = {}, *ret;

    assert( jdb->pUpdateHook );
    assert( op==_SQLITEN_(INSERT) || op==_SQLITEN_(UPDATE) || op==_SQLITEN_(DELETE) );
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, (op==_SQLITEN_(INSERT))?"INSERT":(op==_SQLITEN_(UPDATE))?"UPDATE":"DELETE");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zDb);
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zTbl);
    items[i++] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)rowid);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->pUpdateHook, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;
}
#endif

#ifndef OMIT_SQLITE_COLLATION

static void dbCollateNeeded(
    void *cd,
    _SQL_LITE_N_() *db,
    int enc,
    const char *zName
) {
    int rc;
    Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *vpargs, *items[2], *ret;
    items[0] = Jsi_ValueMakeStringDup(interp, NULL, zName);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->pCollateNeeded, vpargs,& ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    if (rc != JSI_OK)
        jdb->errorCnt++;

}

/*
** This routine is called to evaluate an SQL collation function implemented
** using JSI script.
*/
static int dbSqlCollate(
    void *pCtx,
    int nA,
    const void *zA,
    int nB,
    const void *zB
) {
    SqlCollate *p = (SqlCollate *)pCtx;
    Jsi_Interp *interp = p->interp;

    int rc;
    //Jsi_Db *jdb = (Jsi_Db*)cd;
    Jsi_Value *vpargs, *items[3], *ret;

    items[0] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zA);
    items[1] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zB);
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, p->zScript, vpargs, &ret, NULL);
    if( JSI_OK!=rc ) {
        //jdb->errorCnt++;
        rc = 0;
    } else
        rc = dbGetIntBool(interp, ret);
    Jsi_DecrRefCount(interp, vpargs);
    Jsi_DecrRefCount(interp, ret);
    return rc;
}
#endif

static Jsi_Value* dbGetValueGet(Jsi_Interp *interp, _SQL_LITE_N_(_value) *pIn)
{
    Jsi_Value *v = Jsi_ValueNew(interp);
    switch (_SQL_LITE_N_(_value_type)(pIn)) {
    case _SQLITEN_(BLOB): {
        int bytes;
#ifdef USE_SQLITE_V4
        const char *zBlob = _SQL_LITE_N_(_value_blob)(pIn, &bytes);
#else
        bytes = _SQL_LITE_N_(_value_bytes)(pIn);
        const char *zBlob = (char*) _SQL_LITE_N_(_value_blob)(pIn);
#endif
        if(!zBlob ) {
            return Jsi_ValueMakeNull(interp, &v);
        }
        return Jsi_ValueMakeBlob(interp, &v, (unsigned char*)zBlob, bytes);
    }
    case _SQLITEN_(INTEGER): {
        sqlite_int64 n = _SQL_LITE_N_(_value_int64)(pIn);
        if( n>=-2147483647 && n<=2147483647 ) {
            return Jsi_ValueMakeNumber(interp, &v, n);
        } else {
            return Jsi_ValueMakeNumber(interp, &v, n);
        }
    }
    case _SQLITEN_(FLOAT): {
        return Jsi_ValueMakeNumber(interp, &v, (Jsi_Number)_SQL_LITE_N_(_value_double)(pIn));
    }
    case _SQLITEN_(NULL): {
        return Jsi_ValueMakeNull(interp, &v);
    }
    default:
#ifdef USE_SQLITE_V4
        return Jsi_ValueMakeStringDup(interp, &v, (char *)_SQL_LITE_N_(_value_text)(pIn, 0));
#else
        return Jsi_ValueMakeStringDup(interp, &v, (char *)_SQL_LITE_N_(_value_text)(pIn));
#endif
    }
    return v;
}

static void jsiSqlFunc(_SQL_LITE_N_(_context) *context, int argc, _SQL_LITE_N_(_value)**argv) {
#ifdef USE_SQLITE_V4
    SqlFunc *p = (SqlFunc*)_SQL_LITE_N_(_context_appdata)(context);
#else
    SqlFunc *p = (SqlFunc*)_SQL_LITE_N_(_user_data)(context);
#endif
    int i;
    int rc;
    Jsi_Interp *interp = p->interp;
    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;
    if (argc>100)
        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));

    for(i=0; i<argc; i++) {
        items[i] = dbGetValueGet(interp, argv[i]);
    }
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew1(interp);
    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);
    if (items != itemsStatic)
        Jsi_Free(items);

    if( rc != JSI_OK) {
        char buf[250];
        snprintf(buf, sizeof(buf), "error in function: %.200s", p->zName);
        _SQL_LITE_N_(_result_error)(context, buf, -1);

    } else if (Jsi_ValueIsBoolean(interp, ret)) {
        Jsi_GetBoolFromValue(interp, ret, &i);
        _SQL_LITE_N_(_result_int)(context, i);
    } else if (Jsi_ValueIsNumber(interp, ret)) {
        Jsi_Number d;
        // if (Jsi_GetIntFromValueBase(interp, ret, &i, 0, JSI_NO_ERRMSG);
        // _SQL_LITE_N_(_result_int64)(context, v);
        Jsi_GetNumberFromValue(interp, ret, &d);
        _SQL_LITE_N_(_result_double)(context, (double)d);
    } else {
        const char * data;
        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {
            //TODO: handle objects???
            data = Jsi_ValueToString(interp, ret, NULL);
            i = Jsi_Strlen(data);
        }
        _SQL_LITE_N_(_result_text)(context, (char *)data, i, _SQLITEN_(TRANSIENT) _SQLBIND_END_);
    }
    Jsi_DecrRefCount(interp, ret);
}

#ifndef SQLITE_OMIT_AUTHORIZATION
/*
** This is the authentication function.  It appends the authentication
** type code and the two arguments to zCmd[] then invokes the result
** on the interpreter.  The reply is examined to determine if the
** authentication fails or succeeds.
*/
static int dbAuthCallback(
    void *pArg,
    int code,
    const char *zArg1,
    const char *zArg2,
    const char *zArg3,
    const char *zArg4
) {
    const char *zCode;
    int rc;
    const char *zReply;
    Jsi_Db *jdb = (Jsi_Db*)pArg;
    Jsi_Interp *interp = jdb->interp;
    if( jdb->disableAuth ) return SQLITE_OK;

    switch( code ) {
    case _SQLITEN_(COPY)              :
        zCode="_SQLITEN_(COPY)";
        break;
    case _SQLITEN_(CREATE_INDEX)      :
        zCode="_SQLITEN_(CREATE_INDEX)";
        break;
    case _SQLITEN_(CREATE_TABLE)      :
        zCode="_SQLITEN_(CREATE_TABLE)";
        break;
    case _SQLITEN_(CREATE_TEMP_INDEX) :
        zCode="_SQLITEN_(CREATE_TEMP_INDEX)";
        break;
    case _SQLITEN_(CREATE_TEMP_TABLE) :
        zCode="_SQLITEN_(CREATE_TEMP_TABLE)";
        break;
    case _SQLITEN_(CREATE_TEMP_TRIGGER):
        zCode="_SQLITEN_(CREATE_TEMP_TRIGGER)";
        break;
    case _SQLITEN_(CREATE_TEMP_VIEW)  :
        zCode="_SQLITEN_(CREATE_TEMP_VIEW)";
        break;
    case _SQLITEN_(CREATE_TRIGGER)    :
        zCode="_SQLITEN_(CREATE_TRIGGER)";
        break;
    case _SQLITEN_(CREATE_VIEW)       :
        zCode="_SQLITEN_(CREATE_VIEW)";
        break;
    case _SQLITEN_(DELETE)            :
        zCode="_SQLITEN_(DELETE)";
        break;
    case _SQLITEN_(DROP_INDEX)        :
        zCode="_SQLITEN_(DROP_INDEX)";
        break;
    case _SQLITEN_(DROP_TABLE)        :
        zCode="_SQLITEN_(DROP_TABLE)";
        break;
    case _SQLITEN_(DROP_TEMP_INDEX)   :
        zCode="_SQLITEN_(DROP_TEMP_INDEX)";
        break;
    case _SQLITEN_(DROP_TEMP_TABLE)   :
        zCode="_SQLITEN_(DROP_TEMP_TABLE)";
        break;
    case _SQLITEN_(DROP_TEMP_TRIGGER) :
        zCode="_SQLITEN_(DROP_TEMP_TRIGGER)";
        break;
    case _SQLITEN_(DROP_TEMP_VIEW)    :
        zCode="_SQLITEN_(DROP_TEMP_VIEW)";
        break;
    case _SQLITEN_(DROP_TRIGGER)      :
        zCode="_SQLITEN_(DROP_TRIGGER)";
        break;
    case _SQLITEN_(DROP_VIEW)         :
        zCode="_SQLITEN_(DROP_VIEW)";
        break;
    case _SQLITEN_(INSERT)            :
        zCode="_SQLITEN_(INSERT)";
        break;
    case _SQLITEN_(PRAGMA)            :
        zCode="_SQLITEN_(PRAGMA)";
        break;
    case _SQLITEN_(READ)              :
        zCode="_SQLITEN_(READ)";
        break;
    case _SQLITEN_(SELECT)            :
        zCode="_SQLITEN_(SELECT)";
        break;
    case _SQLITEN_(TRANSACTION)       :
        zCode="_SQLITEN_(TRANSACTION)";
        break;
    case _SQLITEN_(UPDATE)            :
        zCode="_SQLITEN_(UPDATE)";
        break;
    case _SQLITEN_(ATTACH)            :
        zCode="_SQLITEN_(ATTACH)";
        break;
    case _SQLITEN_(DETACH)            :
        zCode="_SQLITEN_(DETACH)";
        break;
    case _SQLITEN_(ALTER_TABLE)       :
        zCode="_SQLITEN_(ALTER_TABLE)";
        break;
    case _SQLITEN_(REINDEX)           :
        zCode="_SQLITEN_(REINDEX)";
        break;
    case _SQLITEN_(ANALYZE)           :
        zCode="_SQLITEN_(ANALYZE)";
        break;
    case _SQLITEN_(CREATE_VTABLE)     :
        zCode="_SQLITEN_(CREATE_VTABLE)";
        break;
    case _SQLITEN_(DROP_VTABLE)       :
        zCode="_SQLITEN_(DROP_VTABLE)";
        break;
    case _SQLITEN_(FUNCTION)          :
        zCode="_SQLITEN_(FUNCTION)";
        break;
    case _SQLITEN_(SAVEPOINT)         :
        zCode="_SQLITEN_(SAVEPOINT)";
        break;
    default                       :
        zCode="????";
        break;
    }
    int i = 0;
    Jsi_Value *vpargs, *items[6] = {}, *ret;

    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zCode);
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg1 ? zArg1 : "");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg2 ? zArg2 : "");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg3 ? zArg3 : "");
    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg4 ? zArg4 : "");
    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));
    Jsi_IncrRefCount(interp, vpargs);
    ret = Jsi_ValueNew(interp);
    rc = Jsi_FunctionInvoke(interp, jdb->zAuth, vpargs, &ret, NULL);
    Jsi_DecrRefCount(interp, vpargs);

    if (rc == JSI_OK && (zReply = Jsi_ValueGetStringLen(interp, ret, NULL)))
    {
        if( Jsi_Strcmp(zReply,"SQLITE_OK")==0 ) {
            rc = SQLITE_OK;
        } else if( Jsi_Strcmp(zReply,"_SQLITEN_(DENY)")==0 ) {
            rc = _SQLITEN_(DENY);
        } else if( Jsi_Strcmp(zReply,"_SQLITEN_(IGNORE)")==0 ) {
            rc = _SQLITEN_(IGNORE);
        } else {
            rc = 999;
        }
    }
    Jsi_DecrRefCount(interp, ret);
    return rc;
}
#endif /* _SQLITEN_(OMIT_AUTHORIZATION) */

/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** The interface is like "readline" but no command-line editing
** is done.
**
** copied from shell.c from '.import' command
*/
static char *dbLocalGetline(char *zPrompt, Jsi_Channel in) {
    char *zLine;
    int nLine;
    int n;
    int eol;

    nLine = 100;
    zLine = (char*)Jsi_Malloc( nLine );
    if( zLine==0 ) return 0;
    n = 0;
    eol = 0;
    while( !eol ) {
        if( n+100>nLine ) {
            nLine = nLine*2 + 100;
            zLine = (char*)Jsi_Realloc(zLine, nLine);
            if( zLine==0 ) return 0;
        }
        if( Jsi_Gets(in, &zLine[n], nLine - n)==0 ) {
            if( n==0 ) {
                Jsi_Free(zLine);
                return 0;
            }
            zLine[n] = 0;
            eol = 1;
            break;
        }
        while( zLine[n] ) {
            n++;
        }
        if( n>0 && zLine[n-1]=='\n' ) {
            n--;
            zLine[n] = 0;
            eol = 1;
        }
    }
    zLine = (char*)Jsi_Realloc( zLine, n+1 );
    return zLine;
}


/*
** This function is part of the implementation of the command:
**
**   $db transaction [-deferred|-immediate|-exclusive] SCRIPT
**
** It is invoked after evaluating the script SCRIPT to commit or rollback
** the transaction or savepoint opened by the [transaction] command.
*/
static int dbTransPostCmd(
    Jsi_Db *jdb,                       /* Sqlite3Db for $db */
    Jsi_Interp *interp,                  /* Jsi interpreter */
    int result                           /* Result of evaluating SCRIPT */
) {
    static const char *azEnd[] = {
        "RELEASE _jsi_transaction",        /* rc==JSI_ERROR, nTransaction!=0 */
        "COMMIT",                          /* rc!=JSI_ERROR, nTransaction==0 */
        "ROLLBACK TO _jsi_transaction ; RELEASE _jsi_transaction",
        "ROLLBACK"                         /* rc==JSI_ERROR, nTransaction==0 */
    };
    int rc = result;
    const char *zEnd;

    jdb->nTransaction--;
    zEnd = azEnd[(rc==JSI_ERROR)*2 + (jdb->nTransaction==0)];

    jdb->disableAuth++;
    if( _SQL_LITE_N_(_exec)(jdb->db, zEnd, 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
    )) {
        /* This is a tricky scenario to handle. The most likely cause of an
        ** error is that the exec() above was an attempt to commit the
        ** top-level transaction that returned _SQLITEN_(BUSY). Or, less likely,
        ** that an IO-error has occured. In either case, throw a Jsi exception
        ** and try to rollback the transaction.
        **
        ** But it could also be that the user executed one or more BEGIN,
        ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
        ** this method's logic. Not clear how this would be best handled.
        */
        if( rc!=JSI_ERROR ) {
            Jsi_LogError("%s", _SQL_LITE_N_(_errmsg)(jdb->db));
            rc = JSI_ERROR;
        }
        _SQL_LITE_N_(_exec)(jdb->db, "ROLLBACK", 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
    );
    }
    jdb->disableAuth--;

    return rc;
}



#if 0
static void dbEvalRowInfo(
    DbEvalContext *p,               /* Evaluation context */
    int *pnCol,                     /* OUT: Number of column names */
    char ***papColName,           /* OUT: Array of column names */
    int **papColType
) {
    /* Compute column names */
    // Jsi_Interp *interp = p->jdb->interp;

    if( 0==p->apColName ) {
        _SQL_LITE_N_(_stmt) *pStmt = p->pPreStmt->pStmt;
        int i;                        /* Iterator variable */
        int nCol;                     /* Number of columns returned by pStmt */
        char **apColName = 0;      /* Array of column names */
        int *apColType = 0;
        const char *zColName;         /* Column name */
        int numRid = 0;               /* Number of times rowid seen. */

        p->nCol = nCol = _SQL_LITE_N_(_column_count)(pStmt);
        if( nCol>0 && (papColName || p->pArray) ) {
            int cnLen = sizeof(char*)*nCol, cnStart = cnLen;
            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)
                cnLen += Jsi_Strlen(_SQL_LITE_N_(_column_name)(pStmt,i))+1;
            if (cnLen>=sizeof(p->staticColNames)) {
                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );
                cnStart = 0;
            } else {
                apColName = (char**)p->staticColNames;
            }
            if (papColType) {
                if (nCol < SQL_MAX_STATIC_TYPES)
                    apColType = p->staticColTypes;
                else
                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));
            }
            for(i=0; i<nCol; i++) {
                zColName = _SQL_LITE_N_(_column_name)(pStmt,i);
                if (cnStart==0)
                    apColName[i] = Jsi_Strdup(zColName);
                else {
                    apColName[i] = p->staticColNames+cnStart;
                    Jsi_Strcpy(apColName[i], zColName);
                    cnStart += Jsi_Strlen(zColName)+1;
                }
                if (apColType)
                    apColType[i] = _SQL_LITE_N_(_column_type)(pStmt,i);
                /* Check if rowid appears first, and more than once. */
                if ((i == 0 || numRid>0) &&
                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,"rowid") == 0)) {
                    numRid++;
                }
            }
            /* Change first rowid to oid. */
            if (numRid > 1) {
                if (apColName != (char**)p->staticColNames) {
                    Jsi_Free(apColName[0]);
                    apColName[0] = Jsi_Strdup("oid");
                } else {
                    Jsi_Strcpy(apColName[0], "oid");
                }
            }
            p->apColName = apColName;
            p->apColType = apColType;
        }
    }
    if( papColName ) {
        *papColName = p->apColName;
    }
    if( papColType ) {
        *papColType = p->apColType;
    }
    if( pnCol ) {
        *pnCol = p->nCol;
    }
}
#endif

/*
** Return a JSON formatted value for the iCol'th column of the row currently pointed to by
** the DbEvalContext structure passed as the first argument.
*/
static void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {
    Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];

    _SQL_LITE_N_(_stmt) *pStmt = p->pPreStmt->pStmt;

    switch( _SQL_LITE_N_(_column_type)(pStmt, iCol) ) {
    case _SQLITEN_(BLOB): {
#ifndef USE_SQLITE_V4
        int bytes = _SQL_LITE_N_(_column_bytes)(pStmt, iCol);
        const char *zBlob = (char*)_SQL_LITE_N_(_column_blob)(pStmt, iCol);
#else
        int bytes;
        const char *zBlob = _SQL_LITE_N_(_column_blob)(pStmt, iCol, &bytes);
#endif
        if( !zBlob ) {
            Jsi_DSAppend(dStr, "null", NULL);
            return;
        }
        Jsi_JSONQuote(interp, zBlob, bytes, dStr);
        return;
    }
    case _SQLITEN_(INTEGER): {
        sqlite_int64 v = _SQL_LITE_N_(_column_int64)(pStmt, iCol);
        sprintf(nbuf, "%lld", v);
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case _SQLITEN_(FLOAT): {
        Jsi_NumberToString(_SQL_LITE_N_(_column_double)(pStmt, iCol), nbuf);
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case _SQLITEN_(NULL): {
        Jsi_DSAppend(dStr, "null", NULL);
        return;
    }
    }
    const char *str = (char*)_SQL_LITE_N_(_column_text)(pStmt, iCol _SQLBIND_END_);
    if (!str)
        str = p->jdb->optPtr->nullvalue;
    Jsi_JSONQuote(interp, str?str:"", -1, dStr);
}

static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {
    //Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];

    _SQL_LITE_N_(_stmt) *pStmt = p->pPreStmt->pStmt;

    switch( _SQL_LITE_N_(_column_type)(pStmt, iCol) ) {
    case _SQLITEN_(BLOB): {
#ifndef USE_SQLITE_V4
        int bytes = _SQL_LITE_N_(_column_bytes)(pStmt, iCol);
        const char *zBlob = (char*)_SQL_LITE_N_(_column_blob)(pStmt, iCol);
#else
        int bytes;
        const char *zBlob = (char*)_SQL_LITE_N_(_column_blob)(pStmt, iCol, &bytes);
#endif
        if( !zBlob ) {
            return;
        }
        Jsi_DSAppendLen(dStr, zBlob, bytes);
        return;
    }
    case _SQLITEN_(INTEGER): {
        sqlite_int64 v = _SQL_LITE_N_(_column_int64)(pStmt, iCol);
        sprintf(nbuf, "%lld", v);
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case _SQLITEN_(FLOAT): {
        Jsi_NumberToString(_SQL_LITE_N_(_column_double)(pStmt, iCol), nbuf);
        Jsi_DSAppend(dStr, nbuf, NULL);
        return;
    }
    case _SQLITEN_(NULL): {
        return;
    }
    }
    const char *str = (char*)_SQL_LITE_N_(_column_text)(pStmt, iCol _SQLBIND_END_);
    if (!str)
        str = p->jdb->optPtr->nullvalue;
    Jsi_DSAppend(dStr, str?str:"", NULL);
}


static Jsi_Value* dbEvalSetColumnValue(DbEvalContext *p, int iCol, Jsi_Value **val) {
    Jsi_Interp *interp = p->jdb->interp;

    _SQL_LITE_N_(_stmt) *pStmt = p->pPreStmt->pStmt;
    const char *str;
    
    switch( _SQL_LITE_N_(_column_type)(pStmt, iCol) ) {
    case _SQLITEN_(BLOB): {
#ifndef USE_SQLITE_V4
        int bytes = _SQL_LITE_N_(_column_bytes)(pStmt, iCol);
        const char *zBlob = (char*)_SQL_LITE_N_(_column_blob)(pStmt, iCol);
#else
        int bytes;
        const char *zBlob = (char*)_SQL_LITE_N_(_column_blob)(pStmt, iCol, &bytes);
#endif
        if( !zBlob )
            return Jsi_ValueMakeNull(interp, val);
        return Jsi_ValueMakeBlob(interp, val, (unsigned char*)zBlob, bytes);
        break;
    }
    case _SQLITEN_(INTEGER): {
        sqlite_int64 v = _SQL_LITE_N_(_column_int64)(pStmt, iCol);
        if( v>=-2147483647 && v<=2147483647 ) {
            return Jsi_ValueMakeNumber(interp, val, v);
        } else {
            return Jsi_ValueMakeNumber(interp, val, v);
        }
        break;
    }
    case _SQLITEN_(FLOAT): {
        return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)_SQL_LITE_N_(_column_double)(pStmt, iCol));
        break;
    }
    case _SQLITEN_(NULL): {
        return Jsi_ValueMakeNull(interp, val);
        break;;
    }
    default:
        str = (char*)_SQL_LITE_N_(_column_text)(pStmt, iCol _SQLBIND_END_);
        if (!str)
            str = p->jdb->optPtr->nullvalue;
        return Jsi_ValueMakeStringDup(interp, val, str?str:"");
    }
    return Jsi_ValueNew1(interp);
}


# define SQLITE_JSI_NRE 0
# define DbUseNre() 0
# define Jsi_NRAddCallback(a,b,c,d,e,f) 0
# define Jsi_NREvalObj(a,b,c) 0
# define Jsi_NRCreateCommand(a,b,c,d,e,f) 0

#include <stdio.h>

static int dbEvalCallCmd( DbEvalContext *p, Jsi_Interp *interp, int result)
{
    int cnt = 0, rc = result;
    Jsi_Value *varg1;
    Jsi_Obj *argso;
    char **apColName = NULL;
    int *apColType = NULL;
    if (p->jdb->debug & TMODE_EVAL)
        JSI_DBQUERY_PRINTF( "DEBUG: eval\n");

    while( (rc==JSI_OK) && JSI_OK==(rc = dbEvalStep(p)) ) {
        int i;
        int nCol;

        cnt++;
        dbEvalRowInfo(p, &nCol, &apColName, &apColType);
        if (nCol<=0)
            continue;
        if (Jsi_ValueIsNull(interp,p->tocall))
            continue;
        /* Single object containing sql result members. */
        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));
        for(i=0; i<nCol; i++) {
            Jsi_Value *nnv = dbEvalSetColumnValue(p, i, NULL);
            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);
        }
        Jsi_IncrRefCount(interp, varg1);
        rc = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);
        Jsi_DecrRefCount(interp, varg1);
        if (rc)
            break;
    }
    //dbEvalFinalize(p);

    if( rc==JSI_OK || rc==JSI_BREAK ) {
        //Jsi_ResetResult(interp);
        rc = JSI_OK;
    }
    return rc;
}

static Jsi_Db *dbGetDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb = (Jsi_Db*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!jdb) {
        Jsi_LogError("Sqlite call to a non-sqlite object\n");
        return NULL;
    }
    if (!jdb->db)
    {
        Jsi_LogError("Sqlite db closed");
        return NULL;
    }
    return jdb;
}

static void sqliteObjErase(Jsi_Db *jdb)
{
    dbDeleteCmd(jdb);
    jdb->db = NULL;
}

static int sqliteObjFree(Jsi_Interp *interp, void *data)
{
    Jsi_Db *fo = (Jsi_Db*)data;
    SQLSIGASSERT(fo,DB);
    sqliteObjErase(fo);
    MEMCLEAR(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static int sqliteObjIsTrue(void *data)
{
    Jsi_Db *fo = (Jsi_Db*)data;
    SQLSIGASSERT(fo,DB);
    if (!fo->db) return 0;
    else return 1;
}

static int sqliteObjEqual(void *data1, void *data2)
{
    //SQLSIGASSERT(data1,DB);
    //SQLSIGASSERT(data2,DB);
    return (data1 == data2);
}

static void dbStmtFreeProc(Jsi_List *list, Jsi_ListEntry *l);

/**   new Sqlite(FILENAME,?-vfs VFSNAME?,?-key KEY?,?-readonly BOOLEAN?,
**                           ?-create BOOLEAN?,?-nomutex BOOLEAN?)
**
** This is the sqlite constructior called  using "new Sqlite".
**
** The first argument is the name of the database file.
**
*/

static int SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc = JSI_OK;
    /* void *cd = clientData; */
    int  flags;
    char *zErrMsg;
    const char *zFile = NULL, *vfs = 0;
    Jsi_ListAttr attr = {};
    /* In normal use, each JSI interpreter runs in a single thread.  So
    ** by default, we can turn of mutexing on SQLite database connections.
    ** However, for testing purposes it is useful to have mutexes turned
    ** on.  So, by default, mutexes default off.  But if compiled with
    ** _SQLITEN_(JSI_DEFAULT_FULLMUTEX) then mutexes default on.
    */
    flags = _SQLITEN_(OPEN_READWRITE) | _SQLITEN_(OPEN_CREATE);
#ifdef USE_SQLITE_V4
    vfs = vfs; // Gets rid of warning.
#else
#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX
    flags |= _SQLITEN_(OPEN_FULLMUTEX);
#else
    flags |= _SQLITEN_(OPEN_NOMUTEX);
#endif
#endif

    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_DString dStr = {};
    int ismem = 0;
    Jsi_Obj *userObjPtr;
    Jsi_Value *toacc;
    
    if (vFile==NULL || Jsi_ValueIsNull(interp, vFile)) {
        zFile = ":memory:";
        ismem = 1;
    } else {
        zFile = Jsi_ValueNormalPath(interp, vFile, &dStr);
        if (zFile == NULL) {
            Jsi_LogError("bad or missing file name");
            return JSI_ERROR;
        }
    }
    zErrMsg = 0;
    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );
    if( db==0 ) {
        Jsi_DSFree(&dStr);
        Jsi_LogError("malloc failed");
        return JSI_ERROR;
    }
    db->sig = SQLITE_SIG_DB;
    db->maxStmts = NUM_PREPARED_STMTS;
    db->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (db->hasOpts && Jsi_OptionsProcess(interp, SqlOptions, arg, db, 0) < 0) {
        Jsi_DSFree(&dStr);
        return JSI_ERROR;

    }
    if (ismem == 0 && Jsi_InterpAccess(interp, vFile, db->readonly==0) != JSI_OK) {
        Jsi_LogError("Safe accces denied");
        goto bail;
    }

    if (db->maxStmts<0 || db->maxStmts>MAX_PREPARED_STMTS) {
        Jsi_LogError("option maxStmts value %d is not in range 0..%d", db->maxStmts, MAX_PREPARED_STMTS);
        goto bail;
    }
    if (db->readonly) {
        flags &= ~(_SQLITEN_(OPEN_READWRITE)|_SQLITEN_(OPEN_CREATE));
        flags |= _SQLITEN_(OPEN_READONLY);
    } else {
        flags &= ~_SQLITEN_(OPEN_READONLY);
        flags |= _SQLITEN_(OPEN_READWRITE);
        if (db->nocreate) {
            flags &= ~_SQLITEN_(OPEN_CREATE);
        }
    }
    if (db->vfs)
        vfs = Jsi_ValueToString(interp, db->vfs, NULL);
#ifndef USE_SQLITE_V4
    if(db->mutex == MUTEX_NONE) {
        flags |= _SQLITEN_(OPEN_NOMUTEX);
        flags &= ~_SQLITEN_(OPEN_FULLMUTEX);
    } else {
        flags &= ~_SQLITEN_(OPEN_NOMUTEX);
    }
    if(db->mutex ==MUTEX_FULL) {
        flags |= _SQLITEN_(OPEN_FULLMUTEX);
        flags &= ~_SQLITEN_(OPEN_NOMUTEX);
    } else {
        flags &= ~_SQLITEN_(OPEN_FULLMUTEX);
    }
  
    if (SQLITE_OK != _SQL_LITE_N_(_open_v2)(zFile, &db->db, flags, vfs)) {
        Jsi_LogError("db open failed");
        goto bail;
    }
#else
    if (SQLITE_OK != _SQL_LITE_N_(_open)(db->pEnv, zFile, &db->db, NULL)) {
        Jsi_LogError("db open failed");
        goto bail;
    }
#endif
    //Jsi_DSFree(&translatedFilename);

    if( SQLITE_OK!=_SQL_LITE_N_(_errcode)(db->db) ) {
        zErrMsg = _SQL_LITE_N_(_mprintf)(_SQLITE_PENV_(db) "%s", _SQL_LITE_N_(_errmsg)(db->db));
        DbClose(db->db);
        db->db = 0;
    }
#ifdef SQLITE_HAS_CODEC
    if( db->db && db->key) {
        const char *key = 0;
        if (db->key)
            key = Jsi_ValueString(interp, db->key, NULL);
        if (key)
            _SQL_LITE_N_(_key)(db->db, key, strlen(key));
    }
#endif
    if( db->db==0 ) {
#ifdef USE_SQLITE_V4
        _SQL_LITE_N_(_free)(db->pEnv, zErrMsg);
#else
        _SQL_LITE_N_(_free)(zErrMsg);
#endif
        goto bail;
    }
;
    toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Sqlite", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }
    userObjPtr = Jsi_ValueGetObj(interp, toacc /* constructor obj*/);
    if ((db->objId = Jsi_UserObjNew(interp, &sqliteobject, userObjPtr, db))<0)
        goto bail;
    db->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    db->userObjPtr = userObjPtr;
    //dbSys->cnt = Jsi_UserObjCreate(interp, sqliteobject.name /*dbSys*/, userObjPtr, db);
    db->interp = interp;
    db->optPtr = &db->queryOpts;
    attr.data=(void*)db;
    attr.freeProc=dbStmtFreeProc;
    db->stmtCache = Jsi_ListNew(&attr);
    rc = JSI_OK;
    
bail:
    if (rc != JSI_OK) {
        if (db->hasOpts)
            Jsi_OptionsFree(interp, SqlOptions, db, 0);
        Jsi_Free(db);
    }
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeUndef(interp, ret);
    return rc;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_busy JSI_INFO("\
Invoke the given callback when an SQL statement attempts to open \
a locked database file. Call with null to disable, or no arguments, \
to return the current busy function. ")

static int SqliteBusyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zBusy ) {
            Jsi_ValueReplace(interp, ret, jdb->zBusy);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_busy_handler)(jdb->db, 0, 0);
        if( jdb->zBusy ) {
            Jsi_DecrRefCount(interp, jdb->zBusy);
        }
        jdb->zBusy = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zBusy ) {
            Jsi_DecrRefCount(interp, jdb->zBusy);
        }
        jdb->zBusy = func;
        Jsi_IncrRefCount(interp, func);
        _SQL_LITE_N_(_busy_handler)(jdb->db, dbBusyHandler, jdb);
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}
#endif

#ifndef OMIT_SQLITE_COLLATION
static int SqliteCollateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *func;

    SqlCollate *pCollate;
    char *zName;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    func = Jsi_ValueArrayIndex(interp, args, 1);
    pCollate = (SqlCollate*)Jsi_Calloc(1, sizeof(*pCollate));
    if( pCollate==0 ) return JSI_ERROR;
    pCollate->interp = interp;
    pCollate->pNext = jdb->pCollate;
    pCollate->zScript = func; /*(char*)&pCollate[1];*/
    jdb->pCollate = pCollate;

#ifdef USE_SQLITE_V4
    if( _SQL_LITE_N_(_create_collation)(jdb->db, zName, pCollate, dbSqlCollate, 0 ))
#else
    if( _SQL_LITE_N_(_create_collation)(jdb->db, zName, _SQLITEN_(UTF8), pCollate, dbSqlCollate) )
#endif
    {
        Jsi_LogError("%s", (char *)_SQL_LITE_N_(_errmsg)(jdb->db));
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int SqliteCollationNeededCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *func;
    int argc = Jsi_ValueGetLength(interp, args);

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pCollateNeeded ) {
            Jsi_ValueReplace(interp, ret, jdb->pCollateNeeded);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_collation_needed)(jdb->db, 0, 0);
        if( jdb->zCommit ) {
            Jsi_DecrRefCount(interp, jdb->pCollateNeeded);
        }
        jdb->zCommit = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pCollateNeeded ) {
            Jsi_DecrRefCount(interp, jdb->pCollateNeeded);
        }
        jdb->pCollateNeeded = func;
        Jsi_DecrRefCount(interp, func);
        _SQL_LITE_N_(_collation_needed)(jdb->db, jdb, dbCollateNeeded);
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;

}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_commithook JSI_INFO("\
Invoke the given callback just before committing every SQL transaction. \
If the callback throws an exception or returns non-zero, then the \
transaction is aborted.  If CALLBACK is an empty string, the callback \
is disabled.")

static int SqliteCommitHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zCommit ) {
            Jsi_ValueReplace(interp, ret, jdb->zCommit);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_commit_hook)(jdb->db, 0, 0);
        if( jdb->zCommit ) {
            Jsi_DecrRefCount(interp, jdb->zCommit);
        }
        jdb->zCommit = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zCommit ) {
            Jsi_DecrRefCount(interp, jdb->zCommit);
        }
        jdb->zCommit = func;
        Jsi_IncrRefCount(interp, func);
        _SQL_LITE_N_(_commit_hook)(jdb->db, dbCommitHandler, jdb);
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int SqliteProgressCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int n, argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func, *nVal;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zProgress ) {
            Jsi_ValueReplace(interp, ret, jdb->zProgress);
        }
        return JSI_OK;
    }
    if (argc != 2) {
        Jsi_LogError("expected 0 or 2 args");
        return JSI_ERROR;
    }
    func = Jsi_ValueArrayIndex(interp, args, 1);
    nVal = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_GetIntFromValue(interp, nVal, &n) != JSI_OK)
        return JSI_ERROR;
    if (Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_progress_handler)(jdb->db, 0, 0, 0);
        if( jdb->zProgress ) {
            Jsi_DecrRefCount(interp, jdb->zProgress);
        }
        jdb->zProgress = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zProgress ) {
            Jsi_DecrRefCount(interp, jdb->zProgress);
        }
        jdb->zProgress = func;
        Jsi_IncrRefCount(interp, func);
        _SQL_LITE_N_(_progress_handler)(jdb->db, n, dbProgressHandler, jdb);
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}
#endif

#define FN_profile JSI_INFO("\
Make arrangements to invoke the CALLBACK routine after each SQL statement \
that has run.  The text of the SQL and the amount of elapse time are \
arguments to CALLBACK.")

static int SqliteProfileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zProfile ) {
            Jsi_ValueReplace(interp, ret, jdb->zProfile);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
#ifndef SQLITE_OMIT_TRACE
        _SQL_LITE_N_(_profile)(jdb->db, 0, 0 _SQLBIND_END_);
#endif
        if( jdb->zProfile ) {
            Jsi_DecrRefCount(interp, jdb->zProfile);
        }
        jdb->zProfile = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zProfile ) {
            Jsi_DecrRefCount(interp, jdb->zProfile);
        }
        jdb->zProfile = func;
        Jsi_IncrRefCount(interp, func);
#ifndef SQLITE_OMIT_TRACE
#ifdef USE_SQLITE_V4
        _SQL_LITE_N_(_profile)(jdb->db, jdb->db, dbProfileHandler, 0);
#else
        _SQL_LITE_N_(_profile)(jdb->db, dbProfileHandler, jdb);
#endif
#endif
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int SqliteRekeyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    int nKey, rc = JSI_OK;
    void *pKey = Jsi_ValueString(interp, val, &nKey);
    
    if (!pKey) {
        Jsi_LogError("key must be a non-null string");
        return JSI_ERROR;
    }
#ifdef SQLITE_HAS_CODEC
    rc = _SQL_LITE_N_(_rekey)(jdb->db, pKey, nKey);
    if( rc ) {
#if defined(SQLITE3_AMALGAMATION) || defined(SQLITE4_AMALGAMATION)
        Jsi_LogError("Rekey: %s", _SQL_LITE_N_(ErrStr(rc)));
#else
        Jsi_LogError("Rekey error");
#endif
        rc = JSI_ERROR;
    } else {
        Jsi_ValueMakeBool(interp, *ret, 1);
    }
#endif
    return rc;
}

#define FN_trace JSI_INFO("\
Make arrangements to invoke the callback routine for each SQL statement\
that is executed.  The text of the SQL is an argument to callback.")

static int SqliteTraceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zTrace ) {
            Jsi_ValueReplace(interp, ret, jdb->zTrace);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
#ifndef SQLITE_OMIT_TRACE
        _SQL_LITE_N_(_trace)(jdb->db, 0, 0 _SQLBIND_END_);
#endif
        if( jdb->zTrace ) {
            Jsi_DecrRefCount(interp, jdb->zTrace);
        }
        jdb->zTrace = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->zTrace ) {
            Jsi_DecrRefCount(interp, jdb->zTrace);
        }
        jdb->zTrace = func;
        Jsi_IncrRefCount(interp, func);
#ifndef SQLITE_OMIT_TRACE
#ifdef USE_SQLITE_V4
        _SQL_LITE_N_(_trace)(jdb->db, dbTraceHandler, 0, 0);
#else
        _SQL_LITE_N_(_trace)(jdb->db, dbTraceHandler, jdb);
#endif
#endif
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

static int SqliteUnlockNotifyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{

#ifndef SQLITE_ENABLE_UNLOCK_NOTIFY
    Jsi_LogError("unlock_notify not available in this build");
    return JSI_ERROR;
#else
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->zUnlockNotify ) {
            Jsi_ValueReplace(interp, ret, jdb->zUnlockNotify);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (func == NULL || Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_unlock_notify)(jdb->db, 0, 0);
        if( jdb->pUnlockNotify ) {
            Jsi_DecrRefCount(interp, jdb->pUnlockNotify);
        }
        jdb->pUnlockNotify = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pUnlockNotify ) {
            Jsi_DecrRefCount(interp, jdb->pUnlockNotify);
        }
        jdb->pUnlockNotify = func;
        Jsi_IncrRefCount(interp, func);
        if( _SQL_LITE_N_(_unlock_notify)(jdb->db, dbUnlockNotify, (void*)jdb)) {
            Jsi_LogError("%s", _SQL_LITE_N_(_errmsg)(jdb->db));
            return JSI_ERROR;
        }

    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
#endif
}

static int SqliteUpdateHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pUpdateHook ) {
            Jsi_ValueReplace(interp, ret, jdb->pUpdateHook);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (func == NULL || Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_update_hook)(jdb->db, 0, 0);
        if( jdb->pUpdateHook ) {
            Jsi_DecrRefCount(interp, jdb->pUpdateHook);
        }
        jdb->pUpdateHook = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pUpdateHook ) {
            Jsi_DecrRefCount(interp, jdb->pUpdateHook);
        }
        jdb->pUpdateHook = func;
        Jsi_IncrRefCount(interp, func);
        _SQL_LITE_N_(_update_hook)(jdb->db, dbUpdateHandler, jdb);

    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}

static int SqliteRollbackHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pRollbackHook ) {
            Jsi_ValueReplace(interp, ret, jdb->pRollbackHook);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_rollback_hook)(jdb->db, 0, 0);
        if( jdb->pRollbackHook ) {
            Jsi_DecrRefCount(interp, jdb->pRollbackHook);
        }
        jdb->pRollbackHook = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pRollbackHook ) {
            Jsi_DecrRefCount(interp, jdb->pRollbackHook);
        }
        jdb->pRollbackHook = func;
        Jsi_IncrRefCount(interp, func);
        _SQL_LITE_N_(_rollback_hook)(jdb->db, dbRollbackHandler, jdb);
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}


static int SqliteWalHookCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Value *func;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    if( argc==0 ) {
        if( jdb->pWalHook ) {
            Jsi_ValueReplace(interp, ret, jdb->pWalHook);
        }
        return JSI_OK;
    }
    func = Jsi_ValueArrayIndex(interp, args, 0);
    if (Jsi_ValueIsNull(interp, func)) {
        _SQL_LITE_N_(_rollback_hook)(jdb->db, 0, 0);
        if( jdb->pWalHook ) {
            Jsi_DecrRefCount(interp, jdb->pWalHook);
        }
        jdb->pWalHook = NULL;
    } else if(Jsi_ValueIsFunction(interp, func)) {
        if( jdb->pWalHook ) {
            Jsi_DecrRefCount(interp, jdb->pWalHook);
        }
        jdb->pWalHook = func;
        Jsi_IncrRefCount(interp, func);
        _SQL_LITE_N_(_wal_hook)(jdb->db, dbWalHandler, jdb);
    } else {
        Jsi_LogError("expected null or function");
        return JSI_ERROR;
    }
    return JSI_OK;
}
#endif

#define FN_authorizer JSI_INFO("\
  db.authorizer(FUNC) \
\n\
Invoke the given callback to authorize each SQL operation as it is \
compiled.  5 arguments are appended to the callback before it is \
invoked: \
\n\
  (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...) \
  (2) First descriptive name (depends on authorization type) \
  (3) Second descriptive name \
  (4) Name of the database (ex: 'main', 'temp') \
  (5) Name of trigger that is doing the access \
\n\
The callback should return on of the following strings: SQLITE_OK, \
SQLITE_IGNORE, or SQLITEN_DENY.  Any other return value is an error. \
\n\
If this method is invoked with no arguments, the current authorization \
callback string is returned.")

#ifndef SQLITE_OMIT_AUTHORIZATION
static int SqliteAuthorizorCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Value *auth;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    auth = Jsi_ValueArrayIndex(interp, args, 0);
    if (!auth) {
        if (jdb->zAuth)
            Jsi_ValueDup2(interp, ret, jdb->zAuth);
        return JSI_OK;
    }
    if (Jsi_ValueIsFunction(interp, auth)) {
        if (jdb->zAuth)
            Jsi_DecrRefCount(interp, jdb->zAuth);
        jdb->zAuth = auth;
        Jsi_IncrRefCount(interp, auth);
    } else if (Jsi_ValueIsUndef(interp, auth)) {
        if (jdb->zAuth)
            Jsi_DecrRefCount(interp, jdb->zAuth);
        jdb->zAuth = 0;
    } else {
        Jsi_LogError("expected function or undefined");
        return JSI_ERROR;
    }
    if( jdb->zAuth ) {
        jdb->interp = interp;
        _SQL_LITE_N_(_set_authorizer)(jdb->db, dbAuthCallback, jdb);
    } else {
        _SQL_LITE_N_(_set_authorizer)(jdb->db, 0, 0);
    }
    return JSI_OK;
}
#endif


static const char *copyConflictStrs[] = {
    "ROLLBACK", "ABORT", "FAIL", "IGNORE", "REPLACE", 0
};
enum { CC_ROLLBACK, CC_ABORT, CC_FAIL, CC_IGNORE, CC_REPLACE, CC_NONE };

typedef struct ImportData {
    int limit;
    int conflict;
    Jsi_Bool csv;
    Jsi_Bool headers;
    const char *separator;
    const char *nullvalue;
} ImportData;

static Jsi_OptionSpec ImportOptions[] =
{
    JSI_OPT(BOOL,   ImportData, headers, .help="First row contains column labels"),
    JSI_OPT(BOOL,   ImportData, csv, .help="Treat input values as CSV"),
    JSI_OPT(CUSTOM, ImportData, conflict, .custom=Jsi_Opt_SwitchEnum,  .data=copyConflictStrs, .help="Set conflict resolution"),
    JSI_OPT(INT,    ImportData, limit, .help="Maximum number of lines to load"),
    JSI_OPT(STRKEY, ImportData, nullvalue, .help="Null string"),
    JSI_OPT(STRKEY, ImportData, separator, .help="Separator string; default is comma if csv, else tabs"),
    JSI_OPT_END(ImportData)
};

#define FN_import JSI_INFO("\
Import data from a file into table. SqlOptions include the 'separator' \
to use, which defaults to commas for csv, or tabs otherwise.\
If a column contains a null string, or the \
value of 'nullvalue', a null is inserted for the column. \
A 'conflict' is one of the sqlite conflict algorithms: \
   rollback, abort, fail, ignore, replace \
On success, return the number of lines processed, not necessarily same \
as 'db.changes' due to the conflict algorithm selected. \
")

static int SqliteImportCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int rc;
    char *zTable;               /* Insert data into this table */
    char *zFile;                /* The file from which to extract data */
    const char *zConflict;            /* The conflict algorithm to use */
    _SQL_LITE_N_(_stmt) *pStmt;        /* A statement */
    int nCol;                   /* Number of columns in the table */
    int nByte;                  /* Number of bytes in an SQL string */
    int i, j;                   /* Loop counters */
    int nSep;                   /* Number of bytes in zSep[] */
    int nNull;                  /* Number of bytes in zNull[] */
    char *zSql;                 /* An SQL statement */
    char *zLine;                /* A single line of input from the file */
    char **azCol;               /* zLine[] broken up into columns */
    const char *zCommit;              /* How to commit changes */
    Jsi_Channel in;                   /* The input file */
    int lineno = 0;             /* Line number of input file */
    int created = 0;
    const char *zSep;
    const char *zNull;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 2);
    ImportData opts = {};

    if (arg) {
        if (Jsi_OptionsProcess(interp, ImportOptions, arg, &opts, 0) < 0)
            return JSI_ERROR;
    }
    zConflict = copyConflictStrs[opts.conflict];
    
    if(opts.separator ) {
        zSep = opts.separator;
    } else {
        zSep = (opts.csv ? "," : "\t");
    }
    if(opts.nullvalue ) {
        zNull = opts.nullvalue;
    } else {
        zNull = "";
    }
    zTable = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 1);
    zFile = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    nSep = Jsi_Strlen(zSep);
    nNull = Jsi_Strlen(zNull);
    if( nSep==0 ) {
        Jsi_LogError("Error: non-null separator required for copy");
        return JSI_ERROR;
    }


    zSql = _SQL_LITE_N_(_mprintf)(_SQLITE_PENV_(jdb) "SELECT * FROM '%q'", zTable);
    if (zSql==0) {
        Jsi_LogError("Error: bad table: %s", zTable);
        return JSI_ERROR;
    }
    
    if (opts.headers) {
        in = Jsi_Open(interp, fname, "rb");
        if( in==0 ) {
            Jsi_LogError("Error: cannot open file: %s", zFile);
            return JSI_ERROR;
        }
        if ((zLine = dbLocalGetline(0, in))==0 ) {
            Jsi_Close(in);
            return JSI_ERROR;
        }
        Jsi_Close(in);
        char *zn, *ze, *z = zLine;
        Jsi_DString cStr = {};
        int zlen = 0, icnt = 0;
        Jsi_DSAppend(&cStr, "CREATE TABLE IF NOT EXISTS '", zTable, "' (", NULL);
        while (1) {
            zn = strstr(z, zSep);
            if (!zn) zlen = Jsi_Strlen(z);
            else zlen = zn-z;
            if (zlen<=0) break;
            ze = z+zlen-1;
            Jsi_DSAppend(&cStr, (icnt?",":""), "'", NULL);
            icnt++;
            if (opts.csv && *z=='"' && zn>z && *ze == '"')
                Jsi_DSAppendLen(&cStr, z+1, zlen-2);
            else
                Jsi_DSAppendLen(&cStr, z, zlen);
            Jsi_DSAppend(&cStr, "'", NULL);
            if (!zn) break;
            z = zn+nSep;
        }
        Jsi_DSAppend(&cStr, ");", NULL);
        Jsi_Free(zLine);
        if (zlen<=0) {
            Jsi_DSFree(&cStr);
            Jsi_LogError("null header problem");
            return JSI_ERROR;
        }
        rc = _SQL_LITE_N_(_exec)(jdb->db, Jsi_DSValue(&cStr), 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
        );
        Jsi_DSFree(&cStr);
        if (rc) {
            Jsi_LogError("%s", _SQL_LITE_N_(_errmsg)(jdb->db));
            return JSI_ERROR;
        }
        created = 1;
    }
    
    nByte = Jsi_Strlen(zSql);
    rc = _SQL_LITE_N_(_prepare)(jdb->db, zSql, -1, &pStmt, 0);
#ifdef USE_SQLITE_V4
        _SQL_LITE_N_(_free)(jdb->pEnv, zSql);
#else
        _SQL_LITE_N_(_free)(zSql);
#endif
    if( rc ) {
        Jsi_LogError("%s", _SQL_LITE_N_(_errmsg)(jdb->db));
        nCol = 0;
    } else {
        nCol = _SQL_LITE_N_(_column_count)(pStmt);
    }
    _SQL_LITE_N_(_finalize)(pStmt);
    if( nCol==0 ) {
        rc = JSI_ERROR;
        goto bail;
    }
    zSql = (char*)Jsi_Malloc( nByte + 50 + nCol*2 );
    if( zSql==0 ) {
        Jsi_LogError("Error: can't malloc()");
        rc = JSI_ERROR;
        goto bail;
    }
    _SQL_LITE_N_(_snprintf)(
#ifdef USE_SQLITE_V4
    zSql, nByte+50, 
#else
    nByte+50, zSql, 
#endif
        "INSERT OR %q INTO '%q' VALUES(?",
                     zConflict, zTable);
    j = Jsi_Strlen(zSql);
    for(i=1; i<nCol; i++) {
        zSql[j++] = ',';
        zSql[j++] = '?';
    }
    zSql[j++] = ')';
    zSql[j] = 0;
    rc = _SQL_LITE_N_(_prepare)(jdb->db, zSql, -1, &pStmt, 0);
    Jsi_Free(zSql);
    if( rc ) {
        Jsi_LogError("Error: %s", _SQL_LITE_N_(_errmsg)(jdb->db));
        _SQL_LITE_N_(_finalize)(pStmt);
        return JSI_ERROR;
    }
    in = Jsi_Open(interp, fname, "rb");
    if( in==0 ) {
        Jsi_LogError("Error: cannot open file: %s", zFile);
        _SQL_LITE_N_(_finalize)(pStmt);
        return JSI_ERROR;
    }
    azCol = (char**)Jsi_Malloc( sizeof(azCol[0])*(nCol+1) );
    if( azCol==0 ) {
        Jsi_LogError("Error: can't malloc()");
        Jsi_Close(in);
        rc = JSI_ERROR;
        goto bail;
    }
    (void)_SQL_LITE_N_(_exec)(jdb->db, "BEGIN", 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
    );
    zCommit = "COMMIT";
    while ((zLine = dbLocalGetline(0, in))!=0 ) {
        char *z;
        i = 0;
        lineno++;
        if (opts.limit>0 && lineno > opts.limit) {
            Jsi_Free(zLine);
            break;
        }
        if (lineno == 1 && opts.headers) {
            Jsi_Free(zLine);
            continue;
        }
        if (opts.csv && strchr(zLine,'"')) 
        {
            char *zn, *z = zLine;
            Jsi_DString sStr = {};
            int qcnt = 0;
            i = -1;
            while (*z) if (*z++ == '"') qcnt++;
            z = zLine;
            if (qcnt%2) { /* aggregate quote spanning newlines */
                Jsi_DSAppend(&sStr, zLine, NULL);
                do {
                    lineno++;
                    Jsi_DSAppend(&sStr, "\n", NULL);
                    Jsi_Free(zLine);
                    if (((zLine = dbLocalGetline(0, in)))==0)
                        break;
                    Jsi_DSAppend(&sStr, zLine, NULL);
                    z = zLine;
                    while (*z) if (*z++ == '"') qcnt++;
                } while (qcnt%2);
                z = Jsi_DSValue(&sStr);
            }
            if (qcnt%2) {
                Jsi_DSFree(&sStr);
                Jsi_Free(zLine);
                Jsi_Close(in);
                Jsi_LogError("unterminated string at line: %d", lineno);
                break;
            }
            while (z) {
                if (*z != '\"') { /* Handle un-quoted value */
                    zn = strstr(z, zSep);
                    azCol[++i] = z;
                    if (!zn)
                        break;
                    *zn = 0;
                    z = zn+nSep;
                    continue;
                }
                /* Handle quoted value */
                zn = ++z;
                Jsi_DString cStr = {};
                while (1) {
                    if (!zn)
                        break;
                    if (*zn != '"')
                        Jsi_DSAppendLen(&cStr, zn, 1);
                    else {
                        if (zn[1] == '"') {
                            zn++;
                            Jsi_DSAppendLen(&cStr, "\"", 1);
                        } else if (zn[1] == 0) {
                            break;
                        } else if (strncmp(zn+1,zSep, nSep)==0) {
                            *zn = 0;
                            zn += (nSep + 1);
                            break;
                        } else {
                            /* Invalid, comma should be right after close quote, so just eat quote. */
                            Jsi_DSAppendLen(&cStr, zn, 1);
                        }
                    }
                    zn++;
                }
                strcpy(z, Jsi_DSValue(&cStr));
                Jsi_DSFree(&cStr);
                azCol[++i] = z;
                z = zn;
            }
        } else {
            azCol[0] = zLine;
            for(i=0, z=zLine; *z; z++) {
                if( *z==zSep[0] && strncmp(z, zSep, nSep)==0 ) {
                    *z = 0;
                    i++;
                    if( i<nCol ) {
                        azCol[i] = &z[nSep];
                        z += nSep-1;
                    }
                }
            }
        }
        if( i+1!=nCol ) {
            Jsi_LogError("%s line %d: expected %d columns of data but found %d",
                 zFile, lineno, nCol, i+1);
            zCommit = "ROLLBACK";
            break;
        }
        for(i=0; i<nCol; i++) {
            /* check for null data, if so, bind as null */
            if( (nNull>0 && Jsi_Strcmp(azCol[i], zNull)==0)
                    || Jsi_Strlen(azCol[i])==0
              ) {
                _SQL_LITE_N_(_bind_null)(pStmt, i+1);
            } else {
                _SQL_LITE_N_(_bind_text)(pStmt, i+1, azCol[i], -1, _SQLITEN_(STATIC) _SQLBIND_END_);
            }
        }
        _SQL_LITE_N_(_step)(pStmt);
        rc = _SQL_LITE_N_(_reset)(pStmt);
        if (zLine)
            Jsi_Free(zLine);
        if( rc!=SQLITE_OK ) {
            Jsi_LogError("%s at line: %d", _SQL_LITE_N_(_errmsg)(jdb->db), lineno);
            zCommit = "ROLLBACK";
            break;
        }
    }
    Jsi_Free(azCol);
    Jsi_Close(in);
    _SQL_LITE_N_(_finalize)(pStmt);
    (void)_SQL_LITE_N_(_exec)(jdb->db, zCommit, 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
    );

    if( zCommit[0] == 'C' ) {
        /* success, set result as number of lines processed */
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)lineno);
        rc = JSI_OK;
    } else {
        rc = JSI_ERROR;
    }
    
bail:
    if (rc != JSI_OK && created && opts.conflict == CC_ROLLBACK) {
        Jsi_DString cStr = {};
        Jsi_DSAppend(&cStr, "DROP TABLE IF EXISTS '", zTable, "';", NULL);
        (void)_SQL_LITE_N_(_exec)(jdb->db, Jsi_DSValue(&cStr), 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
        );
        Jsi_DSFree(&cStr);
    }
    return rc;
}

/*
** Make sure we have a PACKAGE_VERSION macro defined.  This will be
** defined automatically by the TEA makefile.  But other makefiles
** do not define it.
*/
#ifndef PACKAGE_VERSION
# define PACKAGE_VERSION _SQLITEN_(VERSION)
#endif

/*
int Sqlite3_Init(Jsi_Interp *interp){
  Jsi_InitStubs(interp, "8.4", 0);
  Jsi_CommandCreate(interp, "_SQL_LITE_N_()", DbMain, 0, 0);
  Jsi_PkgProvide(interp, "_SQL_LITE_N_()", PACKAGE_VERSION);
  Jsi_CommandCreate(interp, "sqlite", DbMain, 0, 0);
  Jsi_PkgProvide(interp, "sqlite", PACKAGE_VERSION);
  return JSI_OK;
}*/

static int SqliteCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *p;
    if (!(p = dbGetDbHandle(interp, _this, funcPtr)))
        return JSI_ERROR;
    DbClose(p->db);
    p->db = NULL;
    return JSI_OK;
}

#define FN_evaluate JSI_INFO("\
Supports multiple semicolon seperated commands. \
Variable binding is NOT performed, results are discarded, and  \
no value is returned")
static int SqliteEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc = SQLITE_OK, rc2;
    Jsi_Db *jdb;
    _SQL_LITE_N_(_stmt) *pStmt = NULL;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    _SQL_LITE_N_() *db = jdb->db;
    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    const char *zLeftover = NULL, *zErrMsg = NULL;

    while( zSql[0] && (SQLITE_OK == rc) ) {
        rc = _SQL_LITE_N_(_prepare_v2)(db, zSql, -1, &pStmt, &zLeftover);

        if( SQLITE_OK != rc ) {
            break;
        } else {
            if( !pStmt ) {
                /* this happens for a comment or white-space */
                zSql = zLeftover;
                while( isspace(zSql[0]) ) zSql++;
                continue;
            }

            do {
                if (jdb->debug & TMODE_STEP)
                    JSI_DBQUERY_PRINTF( "DEBUG: step: %s\n", zSql);
                rc = _SQL_LITE_N_(_step)(pStmt);
            } while( rc == _SQLITEN_(ROW) );
            rc2 = _SQL_LITE_N_(_finalize)(pStmt);
            if( rc!=_SQLITEN_(NOMEM) ) rc = rc2;
            if( rc==SQLITE_OK ) {
                zSql = zLeftover;
                while( isspace(zSql[0]) ) zSql++;
            } else {
            }
        }
    }
 
    if (rc == SQLITE_OK)
        return JSI_OK;
    zErrMsg = _SQL_LITE_N_(_errmsg)(db);
    Jsi_LogError("sqlite error: %s", zErrMsg ? zErrMsg : "");
    return JSI_ERROR;
}

/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static const char needCsvQuote[] = {
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, 
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
};

/*
** Output a single term of CSV.  Actually, p->separator is used for
** the separator, which may or may not be a comma.  p->nullvalue is
** the null value.  Strings are quoted if necessary.
*/
static void dbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)
{
    if( z==0 ) {
        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:"", NULL);
    } else {
        int i;
        int nSep = Jsi_Strlen(p->separator);
        for(i=0; z[i]; i++) {
            if( needCsvQuote[((unsigned char*)z)[i]] || 
                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {
                i = 0;
                break;
            }
        }
        if( i==0 ) {
            Jsi_DSAppend(dStr, "\"", NULL);
            for(i=0; z[i]; i++) {
                if( z[i]=='"' ) Jsi_DSAppend(dStr, "\"", NULL);
                Jsi_DSAppendLen(dStr, z+i, 1);
            }
            Jsi_DSAppend(dStr, "\"", NULL);
        } else {
            Jsi_DSAppend(dStr, z, NULL);
        }
    }
    if( bSep ) {
        Jsi_DSAppend(dStr, p->separator, NULL);
    }
}

static void dbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)
{
    while( *z ) {
        switch (*z) {
        case '<':
            Jsi_DSAppend(dStr, "&lt;", NULL);
            break;
        case '>':
            Jsi_DSAppend(dStr, "&gt;", NULL);
            break;
        case '&':
            Jsi_DSAppend(dStr, "&amp;", NULL);
            break;
        case '\"':
            Jsi_DSAppend(dStr, "&quot;", NULL);
            break;
        case '\'':
            Jsi_DSAppend(dStr, "&#39;", NULL);
            break;
        default:
            Jsi_DSAppendLen(dStr, z, 1);
            break;
        }
        z++;
    }
}
/*
** Output the given string as a quoted string using SQL quoting conventions.
*/
static void dbOutputQuotedString(Jsi_DString *dStr, const char *z) {
    int i;
    int nSingle = 0;
    for(i=0; z[i]; i++) {
        if( z[i]=='\'' ) nSingle++;
    }
    if( nSingle==0 ) {
        Jsi_DSAppend(dStr,"'", z, "'", NULL);
    } else {
        Jsi_DSAppend(dStr,"'", NULL);
        while( *z ) {
            for(i=0; z[i] && z[i]!='\''; i++) {}
            if( i==0 ) {
                Jsi_DSAppend(dStr,"''", NULL);
                z++;
            } else if( z[i]=='\'' ) {
                Jsi_DSAppendLen(dStr,z, i);
                Jsi_DSAppend(dStr,"''", NULL);
                z += i+1;
            } else {
                Jsi_DSAppend(dStr, z, NULL);
                break;
            }
        }
        Jsi_DSAppend(dStr,"'", NULL);
    }
}
/*
** Output the given string as a hex-encoded blob (eg. X'1234' )
*/
static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){
  int i;
  char out[100], *zBlob = (char *)pBlob;
  Jsi_DSAppend(dStr, "X'", NULL);
  for(i=0; i<nBlob; i++){ sprintf(out,"%02x",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }
  Jsi_DSAppend(dStr, "'", NULL);
}

#define FN_sqlexec JSI_INFO("\
Return values in formatted as JSON, HTML, etc. \
, optionally calling function with a result object")
static int SqliteQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc = JSI_OK;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString eStr = {};
#ifdef JSI_DB_DSTRING_SIZE
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
#else
    Jsi_DString ddStr, *dStr = &ddStr;
    Jsi_DSInit(dStr);
#endif
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int cnt = 0;
    char **apColName = NULL;
    int *apColType = NULL, isopts = 0;
    DbEvalContext sEval = {};
    QueryOpts opts, *oEopt;
    opts = jdb->queryOpts;
    opts.callback = NULL;
    opts.width = NULL;
    Jsi_Value *callback = NULL, *width = NULL;
            
    if (arg) {
        if (Jsi_ValueIsFunction(interp,arg)) {
            callback = opts.callback = arg;
        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {
            isopts = 1;
        } else {
            Jsi_LogError("argument must be a function, or options");
            return JSI_ERROR;
        }
    }

    if (isopts) {
        if (Jsi_OptionsProcess(interp, ExecFmtOptions, arg, &opts, 0) < 0)
            return JSI_ERROR;
        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);
        width = (opts.width ? opts.width : jdb->queryOpts.width);
    }
    if (jdb->queryOpts.Cdata) {
        char *cdata = (char*)jdb->queryOpts.Cdata;
        Jsi_DbMultipleBind* copts = Jsi_CDataLookup(interp, cdata);
        if (!copts) {
            Jsi_LogError("unknown Cdata option: %s", jdb->queryOpts.Cdata);
            return JSI_ERROR;
        }
        int n = Jsi_DbQuery(jdb, copts->opts, copts->data, copts->numData, zSql, copts->flags);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
        return JSI_OK;
    }
    if (!opts.separator) {
        switch (opts.mode) {
            case _JSI_EF_LIST: opts.separator = "|"; break;
            case _JSI_EF_COLUMN: opts.separator = " "; break;
            case _JSI_EF_TABS: opts.separator = "\t"; break;
            default: opts.separator = ",";
        }
    }
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = opts.nocache;
    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)
        goto bail;
    sEval.ret = *ret;
    oEopt = jdb->optPtr;
    jdb->optPtr = &opts;
    if (callback) {
        sEval.tocall = callback;
        if (opts.mode != _JSI_EF_ROWS) {
            Jsi_LogError("'mode' must be 'rows' with 'callback'");
            rc = JSI_ERROR;
            goto bail;
        }
        rc = dbEvalCallCmd(&sEval, interp, JSI_OK);
        goto bail;
    } else
    switch (opts.mode) {
    case _JSI_EF_NONE:
        while(JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        goto bail;
        break;
    case _JSI_EF_JSON:
        if (opts.headers) {
            Jsi_DSAppend(dStr, "[ ", NULL);
            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0) {
                    Jsi_DSAppend(dStr, "[", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                    }
                    Jsi_DSAppend(dStr, "]", NULL);
                    cnt++;
                }
                if (cnt)
                    Jsi_DSAppend(dStr, ", ", NULL);
                Jsi_DSAppend(dStr, "[", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    dbEvalSetColumnJSON(&sEval, i, dStr);
                }
                Jsi_DSAppend(dStr, "]", NULL);
                cnt++;
                if (opts.limit && cnt>opts.limit) break;
            }
            Jsi_DSAppend(dStr, " ]", NULL);
            
        } else {
            Jsi_DSAppend(dStr, "[ ", NULL);
            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt)
                    Jsi_DSAppend(dStr, ", ", NULL);
                Jsi_DSAppend(dStr, "{", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                    Jsi_DSAppend(dStr, ":", NULL);
                    dbEvalSetColumnJSON(&sEval, i, dStr);
                }
                Jsi_DSAppend(dStr, "}", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSAppend(dStr, " ]", NULL);
        }
        break;
        
    case _JSI_EF_JSON2: {
            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && 1) {
                    Jsi_DSAppend(dStr, "{ \"names\": [ ", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                    }
                    Jsi_DSAppend(dStr, " ], \"values\": [ ", NULL);
                }
                if (cnt)
                    Jsi_DSAppend(dStr, ", ", NULL);
                Jsi_DSAppend(dStr, "[", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    dbEvalSetColumnJSON(&sEval, i, dStr);
                }
                Jsi_DSAppend(dStr, " ]", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            if (cnt)
                Jsi_DSAppend(dStr, " ] } ", NULL);
        }
        break;
        
    case _JSI_EF_LIST:
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSAppend(dStr, apColName[i], NULL);
                }
            }

            if (cnt || opts.headers)
                Jsi_DSAppend(dStr, "\n", NULL);
            for(i=0; i<nCol; i++) {
                if (i)
                    Jsi_DSAppend(dStr, opts.separator, NULL);
                dbEvalSetColumn(&sEval, i, dStr);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        break;
        
    case _JSI_EF_COLUMN: {
        int *wids = NULL;
        Jsi_DString vStr = {};
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i, w;
            int nCol;
            
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && nCol>0) {
                Jsi_DString sStr;
                wids = (int*)Jsi_Calloc(nCol, sizeof(int));
                Jsi_DSInit(&sStr);
                for(i=0; i<nCol; i++) {
                    int j = Jsi_Strlen(apColName[i]);
                    wids[i] = (j<10?10:j);
                    if (width) {
                        Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);
                        if (wv) {
                            Jsi_Number dv;
                            Jsi_ValueGetNumber(interp, wv, &dv);
                            if (dv>0)
                                wids[i] = (int)dv;
                        }
                    }
                    w = (j<wids[i] ? j : wids[i]);
                    Jsi_DSAppendLen(dStr, apColName[i], w);
                    w = (j<wids[i] ? wids[i]-j+1 : 0);
                    while (w-- > 0)
                        Jsi_DSAppend(dStr, " ", NULL);
                }
                for(i=0; i<nCol && opts.headers; i++) {
                    w = wids[i];
                    w -= Jsi_Strlen(apColName[i]);
                    if (i) {
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                        Jsi_DSAppend(&sStr, opts.separator, NULL);
                    }
                    w = wids[i];
                    while (w-- > 0)
                        Jsi_DSAppend(&sStr, "-", NULL);
                }
                if (opts.headers)
                    Jsi_DSAppend(dStr, "\n", Jsi_DSValue(&sStr), "\n", NULL);
                Jsi_DSFree(&sStr);
            }

            if (cnt)
                Jsi_DSAppend(dStr, "\n", NULL);
            for(i=0; i<nCol; i++) {
                if (i)
                    Jsi_DSAppend(dStr, opts.separator, NULL);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                int nl = Jsi_DSLength(&vStr);
                if (nl > wids[i]) {
                    Jsi_DSSetLength(&vStr, wids[i]);
                    w = 0;
                } else {
                    w = wids[i]-nl;
                }
                Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
                while (w-- > 0)
                    Jsi_DSAppend(dStr, " ", NULL);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        if (wids)
            Jsi_Free(wids);
        break;
    }
    
    case _JSI_EF_INSERT: {
        Jsi_DString vStr = {};    
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            const char *tbl = (opts.table ? opts.table : "table");
            if (cnt)
                Jsi_DSAppend(dStr, "\n", NULL);
            Jsi_DSAppend(dStr, "INSERT INTO ", tbl, " VALUES(", NULL);
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            for(i=0; i<nCol; i++) {
                Jsi_Number dv;
                const char *azArg;
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                _SQL_LITE_N_(_stmt) *pStmt = sEval.pPreStmt->pStmt;
                int ptype = _SQL_LITE_N_(_column_type)(pStmt, i);
                
                azArg = Jsi_DSValue(&vStr);
                const char *zSep = i>0 ? ",": "";
                if( (azArg[i]==0) || (apColType && apColType[i]==_SQLITEN_(NULL)) ) {
                  Jsi_DSAppend(dStr, zSep, "NULL", NULL);
                }else if( ptype ==_SQLITEN_(TEXT) ) {
                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                  dbOutputQuotedString(dStr, azArg);
                }else if (ptype==_SQLITEN_(INTEGER) || ptype ==_SQLITEN_(FLOAT)) {
                  Jsi_DSAppend(dStr, zSep, azArg, NULL);
                }else if (ptype ==_SQLITEN_(BLOB)) {
#ifdef USE_SQLITE_V4
                  int nBlob;
                  const void *pBlob = _SQL_LITE_N_(_column_blob)(pStmt, i, &nBlob);
#else
                  const void *pBlob = _SQL_LITE_N_(_column_blob)(pStmt, i _SQLBIND_END_);
                  int nBlob = _SQL_LITE_N_(_column_bytes)(pStmt, i);
#endif
                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                  dbOutputHexBlob(dStr, pBlob, nBlob);
                }else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ){
                  Jsi_DSAppend(dStr, zSep, azArg, NULL);
                }else{
                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                  dbOutputQuotedString(dStr, azArg);
                }
            }
            Jsi_DSAppend(dStr, ");", NULL);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
    }

    case _JSI_EF_TABS:
    case _JSI_EF_CSV: {
        Jsi_DString vStr = {};  
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSAppend(dStr, apColName[i], NULL);
                }
            }

            if (cnt || opts.headers)
                Jsi_DSAppend(dStr, "\n", NULL);
            for(i=0; i<nCol; i++) {
                if (i)
                    Jsi_DSAppend(dStr, opts.separator, NULL);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                if (opts.mode == _JSI_EF_CSV)
                    dbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);
                else
                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        break;
    }
        
    case _JSI_EF_LINE: {
        int i, w = 5, ww;
        int nCol;
        Jsi_DString vStr = {};   
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0) {
                for(i=0; i<nCol; i++) {
                    ww = Jsi_Strlen(apColName[i]);
                    if (ww>w)
                        w = ww;
                }
            }

            for(i=0; i<nCol; i++) {
                Jsi_DString eStr;
                Jsi_DSInit(&eStr);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                Jsi_DSPrintf(&eStr, "%*s = %s", w, apColName[i], Jsi_DSValue(&vStr));
                Jsi_DSAppend(dStr, (cnt?"\n":""), Jsi_DSValue(&eStr), NULL);
                Jsi_DSFree(&eStr);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        break;
    }
        
    case _JSI_EF_HTML: {
        Jsi_DString vStr = {};   
        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                Jsi_DSAppend(dStr, "<TR>", NULL);
                for(i=0; i<nCol; i++) {
                    Jsi_DSAppend(dStr, "<TH>", NULL);
                    dbOutputHtmlString(&opts, apColName[i], dStr);
                    Jsi_DSAppend(dStr, "</TH>", NULL);
                }
                Jsi_DSAppend(dStr, "</TR>", NULL);
            }
            if (cnt || opts.headers)
                Jsi_DSAppend(dStr, "\n", NULL);
            Jsi_DSAppend(dStr, "<TR>", NULL);
            for(i=0; i<nCol; i++) {
                Jsi_DSAppend(dStr, "<TD>", NULL);
                Jsi_DSSetLength(&vStr, 0);
                dbEvalSetColumn(&sEval, i, &vStr);
                dbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);
                Jsi_DSAppend(dStr, "</TD>", NULL);
            }
            Jsi_DSAppend(dStr, "</TR>", NULL);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        Jsi_DSFree(&vStr);
        break;
    }
        
    case _JSI_EF_ROWS:
    {
        Jsi_Value *vcur, *vrow;
        int cnt = 0;
        Jsi_Obj *oall, *ocur;
        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));

        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
            vrow = Jsi_ValueMakeObject(interp, NULL, ocur);
            for(i=0; i<nCol; i++) {
                vcur = dbEvalSetColumnValue(&sEval, i, NULL);
                Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);
            }
            Jsi_ObjArrayAdd(interp, oall, vrow);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        dbEvalFinalize(&sEval);
        if (rc != JSI_ERROR)
            rc = JSI_OK;
        goto bail;
        break;
    }
    case _JSI_EF_ARRAYS:
    {
        Jsi_Value *vcur, *vrow;
        int cnt = 0;
        Jsi_Obj *oall, *ocur;
        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));

        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
                for(i=0; i<nCol; i++) {
                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                    Jsi_ObjArrayAdd(interp, ocur, vcur);
                }
                Jsi_ObjArrayAdd(interp, oall, vrow);
            }
            vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
            for(i=0; i<nCol; i++) {
                vcur = dbEvalSetColumnValue(&sEval, i, NULL);
                Jsi_ObjArrayAdd(interp, ocur, vcur);
            }
            Jsi_ObjArrayAdd(interp, oall, vrow);
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        dbEvalFinalize(&sEval);
        if (rc != JSI_ERROR)
            rc = JSI_OK;
        goto bail;
        break;
    }
    case _JSI_EF_ARRAY1D:
    {
        Jsi_Value *vcur;
        int cnt = 0;
        Jsi_Obj *oall;
        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));

        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
            int i;
            int nCol;
            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
            if (cnt == 0 && opts.headers) {
                for(i=0; i<nCol; i++) {
                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                    Jsi_ObjArrayAdd(interp, oall, vcur);
                }
            }
            for(i=0; i<nCol; i++) {
                vcur = dbEvalSetColumnValue(&sEval, i, NULL);
                Jsi_ObjArrayAdd(interp, oall, vcur);
            }
            cnt++;
            if (opts.limit && cnt>=opts.limit) break;
        }
        dbEvalFinalize(&sEval);
        if (rc != JSI_ERROR)
            rc = JSI_OK;
        goto bail;
        break;
    }
    }
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr));
bail:
    dbEvalFinalize(&sEval);
    if (isopts) {
        Jsi_OptionsFree(interp, ExecFmtOptions, &opts, 0);
    }
    Jsi_DSFree(dStr);
    Jsi_DSFree(&eStr);
    jdb->optPtr = oEopt;
    return rc;
}

static int SqliteOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    DbEvalContext sEval = {};
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    sEval.nocache = jdb->queryOpts.nocache;
    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)
        return rc;
    sEval.ret = *ret;
    sEval.tocall = NULL;
    int cnt = 0;


    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
        _SQL_LITE_N_(_stmt) *pStmt = sEval.pPreStmt->pStmt;
        int nCol = _SQL_LITE_N_(_column_count)(pStmt);
        if (nCol>0)
            dbEvalSetColumnValue(&sEval, 0, ret);
        cnt++;
    }
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    return rc;
}

static int SqliteExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                           Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    const char *zSql;
    Jsi_DString dStr = {};
    DbEvalContext sEval = {};
    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = jdb->queryOpts.nocache;
    if (dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)
        return JSI_ERROR;
    sEval.ret = *ret;
    int cnt = 0;


    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {
        _SQL_LITE_N_(_stmt) *pStmt = sEval.pPreStmt->pStmt;
        int nCol = _SQL_LITE_N_(_column_count)(pStmt);
        if (nCol>0)
            cnt++;
    }
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeBool(interp, ret, cnt);
    return rc;
}

static int SqliteFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifndef SQLITE_OMIT_LOAD_EXTENSION
#if (_SQLITEN_(VERSION_NUMBER)>3007016)
    const char *zName = "main";
    int argc = Jsi_ValueGetLength(interp, args);
    Jsi_Db *jdb;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    if (argc)
        zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    zName = _SQL_LITE_N_(_db_filename)(jdb->db, zName);
    if (zName)
        Jsi_ValueMakeStringDup(interp, ret, zName);
#endif
#endif
    return JSI_OK;
}

/*
** Find an SqlFunc structure with the given name.  Or create a new
** one if an existing one cannot be found.  Return a pointer to the
** structure.
*/
static SqlFunc *dbFindSqlFunc(Jsi_Db *jdb, const char *zName) {
    SqlFunc *p, *pNew;
    int i;
    pNew = (SqlFunc*)Jsi_Calloc(1, sizeof(*pNew) + Jsi_Strlen(zName) + 1 );
    pNew->sig = SQLITE_SIG_FUNC;
    pNew->zName = (char*)&pNew[1];
    for(i=0; zName[i]; i++) {
        pNew->zName[i] = tolower(zName[i]);
    }
    pNew->zName[i] = 0;
    for(p=jdb->pFunc; p; p=p->pNext) {
        if( Jsi_Strcmp(p->zName, pNew->zName)==0 ) {
            Jsi_Free((char*)pNew);
            return p;
        }
    }
    pNew->interp = jdb->interp;
    pNew->pScript = 0;
    Jsi_DSInit(&pNew->dScript);
    pNew->pNext = jdb->pFunc;
    jdb->pFunc = pNew;
    return pNew;
}

static int SqliteFunctionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    SqlFunc *pFunc;
    Jsi_Value *tocall, *nVal;
    char *zName;
    int rc, nArg = -1, argc;
    argc = Jsi_ValueGetLength(interp, args);
    Jsi_Db *jdb;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    tocall = Jsi_ValueArrayIndex(interp, args, 1);
    if (zName == NULL) {
        Jsi_LogError("expected name");
        return JSI_ERROR;
    }
    if (!Jsi_ValueIsFunction(interp, tocall)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }
    if (argc == 3) {
        nVal = Jsi_ValueArrayIndex(interp, args, 2);
        if (Jsi_GetIntFromValue(interp, nVal, &nArg) != JSI_OK)
            return JSI_ERROR;
    } else {
        Jsi_FunctionArguments(interp, tocall, &nArg);
    }
    if (nArg > _SQLITEN_(LIMIT_FUNCTION_ARG)) {
        Jsi_LogError("to many args");
        return JSI_ERROR;
    }
    /*  if( argc==6 ){
        const char *z = Jsi_GetString(objv[3]);
        int n = Jsi_Strlen(z);
        if( n>2 && strncmp(z, "-argcount",n)==0 ){
          if( Jsi_GetIntFromObj(interp, objv[4], &nArg) ) return JSI_ERROR;
          if( nArg<0 ){
            Jsi_LogError( "number of arguments must be non-negative");
            return JSI_ERROR;
          }
        }
        pScript = objv[5];
      }else if( argc!=4 ){
        Jsi_WrongNumArgs(interp, 2, objv, "NAME [-argcount N] SCRIPT");
        return JSI_ERROR;
      }else{
        pScript = objv[3];
      }*/
    pFunc = dbFindSqlFunc(jdb, zName);
    if( pFunc==0 ) return JSI_ERROR;
    SQLSIGASSERT(pFunc,FUNC);

    pFunc->tocall = tocall;
    Jsi_IncrRefCount(interp, pFunc->tocall);
#ifdef USE_SQLITE_V4
    rc = _SQL_LITE_N_(_create_function)(jdb->db, zName, nArg,
                                 pFunc, jsiSqlFunc, 0, 0, 0);
#else
    rc = _SQL_LITE_N_(_create_function)(jdb->db, zName, nArg, _SQLITEN_(UTF8),
                                 pFunc, jsiSqlFunc, 0, 0);
#endif
    if( rc!=SQLITE_OK ) {
        rc = JSI_ERROR;
        Jsi_LogError("function create error: %s", (char *)_SQL_LITE_N_(_errmsg)(jdb->db));
    }
    return JSI_OK;
}

static int SqliteLastInsertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Wide rowid;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    rowid = dbLastInsertRowid(jdb);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rowid);
    return JSI_OK;
}

static int SqliteInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    _SQL_LITE_N_(_interrupt)(jdb->db);
    return JSI_OK;
}


static int SqliteCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);
    const char *str =  Jsi_ValueString(interp, s, NULL);
    int isComplete = 0;
    if (str)
        isComplete = _SQL_LITE_N_(_complete)( str );
    Jsi_ValueMakeBool(interp, ret, isComplete);
    return JSI_OK;
}

static int SqliteEnableLoadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                               Jsi_Value **ret, Jsi_Func *funcPtr)
{
#ifndef SQLITE_OMIT_LOAD_EXTENSION
    Jsi_Db *jdb;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    int onoff;
    if( Jsi_GetBoolFromValue(interp, arg, &onoff) != JSI_OK) {
        return JSI_ERROR;
    }
    _SQL_LITE_N_(_enable_load_extension)(jdb->db, onoff);
    return JSI_OK;
#else
    Jsi_LogError("extension loading is turned off at compile-time");
    return JSI_ERROR;
#endif
}

static int SqliteErrorCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    n = _SQL_LITE_N_(_errcode)(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}


static int SqliteChangesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    n = _SQL_LITE_N_(_changes)(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}


static int SqliteTotalChangesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                 Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n;
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    n = _SQL_LITE_N_(_total_changes)(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_restore JSI_INFO("\
   db.restore(FILENAME, ?,DATABASE? ) \
\n\
Open a database file named FILENAME.  Transfer the content \
of FILENAME into the local database DATABASE (default: 'main').")

static int SqliteRestoreCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    const char *zSrcFile;
    const char *zDestDb;
    _SQL_LITE_N_() *pSrc;
    _SQL_LITE_N_(_backup) *pBackup;
    int nTimeout = 0, rc;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);
    int argc = Jsi_ValueGetLength(interp, args);
    if( argc==1 ) {
        zDestDb = "main";
    } else {
        zDestDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    }
    Jsi_DString dStr = {};
    if (!vFile)
        zSrcFile = ":memory:";
    else {
        zSrcFile = Jsi_ValueNormalPath(interp, vFile, &dStr);
        if (zSrcFile == NULL) {
            Jsi_LogError("bad or missing file name");
            return JSI_ERROR;
        }
    }
#ifdef USE_SQLITE_V4
    rc = _SQL_LITE_N_(_open)(jdb->pEnv, zSrcFile, &pSrc, _SQLITEN_(OPEN_READONLY), NULL);
#else
    rc = _SQL_LITE_N_(_open_v2)(zSrcFile, &pSrc, _SQLITEN_(OPEN_READONLY), 0);
#endif
    if( rc!=SQLITE_OK ) {
        Jsi_LogError("cannot open source database: %s", _SQL_LITE_N_(_errmsg)(pSrc));
        DbClose(pSrc);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    pBackup = _SQL_LITE_N_(_backup_init)(jdb->db, zDestDb, pSrc, "main");
    if( pBackup==0 ) {
        Jsi_LogError("restore failed: %s", _SQL_LITE_N_(_errmsg)(jdb->db));
        DbClose(pSrc);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    while( (rc = _SQL_LITE_N_(_backup_step)(pBackup,100))==SQLITE_OK
            || rc==_SQLITEN_(BUSY) ) {
        if( rc==_SQLITEN_(BUSY) ) {
            if( nTimeout++ >= 3 ) break;
            _SQL_LITE_N_(_sleep)(100);
        }
    }
    _SQL_LITE_N_(_backup_finish)(pBackup);
    if( rc==_SQLITEN_(DONE) ) {
        rc = JSI_OK;
    } else if( rc==_SQLITEN_(BUSY) || rc==_SQLITEN_(LOCKED) ) {
        Jsi_LogError("restore failed: source database busy");
        rc = JSI_ERROR;
    } else {
        Jsi_LogError("restore failed: %s", _SQL_LITE_N_(_errmsg)(jdb->db));
        rc = JSI_ERROR;
    }
    Jsi_DSFree(&dStr);
    DbClose(pSrc);
    return rc;
}
#endif

#ifndef OMIT_SQLITE_HOOK_COMMANDS

static int SqliteTimeoutCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    Jsi_Number n;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_GetNumberFromValue(interp, s, &n);
    _SQL_LITE_N_(_busy_timeout)( jdb->db, (int)n );
    return JSI_OK;
}
#endif

#define FN_transaction JSI_INFO("\
   db.transaction(FUNC ?,'deferred'|'immediate'|'exclusive'?)\
\n\
Start a new transaction (if we are not already in the midst of a \
transaction) and execute the JS function FUNC.  After FUNC \
completes, either commit the transaction or roll it back if FUNC \
throws an exception.  Or if no new transation was started, do nothing. \
pass the exception on up the stack.")
static int SqliteTransactionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    Jsi_Db *jdb;

    int argc = Jsi_ValueGetLength(interp, args);
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;

    Jsi_Value *pScript;
    const char *zBegin = "SAVEPOINT _jsi_transaction";

    if( jdb->nTransaction==0 && argc==2 ) {
        Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
        static const char *TTYPE_strs[] = {
            "deferred",   "exclusive",  "immediate", 0
        };
        enum TTYPE_enum {
            TTYPE_DEFERRED, TTYPE_EXCLUSIVE, TTYPE_IMMEDIATE
        };
        int ttype;
        if( Jsi_ValueGetIndex(interp, arg, TTYPE_strs, "transaction type",
                              0, &ttype) ) {
            return JSI_ERROR;
        }
        switch( (enum TTYPE_enum)ttype ) {
        case TTYPE_DEFERRED:    /* no-op */
            ;
            break;
        case TTYPE_EXCLUSIVE:
            zBegin = "BEGIN EXCLUSIVE";
            break;
        case TTYPE_IMMEDIATE:
            zBegin = "BEGIN IMMEDIATE";
            break;
        }
    }
    pScript = Jsi_ValueArrayIndex(interp, args, argc-1);
    if(!Jsi_ValueIsFunction(interp, pScript)) {
        Jsi_LogError("expected function");
        return JSI_ERROR;
    }

    /* Run the SQLite BEGIN command to open a transaction or savepoint. */
    jdb->disableAuth++;
    rc = _SQL_LITE_N_(_exec)(jdb->db, zBegin, 0, 0
#ifndef USE_SQLITE_V4
        ,0
#endif
    );
    jdb->disableAuth--;
    if( rc!=SQLITE_OK ) {
        Jsi_LogError("%s", _SQL_LITE_N_(_errmsg)(jdb->db));
        return JSI_ERROR;
    }
    jdb->nTransaction++;

    /* Evaluate the function , then
    ** call function dbTransPostCmd() to commit (or rollback) the transaction
    ** or savepoint.  */
    rc = Jsi_FunctionInvoke(interp, pScript, NULL, NULL, NULL);
    rc = dbTransPostCmd(jdb, interp, rc);
    return rc;
}

static int SqliteVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                            Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    char *str;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    str=Jsi_Strdup((char *)_SQL_LITE_N_(_libversion)());
    Jsi_ValueMakeString(interp, ret, str);
    return JSI_OK;
}

#ifndef OMIT_SQLITE_HOOK_COMMANDS

#define FN_backup JSI_INFO("\
    db.backup(FILENAME, ?DATABASE?) \
\n\
Open or create a database file named FILENAME.  Transfer the \
content of local database DATABASE (default: 'main') into the \
FILENAME database.")

static int SqliteBackupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                           Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    int rc;
    const char *zDestFile;
    const char *zSrcDb;
    _SQL_LITE_N_() *pDest;
    _SQL_LITE_N_(_backup) *pBackup;

    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);
    int argc = Jsi_ValueGetLength(interp, args);
    if( argc==1 ) {
        zSrcDb = "main";
    } else {
        zSrcDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    }
    Jsi_DString dStr = {};
    if (!vFile)
        zDestFile = ":memory:";
    else {
        zDestFile = Jsi_ValueNormalPath(interp, vFile, &dStr);
        if (zDestFile == NULL) {
            Jsi_LogError("bad or missing file name");
            return JSI_ERROR;
        }
    }
#ifdef USE_SQLITE_V4
    rc = _SQL_LITE_N_(_open)(jdb->pEnv, zDestFile, &pDest, NULL);
#else
    rc = _SQL_LITE_N_(_open)(zDestFile, &pDest);
#endif
    if( rc!=SQLITE_OK ) {
        Jsi_LogError("cannot open target database %s: %s", zDestFile, _SQL_LITE_N_(_errmsg)(pDest));
        DbClose(pDest);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    pBackup = _SQL_LITE_N_(_backup_init)(pDest, "main", jdb->db, zSrcDb);
    if( pBackup==0 ) {
        Jsi_LogError("backup failed: %s", _SQL_LITE_N_(_errmsg)(pDest));
        DbClose(pDest);
        Jsi_DSFree(&dStr);
        return JSI_ERROR;
    }
    while(  (rc = _SQL_LITE_N_(_backup_step)(pBackup,100))==SQLITE_OK ) {}
    _SQL_LITE_N_(_backup_finish)(pBackup);
    if( rc==_SQLITEN_(DONE) ) {
        rc = JSI_OK;
    } else {
        Jsi_LogError("backup failed: %s", _SQL_LITE_N_(_errmsg)(pDest));
        rc = JSI_ERROR;
    }
    Jsi_DSFree(&dStr);
    DbClose(pDest);
    return rc;
}
#endif

static int SqliteConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Db *jdb;
    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    //jdb->hasOpts = 1; //TODO: memory leak?
    int oms = jdb->maxStmts;
    int rc = Jsi_OptionsConf(interp, SqlOptions, Jsi_ValueArrayIndex(interp, args, 0), jdb, ret, 0);
    if (jdb->maxStmts<0 || jdb->maxStmts>MAX_PREPARED_STMTS) {
        JSI_DBQUERY_PRINTF( "option maxStmts value %d is not in range 0..%d", jdb->maxStmts, MAX_PREPARED_STMTS);
        jdb->maxStmts = oms;
        rc = JSI_ERROR;
    }
    dbPrepStmtLimit(jdb);
    return rc;
}

static Jsi_CmdSpec sqliteCmds[] = {
    { "Sqlite",         SqliteConstructor,      0,  2,  "file:string=void, options:object=void", JSI_CMD_IS_CONSTRUCTOR, 
        .help="Create a new db connection to the named file or :memory:", .opts=SqlOptions, .retType=(uint)JSI_TT_USEROBJ },
#ifndef SQLITE_OMIT_AUTHORIZATION
    { "authorizor",     SqliteAuthorizorCmd,    0,  1, "callback:function=void", .help="Setup authorizor", .info=FN_authorizer, .retType=(uint)JSI_TT_FUNCTION },
#endif
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "backup",         SqliteBackupCmd,        1,  2, "file:string, dbname:string='main'", .help="Backup db to file", .info=FN_backup, .retType=(uint)JSI_TT_VOID },
    { "busy",           SqliteBusyCmd,          0,  1, "callback:function=void", .help="Function callback upon open busy", .info=FN_busy, .retType=(uint)JSI_TT_FUNCTION },
#endif
    { "changes",        SqliteChangesCmd,       0,  0, "", .help="Return the number of rows that were modified, inserted, or deleted by last command.", .retType=(uint)JSI_TT_NULL },
    { "close",          SqliteCloseCmd,         0,  0, "", .help="Close db", .retType=(uint)JSI_TT_VOID },
#ifndef OMIT_SQLITE_COLLATION
    { "collate",        SqliteCollateCmd,       2,  2, "name:string, callback:function", .help="Create new SQL collation command", .retType=(uint)JSI_TT_VOID },
    { "collation_needed",SqliteCollationNeededCmd,0,  1, "callback:null|function=void", .help="Set/get func to call on unknown collation", .retType=(uint)JSI_TT_FUNCTION },
#endif
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "commit_hook",    SqliteCommitHookCmd,    0,  1, "callback:null|function=void", .help="Set/get func to call on commit", .info=FN_commithook, .retType=(uint)JSI_TT_FUNCTION },
#endif
    { "complete",       SqliteCompleteCmd,      1,  1, "sql:string", .help="Return true if sql is complete", .retType=(uint)JSI_TT_BOOL },
    { "conf",           SqliteConfCmd,          0,  1, "options:string|object=void", .help="Configure options", .opts=SqlOptions, .retType=(uint)JSI_TT_ANY },
    { "enable_load_extension", SqliteEnableLoadCmd, 1,  1, "enable:boolean", .help="En/disable loading of extensions (default false)"},
    { "errorcode",      SqliteErrorCodeCmd,     0,  0, "", .help = "Return the numeric error code that was returned by the most recent call to sqlite3_exec()", .retType=(uint)JSI_TT_NULL },
    { "eval",           SqliteEvalCmd,          1,  1, "sql:string", .help="Run sql commands without input/output", .info=FN_evaluate },
    { "query",          SqliteQueryCmd,         1,  2, "sql:string, options:function|object=void", .help="Evaluate an sql query with bindings", .opts=ExecFmtOptions, .info=FN_sqlexec },
    { "exists",         SqliteExistsCmd,        1,  1, "sql:string", .help="Execute sql, and return true if there is at least one result value", .retType=(uint)JSI_TT_BOOL },
    { "filename",       SqliteFilenameCmd,      0,  1, "name:string='main'", .help="Return filename for named or all attached databases", .retType=(uint)JSI_TT_STRING },
    { "func",           SqliteFunctionCmd,      2,  3, "name:string, callback:function, numArgs:number=void", .help="Register a new function with database", .retType=(uint)JSI_TT_VOID },
    { "import",         SqliteImportCmd,        2,  3, "table:string, file:string, options:object=void", .help="Import data from file into table ", .info=FN_import, .opts=ImportOptions, .retType=(uint)JSI_TT_NUMBER },
    { "interrupt",      SqliteInterruptCmd,     0,  0, "", .help="Interrupt in progress statement", .retType=(uint)JSI_TT_VOID },
    { "lastInsert",     SqliteLastInsertCmd,    0,  0, "", .help="Return rowid of last insert", .retType=(uint)JSI_TT_NUMBER },
    { "onecolumn",      SqliteOnecolumnCmd,     1,  1, "sql:string", .help="Execute sql, and return a single value", .retType=(uint)JSI_TT_ANY },
    { "profile",        SqliteProfileCmd,       0,  1, "callback:null|function=void", .help="Set/get func to call on every SQL executed. Call args are: SQL,time", .info=FN_profile, .retType=(uint)JSI_TT_FUNCTION },
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "progress",       SqliteProgressCmd,      0,  2, "nth:number=void, callback:null|function=void", .help="Set/get func to call on every N VM opcodes executed", .retType=(uint)JSI_TT_FUNCTION },
#endif
    { "rekey",          SqliteRekeyCmd,         1,  1, "key:string", .help="Change the encryption key on the currently open database", .retType=(uint)JSI_TT_BOOL },
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "restore",        SqliteRestoreCmd,       1,  2, "file:string, dbname:string", .help="Restore db from file (default db is 'main')", .info=FN_restore, .retType=(uint)JSI_TT_VOID },
    { "rollback_hook",  SqliteRollbackHookCmd,  0,  1, "callback:null|function=void", .help="Set/get func to call on rollback", .retType=(uint)JSI_TT_FUNCTION },
    { "timeout",        SqliteTimeoutCmd,       1,  1, "millisecs:number", .help="Delay for the number of milliseconds specified when a file is locked"},
#endif
    { "total_changes",  SqliteTotalChangesCmd,  0,  0, "", .help="Return the number of rows that were modified, inserted, or deleted since db opened", .retType=(uint)JSI_TT_NUMBER },
    { "trace",          SqliteTraceCmd,         0,  1, "callback:null|function=void", .help="Set/get func to trace SQL: Call args are: SQL", .info=FN_trace, .retType=(uint)JSI_TT_FUNCTION },
    { "transaction",    SqliteTransactionCmd,   1,  2, "callback:function, type:string=void", .help="Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'", .info=FN_transaction, .retType=(uint)JSI_TT_VOID },
#ifndef OMIT_SQLITE_HOOK_COMMANDS
    { "update_hook",    SqliteUpdateHookCmd,    0,  1, "callback:null|function=void", .help="Set/get func to call on update: Call args are: OP,db,table,rowid", .retType=(uint)JSI_TT_FUNCTION },
    { "unlock_notify",  SqliteUnlockNotifyCmd,  0,  1, "callback:null|function=void", .help="Set/get func to call on unlock", .retType=(uint)JSI_TT_FUNCTION },
    { "wal_hook",       SqliteWalHookCmd,       0,  1, "callback:null|function=void", .help="Set/get func to call on wal commit: Call args are: db,numEntries", .retType=(uint)JSI_TT_FUNCTION },
#endif
    { "version",        SqliteVersionCmd,       0,  0, "", .help="Return database verion string", .retType=(uint)JSI_TT_STRING },
    { NULL, .help="Commands for accessing sqlite databases" }
};

#endif

typedef struct {
    Jsi_DbMultipleBind *binds;
    Jsi_OptionSpec *rowidPtr, *dirtyPtr;
    int optLen;             /* Length of binds[0].binds */
} OptionBind;

static int dbBindOptionStmt(Jsi_Db *jdb, _SQL_LITE_N_(_stmt) *pStmt, OptionBind *obPtr,
                            int dataIdx, int bmax, int flags)
{
    Jsi_DbMultipleBind *binds = obPtr->binds;
    Jsi_Interp *interp = jdb->interp;
    int j, k, cnt = 0, idx, sidx = -1, rc = 0;
    Jsi_OptionSpec *specPtr, *specs;
    void *rec;
    Jsi_DString *eStr;
    const char *bName;
    int lastBind = _SQL_LITE_N_(_bind_parameter_count)(pStmt);
    if (lastBind<=0)
        return JSI_OK;
    int structSize = 0;
    _SQL_LITE_N_(_destructor_type) statFlags = ((flags&JSI_DB_NO_STATIC)?_SQLITEN_(TRANSIENT):_SQLITEN_(STATIC));
    specPtr = binds[0].opts;
    structSize = specPtr[obPtr->optLen].size;
    
    for (j=1; j<=lastBind; j++) {
        bName = _SQL_LITE_N_(_bind_parameter_name)(pStmt, j);
        if (bName==NULL || bName[0]==0 || bName[1]==0)
            continue;
        idx = j;
        /*        if (bName[0] != '?')
                    idx = j;
                else {
                    idx = _SQL_LITE_N_(_bind_parameter_index)(pStmt, bName);
                    if (idx<=0)
                        continue;
                }*/
        if (binds[0].prefix==0)
            k = 0;
        else {
            for (k=0; binds[k].opts; k++) {
                if (bName[0] == binds[k].prefix)
                    break;
            }
            if (bmax>0 && k>=bmax)
                continue;
            if (!binds[k].opts) {
                Jsi_LogError("bad bind: %s", bName);
                continue;
            }
        }
        specs = binds[k].opts;
        rec = binds[k].data;
        if (k==0) {
            if (flags & JSI_DB_PTRS)
                rec = ((void**)rec)[dataIdx];
            else
                rec = (char*)rec + (dataIdx * structSize);
        }
        if (bName[0] == '?')
            sidx = atoi(bName+1);
        for (specPtr = specs, cnt=1; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END; specPtr++, cnt++) {
            if (specPtr->flags&JSI_OPT_DB_IGNORE)
                continue;
            if (bName[0] == '?') {
                if (cnt == sidx)
                    break;
            } else {
                const char *sName = specPtr->name;
                if (bName[1] == sName[0] && !Jsi_Strcmp(bName+1, sName))
                    break;
            }
        }
        if (specPtr->type<=JSI_OPTION_NONE || specPtr->type>=JSI_OPTION_END) {
            Jsi_LogError("unknown bind: %s", bName);
            return JSI_ERROR;
        }

        char *ptr = (char *)rec + specPtr->offset;
        switch (specPtr->type) {
        case JSI_OPTION_BOOL:
            rc = _SQL_LITE_N_(_bind_int)(pStmt, idx, *(int*)ptr);
            break;
        case JSI_OPTION_INT:
            rc = _SQL_LITE_N_(_bind_int64)(pStmt, idx, *(int*)ptr);
            break;
        case JSI_OPTION_TIMESTAMP:
            rc = _SQL_LITE_N_(_bind_int64)(pStmt, idx, (Jsi_Wide)*(time_t*)ptr);
            break;
        case JSI_OPTION_WIDE:
            rc = _SQL_LITE_N_(_bind_int64)(pStmt, idx, *(Jsi_Wide*)ptr);
            break;
        case JSI_OPTION_DATE:
        case JSI_OPTION_TIME:
        case JSI_OPTION_DATETIME:
        case JSI_OPTION_DOUBLE:
            rc = _SQL_LITE_N_(_bind_double)(pStmt, idx, *(Jsi_Number*)ptr);
            break;
        case JSI_OPTION_CUSTOM: {
            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
            if (cust && cust->formatProc) {
                Jsi_DString dStr;
                Jsi_DSInit(&dStr);
                if ((*cust->formatProc)(interp, specPtr, NULL, &dStr, rec) != JSI_OK) {
                    Jsi_DSFree(&dStr);
                    return JSI_ERROR;
                }
                rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, Jsi_DSValue(&dStr), -1, _SQLITEN_(TRANSIENT) _SQLBIND_END_);
                Jsi_DSFree(&dStr);
            } else {
                Jsi_LogError("missing or invalid custom for \"%s\"", specPtr->name);
                return JSI_ERROR;
            }
            break;
        }
        case JSI_OPTION_DSTRING:
            eStr = (Jsi_DString*)ptr;
            if (jdb->optPtr->nullvalue && !Jsi_Strcmp(jdb->optPtr->nullvalue, Jsi_DSValue(eStr)))
                rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, NULL, -1, statFlags _SQLBIND_END_);
            else
                rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, Jsi_DSValue(eStr), -1, statFlags _SQLBIND_END_);
            break;
        case JSI_OPTION_STRBUF:
            if (jdb->optPtr->nullvalue && ptr && !Jsi_Strcmp(jdb->optPtr->nullvalue, (char*)ptr))
                rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, NULL, -1, statFlags _SQLBIND_END_);
            else
                rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, (char*)ptr, -1, statFlags _SQLBIND_END_);
            break;
        case JSI_OPTION_STRKEY:
            rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, (char*)ptr, -1, _SQLITEN_(STATIC) _SQLBIND_END_);
            break;
#ifndef JSI_LITE_ONLY
        case JSI_OPTION_STRING:
            rc = _SQL_LITE_N_(_bind_text)(pStmt, idx, Jsi_ValueString(interp, *((Jsi_Value **)ptr), NULL), -1, statFlags _SQLBIND_END_);
            break;
#else
        case JSI_OPTION_STRING:
#endif
        case JSI_OPTION_VALUE: /* Unsupported. */
        case JSI_OPTION_VAR:
        case JSI_OPTION_OBJ:
        case JSI_OPTION_ARRAY:
        case JSI_OPTION_FUNC:
        case JSI_OPTION_END:
        case JSI_OPTION_NONE:
        default:
            Jsi_LogError("unsupported jdb option type \"%s\" for \"%s\"", Jsi_OptionTypeStr(specPtr->type, 0), specPtr->name);
            return JSI_ERROR;

        }
        if (rc != SQLITE_OK)
            Jsi_LogError("bind failure: %s", _SQL_LITE_N_(_errmsg)(jdb->db));
    }
    cnt++;
    return JSI_OK;
}

/* Prepare, bind, then step.
 * If there are results return JSI_OK. On error return JSI_ERROR;
 */
static int dbEvalStepOption(DbEvalContext *p, OptionBind *obPtr, int *cntPtr, int didx, int bmax, int flags, int *erc) {
    //Jsi_DbMultipleBind *binds = obPtr->binds;
    Jsi_Db *jdb = p->jdb;
    int cnt = 0;
    while( p->zSql[0] || p->pPreStmt ) {
        int rc;
        cnt++;
        if( p->pPreStmt==0 ) {
            rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);
            if( rc!=JSI_OK ) return rc;
        }
        if (bmax!=0) {
            rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, obPtr, didx, bmax, flags);
            if( rc!=JSI_OK ) return rc;
        }
        rc = dbEvalStepSub(p, 1, erc);
        if (rc != JSI_BREAK)
            return rc;
        *cntPtr = cnt;
    }
    
    /* Finished */
    return JSI_BREAK;
}

static Jsi_OptionSpec* dbLookupSpecFromName(Jsi_OptionSpec *specs, const char *name) {
    Jsi_OptionSpec *specPtr = NULL;
    for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END; specPtr++) {
        if  (specPtr->flags&JSI_OPT_DB_IGNORE)
            continue;
        const char *cname = (specPtr->extName?specPtr->extName:specPtr->name);
        if (cname[0] == name[0] && !Jsi_Strncasecmp(cname, name, -1))
            return specPtr;
    }
    return NULL;
}

const char* Jsi_DbKeyAdd(Jsi_Db *jdb, const char *str)
{
#ifndef JSI_LITE_ONLY
    if (jdb->interp)
        return Jsi_KeyAdd(jdb->interp, str);
#endif
    Jsi_HashEntry *hPtr;
    int isNew;
    hPtr = Jsi_HashEntryNew(jdb->strKeyTbl, str, &isNew);
    assert(hPtr) ;
    return (const char*)Jsi_HashKeyGet(hPtr);
}

static int dbOptSelect(Jsi_Db *jdb, const char *cmd, OptionBind *obPtr, int flags)
{
    Jsi_DbMultipleBind *binds = obPtr->binds;
    void *rec = binds[0].data, **recPtrPtr = NULL;
    Jsi_Interp *interp = jdb->interp;
    Jsi_OptionSpec *specPtr, *specs = binds[0].opts;
    DbEvalContext sEval = {};
    int ccnt = 0;
    const char *cPtr = strstr(cmd, " %s");
    if (!cPtr) cPtr = strstr(cmd, "\t%s");
    Jsi_DString *eStr;
#ifdef JSI_DB_DSTRING_SIZE
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
#else
    Jsi_DString sStr, *dStr = &sStr;
    Jsi_DSInit(dStr);
#endif
    dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0);
    if (flags&JSI_DB_NO_CACHE)
        sEval.nocache = 1;
    Jsi_DSAppendLen(dStr, cmd, cPtr?(cPtr-cmd):-1);
    if (cPtr) {
        Jsi_DSAppend(dStr, " ", NULL);
        for (specPtr = specs; specPtr->type>JSI_OPTION_NONE && specPtr->type < JSI_OPTION_END; specPtr++) {
            if (specPtr == obPtr->dirtyPtr || (specPtr->flags&JSI_OPT_DB_IGNORE))
                continue;
            if (ccnt)
                Jsi_DSAppendLen(dStr, ",", 1);
            Jsi_DSAppend(dStr, "[", specPtr->extName?specPtr->extName:specPtr->name, "]", NULL);
            ccnt++; 
        }
        Jsi_DSAppend(dStr, cPtr+3, NULL);
    }
    sEval.zSql = Jsi_DSValue(dStr);
    sEval.nocache = jdb->optPtr->nocache;
    int rc, erc = -1, structSize = 0;
    int cnt = 0, dmax = ((flags&JSI_DB_PTR_PTRS)?0:1);
    int multi = ((flags&JSI_DB_PTR_PTRS)!=0);
    int dnum = binds[0].numData;
    if (dnum<=0 && !(flags&JSI_DB_PTR_PTRS)) {
        dmax = dnum = 1;
    }
    if (dnum>1) {
        multi = 1;
        dmax = binds[0].numData;
    }
    if (flags&JSI_DB_PTR_PTRS) {
        recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */
        rec = *recPtrPtr;
    }
    structSize = specs[obPtr->optLen].size;

    cnt = 0;
    int ncnt = 0, bmax = -1, didx = -1;
    while(1) {
        didx++;
        if (didx>=dmax) {
            if (!(flags&JSI_DB_PTR_PTRS))
                break;
            else {
            /* Handle fully dynamic allocation of memory. */
#ifndef JSI_DB_MAXDYN_SIZE
#define JSI_DB_MAXDYN_SIZE 100000000
#endif
#ifndef JSI_DB_DYN_INCR
#define JSI_DB_DYN_INCR 16
#endif
                if (dmax>=JSI_DB_MAXDYN_SIZE)
                    break;
                int olddm = dmax;
                dmax += JSI_DB_DYN_INCR;
                if (dmax>JSI_DB_MAXDYN_SIZE)
                    dmax = JSI_DB_MAXDYN_SIZE;
                if (!olddm)
                    rec = Jsi_Calloc(dmax+1, sizeof(void*));
                else {
                    rec = Jsi_Realloc(rec, (dmax+1)*sizeof(void*));
                    memset((char*)rec+olddm*sizeof(void*), 0, (dmax-olddm+1)*sizeof(void*));
                }
                *recPtrPtr = rec;
            }
        }

        rc = dbEvalStepOption(&sEval, obPtr, &ncnt, didx, bmax, flags, &erc);
        if (rc == JSI_ERROR)
            break;
        if (rc != JSI_OK)
            break;
        cnt += ncnt;
        _SQL_LITE_N_(_stmt) *pStmt = sEval.pPreStmt->pStmt;
        int idx;
        int nCol;
        char **apColName;
        const char *str;
        int *apColType;
        void *prec = rec;
        bmax = 0;

        if (flags & (JSI_DB_PTR_PTRS|JSI_DB_PTRS)) {
            prec = ((void**)rec)[didx];
            if (!prec)
                ((void**)rec)[didx] = prec = Jsi_Calloc(1, structSize);
        } else
                prec = (char*)rec + (didx * structSize);
        dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
        for (idx=0; idx<nCol; idx++) {
            specPtr = dbLookupSpecFromName(specs, apColName[idx]);
            if (!specPtr) {
                Jsi_LogError("unknown column name: %s", apColName[idx]);
                goto bail;
            }          
            if (specPtr->type<=JSI_OPTION_NONE || specPtr->type>=JSI_OPTION_END) {
                Jsi_LogError("unknown option type \"%d\" for \"%s\"", specPtr->type, specPtr->name);
                goto bail;
            }
            char *ptr = (char*)prec + specPtr->offset;

            switch (specPtr->type) {
                case JSI_OPTION_BOOL:
                    *(int*)ptr = _SQL_LITE_N_(_column_int)(pStmt, idx);
                    break;
                case JSI_OPTION_INT:
                    *(int*)ptr = (int)_SQL_LITE_N_(_column_int64)(pStmt, idx);
                    break;
                case JSI_OPTION_TIMESTAMP:
                    *(time_t*)ptr = (time_t)_SQL_LITE_N_(_column_int64)(pStmt, idx);
                    break;
                case JSI_OPTION_WIDE:
                    *(Jsi_Wide*)ptr = (Jsi_Wide)_SQL_LITE_N_(_column_int64)(pStmt, idx);
                    break;
                case JSI_OPTION_DATE:
                case JSI_OPTION_TIME:
                case JSI_OPTION_DATETIME:
                case JSI_OPTION_DOUBLE:
                    *(Jsi_Number*)ptr = (Jsi_Number)_SQL_LITE_N_(_column_double)(pStmt, idx);
                    break;
                case JSI_OPTION_DSTRING:
                    eStr = (Jsi_DString*)ptr;
                    str = (char*)_SQL_LITE_N_(_column_text)(pStmt, idx _SQLBIND_END_);
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    Jsi_DSSet(eStr, str?str:"");
                    break;
                case JSI_OPTION_STRBUF:
                    str = (char*)_SQL_LITE_N_(_column_text)(pStmt, idx _SQLBIND_END_);
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    strncpy((char*)ptr, str?str:"", specPtr->size);
                    ((char*)ptr)[specPtr->size-1] = 0;
                    break;
                case JSI_OPTION_CUSTOM: {
                    Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);
                    if (cust && cust->parseProc) {
                        str = (char*)_SQL_LITE_N_(_column_text)(pStmt, idx _SQLBIND_END_);
                        if ((*cust->parseProc)(interp, specPtr, NULL, str, prec) != JSI_OK) {
                            goto bail;
                        }
                    } else {
                        Jsi_LogError("missing or invalid custom for \"%s\"", specPtr->name);
                        goto bail;
                    }
                    break;
                }
                case JSI_OPTION_STRKEY:
                    str = (char*)_SQL_LITE_N_(_column_text)(pStmt, idx _SQLBIND_END_);
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    *(char**)ptr = (str?(char*)Jsi_DbKeyAdd(jdb, str):NULL);
                    break;
#ifndef JSI_LITE_ONLY
                case JSI_OPTION_STRING: {
                    Jsi_Value *vPtr = *((Jsi_Value **)ptr);
                    if (!(flags&JSI_OPT_NO_DUPVALUE)) {
                        if (vPtr) Jsi_DecrRefCount(interp, vPtr);
                        *((Jsi_Value **)ptr) = NULL;
                    }
                    str = (char*)_SQL_LITE_N_(_column_text)(pStmt, idx _SQLBIND_END_);
                    if (!str)
                        str = jdb->optPtr->nullvalue;
                    if (str) {
                        vPtr = Jsi_ValueNewStringDup(interp, str);
                        *((Jsi_Value **)ptr) = vPtr;
                    }
                    break;
                }
#else
                case JSI_OPTION_STRING:        
#endif
                case JSI_OPTION_VALUE: /* The rest are unsupported. */
                case JSI_OPTION_VAR:
                case JSI_OPTION_OBJ:
                case JSI_OPTION_ARRAY:
                case JSI_OPTION_FUNC:
                
                case JSI_OPTION_END:
                case JSI_OPTION_NONE:
                default:
                    JSI_DBQUERY_PRINTF( "unsupported type: %s\n", Jsi_OptionTypeStr(specPtr->type, 0));
                    break;
            }
        }
        if (binds[0].callback)
            binds[0].callback(interp, binds, prec);
        cnt++;
        if (!multi)
            break;
    }
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    return (rc==JSI_OK?cnt:erc);

bail:
    dbEvalFinalize(&sEval);
    return erc;
}

static int jsi_DbExecBinds(Jsi_Db *jdb, Jsi_DbMultipleBind *binds, const char *cmd, int flags)
{
    int k, cnt, erc = -1;
    OptionBind ob = {.binds = binds};
    Jsi_OptionSpec *specPtr, *specs;
    Jsi_Interp *interp = jdb->interp;
    if (!cmd) cmd="";
    if (cmd[0]==';') {
        if (!dbExecCmd(jdb, cmd+1, &erc)) {
            Jsi_LogError("EXEC ERROR=\"%s\", SQL=\"%s\"\n", _SQL_LITE_N_(_errmsg)(jdb->db), cmd);
            return erc;
        }
        return 0;
    }
    const char *cPtr = strstr(cmd, " %s");
    if (!cPtr) cPtr = strstr(cmd, "\t%s");
    if (!binds) {
        Jsi_LogError("binds may not be null");
        return -1;
    }
    if (!binds[0].data) {
        Jsi_LogError("data may not be null");
        return -1;
    }
    for (k=0; binds[k].opts; k++) {
        if (binds[k].numData>1 || k==0) {
            int scnt = 0;
            for (specPtr = binds[k].opts, scnt=0; specPtr->type>JSI_OPTION_NONE
                && specPtr->type < JSI_OPTION_END; specPtr++, scnt++) {
                if (specPtr->flags&JSI_OPT_DB_IGNORE)
                    continue;
                if (k==0) {
                    if (specPtr->flags&JSI_OPT_DB_ROWID) {
                        if (specPtr->type != JSI_OPTION_WIDE) {
                            Jsi_LogError("rowid flag must be a wide field: %s", specPtr->name);
                            return -1;
                        }
                        ob.rowidPtr = specPtr;
                    }
                    if (specPtr->flags&JSI_OPT_DB_DIRTY) {
                        if (specPtr->type == JSI_OPTION_BOOL || specPtr->type == JSI_OPTION_INT) {
                            ob.dirtyPtr = specPtr;
                        } else {
                            Jsi_LogError("dirty flag must be a int/bool field: %s", specPtr->name);
                            return -1;
                        }
                    }
                            
                }
            }
            if (k==0)
                ob.optLen = scnt;
            assert(specPtr->type == JSI_OPTION_END);
        }
    }
    specs = binds[0].opts;
    int structSize = specs[ob.optLen].size;
    if (flags & (JSI_DB_MEMCLEAR|JSI_DB_MEMFREE)) {
        cnt = binds[0].numData;
        void *rec = binds[0].data, *prec = rec;
        void **recPtrPtr = NULL;
        if (flags&JSI_DB_PTR_PTRS) {
            recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */
            rec = *recPtrPtr;
        }
        if (cnt<=0 && rec && flags&JSI_DB_PTR_PTRS) {
            for (cnt=0; ((void**)rec)[cnt]!=NULL; cnt++);
        }
        for (k=0; k<cnt; k++) {
            if (flags & (JSI_DB_PTRS|JSI_DB_PTR_PTRS))
                prec = ((void**)rec)[k];
            else
                prec = (char*)rec + (k * structSize);
            if (!prec)
                continue;
            Jsi_OptionsFree(interp, specs, prec, 0);
            if (flags & (JSI_DB_PTRS|JSI_DB_PTR_PTRS)) {
                Jsi_Free(prec);
            }
        }
        if (recPtrPtr) {
            Jsi_Free(*recPtrPtr);
            *recPtrPtr = NULL;
        }
        if (cmd == NULL || cmd[0] == 0)
            return 0;
    }
    
    if (!Jsi_Strncasecmp(cmd, "SELECT", 6))
        return dbOptSelect(jdb, cmd, &ob, flags);
        
    DbEvalContext sEval = {};
    int insert = 0, replace = 0, update = 0;
    char nbuf[100], *bPtr;
#ifdef JSI_DB_DSTRING_SIZE
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
#else
    Jsi_DString sStr, *dStr = &sStr;
    Jsi_DSInit(dStr);
#endif
    if (flags&JSI_DB_NO_CACHE)
        sEval.nocache = 1;
    if (dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0) != JSI_OK)
        return -1;
    int dmax = binds[0].numData;
    if (dmax<0) {
        Jsi_LogError("Data size of < 0 is valid only for SELECT");
        return -1;
    }
    cnt = 0;
    if (dmax==0)
        dmax = 1;
    char ch[2];

    ch[0] = binds[0].prefix;
    ch[1] = 0;
    if (!ch[0])
        ch[0] = ':';
    if ((update=(Jsi_Strncasecmp(cmd, "UPDATE", 6)==0))) {
        Jsi_DSAppendLen(dStr, cmd, cPtr?(cPtr-cmd):-1);
        if (cPtr) {
            Jsi_DSAppend(dStr, " ", NULL);
            int cidx = 0;
            int killf = (JSI_OPT_DB_IGNORE|JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);
            for (specPtr = specs; specPtr->type != JSI_OPTION_END; specPtr++, cidx++) {
                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || (specPtr->flags&killf))
                    continue;
                const char *fname = specPtr->extName?specPtr->extName:specPtr->name;
                if (ch[0] == '?')
                    sprintf(bPtr=nbuf, "%d", cidx+1);
                else
                    bPtr = (char*)specPtr->name;
                Jsi_DSAppend(dStr, (cnt?",":""), "[", fname, "]=",
                    ch, bPtr, NULL);
                cnt++;
            }
            Jsi_DSAppend(dStr, cPtr+3, NULL);
        }
    } else if ((insert=(Jsi_Strncasecmp(cmd, "INSERT", 6)==0))
        || (replace=(Jsi_Strncasecmp(cmd, "REPLACE", 7)==0))) {
        Jsi_DSAppendLen(dStr, cmd, cPtr?(cPtr-cmd):-1);
        if (cPtr) {
            Jsi_DSAppend(dStr, " (", NULL);
            int killf = JSI_OPT_DB_IGNORE;
            if (replace)
                killf |= (JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);
            for (specPtr = specs; specPtr->type != JSI_OPTION_END; specPtr++) {
                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || specPtr->flags&killf)
                    continue;
                const char *fname = specPtr->extName?specPtr->extName:specPtr->name;
                Jsi_DSAppend(dStr, (cnt?",":""), "[", fname, "]", NULL);
                cnt++;
            }
            Jsi_DSAppendLen(dStr,") VALUES(", -1);
            cnt = 0;
            int cidx = 0;
            for (specPtr = specs; specPtr->type != JSI_OPTION_END; specPtr++, cidx++) {
                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr
                    || specPtr->flags&killf)
                    continue;
                if (ch[0] == '?')
                    sprintf(bPtr=nbuf, "%d", cidx+1);
                else
                    bPtr = (char*)specPtr->name;
                Jsi_DSAppend(dStr, (cnt?",":""), ch, bPtr, NULL);
                cnt++;
            }
            Jsi_DSAppend(dStr,")", cPtr+3, NULL);
        }
    } else if (!Jsi_Strncasecmp(cmd, "DELETE", 6)) {
        Jsi_DSAppend(dStr, cmd, NULL);
    } else {
        Jsi_LogError("unrecognized cmd \"%s\": expected one of: SELECT, UPDATE, INSERT, REPLACE or DELETE", cmd);
        return -1;
    }
    sEval.zSql = Jsi_DSValue(dStr);

    int rc, bmax = -1, didx = 0;
    cnt = 0;
    int ismodify = (replace||insert||update);
    int isnew = (replace||insert);
    int didBegin = 0;
    DbEvalContext *p = &sEval;
    rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);
    if( rc!=JSI_OK ) return -1;
    if (dmax>1 && !(flags&JSI_DB_NO_BEGINCOMMIT)) {
        didBegin = 1;
        if (!dbExecCmd(jdb, JSI_DBQUERY_BEGIN_STR, &erc))
            goto bail;
    }
    while (didx<dmax) {
        if (ismodify && ob.dirtyPtr && (flags&JSI_DB_DIRTY_ONLY)) { /* Check to limit updates to dirty values only. */
            void *rec = binds[0].data;
            if (flags & (JSI_DB_PTRS|JSI_DB_PTR_PTRS))
                rec = ((void**)rec)[didx];
            else
                rec = (char*)rec + (didx * structSize);
            char *ptr = (char*)(rec + ob.dirtyPtr->offset);
            int isDirty = *(int*)ptr;
            int bit = 0;
            if (ob.dirtyPtr->type == JSI_OPTION_BOOL)
                bit = (int)ob.dirtyPtr->data;
            if (!(isDirty&(1<<(bit)))) {
                didx++;
                continue;
            }
            isDirty &= ~(1<<(bit));
            *(int*)ptr = isDirty; /* Note that the dirty bit is cleared, even upon error.*/
        }
        rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, &ob, didx, bmax, flags);
        if( rc!=JSI_OK )
            goto bail;
        bmax = 1;
        rc = dbEvalStepSub(p, (didx>=dmax), &erc);
        if (rc == JSI_ERROR)
            goto bail;
        cnt += _SQL_LITE_N_(_changes)(jdb->db);
        if (rc != JSI_OK && rc != JSI_BREAK)
            break;
        if (ob.rowidPtr && isnew) {
            void *rec = binds[0].data;
            if (flags & (JSI_DB_PTRS|JSI_DB_PTR_PTRS))
                rec = ((void**)rec)[didx];
            else
                rec = (char*)rec + (didx * structSize);
            char *ptr = (char*)(rec + ob.rowidPtr->offset);
            *(Jsi_Wide*)ptr = dbLastInsertRowid(jdb);
        }
        didx++;
    }
    if (didBegin && !dbExecCmd(jdb, JSI_DBQUERY_COMMIT_STR, &erc))
        rc = JSI_ERROR;
    dbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    return (rc==JSI_OK?cnt:erc);

bail:
    dbEvalFinalize(&sEval);
    if (didBegin)
        dbExecCmd(jdb, JSI_DBQUERY_ROLLBACK_STR, NULL);
    return erc;
}

int
Jsi_DbQuery(Jsi_Db *jdb, Jsi_OptionSpec *specs, void *data, int numData, const char *query, int flags)
{
    Jsi_DbMultipleBind binds[2] = {
        {.opts=specs, .data=data, .numData=numData},
        {}
    };
    int rc = jsi_DbExecBinds(jdb, (specs?binds:(Jsi_DbMultipleBind*)data), query, flags);
#ifdef JSI_DBQUERY_ERRORCMD
    if (rc<0)
        rc = JSI_DBQUERY_ERRORCMD(jdb, specs, data, numData, query, flags, rc);
#endif
    return rc;
}

void *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)
{
    SQLSIGASSERT(jdb,DB);
    return jdb->db;
}

/* This is the non-script, JSI_LITE_ONLY creator for Jsi_Db */
Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)
{
    char *zErrMsg;
    Jsi_ListAttr attr = {};
#ifdef JSI_LITE_ONLY
    if (0) { /* Hack to get rid of compiler warnings. */
        const char **ee = execFmtStrs;
        ee = mtxStrs;
        ee = trcModeStrs;
        ee = ee;
    }
#endif
    int flags = _SQLITEN_(OPEN_READWRITE) | _SQLITEN_(OPEN_CREATE);
#ifndef USE_SQLITE_V4
#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX
    flags |= _SQLITEN_(OPEN_FULLMUTEX);
#else
    flags |= _SQLITEN_(OPEN_NOMUTEX);
#endif
#endif

    if (!zFile)
        zFile = ":memory:";
    zErrMsg = 0;
    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );
    if( db==0 ) {
        JSI_DBQUERY_PRINTF( "malloc failed\n");
        return NULL;
    }
    db->sig = SQLITE_SIG_DB;
    db->maxStmts = NUM_PREPARED_STMTS;
    db->optPtr = &db->queryOpts;

    if (inFlags&JSI_DBI_READONLY) {
        flags &= ~(_SQLITEN_(OPEN_READWRITE)|_SQLITEN_(OPEN_CREATE));
        flags |= _SQLITEN_(OPEN_READONLY);
    } else {
        flags &= ~_SQLITEN_(OPEN_READONLY);
        flags |= _SQLITEN_(OPEN_READWRITE);
        if (inFlags&JSI_DBI_NOCREATE) {
            flags &= ~_SQLITEN_(OPEN_CREATE);
        }
    }
#ifndef USE_SQLITE_V4
    if(inFlags&JSI_DBI_NO_MUTEX) {
        flags |= _SQLITEN_(OPEN_NOMUTEX);
        flags &= ~_SQLITEN_(OPEN_FULLMUTEX);
    } else {
        flags &= ~_SQLITEN_(OPEN_NOMUTEX);
    }
    if(inFlags&JSI_DBI_FULL_MUTEX) {
        flags |= _SQLITEN_(OPEN_FULLMUTEX);
        flags &= ~_SQLITEN_(OPEN_NOMUTEX);
    } else {
        flags &= ~_SQLITEN_(OPEN_FULLMUTEX);
    }
#endif
    char cpath[PATH_MAX];
    char *npath = Jsi_FileRealpathStr(NULL, zFile, cpath);
    
    if (SQLITE_OK != _SQL_LITE_N_(_open_v2)(npath, &db->db, flags, NULL)) {
        JSI_DBQUERY_PRINTF( "db open failed\n");
        goto bail;
    }
    //Jsi_DSFree(&translatedFilename);

    if( SQLITE_OK!=_SQL_LITE_N_(_errcode)(db->db) ) {
        zErrMsg = _SQL_LITE_N_(_mprintf)(_SQLITE_PENV_(db) "%s", _SQL_LITE_N_(_errmsg)(db->db));
        DbClose(db->db);
        db->db = 0;
    }
    if( db->db==0 ) {
        JSI_DBQUERY_PRINTF( "Db open failed %s\n", zErrMsg);
#ifdef USE_SQLITE_V4
        _SQL_LITE_N_(_free)(db->pEnv, zErrMsg);
#else
        _SQL_LITE_N_(_free)(zErrMsg);
#endif
        goto bail;
    }
    db->stmtHash = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);
    db->strKeyTbl = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);
    attr.data=(void*)db;
    attr.freeProc=dbStmtFreeProc;
    db->stmtCache = Jsi_ListNew(&attr);
    return db;
    
bail:
    return NULL;
}


#ifndef JSI_LITE_ONLY

int Jsi_DoneSqlite(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &sqliteobject);
    return JSI_OK;
}
#ifdef JSI_DB_TEST
#include "c-demos/dbdemo.c"
#endif

int Jsi_InitSqlite(Jsi_Interp *interp)
{
    Jsi_Hash* dbSys;
#ifdef JSI_USE_STUBS
  if (Jsi_StubsInit(interp, 0) != JSI_OK)
    return JSI_ERROR;
#endif
    if (!(dbSys = Jsi_UserObjRegister(interp, &sqliteobject))) {
        Jsi_LogError("Failed to init sqlite extension");
        return JSI_ERROR;
    }
    if (!Jsi_CommandCreateSpecs(interp, sqliteobject.name, sqliteCmds, dbSys, 0))
        return JSI_ERROR;
#ifdef JSI_DB_TEST
    if (getenv("RUN_DB_TEST"))
        TestSqlite(interp);
#endif
    return JSI_OK;
}
#endif

#else
/* Linking placeholders for when Sqlite is not compiled-in. */
int
Jsi_DbQuery(Jsi_Db *jdb, Jsi_OptionSpec *specs, void *data, int numData, const char *cmd, int flags)
{
    printf( "Sqlite unsupported\n");
    return -1;
}

void *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)
{
    printf( "Sqlite unsupported\n");
    return NULL;
}

Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)
{
    printf( "Sqlite unsupported\n");
    return NULL;
}
    
#endif
#ifndef JSI_LITE_ONLY
#ifdef HAVE_WEBSOCKET
#ifdef JSI_MEM_DEBUG
#include "jsiInt.h"
#else

#ifndef JSI_AMALGAMATION
#include "jsi.h"
#endif
JSI_EXTENSION_INI

#define jsi_Sig int

#ifndef __WIN32
#include <time.h>
#include <sys/time.h>
#endif /* !__WIN32 */
#endif /* JSI_MEM_DEBUG */

#include <ctype.h>

#ifdef CMAKE_BUILD
#include "lws_config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <assert.h>
#ifdef WIN32
#define _GET_TIME_OF_DAY_H
#ifdef EXTERNAL_POLL
    #ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #endif
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #include <stddef.h>

    #include "websock-w32.h"
#endif

#else /* WIN32 */
#include <syslog.h>
#include <unistd.h>
#endif /* WIN32 */

#include <signal.h>

#include <libwebsockets.h>

static Jsi_CmdSpec websockCmds[];

#ifdef EXTERNAL_POLL
static int max_poll_elements;
static struct pollfd *pollfds;
static int *fd_lookup;
static int count_pollfds;
static int force_exit = 0;
#endif /* EXTERNAL_POLL */

typedef enum {  PWS_DEAD, PWS_HTTP, PWS_CONNECTED, PWS_RECV, PWS_SENT, PWS_SENDERR } pws_state;
enum { JWS_SIG_SYS=0xdeadbeea, JWS_SIG_OBJ, JWS_SIG_PWS };

#ifndef NDEBUG
#ifndef MEMCLEAR
#define MEMCLEAR(s) memset(s, 0, sizeof(*s));
#endif
#else
#define MEMCLEAR(s)
#endif
#define WSSIGASSERT(s,n) assert(s->sig == JWS_SIG_##n)

enum demo_protocols {
    /* always first */
    PROTOCOL_HTTP = 0,
    PROTOCOL_JSI,
    /* always last */
    DEMO_PROTOCOL_COUNT
};

typedef struct { /* Interp wide data. */
    int sig;
    Jsi_Interp *interp;
    Jsi_Hash *wsTable;
    int wIdx;
} WebSocketObjInterpData;

typedef struct { /* Per server (or client) data. */
    int sig;
    WebSocketObjInterpData *interpData;
    Jsi_Interp *interp;
    Jsi_Hash *pssTable;
    Jsi_Value *callback;
    Jsi_Value *onCloseLast;
    Jsi_Value *onClose;
    Jsi_Value *onConnect;
    Jsi_Value *onOpen;
    Jsi_Value *defaultUrl;
    Jsi_Value *rootdir;
    Jsi_Value *interface;
    Jsi_Value *address;
    Jsi_Value *mimeTypes;
    char client_name[128];
    char client_ip[128];
    int idx;
    int port;
    char *iface;
    unsigned int oldus;
    Jsi_Bool client;
    Jsi_Bool noUpdate;
    Jsi_Bool noWebsock;
    Jsi_Bool noWarn;
    Jsi_Bool use_ssl;
    int opts;
    int hasOpts;
    int debug;
    int maxConnects;
    int daemonize;
    int deleted;
    int close_test;
    int connectCnt;
    int createCnt;
    int redirCnt;
    time_t createLast;
    time_t startTime;
    char *cmdName;
    struct libwebsocket *wsi_choked[20];
    int num_wsi_choked;
    struct libwebsocket *wsi;

    struct libwebsocket_context *context;
    struct lws_context_creation_info info;
    Jsi_Event *event;
    Jsi_Obj *fobj;
    Jsi_Hash *handlers;
    int objId;
    struct libwebsocket_protocols protocols[DEMO_PROTOCOL_COUNT+1];
    int ietf_version;
    int rx_buffer_size;
    char *ssl_cert_filepath;
    char *ssl_private_key_filepath;
    int ws_uid;
    int ws_gid;
    char *cl_host;
    char *cl_origin;
} WebSocketObj;

typedef struct { /* Per session connection (to each server) */
    int sig;
    WebSocketObj *cmdPtr;
    pws_state state;
    int sentCnt, recvCnt, sentErrCnt, httpCnt;
    time_t sentLast, recvLast, sentErrLast, httpLast;
    struct libwebsocket *wsi;
    Jsi_HashEntry *hPtr;
    void *user;
    Jsi_Stack *stack;
    int id;
} WebSocketPss;

#define IIOF .flags=JSI_OPT_INIT_ONLY

static Jsi_OptionSpec WPSOptions[] =
{
    JSI_OPT(INT,        WebSocketPss, httpCnt,      .help="Number of http reqs", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(TIMESTAMP,   WebSocketPss, httpLast,     .help="Time of last http reqs", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,        WebSocketPss, recvCnt,      .help="Number of recieves", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(TIMESTAMP,   WebSocketPss, recvLast,     .help="Time of last recv", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,        WebSocketPss, sentCnt,      .help="Number of sends", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(TIMESTAMP,   WebSocketPss, sentLast,     .help="Time of last send", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(INT,        WebSocketPss, sentErrCnt,   .help="Number of sends", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(TIMESTAMP,   WebSocketPss, sentErrLast,  .help="Time of last sendErr", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT_END(WebSocketPss)
};

static Jsi_OptionSpec WSOptions[] =
{
    JSI_OPT(INT,    WebSocketObj, connectCnt, .help="Number of active connections", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(VALUE,  WebSocketObj, address,    .help="Address for client to connect to", .init="127.0.0.0" ),
    JSI_OPT(FUNC,   WebSocketObj, callback,   .help="Function to callback when event occurs"),
    JSI_OPT(BOOL,   WebSocketObj, client,     .help="Run in client mode", IIOF),
    JSI_OPT(INT,    WebSocketObj, debug,      .help="Set debug level"),
    JSI_OPT(VALUE,  WebSocketObj, defaultUrl, .help="Default url to serve out", .init="."),
    JSI_OPT(VALUE,  WebSocketObj, interface,  .help="Interface for server to listen on, eg. 'eth0' or 'lo'", IIOF),
    JSI_OPT(INT,    WebSocketObj, maxConnects,.help="In server mode, max number of client connections accepted"),
    JSI_OPT(VALUE,  WebSocketObj, mimeTypes,  .help="Map of file extensions to mime types (eg. {txt:'text/plain', bb:'text/bb'})", IIOF),
    JSI_OPT(BOOL,   WebSocketObj, noUpdate,   .help="Stop processing update events (eg. to exit)"),
    JSI_OPT(BOOL,   WebSocketObj, noWebsock,  .help="Serve html, but disallow websockets", IIOF),
    JSI_OPT(BOOL,   WebSocketObj, noWarn,     .help="Quietly ignore file not found"),
    JSI_OPT(FUNC,   WebSocketObj, onClose,    .help="Function to call when connection closes"),
    JSI_OPT(FUNC,   WebSocketObj, onCloseLast,.help="Function to call when last connection closes"),
    JSI_OPT(FUNC,   WebSocketObj, onConnect,  .help="Function to call when connection starts (return false to kill)"),
    JSI_OPT(FUNC,   WebSocketObj, onOpen,     .help="Function to call when connection opens"),
    JSI_OPT(INT,    WebSocketObj, port,       .help="Port for server to listen on", IIOF, .init="8080" ),
    JSI_OPT(VALUE,  WebSocketObj, rootdir,    .help="Directory to serve html from", .init="."),
    JSI_OPT(TIMESTAMP,  WebSocketObj, startTime,     .help="Time started", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(BOOL,   WebSocketObj, use_ssl,    .help="Use https (for client)", IIOF),
    JSI_OPT_END(WebSocketObj)
};

static int websocketObjFree(Jsi_Interp *interp, void *data);
static int websocketObjIsTrue(void *data);
static int websocketObjEqual(void *data1, void *data2);

static Jsi_UserObjReg websockobject = {
    "WebSocket",
    websockCmds,
    websocketObjFree,
    websocketObjIsTrue,
    websocketObjEqual
};

/* this protocol server (always the first one) just knows how to do HTTP */

static int callback_http(struct libwebsocket_context *context,
        struct libwebsocket *wsi,
        enum libwebsocket_callback_reasons reason, void *user,
        void *in, size_t len);

static int
callback_jsi_protocol(struct libwebsocket_context *context,
      struct libwebsocket *wsi,
      enum libwebsocket_callback_reasons reason,
      void *user, void *in, size_t len);

#if 0
/* list of supported protocols and callbacks */
static struct libwebsocket_protocols protocols[] = {
    /* first protocol must always be HTTP handler */

    {
        .name="http-only",
        .callback=callback_http,
        .per_session_data_size=0,
        .rx_buffer_size=0,          /* max frame size / rx buffer */
    },
    {
        .name="jsi-protocol",
        .callback=callback_jsi_protocol,
        .per_session_data_size=sizeof(WebSocketPss),
        .rx_buffer_size=50000,
    },

    { NULL, NULL, 0, 0 } /* terminator */
};
#endif

static WebSocketPss*
getPss(WebSocketObj *cmdPtr, struct libwebsocket *wsi, void *user, int create)
{
    Jsi_HashEntry *hPtr;
    int isNew;
    WebSocketPss *pss = (WebSocketPss*)user;
    if (user==NULL)
        return NULL;
    if (create)
        hPtr = Jsi_HashEntryNew(cmdPtr->pssTable, user, &isNew);
    else
        hPtr = Jsi_HashEntryFind(cmdPtr->pssTable, user);
    if (!hPtr)
        return NULL;
    if (create == 0 || isNew == 0) {
        WSSIGASSERT(pss, PWS);
        return pss;
    }
    memset(pss, 0, sizeof(*pss));
    pss->sig = JWS_SIG_PWS;
    pss->hPtr = hPtr;
    cmdPtr->connectCnt++;
    cmdPtr->createCnt++;
    cmdPtr->createLast = time(NULL);
    Jsi_HashValueSet(hPtr, pss);
    pss->cmdPtr = cmdPtr;
    pss->wsi = wsi;
    pss->user = user; /* Same as pss. */
    pss->state = PWS_CONNECTED;
    pss->id = cmdPtr->idx++;
    pss->stack = Jsi_StackNew();
    return pss;
}

static int DelPss(Jsi_Interp *interp, void *data) { Jsi_Free(data); return JSI_OK; }

static void
deletePss(WebSocketPss *pss)
{
    if (pss->hPtr) {
        Jsi_HashEntryDelete(pss->hPtr);
        pss->hPtr = NULL;
    }
    Jsi_StackFreeElements(pss->cmdPtr->interp, pss->stack, DelPss);
    Jsi_StackFree(pss->stack);
    pss->cmdPtr->connectCnt--;
    /*Jsi_ObjDecrRefCount(pss->msgs);*/
    pss->state = PWS_DEAD;
}

static int ServeString(WebSocketObj *cmdPtr, struct libwebsocket *wsi,
    const char *buf, int code, const char *reason, const char *mime)
{
    int rc, strLen = Jsi_Strlen(buf);
    Jsi_DString jStr = {};
    Jsi_DSPrintf(&jStr,
        "HTTP/1.0 %d %s\x0d\x0a"
        "Server: libwebsockets\x0d\x0a"
        "Content-Type: %s\x0d\x0a"
        "Content-Length: %u\x0d\x0a\x0d\x0a",
        (code<=0?200:code), (reason?reason:"OK"),
        (mime?mime:"text/html"),
        strLen);
    Jsi_DSAppend(&jStr, buf, NULL);
    char *vStr = Jsi_DSValue(&jStr);
    rc = libwebsocket_write(wsi, (unsigned char*)vStr, Jsi_Strlen(vStr), LWS_WRITE_HTTP);
    Jsi_DSFree(&jStr);
    return rc;
}

static int callback_http(struct libwebsocket_context *context,
                         struct libwebsocket *wsi,
                         enum libwebsocket_callback_reasons reason, void *user,
                         void *in, size_t len)
{
    char buf[BUFSIZ];
    char *ext = NULL, *inPtr = (char*)in;
    // int n;
#ifdef EXTERNAL_POLL
    int m;
    int fd = (int)(long)user;
#endif
    WebSocketObj *cmdPtr = (WebSocketObj *)libwebsocket_context_user(context);
    Jsi_Interp *interp = cmdPtr->interp;
    int rc = 0;

    buf[0] = 0;
    WSSIGASSERT(cmdPtr, OBJ);
    switch (reason) {
    case LWS_CALLBACK_PROTOCOL_INIT:
        break;
    case LWS_CALLBACK_FILTER_NETWORK_CONNECTION:
        if (cmdPtr->maxConnects && cmdPtr->connectCnt>=cmdPtr->maxConnects) {
            if (cmdPtr->debug)
                fprintf(stderr, "maxConnects exceeded: rejecting connection <%p>\n", user);
            rc = -1;
        }
        /* if we returned non-zero from here, we kill the connection */
        break;

    case LWS_CALLBACK_HTTP:
    {
        const char *mime = "text/html";
        if (cmdPtr->defaultUrl && (*inPtr == 0 || !strcmp(inPtr, "/")) && cmdPtr->redirCnt++ < 1000) {
            /* Redirect to defaultUrl. */
            inPtr = Jsi_ValueString(cmdPtr->interp, cmdPtr->defaultUrl, NULL);
            if (inPtr) {
                snprintf(buf, sizeof(buf), "<head><meta http-equiv=\"refresh\" content=\"1; url=%s\" /></head><body>Redirecting...</body>", inPtr);
                rc = ServeString(cmdPtr, wsi, buf, 0, NULL, NULL);
                break;
            }
        }
        if (inPtr) {
            ext = strrchr(inPtr, '.');
        }

        snprintf(buf, sizeof(buf), "%s/%s",
             cmdPtr->rootdir?Jsi_ValueString(cmdPtr->interp, cmdPtr->rootdir, NULL):"./", inPtr);
        if (ext) {
            Jsi_HashEntry *hPtr;

            if (Jsi_Strncasecmp(ext,".png", -1) == 0) mime = "image/png";
            else if (Jsi_Strncasecmp(ext,".ico", -1) == 0) mime = "image/icon";
            else if (Jsi_Strncasecmp(ext,".gif", -1) == 0) mime = "image/gif";
            else if (Jsi_Strncasecmp(ext,".jpeg", -1) == 0) mime = "image/jpeg";
            else if (Jsi_Strncasecmp(ext,".jpg", -1) == 0) mime = "image/jpeg";
            else if (Jsi_Strncasecmp(ext,".js", -1) == 0) mime = "application/x-javascript";
            else if (Jsi_Strncasecmp(ext,".jsi", -1) == 0) mime = "application/x-javascript";
            else if (Jsi_Strncasecmp(ext,".svg", -1) == 0) mime = "image/svg+xml";
            else if (Jsi_Strncasecmp(ext,".css", -1) == 0) mime = "text/css";
            else if (Jsi_Strncasecmp(ext,".json", -1) == 0) mime = "application/json";
            else if (Jsi_Strncasecmp(ext,".txt", -1) == 0) mime = "text/plain";
            else if ((hPtr = Jsi_HashEntryFind(cmdPtr->handlers, ext))) {
                /* Use interprete html eg. using jsi_wpp preprocessor */
                Jsi_DString jStr = {};
                Jsi_Value *vrc = NULL;
                int hrc = 0, strLen, evrc, isalloc=0;
                char *vStr, *hstr;
                Jsi_Value *hv = (Jsi_Value*)Jsi_HashValueGet(hPtr);
                
                if (strchr(buf, '\'') || strchr(buf, '\"')) {
                    ServeString(cmdPtr, wsi, "Can not handle quotes in url", 404, NULL, NULL);                    
                }
                if (Jsi_ValueIsFunction(interp, hv)) {
                    Jsi_DSAppend(&jStr, "[\"", buf, "\"];", NULL);
                    vrc = Jsi_ValueNew1(interp);
                    evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);
                    isalloc = 1;
                } else {
                    hstr = Jsi_ValueString(interp, hv, NULL);
                    Jsi_DSAppend(&jStr, hstr, "('", buf, "');", NULL);
                    evrc = Jsi_EvalString(interp, Jsi_DSValue(&jStr), JSI_EVAL_RETURN);
                    if (evrc == JSI_OK)
                        vrc = Jsi_InterpResult(interp);
                }
                if (evrc != JSI_OK) {
                    Jsi_LogError("failure in websocket handler");
                } else if ((!vrc) ||
                    (!(vStr = Jsi_ValueString(interp, vrc, &strLen)))) {
                    Jsi_LogError("failed to get result");
                } else {
                    Jsi_DSSetLength(&jStr, 0);
                    Jsi_DSPrintf(&jStr,
                        "HTTP/1.0 200 OK\x0d\x0a"
                        "Server: libwebsockets\x0d\x0a"
                        "Content-Type: %s\x0d\x0a"
                        "Content-Length: %u\x0d\x0a\x0d\x0a",
                        mime,
                        strLen);
                    Jsi_DSAppend(&jStr, vStr, NULL);
                    vStr = Jsi_DSValue(&jStr);
                    hrc = libwebsocket_write(wsi, (unsigned char*)vStr, Jsi_Strlen(vStr), LWS_WRITE_HTTP);
                }
                Jsi_DSFree(&jStr);
                if (isalloc)
                    Jsi_DecrRefCount(interp, vrc);
                if (hrc)
                    return 1;
                return 0;
            } else if (Jsi_Strncasecmp(ext,".html", -1) == 0) {
            } else if (cmdPtr->mimeTypes) {
                /* Lookup mime type in mimeTypes object. */
                const char *nmime;
                Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->mimeTypes, ext+1, 1);
                if (mVal && ((nmime = Jsi_ValueString(interp, mVal, NULL))))
                    mime = nmime;
            }
        }
        if (!buf[0]) {
            if (cmdPtr->debug)
                fprintf(stderr, "Unknown file: %s\n", inPtr);
            break;
        }
        Jsi_Value* fname = Jsi_ValueNewStringDup(interp, buf);
        Jsi_IncrRefCount(interp, fname);

        Jsi_StatBuf jsb;
        if (Jsi_Stat(interp, fname, &jsb)) {
nofile:
            if (cmdPtr->noWarn==0 && strstr(buf, "favicon.ico")==0)
                fprintf(stderr, "failed open file for read: %s\n", buf);
            rc = ServeString(cmdPtr, wsi, "<b style='color:red'>ERROR: can not serve file!</b>", 404, NULL, NULL);
            Jsi_DecrRefCount(interp, fname);
            break;
        }
        if (S_ISDIR(jsb.st_mode)) {
            if (cmdPtr->noWarn==0)
                fprintf(stderr, "can not serve directory: %s\n", buf);
            rc = ServeString(cmdPtr, wsi, "<b style='color:red'>ERROR: can not serve directory!</b>", 404, NULL, NULL);
            Jsi_DecrRefCount(interp, fname);
            break;
        }
        if (Jsi_IsNative(interp, fname)) {
            int hrc = libwebsockets_serve_http_file(context, wsi, buf, mime, NULL);
            Jsi_DecrRefCount(interp, fname);
            if (hrc<0) {
                if (cmdPtr->noWarn==0)
                    fprintf(stderr, "can not serve file (%d): %s\n", hrc, buf);
                return 1;
            }
        } else {
            Jsi_Channel chan = Jsi_Open(interp, fname, "rb");
            int n, sum = 0;

            if (!chan) {
                goto nofile;
            }
            Jsi_DString dStr = {};
            char sbuf[BUFSIZ];
            Jsi_DSPrintf(&dStr,
                "HTTP/1.0 200 OK\x0d\x0a"
                "Server: libwebsockets\x0d\x0a"
                "Content-Type: %s\x0d\x0a"
                "Content-Length: %u\x0d\x0a\x0d\x0a",
                mime,
                (unsigned int)jsb.st_size);
            while (sum < 10000000 && (n = Jsi_Read(chan, sbuf, sizeof(sbuf))) > 0) {
                Jsi_DSAppendLen(&dStr, sbuf, n);
                sum += n;
            }
            Jsi_Close(chan);
            char *str = Jsi_DSValue(&dStr);
            int hrc, strLen = Jsi_DSLength(&dStr);
            Jsi_DecrRefCount(interp, fname);
            hrc = libwebsocket_write(wsi, (unsigned char*)str, strLen, LWS_WRITE_HTTP);
            Jsi_DSFree(&dStr);
            if (hrc<0) {
                if (cmdPtr->noWarn==0)
                    fprintf(stderr, "can not serve data (%d): %s\n", hrc, buf);
                return 1;
            }
        }
        /*
         * notice that the sending of the file completes asynchronously,
         * we'll get a LWS_CALLBACK_HTTP_FILE_COMPLETION callback when
         * it's done
         */

        break;
    }

    case LWS_CALLBACK_HTTP_FILE_COMPLETION:
//      lwsl_info("LWS_CALLBACK_HTTP_FILE_COMPLETION seen\n");
        /* kill the connection after we sent one file */
        return 1;

        /*
         * callback for confirming to continue with client IP appear in
         * protocol 0 callback since no websocket protocol has been agreed
         * yet.  You can just ignore this if you won't filter on client IP
         * since the default uhandled callback return is 0 meaning let the
         * connection continue.
         */

#ifdef EXTERNAL_POLL
        /*
         * callbacks for managing the external poll() array appear in
         * protocol 0 callback
         */

    case LWS_CALLBACK_ADD_POLL_FD:

        if (count_pollfds >= max_poll_elements) {
            lwsl_err("LWS_CALLBACK_ADD_POLL_FD: too many sockets to track\n");
            return 1;
        }

        fd_lookup[fd] = count_pollfds;
        pollfds[count_pollfds].fd = fd;
        pollfds[count_pollfds].events = (int)(long)len;
        pollfds[count_pollfds++].revents = 0;
        break;

    case LWS_CALLBACK_DEL_POLL_FD:
        if (!--count_pollfds)
            break;
        m = fd_lookup[fd];
        /* have the last guy take up the vacant slot */
        pollfds[m] = pollfds[count_pollfds];
        fd_lookup[pollfds[count_pollfds].fd] = m;
        break;

    case LWS_CALLBACK_SET_MODE_POLL_FD:
        pollfds[fd_lookup[fd]].events |= (int)(long)len;
        break;

    case LWS_CALLBACK_CLEAR_MODE_POLL_FD:
        pollfds[fd_lookup[fd]].events &= ~(int)(long)len;
        break;
#endif

    default:
        break;
    }

    return rc;
}

static Jsi_Value*
dump_handshake_info(WebSocketObj *cmdPtr, struct libwebsocket *wsi)
{
    int n;
    static const char *token_names[WSI_TOKEN_COUNT] = {
        /*[WSI_TOKEN_GET_URI]       =*/ "Uri",
        /*[WSI_TOKEN_POST_URI]      =*/ "POST URI",
        /*[WSI_TOKEN_HOST]      =*/ "Host",
        /*[WSI_TOKEN_CONNECTION]    =*/ "Connection",
        /*[WSI_TOKEN_KEY1]      =*/ "Key1",
        /*[WSI_TOKEN_KEY2]      =*/ "Key2",
        /*[WSI_TOKEN_PROTOCOL]      =*/ "Protocol",
        /*[WSI_TOKEN_UPGRADE]       =*/ "Upgrade",
        /*[WSI_TOKEN_ORIGIN]        =*/ "Origin",
        /*[WSI_TOKEN_DRAFT]     =*/ "Draft",
        /*[WSI_TOKEN_CHALLENGE]     =*/ "Challenge",

        /* new for 04 */
        /*[WSI_TOKEN_KEY]       =*/ "Key",
        /*[WSI_TOKEN_VERSION]       =*/ "Version",
        /*[WSI_TOKEN_SWORIGIN]      =*/ "Sworigin",

        /* new for 05 */
        /*[WSI_TOKEN_EXTENSIONS]    =*/ "Extensions",

        /* client receives these */
        /*[WSI_TOKEN_ACCEPT]        =*/ "Accept",
        /*[WSI_TOKEN_NONCE]     =*/ "Nonce",
        /*[WSI_TOKEN_HTTP]      =*/ "Http",

        "Accept:",
        "If-Modified-Since:",
        "Accept-Encoding:",
        "Accept-Language:",
        "Pragma:",
        "Cache-Control:",
        "Authorization:",
        "Cookie:",
        "Content-Length:",
        "Content-Type:",
        "Date:",
        "Range:",
        "Referer:",
        "Uri-Args:",
        
        /*[WSI_TOKEN_MUXURL]    =*/ "MuxURL",
    };
    char buf[BUFSIZ];
    int ntoks = sizeof(token_names)/sizeof(char*);
    Jsi_Interp *interp = cmdPtr->interp;
    Jsi_Obj *nobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
    Jsi_Value *nv, *ret = Jsi_ValueMakeObject(interp, NULL, nobj);
    Jsi_ValueMakeObject(interp, &ret, nobj);
#ifdef JSI_MEM_DEBUG
    jsi_ValueDebugLabel(ret, "websock", "dump_handshake");
#endif   
    for (n = 0; n < ntoks; n++) {
       
        if (lws_hdr_total_length(wsi, (enum lws_token_indexes)n)<=0)
            continue;

        lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);
        buf[sizeof(buf)-1] = 0;
        nv = Jsi_ValueNewStringDup(interp, buf);
        Jsi_ObjInsert(interp, nobj, token_names[n], nv, 0);
    }
    return ret;
}

static int
callback_jsi_protocol(struct libwebsocket_context *context,
      struct libwebsocket *wsi,
      enum libwebsocket_callback_reasons reason,
      void *user, void *in, size_t len)
{
    WebSocketPss *pss = (WebSocketPss *)user;
    WebSocketObj *cmdPtr = (WebSocketObj *)libwebsocket_context_user(context);
    Jsi_Interp *interp = cmdPtr->interp;
    char *inPtr = (char*)in;
    int sLen, bSiz, n, rc =0; /*, result = JSI_OK;*/
#define LWSPAD (LWS_SEND_BUFFER_PRE_PADDING + LWS_SEND_BUFFER_POST_PADDING)
#define LBUFMAX (BUFSIZ+LWSPAD)
    char buf[LBUFMAX], *bufPtr = buf;
    static char *statBuf = NULL;
    static int statSize = 0;

    WSSIGASSERT(cmdPtr, OBJ);
    switch (reason) {
    case LWS_CALLBACK_PROTOCOL_INIT:
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CALLBACK_INIT: %p\n", user);
        if (cmdPtr->noWebsock)
            return 1;
        //pss = getPss(cmdPtr, wsi, user, 1);
        break;
        
    case LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION:
        //pss = getPss(cmdPtr, wsi, user, 1);
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CALLBACK_FILTER: %p\n", pss);
        if (cmdPtr->onConnect) {
            int killcon = 0;
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2], *ret = Jsi_ValueNew1(interp);
            
            vargs[0] = dump_handshake_info(cmdPtr, wsi);
            Jsi_IncrRefCount(interp, vargs[0]);
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 1));
            Jsi_DecrRefCount(interp, vargs[0]);
            Jsi_IncrRefCount(interp, vpargs);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onConnect, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return 1;
            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {
                if (cmdPtr->debug)
                    fprintf(stderr, "WS:KILLING CONNECTION: %p\n", pss);
                killcon = 1;
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return 1;
            }
            if (killcon)
                return 1;
        }
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
    case LWS_CALLBACK_ESTABLISHED:
        pss = getPss(cmdPtr, wsi, user, 1);
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CALLBACK_ESTABLISHED: %d,%p\n", pss->id, pss);
        if (cmdPtr->onOpen) {
            /* Pass 2 args: data and id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return JSI_ERROR;
            }
        }        
        break;

    case LWS_CALLBACK_CLOSED:
    case LWS_CALLBACK_PROTOCOL_DESTROY:
        pss = (WebSocketPss *)user;
        if (cmdPtr->debug)
            fprintf(stderr, "WS:CLOSE: %p\n", pss);
        if (!pss) break;
        if (cmdPtr->onClose) {
            /* Pass 2 args: data and id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 1, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->onClose, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return JSI_ERROR;
            }
        }        
        deletePss(pss);
        if (cmdPtr->connectCnt<=0 && cmdPtr->onCloseLast) {
            Jsi_FunctionInvokeBool(interp, cmdPtr->onCloseLast, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
        }
        break;
    case LWS_CALLBACK_CLIENT_WRITEABLE:
    case LWS_CALLBACK_SERVER_WRITEABLE:
        pss = getPss(cmdPtr, wsi, user, 0);
        if (!pss) break;
        n=0;
        while (1) {
            char *data = (char*)Jsi_StackPop(pss->stack);
            unsigned char *p;
            if (data == NULL)
                break;
            pss->state = PWS_SENT;
            sLen = strlen(data);
            bSiz = sLen + LWSPAD;
            if (bSiz >= LBUFMAX) {
                if (statBuf == NULL) {
                    statSize = bSiz+1+LBUFMAX;
                    statBuf = (char*)Jsi_Malloc(statSize);
                } else if (statSize <= bSiz) {
                    statSize = bSiz+1+LBUFMAX;
                    statBuf = (char*)Jsi_Realloc(statBuf, statSize);
                }
                bufPtr = statBuf;
            }
            // TODO: check output size
            p = (unsigned char *)bufPtr+LWS_SEND_BUFFER_PRE_PADDING;
            memcpy(p, data, sLen);
            Jsi_Free(data);
            n = libwebsocket_write(wsi, p, sLen, LWS_WRITE_TEXT);
            if (bufPtr != buf)
                Jsi_Free(bufPtr);
            if (cmdPtr->debug>=10)
                fprintf(stderr, "WS:CLIENT WRITE(%p): %d=>%d\n", pss, sLen, n);
                                   
            if (n >= 0) {
                pss->sentCnt++;
                pss->sentLast = time(NULL);
            } else {
                lwsl_err("ERROR %d writing to socket\n", n);
                pss->state = PWS_SENDERR;
                pss->sentErrCnt++;
                pss->sentErrLast = time(NULL);
                rc = 1;
                return rc;
            }

            // lwsl_debug("tx fifo %d\n", (ringbuffer_head - pss->ringbuffer_tail) & (MAX_MESSAGE_QUEUE - 1));

            /*if (lws_send_pipe_choked(wsi)) {
                    libwebsocket_callback_on_writable(context, wsi);
                    return 0;
            }*/
        }
        break;
        
    case LWS_CALLBACK_CLIENT_RECEIVE:
    case LWS_CALLBACK_RECEIVE:
    {
        int rc;
        pss = getPss(cmdPtr, wsi, user, 0);
        if (!pss) break;
        if (cmdPtr->debug>=10)
            fprintf(stderr, "WS:RECV: %p\n", pss);

        //fprintf(stderr, "rx %d\n", (int)len);
        pss->recvCnt++;
        pss->recvLast = time(NULL);

        if (cmdPtr->callback && !Jsi_ValueIsNull(interp, cmdPtr->callback)) {
            /* Pass 2 args: data and id. */
            Jsi_Obj *oarg1;
            Jsi_Value *vpargs, *vargs[2];
            vargs[0]  = Jsi_ValueNewStringDup(interp, inPtr);
            vargs[1] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->id));
            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, 2, 0));
            Jsi_IncrRefCount(interp, vpargs);
            
            Jsi_Value *ret = Jsi_ValueNew1(interp);
            Jsi_ValueMakeUndef(interp, &ret);
            rc = Jsi_FunctionInvoke(interp, cmdPtr->callback, vpargs, &ret, NULL);
            if (Jsi_InterpGone(interp))
                return JSI_ERROR;
            if (rc == JSI_OK && Jsi_ValueIsUndef(interp, ret)==0) {
                /* TODO: handle callback return data??? */
            }

            Jsi_DecrRefCount(interp, vpargs);
            Jsi_DecrRefCount(interp, ret);
            if (rc != JSI_OK) {
                Jsi_LogError("websock bad rcv eval");
                return 1;
            }
        }
        //if (!strlen(Jsi_GetStringResult(interp))) { }
        libwebsocket_callback_on_writable_all_protocol(libwebsockets_get_protocol(wsi));

        //if (len < 6)
            //break;
        //if (Jsi_Strcmp((const char *)in, "reset\n") == 0)
        //pss->number = 0;
        break;
 
    }
    default:
        break;
    }
    return rc;
}


static int WebSocketConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
  
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-websock object");
        return JSI_ERROR;
    }
    return Jsi_OptionsConf(interp, WSOptions, Jsi_ValueArrayIndex(interp, args, 0), cmdPtr, ret, 0);

}

static int WebSocketIdConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-websock object");
        return JSI_ERROR;
    }
    Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Number vid;
    if (Jsi_ValueGetNumber(interp, valPtr, &vid) != JSI_OK || vid < 0) {
        Jsi_LogError("Expected number id");
        return JSI_ERROR;
    }
    int id = (int)vid;
    WebSocketPss *pss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
        WebSocketPss* tpss = (WebSocketPss*)Jsi_HashValueGet(hPtr);
        WSSIGASSERT(tpss, PWS);
        if (tpss->id == id && tpss->state != PWS_DEAD) {
            pss = tpss;
            break;
        }
    }

    if (!pss) {
        Jsi_LogError("No such id: %d", id);
        return JSI_ERROR;
    }
    return Jsi_OptionsConf(interp, WPSOptions, Jsi_ValueArrayIndex(interp, args, 0), pss, ret, 0);
}

static int WebSocketIdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-websock object");
        return JSI_ERROR;
    }
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DSAppend(&dStr, "{", NULL);
    WebSocketPss *pss = NULL;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    int cnt = 0;
    for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
        pss = (WebSocketPss*)Jsi_HashValueGet(hPtr);
        WSSIGASSERT(pss, PWS);
        if (pss->state != PWS_DEAD) {
            Jsi_DSPrintf(&dStr, "%s%d", cnt++?",":"", pss->id);
        }
    }
    Jsi_DSAppend(&dStr, "}", NULL);
    int rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
    Jsi_DSFree(&dStr);
    return rc;
}

#define FN_wshandler JSI_INFO("\
With no args, returns handlers object.  With one, return value for a single handler."\
"Otherwise, sets the handler.")

static int WebSocketHandlerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_HashEntry *hPtr;
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-websock object");
        return JSI_ERROR;
    }
    WSSIGASSERT(cmdPtr, OBJ);
    int argc = Jsi_ValueGetLength(interp, args);
    if (argc == 0) {
        Jsi_HashSearch search;
        Jsi_Obj* obj = Jsi_ObjNew(interp);
        for (hPtr = Jsi_HashEntryFirst(cmdPtr->handlers, &search); hPtr; hPtr = Jsi_HashEntryNext(&search)) {
            const char *key = (char*)Jsi_HashKeyGet(hPtr);
            Jsi_Value *val = (Jsi_Value*)Jsi_HashValueGet(hPtr);
            Jsi_ObjInsert(interp, obj, key, val, 0);
        }
        Jsi_ValueMakeObject(interp, ret, obj);
        return JSI_OK;
    }
    if (argc == 1) {
        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, Jsi_ValueArrayIndexToStr(interp, args, 0, NULL));
        if (!hPtr)
            return JSI_OK;
        Jsi_Value *val = (Jsi_Value*)Jsi_HashValueGet(hPtr);
        Jsi_ValueReplace(interp, ret, val);
        return JSI_OK;
    }
    const char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);
    Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 1);
    if (Jsi_ValueIsNull(interp, valPtr)) {
        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, key);
        if (!hPtr)
            return JSI_OK;
        valPtr = (Jsi_Value*)Jsi_HashValueGet(hPtr);
        Jsi_DecrRefCount(interp, valPtr);
        Jsi_HashEntryDelete(hPtr);
        return JSI_OK;
    }
    if (Jsi_ValueIsFunction(interp, valPtr)==0 && Jsi_ValueIsString(interp, valPtr)==0) {
        Jsi_LogError("expected string, function or null");
        return JSI_ERROR;
    }
    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, key, NULL);
    if (!hPtr)
        return JSI_ERROR;
    Jsi_HashValueSet(hPtr, valPtr);
    Jsi_IncrRefCount(interp, valPtr);
    return JSI_OK;
}

#define FN_wssend JSI_INFO("\
Send a message to 1 (or all connections if -1). If not already a string, msg is format as JSON prior to the send.")

static int WebSocketSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!cmdPtr) {
        Jsi_LogError("Apply in a non-websock object");
        return JSI_ERROR;
    }
    WSSIGASSERT(cmdPtr, OBJ);
    //int len;
    //char *in;
    //Jsi_HashEntry *hPtr;
    //Jsi_HashSearch cursor;
    //Jsi_Obj *objPtr;
    WebSocketPss *pss;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch cursor;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    char *str = Jsi_ValueString(interp, arg, NULL);
    int id = -1, argc = Jsi_ValueGetLength(interp, args);
    Jsi_DString eStr = {};
    if (argc>1) {
        Jsi_Number dnum;
        Jsi_Value *darg = Jsi_ValueArrayIndex(interp, args, 1);
        if (Jsi_ValueGetNumber(interp, darg, &dnum) != JSI_OK) {
            Jsi_LogError("invalid id");
            return JSI_ERROR;
        }
        id = (int)dnum;
    }
    if (!str) {
        str = (char*)Jsi_ValueGetDString(interp, arg, &eStr, JSI_OUTPUT_JSON);
    }
    for (hPtr = Jsi_HashEntryFirst(cmdPtr->pssTable, &cursor);
        hPtr != NULL; hPtr = Jsi_HashEntryNext(&cursor)) {
        pss = (WebSocketPss*)Jsi_HashValueGet(hPtr);
        WSSIGASSERT(pss, PWS);
        if ((id<0 || pss->id == id) && pss->state != PWS_DEAD)
            Jsi_StackPush(pss->stack, Jsi_Strdup(str));
    }
   
    Jsi_DSFree(&eStr);
    return JSI_OK;
}

static int wsService(WebSocketObj *cmdPtr)
{
    int n = 0;
    struct timeval tv;

    gettimeofday(&tv, NULL);

    /*
     * This provokes the LWS_CALLBACK_SERVER_WRITEABLE for every
     * live websocket connection using the DUMB_INCREMENT protocol,
     * as soon as it can take more packets (usually immediately)
     */

    if (((unsigned int)tv.tv_usec - cmdPtr->oldus) > 50000) {
        libwebsocket_callback_on_writable_all_protocol(&cmdPtr->protocols[PROTOCOL_JSI]);
        cmdPtr->oldus = tv.tv_usec;
    }

#ifdef EXTERNAL_POLL

    /*
     * this represents an existing server's single poll action
     * which also includes libwebsocket sockets
     */

    n = poll(pollfds, count_pollfds, 50);
    if (n < 0)
        return 0;


    if (n)
        for (n = 0; n < count_pollfds; n++)
            if (pollfds[n].revents)
                /*
                * returns immediately if the fd does not
                * match anything under libwebsockets
                * control
                */
                if (libwebsocket_service_fd(context,
                                            &pollfds[n]) < 0)
                    return -1;
#else
    /*
     * If libwebsockets sockets are all we care about,
     * you can use this api which takes care of the poll()
     * and looping through finding who needed service.
     *
     * If no socket needs service, it'll return anyway after
     * the number of ms in the second argument.
     */

    n = libwebsocket_service(cmdPtr->context, 50);
#endif
    return n;
}

#define FN_wsupdate JSI_INFO("\
Update websocket queue.  This is used only in server mode to broadcast to clients.")

static int WebSocketUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    Jsi_Value *oldcb = cmdPtr->callback;
    if (!cmdPtr) {
        Jsi_LogError("Apply to non-websock object");
        return JSI_ERROR;
    }
    if (cmdPtr->noUpdate)
        return JSI_OK;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (arg) {
        if (Jsi_ValueIsType(interp, arg, JSI_VT_OBJECT)==0 || Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION)==0) {
            Jsi_LogError("arg is not a function");
            return JSI_ERROR;
        }
        cmdPtr->callback = arg;
    }
    wsService(cmdPtr);
    if (arg)
        cmdPtr->callback = oldcb;
    return JSI_OK;
}

static int websockUpdate(Jsi_Interp *interp, void *data)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)data;
    WSSIGASSERT(cmdPtr,OBJ);
    wsService(cmdPtr);
    return JSI_OK;
}

static void websocketObjErase(WebSocketObj *cmdPtr)
{
    if (cmdPtr->interp) {
        if (cmdPtr->event)
            Jsi_EventFree(cmdPtr->interp, cmdPtr->event);
        cmdPtr->event = NULL;
        if (cmdPtr->hasOpts)
            Jsi_OptionsFree(cmdPtr->interp, WSOptions, cmdPtr, 0);
        cmdPtr->hasOpts = 0;
        if (cmdPtr->handlers)
            Jsi_HashDelete(cmdPtr->handlers);
        cmdPtr->handlers = NULL;
        if (cmdPtr->pssTable)
            Jsi_HashDelete(cmdPtr->pssTable);
        cmdPtr->pssTable = NULL;
    }
    cmdPtr->interp = NULL;
}

static int websocketObjFree(Jsi_Interp *interp, void *data)
{
    WebSocketObj *cmdPtr = (WebSocketObj*)data;
    WSSIGASSERT(cmdPtr,OBJ);
    if (cmdPtr->context) 
        libwebsocket_context_destroy(cmdPtr->context);
    websocketObjErase(cmdPtr);
    MEMCLEAR(cmdPtr);
    Jsi_Free(cmdPtr);
    return 0;
}

static int websocketObjIsTrue(void *data)
{
    //WebSocketObj *cmdPtr = data;
    return 1;
   /* if (!fo->websockname) return 0;
    else return 1;*/
}

static int websocketObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

static int wsfreeHandlers(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {
    Jsi_Value *v = (Jsi_Value*)ptr;
    if (v)
        Jsi_DecrRefCount(interp, v);
    return JSI_OK;
}

static int wsfreePss(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {
    WebSocketPss *pss = (WebSocketPss*)ptr;
    if (pss) {
        pss->hPtr = NULL;
        deletePss(pss);
    }
    return JSI_OK;
}
#define FN_WebSocket JSI_INFO("\
Create a websocket server or client object.  The server can serve pages out to a \
web browser and then use javascript to upgrade the connection to a bidirectional websocket.")
static int WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    WebSocketObj *cmdPtr;
    Jsi_Value *toacc = NULL;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    cmdPtr = (WebSocketObj*)Jsi_Calloc(1, sizeof(*cmdPtr));
    cmdPtr->sig = JWS_SIG_OBJ;
    cmdPtr->port = 8080;
    //cmdPtr->rootdir = "./";

    cmdPtr->interp = interp;
    cmdPtr->protocols[PROTOCOL_HTTP].name="http-only";
    cmdPtr->protocols[PROTOCOL_HTTP].callback=callback_http;
    cmdPtr->protocols[PROTOCOL_JSI].name="jsi-protocol";
    cmdPtr->protocols[PROTOCOL_JSI].callback=callback_jsi_protocol;
    cmdPtr->protocols[PROTOCOL_JSI].per_session_data_size=sizeof(WebSocketPss);
    cmdPtr->ietf_version = -1;
    cmdPtr->rx_buffer_size = 50000;
    cmdPtr->ws_gid = -1;
    cmdPtr->ws_uid = -1;
    cmdPtr->startTime = time(NULL);
    cmdPtr->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (cmdPtr->hasOpts && Jsi_OptionsProcess(interp, WSOptions, arg, cmdPtr, 0) < 0) {
        cmdPtr->deleted = 1;
        websocketObjFree(interp, cmdPtr);
        //Jsi_EventuallyFree(cmdPtr, destroyWebSocketObj);
        return JSI_ERROR;
    }
    cmdPtr->protocols[PROTOCOL_JSI].rx_buffer_size=cmdPtr->rx_buffer_size;
    cmdPtr->pssTable = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, wsfreePss);
    cmdPtr->info.port = (cmdPtr->client ? CONTEXT_PORT_NO_LISTEN : cmdPtr->port);


#if !defined(LWS_NO_DAEMONIZE) && !defined(WIN32)
    /* 
     * normally lock path would be /var/lock/lwsts or similar, to
     * simplify getting started without having to take care about
     * permissions or running as root, set to /tmp/.lwsts-lock
     */
    if (cmdPtr->daemonize && lws_daemonize("/tmp/.lwsts-lock")) {
        if (cmdPtr->debug)
            fprintf(stderr, "WS:Failed to daemonize\n");
        websocketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
#endif
    cmdPtr->info.user = cmdPtr;
    cmdPtr->info.iface = cmdPtr->interface ? Jsi_ValueString(interp, cmdPtr->interface, NULL) : NULL;
    cmdPtr->info.protocols = cmdPtr->protocols;
#ifndef LWS_NO_EXTENSIONS
    cmdPtr->info.extensions = libwebsocket_get_internal_extensions();
#endif
    cmdPtr->info.ssl_cert_filepath = cmdPtr->ssl_cert_filepath;
    cmdPtr->info.ssl_private_key_filepath = cmdPtr->ssl_private_key_filepath;
    cmdPtr->info.gid = cmdPtr->ws_gid;
    cmdPtr->info.uid = cmdPtr->ws_uid;
    cmdPtr->opts = LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME;
    cmdPtr->info.options = cmdPtr->opts;

     lws_set_log_level(cmdPtr->debug>1?cmdPtr->debug-1:0, NULL);
     cmdPtr->context = libwebsocket_create_context(&cmdPtr->info);
     if (cmdPtr->context == NULL) {
        Jsi_LogError("libwebsocket init failed on port %d (try another port?)", cmdPtr->port);
        websocketObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }

    if (cmdPtr->client) {
        if (NULL == libwebsocket_client_connect(cmdPtr->context,
            cmdPtr->address ? Jsi_ValueString(cmdPtr->interp, cmdPtr->address, NULL) : "127.0.0.1",
            cmdPtr->port, cmdPtr->use_ssl,
            cmdPtr->rootdir?Jsi_ValueString(cmdPtr->interp, cmdPtr->rootdir, NULL):"./",
            cmdPtr->cl_host?cmdPtr->cl_host:"localhost",
            cmdPtr->cl_origin?cmdPtr->cl_origin:"localhost",
             cmdPtr->protocols[PROTOCOL_JSI].name, cmdPtr->ietf_version)) {
            Jsi_LogError("websock connect failed");
            websocketObjFree(interp, cmdPtr);
            return JSI_ERROR;
        }
    }

    cmdPtr->event = Jsi_EventNew(interp, websockUpdate, cmdPtr);
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "WebSocket", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &websockobject, fobj, cmdPtr))<0) {
        websocketObjFree(interp, cmdPtr);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    cmdPtr->handlers = Jsi_HashNew(interp, JSI_KEYS_STRING, wsfreeHandlers);
    cmdPtr->fobj = fobj;
    return JSI_OK;
}

static Jsi_CmdSpec websockCmds[] = {
    { "WebSocket",  WebSocketConstructor, 0,  1, "options:object=void", JSI_CMD_IS_CONSTRUCTOR, .help="Create websocket server/client object", .opts=WSOptions, .info=FN_WebSocket, .retType=(uint)JSI_TT_USEROBJ },
    { "conf",       WebSocketConfCmd,     0,  1, "options:string|object=void",.help="Configure options" , .opts=WSOptions, .retType=(uint)JSI_TT_ANY },
    { "handler",    WebSocketHandlerCmd,  0,  2, "extn:string=void, cmd:string=void", .help="Get/Set handler command for an extension", .info=FN_wshandler, .retType=(uint)JSI_TT_FUNCTION },
    { "ids",        WebSocketIdsCmd,      0,  0, "", .help="Return list of ids", .retType=(uint)JSI_TT_ARRAY},
    { "idconf",     WebSocketIdConfCmd,   1,  2, "id:number, options:string|object=void",.help="Configure options for id" , .opts=WPSOptions, .retType=(uint)JSI_TT_ANY },
    { "send",       WebSocketSendCmd,     1,  2, "data:any, id:number=void", .help="Send a websocket message to id", .info=FN_wssend, .retType=(uint)JSI_TT_VOID },
    { "update",     WebSocketUpdateCmd,   0,  1, "callback:function=void", .help="Service just websocket events", .info=FN_wsupdate, .retType=(uint)JSI_TT_VOID },
    { NULL, .help="Commands for managing WebSocket server/client connections"  }
};


int Jsi_DoneWebSocket(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &websockobject);
    return JSI_OK;
}

int Jsi_InitWebSocket(Jsi_Interp *interp)
{
    Jsi_Hash *wsys;
#ifdef JSI_USE_STUBS
  if (Jsi_StubsInit(interp, 0) != JSI_OK)
    return JSI_ERROR;
#endif
    if (!(wsys = Jsi_UserObjRegister(interp, &websockobject))) {
        Jsi_LogFatal("Can not init websock\n");
        return JSI_ERROR;
    }

    if (!Jsi_CommandCreateSpecs(interp, websockobject.name, websockCmds, wsys, 0))
        return JSI_ERROR;
    return JSI_OK;
}

#endif
#endif
#ifdef HAVE_MYSQL
/* A JSI (Javascript) Interface to MySql. */

typedef enum { MYSQL_SIG_DB = 0xbeefdead, MYSQL_SIG_FUNC, MYSQL_SIG_EXEC, MYSQL_SIG_STMT } MySql_Sig;

#define SQLSIGASSERT(s,n) assert(s->sig == MYSQL_SIG_##n)
#define SQLSIGINIT(s,n) s->sig = MYSQL_SIG_##n

#ifndef NDEBUG
#ifndef MEMCLEAR
#define MEMCLEAR(s) memset(s, 0, sizeof(*s));
#endif
#else
#define MEMCLEAR(s)
#endif
#ifndef JSI_DB_DSTRING_SIZE
#define JSI_DB_DSTRING_SIZE 2000
#endif

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <ctype.h>
#include <stdio.h>
#include <mysql/mysql.h>

#include "jsi.h"
JSI_EXTENSION_INI

#ifndef NUM_PREPARED_STMTS
#define NUM_PREPARED_STMTS 100
#endif
#ifndef MAX_PREPARED_STMTS
#define MAX_PREPARED_STMTS 10000
#endif

#ifndef JSI_DBQUERY_PRINTF
#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#endif

/*
** New SQL functions can be created as JSI scripts.  Each such function
** is described by an instance of the following structure.
*/
typedef struct SqlFunc SqlFunc;
struct SqlFunc {
    MySql_Sig sig;
    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */
    Jsi_Value   *tocall;    /* Callee */
    char        *pScript;   /* The char* representation of the script */
    Jsi_DString dScript;
    char        *zName;     /* Name of this function */
    SqlFunc     *pNext;     /* Next function on the list of them all */
};

/*
** New collation sequences function can be created as JSI scripts.  Each such
** function is described by an instance of the following structure.
*/
typedef struct SqlCollate SqlCollate;
struct SqlCollate {
    MySql_Sig sig;
    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */
    Jsi_Value   *zScript;  /* The function to be run */
    SqlCollate  *pNext;    /* Next function on the list of them all */
};

typedef struct SqlFieldResults {
    MYSQL_FIELD *field;
    my_bool isnull;
    unsigned long len;
    int vsize;
    enum enum_field_types mapType; // Maps to one of DOUBLE, BOOL, VARCHAR or TIMESTAMP
    Jsi_OptionTypes jsiTypeMap;  // Type of data for Jsi.
    union { // Space for data.
        char vchar;
        double vdouble;  // Must convert if Jsi_Number is a long double.
        long long vlonglong;
        my_bool vbool;
        char *vstring;
        MYSQL_TIME timestamp;
    } buffer;
} SqlFieldResults;

/*
    result_bind[0].buffer_type = MYSQL_TYPE_LONG;
    result_bind[0].buffer = &result_int;
    result_bind[0].buffer_length = sizeof(result_int);
    result_bind[0].length = &result_len;
    result_bind[0].is_null = &result_is_null[0];
*/

/*
** Prepared statements are cached for faster execution.  Each prepared
** statement is described by an instance of the following structure.
*/
typedef struct MysqlPrep MysqlPrep;
struct MysqlPrep {
    MySql_Sig sig;
    int deleting;
    MysqlPrep *pNext;  /* Next in linked list */
    MysqlPrep *pPrev;  /* Previous on the list */
    MYSQL_STMT    *myStmt;  /* The prepared statement */
    MYSQL_RES     *resultMetaData;
    MYSQL_RES     *paramMetaData;
    MYSQL_BIND    *bindParam;
    MYSQL_BIND    *bindResult;
    SqlFieldResults *fieldResult;
    SqlFieldResults *fieldParam;
    //int resultColumns, paramCount;
    int nSql;                /* chars in zSql[] */
    char *zSql;        /* Text of the SQL statement */
    const char *zRawSql;     /* SQL before named params extracted. */
    
    int numParam; // Count of input params.
    int numCol; // Count of columns in results
    Jsi_HashEntry *entry;
    Jsi_ListEntry *elPtr;
    char **colNames;       /* List of column names. */
    Jsi_OptionTypes *colTypes;
    // Following used by named params.
    char *origSql;
    char **paramNames;       /* List of param names. */
    int *paramMyTypes;
    int paramCnt;
    Jsi_DString *naStr;
};

static const char *execFmtStrs[] = {
    "rows", "arrays", "array1d", "list", "column", "json",
    "json2", "html", "csv", "insert", "line", "tabs", "none", NULL
};

typedef enum {
    _mdb_EF_ROWS, _mdb_EF_ARRAYS, _mdb_EF_ARRAY1D, _mdb_EF_LIST, _mdb_EF_COLUMN, _mdb_EF_JSON,
    _mdb_EF_JSON2, _mdb_EF_HTML, _mdb_EF_CSV, _mdb_EF_INSERT, _mdb_EF_LINE, _mdb_EF_TABS, _mdb_EF_NONE
} mdbOutput_Mode;


const char *mdbTypeChkStrs[] = { "convert", "error", "warn", "disable", NULL };

typedef enum { mdbTypeCheck_Cast, mdbTypeCheck_Error, mdbTypeCheck_Warn,  mdbTypeCheck_None } mdbTypeCheck_Mode;

typedef struct QueryOpts {
    MySql_Sig sig;
    Jsi_Value *callback, *values;
    Jsi_Value *paramVar;
    int limit;
    mdbOutput_Mode mode;
    mdbTypeCheck_Mode typeCheck;
    Jsi_Bool mapundef, nocache, headers, noNamedParams, prefetch;
    const char *separator;
    const char *nullvalue;
    const char *table;
    //const char *Cdata; // Name of cdata to use for query.
    char varName[100];
    Jsi_Value *width;
    int maxString;
} QueryOpts;

static const char *trcModeStrs[] = {"eval", "delete", "prepare", "step", NULL}; // Bit-set packed into an int.
enum {mdbTMODE_EVAL=0x1, mdbTMODE_DELETE=0x2, mdbTMODE_PREPARE=0x4, mdbTMODE_STEP=0x4};

typedef struct MySqlObj {
    MySql_Sig sig;
    MYSQL  *db;               /* The "real" database structure. MUST BE FIRST */
    Jsi_Interp *interp;        /* The interpreter used for this database */
    Jsi_Value *host;
    const char *user;
    const char *password;
    const char *database;
    int port;
    char *zNull;               /* Text to substitute for an SQL NULL value */
    SqlFunc *pFunc;            /* List of SQL functions */
    int rc;                    /* Return code of most recent mysql_exec() */
    Jsi_List *stmtCache;
//    MysqlPrep *stmtList; /* List of prepared statements*/
//    MysqlPrep *stmtLast; /* Last statement in the list */
    Jsi_Hash *stmtHash;        /* Hash table for statements. */
    int maxStmts;               /* The next maximum number of stmtList */
    int numStmts;                 /* Number of statements in stmtList */
    Jsi_Bool bindWarn, forceInt, reconnect, enableMulti;
    int nStep, nSort;          /* Statistics for most recent operation */
    int nTransaction;          /* Number of nested [transaction] methods */
    int errorCnt;               /* Count of errors. */
    Jsi_Value *key;             /* Key, for codec. */
    int hasOpts;
    Jsi_Obj *userObjPtr;
    QueryOpts queryOpts, *optPtr;
    int objId;
    int debug;
    int deleted;
    Jsi_Event *event;
    //int trace;
    Jsi_DString name;
    int last_errno;
    int version;
    int dbflags;
    Jsi_Value *sslKey, *sslCert, *sslCA, *sslCAPath, *sslCipher;
    Jsi_Hash *typeNameHash;
} MySqlObj;

typedef struct MyDbEvalContext {
    MySqlObj *jdb;                /* Database handle */
    Jsi_DString *dzSql;               /* Object holding string zSql */
    const char *zSql;               /* Remaining SQL to execute */
    MysqlPrep *prep;      /* Current statement */
    int nCol;                       /* Number of columns returned by pStmt */
    Jsi_Value *tocall;
    Jsi_Value *ret;
    /*OBS */
    Jsi_Value *pArray;              /* Name of array variable */
    Jsi_Value *pValVar;             /* Name of list for values. */
    int nocache;
    int namedParams;
} MyDbEvalContext;

static int mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value);
static int mdbPrepareAndBind(MyDbEvalContext *p );
static void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard );

void mdbTypeNameHashInit(MySqlObj *jdb) {
    Jsi_Interp *interp = jdb->interp;
    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    Jsi_HashSet(hPtr, (void*)"string", (void*)MYSQL_TYPE_STRING);
    Jsi_HashSet(hPtr, (void*)"double", (void*)MYSQL_TYPE_DOUBLE);
    Jsi_HashSet(hPtr, (void*)"integer", (void*)MYSQL_TYPE_LONGLONG);
    Jsi_HashSet(hPtr, (void*)"bool", (void*)MYSQL_TYPE_TINY);
    Jsi_HashSet(hPtr, (void*)"blob", (void*)MYSQL_TYPE_BLOB);
    Jsi_HashSet(hPtr, (void*)"date", (void*)MYSQL_TYPE_DATE);
    Jsi_HashSet(hPtr, (void*)"time", (void*)MYSQL_TYPE_TIME);
    Jsi_HashSet(hPtr, (void*)"timestamp", (void*)MYSQL_TYPE_TIMESTAMP);
    Jsi_HashSet(hPtr, (void*)"datetime", (void*)MYSQL_TYPE_DATETIME);
}

static Jsi_OptionSpec QueryFmtOptions[] =
{
    JSI_OPT(FUNC,   QueryOpts, callback, .help="Function to call with each row result" ),
    JSI_OPT(BOOL,   QueryOpts, headers, .help="First row returned contains column labels"),
    JSI_OPT(INT,    QueryOpts, limit, .help="Maximum number of returned values"),
    JSI_OPT(BOOL,   QueryOpts, mapundef, .help="In variable binds, map an 'undefined' var to null"),
    JSI_OPT(INT,    QueryOpts, maxString, .help="If not using prefetch, the maximum string value size (0=8K)"),
    JSI_OPT(CUSTOM, QueryOpts, mode, .custom=Jsi_Opt_SwitchEnum,  .data=execFmtStrs, .help="Set output mode of returned data"),
    JSI_OPT(BOOL,   QueryOpts, nocache, .help="Query is not to be cached"),
    JSI_OPT(BOOL,   QueryOpts, noNamedParams, .help="Disable translating sql to support named params"),
    JSI_OPT(STRKEY, QueryOpts, nullvalue, .help="Null string output (for non-json mode)"),
    JSI_OPT(ARRAY,  QueryOpts, paramVar, .help="Array var to use for parameters" ),
    JSI_OPT(BOOL,   QueryOpts, prefetch, .help="Let client library cache entire results"),
    JSI_OPT(STRKEY, QueryOpts, separator, .help="Separator string (for csv and text mode)"),
    //JSI_OPT(STRKEY, QueryOpts, Cdata, .help="Name of Cdata object to use"),
    JSI_OPT(STRKEY, QueryOpts, table, .help="Table name for mode=insert"),
    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help="Type check mode", .init="error", .custom=Jsi_Opt_SwitchEnum, .data=mdbTypeChkStrs),
    JSI_OPT(ARRAY,  QueryOpts, values, .help="Values for ? bind parameters" ),
    JSI_OPT(STRBUF, QueryOpts, varName,  .help="String name of array var for ? bind parameters" ),
    JSI_OPT(CUSTOM, QueryOpts, width, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)mdbIsNumArray, .help="In column mode, set column widths"),
    JSI_OPT_END(QueryOpts)
};

static Jsi_CmdSpec mysqlCmds[];

#define IIOF .flags=JSI_OPT_INIT_ONLY
static Jsi_OptionSpec SqlOptions[] =
{
    JSI_OPT(BOOL,   MySqlObj, bindWarn, .help="Treat failed variable binds as a warning", IIOF, .init="false"),
    JSI_OPT(STRKEY, MySqlObj, database, .help="Database to use", IIOF ),
    JSI_OPT(CUSTOM, MySqlObj, debug,  .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs, .help="Enable debug trace for various operations"),
    JSI_OPT(BOOL,   MySqlObj, enableMulti,.help="Enable muilti-statements for eval()", IIOF),
    JSI_OPT(INT,    MySqlObj, errorCnt, .help="Count of errors", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(CUSTOM, MySqlObj, queryOpts, .help="Default options for exec", .custom=Jsi_Opt_SwitchSuboption, .data=QueryFmtOptions),
    JSI_OPT(BOOL,   MySqlObj, forceInt, .help="Bind float as int if possible"),
    JSI_OPT(STRING, MySqlObj, host,     .help="IP address or host name for mysqld (default is 127.0.0.1)"),
    JSI_OPT(INT,    MySqlObj, maxStmts, .help="Max cache size for compiled statements"),
    JSI_OPT(DSTRING,MySqlObj, name,     .help="Name for this db handle"),
    JSI_OPT(INT,    MySqlObj, numStmts, .help="Current size of compiled statement cache", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT(STRKEY, MySqlObj, password, .help="Database password.", IIOF ),
    JSI_OPT(INT,    MySqlObj, port,     .help="IP port for mysqld", IIOF),
    JSI_OPT(BOOL,   MySqlObj, reconnect, .help="Reconnect"),
    JSI_OPT(STRING, MySqlObj, sslKey, .help="SSL key"),
    JSI_OPT(STRING, MySqlObj, sslCert, .help="SSL Cert"),
    JSI_OPT(STRING, MySqlObj, sslCA, .help="SSL CA"),
    JSI_OPT(STRING, MySqlObj, sslCAPath, .help="SSL CA path"),
    JSI_OPT(STRING, MySqlObj, sslCipher, .help="SSL Cipher"),
    JSI_OPT(STRKEY, MySqlObj, user,     .help="Database user name. Default is current user-name.", IIOF ),
    JSI_OPT(INT,    MySqlObj, version,  .help="Mysql version number", .flags=JSI_OPT_READ_ONLY),
    JSI_OPT_END(MySqlObj)
};

/* Start of code. */

// Convert MySql time to JS unix time in ms. TODO: handle "neg" and years outside of unix time.
static Jsi_Number mdbMyTimeToJS(MYSQL_TIME* mtm)
{
    struct tm tm;
    tm.tm_sec = mtm->second;
    tm.tm_min = mtm->minute;
    tm.tm_hour = mtm->hour;
    tm.tm_mday = mtm->day;
    tm.tm_mon = mtm->month-1;
    tm.tm_year = mtm->year - 1900;
    time_t tim = mktime(&tm);
    if (tim == (time_t)-1)
        return -1;
    return (Jsi_Number)tim*1000 + (Jsi_Number)mtm->second_part/1000000.0;
}

static void mdbJsToMyTime(Jsi_Number time, MYSQL_TIME* mtm, int utc)
{
    struct tm tm;
    time_t tim = (time_t)(time/1000);
    if (utc)
        gmtime_r(&tim, &tm);
    else
        localtime_r(&tim, &tm);
    mtm->second = tm.tm_sec;
    mtm->minute = tm.tm_min;
    mtm->hour = tm.tm_hour;
    mtm->day = tm.tm_mday;
    mtm->month = tm.tm_mon+1;
    mtm->year = tm.tm_year + 1900;
    Jsi_Number secs = (tim/1000.0);
    mtm->second_part = (int)((secs-(int)secs)*1000000);
}

static int mdbEvalInit(
    Jsi_Interp *interp,
    MyDbEvalContext *p,               /* Pointer to structure to initialize */
    MySqlObj *jdb,                  /* Database handle */
    const char* zSql,                /* Value containing SQL script */
    Jsi_DString *dStr,
    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */
    Jsi_Obj *pValVar                  /* Name element in array for list. */
) {
    p->dzSql = dStr;
    p->zSql = Jsi_DSAppend(p->dzSql, zSql?zSql:"", NULL);
    p->jdb = jdb;
    return JSI_OK;
}

static void mdbEvalFinalize(MyDbEvalContext *p) {
    if( p->prep) {
        mdbReleaseStmt(p->jdb, p->prep, p->nocache);
        p->prep = 0;
    }
    Jsi_DSFree(p->dzSql);
}

static void mdbEvalRowInfo( MyDbEvalContext *eval, int *pnCol, char ***papColName, Jsi_OptionTypes **papColType) {
    if (!papColName) {
        //TODO: Array ???
    }
    *papColName = eval->prep->colNames;
    *papColType = eval->prep->colTypes;
    *pnCol = eval->prep->numCol;
}

/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */
static int mdbEvalStepSub(MyDbEvalContext *eval, int release, int *erc) {
    MySqlObj *jdb = eval->jdb;
    Jsi_Interp *interp = jdb->interp;
    MysqlPrep *prep = eval->prep;
    SQLSIGASSERT(prep, STMT);
    MYSQL_STMT *myStmt = prep->myStmt;

    if (jdb->debug & mdbTMODE_STEP)
        JSI_DBQUERY_PRINTF( "DEBUG: step: %s\n", prep->zSql);
    int m = mysql_stmt_fetch(myStmt);
    if (m == MYSQL_NO_DATA)
        return JSI_BREAK;
    if (m) {
        Jsi_LogError("fetch failed: %s", mysql_error(jdb->db));
        return JSI_ERROR;
    }
    return JSI_OK;
#if 0
    if( eval->pArray ) {
        mdbEvalRowInfo(eval, 0, 0, 0);
    }
    if (release==0)
        return JSI_BREAK;
    eval->prep = 0;
    return JSI_OK;
#endif
}

static void mdbRelease1Stmt( MySqlObj *jdb, MysqlPrep *prep ) {
    // TODO: split out parts reusable by cached query.
    int i;
    if (prep->deleting)
        return;
    prep->deleting = 1;
    if (prep->myStmt)
        mysql_stmt_close(prep->myStmt);
    if (prep->resultMetaData)
        mysql_free_result(prep->resultMetaData);
    if (prep->paramMetaData)
        mysql_free_result(prep->paramMetaData);
    if (prep->bindParam)
        Jsi_Free(prep->bindParam);
    if (prep->fieldParam)
        Jsi_Free(prep->fieldParam);
    if (prep->bindResult) {
        for (i=0; i<prep->numCol; i++) {
            MYSQL_BIND *bind = prep->bindResult+i;
            if (bind->buffer_type == MYSQL_TYPE_STRING && bind->buffer)
                Jsi_Free(bind->buffer);
        }
        Jsi_Free(prep->bindResult);
    }
    if (prep->fieldResult)
        Jsi_Free(prep->fieldResult);
    if (prep->colTypes)
        Jsi_Free(prep->colTypes);
    if (prep->colNames)
        Jsi_Free(prep->colNames);
    if (prep->zSql)
        Jsi_Free(prep->zSql);
    if (prep->naStr) {
        Jsi_Free(prep->origSql);
        Jsi_DSFree(prep->naStr);
        Jsi_Free(prep->naStr);
    }
    if (prep->entry)
        Jsi_HashEntryDelete(prep->entry);
    if (prep->elPtr) {
        Jsi_ListEntry *pPtr = prep->elPtr;
        prep->elPtr = NULL;
        Jsi_ListEntryDelete(pPtr);
        Jsi_Free(pPtr);
    }
    Jsi_Free(prep);
    jdb->numStmts--;
}


static void mdbStmtFreeProc(Jsi_List *list, Jsi_ListEntry *l) {
    MySqlObj *jdb = (MySqlObj *)Jsi_ListGetAttr(list, NULL);
    if (!l) {
        Jsi_Free(list);
    } else {
        mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListEntryGetValue(l));
    }
}

static void mdbStmtLimit( MySqlObj *jdb)
{
    while(jdb->numStmts>jdb->maxStmts ) {
        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);
        mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListEntryGetValue(l));
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
    }
}

/*
** Finalize and free a list of prepared statements
*/
static void mdbFlushStmtCache( MySqlObj *jdb ) {
    Jsi_ListClear(jdb->stmtCache);
    jdb->numStmts = 0;
}

/*
** Release a statement reference obtained by calling mdbPrepareAndBind().
** There should be exactly one call to this function for each call to
** mdbPrepareAndBind().
**
** If the discard parameter is non-zero, then the statement is deleted
** immediately. Otherwise it is added to the LRU list and may be returned
** by a subsequent call to mdbPrepareAndBind().
*/
static void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard ) {
    if( jdb->maxStmts<=0 || discard ) {
        /* If the cache is turned off, deallocated the statement */
        mdbRelease1Stmt(jdb, prep);
    } else {
        /* Add the prepared statement to the beginning of the cache list. */
        if (!prep->elPtr)
            prep->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, prep);
        else
            Jsi_ListPushFront(jdb->stmtCache, prep->elPtr);
        mdbStmtLimit(jdb);
    }
}

long long mdbLastInsertRowid(MySqlObj* jdb)
{
    return mysql_insert_id(jdb->db);
}


static const char *mdbFindEndStr(const char *cp) {
    const char endc = *cp;
    cp++;
    while (*cp && *cp != endc) {
        if (*cp == '\\' && cp[1]) cp++;
        cp++;
    }
    if (*cp != endc)
        return NULL;
    return ++cp;
}
// Collect named parameters and translate Sql to use ?
static int MySqlExtractParmNames(MySqlObj* jdb, const char *sql, Jsi_DString *sStr, Jsi_DString *nStr) {
    const char *ocp, *cp = sql;
    int cnt = 0;
    while (*cp) {
        if (*cp == '\"'||*cp == '\'') {
            ocp = cp;
            cp = mdbFindEndStr(cp);
            if (!cp)
                return JSI_ERROR;
            Jsi_DSAppendLen(sStr, ocp, cp-ocp+1);
        } else if ((*cp == '@' || *cp == ':' || *cp == '$' ) && (isalpha(cp[1]) || cp[1] == '_')) {
            ocp = cp;
            cp+=2;
            while (*cp && (isalnum(*cp) || *cp == '_'))
                cp++;
            if (*ocp == '$' && *cp == '(') {
                const char *ttp = NULL, *ttb = NULL, *eq = NULL;
                cp++;
                if (*cp == '[')
                    eq = cp++;
                while (*cp && (isalnum(*cp) || *cp == '_' || *cp == ':' || *cp == '.' || *cp == ']')) {
                    if (*cp == ':') {
                        if (ttp)
                            return JSI_ERROR;
                        ttp = cp;
                    }
                    if (*cp == ']') {
                        if (ttb)
                            return JSI_ERROR;
                        ttb = cp;
                        if (cp[1] != ')' && cp[1] != ':' && cp[1] != '.')
                            return JSI_ERROR;
                    }
                    cp++;
                }
                if (*cp != ')')
                    return JSI_ERROR;
                if (eq && !ttb)
                    return JSI_ERROR;
                if (ttp) {
                    Jsi_DString tStr = {};
                    Jsi_DSAppendLen(&tStr, ttp+1, (cp - ttp - 1));
                    if (!jdb->typeNameHash) mdbTypeNameHashInit(jdb);
                    int rc = (Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr)) != NULL);
                    if (!rc) {
                        Jsi_DString eStr = {};
                        Jsi_HashEntry *hPtr;
                        Jsi_HashSearch search;
                        Jsi_Interp *interp = jdb->interp;
                        int n = 0;
                        for (hPtr = Jsi_HashEntryFirst(jdb->typeNameHash, &search);
                            hPtr != NULL; hPtr = Jsi_HashEntryNext(&search)) {
                            const char *key = (char*)Jsi_HashKeyGet(hPtr);
                            Jsi_DSAppend(&eStr, (n++?", ":""), key, NULL);
                        }
                        Jsi_LogWarn("bind type \"%s\" is not one of: %s", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));
                        Jsi_DSFree(&eStr);
                    }
                    Jsi_DSFree(&tStr);
                    if (!rc)
                        return JSI_ERROR;
                }
            } else
                cp--;
            if (cnt++)
                Jsi_DSAppendLen(nStr, " ", 1);
            Jsi_DSAppendLen(nStr, ocp, cp-ocp+1);
            Jsi_DSAppendLen(sStr, "?", 1);
        } else if (*cp == '\\' && cp[1]) {
            Jsi_DSAppendLen(sStr, cp, 2);
            cp++;
        } else {
            Jsi_DSAppendLen(sStr, cp, 1);
        }
        cp++;
    }
    return JSI_OK;
}

/*
** Search the cache for a prepared-statement object that implements the
** first SQL statement in the buffer pointed to by parameter zIn. If
** no such prepared-statement can be found, allocate and prepare a new
** one. In either case, bind the current values of the relevant Jsi
** variables to any $var, :var or @var variables in the statement. Before
** returning, set *ppPreStmt to point to the prepared-statement object.
**
** Output parameter *pzOut is set to point to the next SQL statement in
** buffer zIn, or to the '\0' byte at the end of zIn if there is no
** next statement.
**
** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned
** and an error message loaded into interpreter jdb->interp.
*/
static int mdbPrepareStmt(MyDbEvalContext *p)
{
    MySqlObj *jdb = p->jdb;
    //int namedParams = !jdb->optPtr->noNamedParams;
    const char *zSql = p->zSql;         /* Pointer to first SQL statement in zIn */
    MYSQL_STMT *myStmt;            /* Prepared statement object */
    MysqlPrep *prep = 0;  /* Pointer to cached statement */
    int rc = JSI_OK;
    Jsi_Interp *interp = jdb->interp;


    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);
    if (entry && ((prep = (MysqlPrep*)Jsi_HashValueGet(entry)))) {
        
        if (jdb->debug & mdbTMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare cache-hit: %s\n", zSql);
        myStmt = prep->myStmt;

        /* When a prepared statement is found, unlink it from the
        ** cache list.  It will later be added back to the beginning
        ** of the cache list in order to implement LRU replacement.
        */
        Jsi_ListRemove(jdb->stmtCache, prep->elPtr);
        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);
        
        // Sanity check for schema check: right now we just use number of columns
        if (prep->numCol != mysql_stmt_field_count(prep->myStmt)) {
            mdbRelease1Stmt(jdb, prep);
            prep = NULL;
        }
    }
    
    /* If no prepared statement was found. Compile the SQL text. Also allocate
    ** a new MysqlPrep structure.  */
    if (!prep) {
        myStmt = mysql_stmt_init(jdb->db);
        if (!myStmt) {
            Jsi_LogError("can't get statement: %s", mysql_error(jdb->db));
            return JSI_ERROR;
        }
        char **paramNames;
        int paramCnt;
        int namedParams = 0;
        Jsi_DString *naStr = NULL;
        if (p->namedParams)
        {
            int rc = JSI_OK;
            Jsi_DString nsStr, nnStr;
            Jsi_DSInit(&nsStr);
            Jsi_DSInit(&nnStr);
            if (MySqlExtractParmNames(jdb, zSql, &nsStr, &nnStr) != JSI_OK) {
                Jsi_LogError("parsing names from query: %s", zSql);
                rc = JSI_ERROR;
            }
            else if (Jsi_DSLength(&nnStr)) {
                namedParams = 1;
                zSql = Jsi_DSFreeDup(&nsStr);
                naStr = (Jsi_DString*)Jsi_Calloc(1, sizeof(*naStr));
                Jsi_SplitStr(Jsi_DSValue(&nnStr), &paramCnt, &paramNames, " ", naStr);
            }
            Jsi_DSFree(&nsStr);
            Jsi_DSFree(&nnStr);
            if (rc != JSI_OK)
                return rc;
        }

        if (mysql_stmt_prepare(myStmt, zSql, Jsi_Strlen(zSql)) )
        {
            Jsi_LogError("error in sql: %s", mysql_error(jdb->db));
            mysql_stmt_close(myStmt);
            if (namedParams) {
                Jsi_DSFree(naStr);
                Jsi_Free(naStr);
                Jsi_Free((char*)zSql);
            }
            return JSI_ERROR;
        }

        if (jdb->debug & mdbTMODE_PREPARE)
            JSI_DBQUERY_PRINTF( "DEBUG: prepare new: %s\n", zSql);
        assert( prep==0 );
        prep = (MysqlPrep*)Jsi_Calloc(1, sizeof(MysqlPrep));
        jdb->numStmts++;
        prep->sig = MYSQL_SIG_STMT;
        prep->myStmt = myStmt;
        if (!namedParams)
            prep->zSql = Jsi_Strdup(zSql);
        else {
            prep->zSql = (char*)zSql;
            prep->origSql = Jsi_Strdup(p->zSql);
            prep->naStr = naStr;
            prep->paramCnt = paramCnt;
            prep->paramNames = paramNames;
        }
        prep->paramMetaData = mysql_stmt_param_metadata(myStmt);
        prep->resultMetaData = mysql_stmt_result_metadata(myStmt);
        prep->numCol = mysql_stmt_field_count(myStmt);
        if (prep->numCol>0)
            prep->bindResult = (MYSQL_BIND *)Jsi_Calloc(prep->numCol, sizeof(MYSQL_BIND));
        prep->numParam = mysql_stmt_param_count(myStmt);
        if (prep->numParam>0 && !prep->bindParam) {
            prep->bindParam = (MYSQL_BIND *)Jsi_Calloc(prep->numParam, sizeof(MYSQL_BIND));
            prep->fieldParam = (SqlFieldResults*)Jsi_Calloc(prep->numParam, sizeof(*prep->fieldParam));
        }
        int isNew = 0;
        prep->entry = Jsi_HashEntryNew(jdb->stmtHash, p->zSql, &isNew);
        if (!isNew)
            JSI_DBQUERY_PRINTF( "mysql dup stmt entry");
        Jsi_HashValueSet(prep->entry, prep);
    }
    p->prep = prep;
    return rc;
}

/*
** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is
** returned, then an error message is stored in the interpreter before
** returning.
**
** A return value of JSI_OK means there is a row of data available. The
** data may be accessed using mdbEvalRowInfo() and dbEvalColumnValue(). This
** is analogous to a return of _MYSQLN_(ROW) from mysql_step(). If JSI_BREAK
** is returned, then the SQL script has finished executing and there are
** no further rows available. This is similar to _MYSQLN_(DONE).
*/
static int mdbEvalPrep(MyDbEvalContext *p) {
    MysqlPrep *prep = p->prep;
    Jsi_Interp *interp = p->jdb->interp;
    int rc = JSI_OK;
    if( p->prep==0 ) {
        rc = mdbPrepareAndBind(p); //p->jdb, p->zSql, &p->zSql, &p->prep);
        if( rc!=JSI_OK )
            return rc;
        prep = p->prep;
        if (p->jdb->optPtr->prefetch) {
            my_bool aBool = 1;
            mysql_stmt_attr_set(prep->myStmt, STMT_ATTR_UPDATE_MAX_LENGTH, &aBool);
        }
        if (mysql_stmt_execute(prep->myStmt)) {
            Jsi_Interp *interp = p->jdb->interp;
            Jsi_LogError("execute failed: %s", mysql_error(p->jdb->db));
            rc = JSI_ERROR;
        }
        if (p->jdb->optPtr->prefetch && mysql_stmt_store_result(prep->myStmt)) {
            Jsi_LogWarn("prefetch failed, disabling: %s", mysql_error(p->jdb->db));
            p->jdb->optPtr->prefetch = 0;
        }
        MYSQL_RES *res = mysql_stmt_result_metadata(prep->myStmt);
        MYSQL_FIELD *field;
        if (res) {
            // Setup field mappings to/from Jsi.
            prep->fieldResult = (SqlFieldResults*)Jsi_Calloc(res->field_count, sizeof(*prep->fieldResult));
            prep->colNames = (char**)Jsi_Calloc(res->field_count, sizeof(char*));
            prep->colTypes = (Jsi_OptionTypes*)Jsi_Calloc(res->field_count, sizeof(int));
            int iCnt = 0;
            while((field = mysql_fetch_field(res)))
            {
                assert(iCnt<prep->numCol);
                SqlFieldResults *fres = prep->fieldResult+iCnt;
                MYSQL_BIND *bindResult = prep->bindResult+iCnt;
                
                bindResult->buffer = &fres->buffer.vchar;
                fres->field = field;
                prep->colNames[iCnt] = field->name;
                switch (field->type) {
                    case MYSQL_TYPE_TINY:
                    case MYSQL_TYPE_BIT:
                        if (field->length == 1) {
                            fres->jsiTypeMap = JSI_OPTION_BOOL;
                            fres->mapType = MYSQL_TYPE_DOUBLE;
                            fres->vsize = 1;
                            break;
                            
                        }
                    case MYSQL_TYPE_SHORT:
                    case MYSQL_TYPE_LONG:
                    case MYSQL_TYPE_DECIMAL:
                        fres->jsiTypeMap = JSI_OPTION_WIDE;
                        fres->mapType = MYSQL_TYPE_LONG;
                        fres->vsize = sizeof(long long);
                        break;
                    case MYSQL_TYPE_LONGLONG:
                        fres->jsiTypeMap = JSI_OPTION_WIDE;
                        fres->mapType = MYSQL_TYPE_LONGLONG;
                        fres->vsize = sizeof(long long);
                        break;
                    
                    case MYSQL_TYPE_FLOAT:
                    case MYSQL_TYPE_DOUBLE:
                        fres->jsiTypeMap = JSI_OPTION_DOUBLE;
                        fres->mapType = MYSQL_TYPE_DOUBLE;
                        fres->vsize = sizeof(double);
                        break;
                    case MYSQL_TYPE_TIME:
                    case MYSQL_TYPE_DATE:
                    case MYSQL_TYPE_DATETIME:
                    case MYSQL_TYPE_TIMESTAMP:
                        fres->jsiTypeMap = JSI_OPTION_DATETIME;
                        fres->mapType = MYSQL_TYPE_DATETIME;
                        fres->vsize = sizeof(MYSQL_TIME);
                        break;
                    case MYSQL_TYPE_STRING:
                    default:
                        if (IS_NUM(field->type)) {
                            fres->mapType = MYSQL_TYPE_LONGLONG;
                            fres->jsiTypeMap = JSI_OPTION_DOUBLE;
                            fres->vsize = sizeof(double);
                        } else {
                            fres->jsiTypeMap = JSI_OPTION_STRING;
                            fres->mapType = MYSQL_TYPE_STRING;
                            if (p->jdb->optPtr->prefetch)
                                fres->vsize = field->max_length;
                            else
                                fres->vsize = p->jdb->optPtr->maxString;
                            if (fres->vsize <= 0)
                                fres->vsize = BUFSIZ;
                            bindResult->buffer = fres->buffer.vstring = (char*)Jsi_Malloc(fres->vsize);
                            fres->buffer.vstring[0] = 0;
                        }
                        break;
                }
                prep->colTypes[iCnt] = fres->jsiTypeMap;
                bindResult->buffer_type = fres->mapType;
                bindResult->buffer_length = fres->vsize;
                bindResult->length = &fres->len;
                bindResult->is_null = &fres->isnull;
                iCnt++;
            }
        }
        else return JSI_BREAK;
        if (mysql_stmt_bind_result(prep->myStmt, prep->bindResult)) {
            fprintf(stderr, "mysql_stmt_bind_Result(), failed. Error:%s\n", mysql_stmt_error(prep->myStmt));
            return JSI_ERROR;
        }
    }
    return rc;
}

static int mdbEvalStep(MyDbEvalContext *p) {
    int rc = JSI_OK;
    if( p->prep==0)
        rc = mdbEvalPrep(p);
    if (rc == JSI_BREAK)
        return JSI_BREAK;
    if (rc == JSI_OK)
        rc = mdbEvalStepSub(p, 1, NULL);
    return rc;
}

const char *mysqlGetbindParamName(MysqlPrep* pStmt, int n) {
    if (n>=1 && n<=pStmt->paramCnt)
        return pStmt->paramNames[n-1];
    return NULL;
}
  
/*
enum enum_field_types { MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY,
                        MYSQL_TYPE_SHORT,  MYSQL_TYPE_LONG,
                        MYSQL_TYPE_FLOAT,  MYSQL_TYPE_DOUBLE,
                        MYSQL_TYPE_NULL,   MYSQL_TYPE_TIMESTAMP,
                        MYSQL_TYPE_LONGLONG,MYSQL_TYPE_INT24,
                        MYSQL_TYPE_DATE,   MYSQL_TYPE_TIME,
                        MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR,
                        MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR,
                        MYSQL_TYPE_BIT,
                        MYSQL_TYPE_NEWDECIMAL=246,
                        MYSQL_TYPE_ENUM=247,
                        MYSQL_TYPE_SET=248,
                        MYSQL_TYPE_TINY_BLOB=249,
                        MYSQL_TYPE_MEDIUM_BLOB=250,
                        MYSQL_TYPE_LONG_BLOB=251,
                        MYSQL_TYPE_BLOB=252,
                        MYSQL_TYPE_VAR_STRING=253,
                        MYSQL_TYPE_STRING=254,
                        MYSQL_TYPE_GEOMETRY=255

};
*/
/*
 * MYSQL_TYPE_TINY  1
MYSQL_TYPE_SHORT    2
MYSQL_TYPE_LONG 4
MYSQL_TYPE_LONGLONG 8
MYSQL_TYPE_FLOAT    4
MYSQL_TYPE_DOUBLE   8
MYSQL_TYPE_TIME sizeof(MYSQL_TIME)
MYSQL_TYPE_DATE sizeof(MYSQL_TIME)
MYSQL_TYPE_DATETIME sizeof(MYSQL_TIME)
MYSQL_TYPE_STRING   data length
MYSQL_TYPE_BLOB data_length
*/


static int mdbPrepareAndBind(MyDbEvalContext *p)
{
    if (mdbPrepareStmt(p) != JSI_OK)
        return JSI_ERROR;
    MysqlPrep *prep = p->prep;
    MySqlObj *jdb = p->jdb;
    Jsi_Interp *interp = jdb->interp;
    Jsi_Value *pv = NULL, *apv = NULL;
    char tname[50];

    int rc = JSI_OK;
    int i, n, decr, nVar = prep->numParam;

    if (nVar<=0)
        return rc;
    if (!prep->bindParam)
        prep->bindParam = (MYSQL_BIND*)Jsi_Calloc(nVar, sizeof(MYSQL_BIND));
    else
        memset(prep->bindParam, 0, (nVar * sizeof(MYSQL_BIND)));
    for(i=1; i<=nVar; i++) {
        int btype = 0;
        int isInt = 0;
        int isBlob = 0;
        const char *zVar = mysqlGetbindParamName(prep, i);
        tname[0] = 0;
        decr = 0;
        if (zVar == NULL) {
            if (!jdb->optPtr || (!jdb->optPtr->varName[0] && !jdb->optPtr->values)) {
                Jsi_LogError("? bind without varName/values for param %d", i);
                return JSI_ERROR;
            }
            if (!apv) {
                if (!(apv = jdb->optPtr->values))
                    apv = Jsi_NameLookup(interp, jdb->optPtr->varName);
            }
            if (apv == NULL || !Jsi_ValueIsArray(interp, apv)) {
                Jsi_LogError("can not find array var: %s", jdb->optPtr->varName);
                return JSI_ERROR;
            }
            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) {
                Jsi_LogError("array element %d missing", nVar);
                return JSI_ERROR;
            }
        }
        else if ((zVar[0]!='$' && zVar[0]!=':' && zVar[0]!='@') ) {
            Jsi_LogError("can not find bind var %s", zVar);
            return JSI_ERROR;
        } else {
           
            int zvLen = strlen(zVar);
            char *zcp;
            if (zVar[0] =='$' && ((zcp = Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')
            {
                Jsi_DString vStr;
                Jsi_DSInit(&vStr);
                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));
                int slen = Jsi_Strlen(zcp);
                const char *ttp;
                if (jdb->optPtr->typeCheck!=mdbTypeCheck_None && (ttp = Jsi_Strchr(zVar,':'))) {
                    // Extract bind-type.
                    Jsi_DString tStr = {};
                    int tlen = Jsi_Strlen(ttp+1);
                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);
                    strcpy(tname, Jsi_DSValue(&tStr));
                    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(jdb->typeNameHash, tname);
                    assert(hPtr);
                    btype = (int)Jsi_HashValueGet(hPtr);
                    Jsi_DSFree(&tStr);
                    slen -= tlen;
                }

                if (isdigit(zcp[1])) {
                    Jsi_DSAppendLen(&vStr, "[", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                    Jsi_DSAppendLen(&vStr, "]", 1);
                } else {
                    if (zcp[1] != '[')
                        Jsi_DSAppendLen(&vStr, ".", 1);
                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);
                }
                pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));
                Jsi_DSFree(&vStr);
                //decr = 1;
            } else
                pv = Jsi_VarLookup(interp, &zVar[1]);
        }
        Jsi_Number r;
        SqlFieldResults *fres = prep->fieldParam+i-1;
        MYSQL_BIND *bind = prep->bindParam+i-1;
        memset(bind, 0, sizeof(*bind));
        // Now create binding.
        if(!pv ) {
            if (!jdb->bindWarn) {
                Jsi_LogError("unknown bind param: %s", zVar);
                rc = JSI_ERROR;
                break;
            } else
                Jsi_LogWarn("unknown bind param: %s", zVar);
        } else {
            if (btype && !Jsi_ValueIsUndef(interp, pv)) {
                int done = 0, match = 1, cast = (jdb->optPtr->typeCheck==mdbTypeCheck_Cast);
                switch (btype) {
                    case MYSQL_TYPE_BLOB:
                        isBlob = 1;
                    case MYSQL_TYPE_STRING:
                        if (cast)
                            Jsi_ValueToString(interp, pv, &n);
                        else
                            match = Jsi_ValueIsString(interp, pv); 
                        break;
                    case MYSQL_TYPE_DOUBLE:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv); 
                        break;
                    case MYSQL_TYPE_LONGLONG:
                        isInt = 1;
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else
                            match = Jsi_ValueIsNumber(interp, pv); 
                        break;
                    case MYSQL_TYPE_TINY:
                        if (cast)
                            Jsi_ValueToBool(interp, pv);
                        else
                            match = Jsi_ValueIsBoolean(interp, pv); 
                        break;
                    case MYSQL_TYPE_TIME:
                    case MYSQL_TYPE_DATE:
                    case MYSQL_TYPE_DATETIME:
                    case MYSQL_TYPE_TIMESTAMP:
                        if (cast)
                            Jsi_ValueToNumber(interp, pv);
                        else if (!Jsi_ValueIsNumber(interp, pv))
                            goto errout;
                        Jsi_GetNumberFromValue(interp, pv, &r);
                        bind->buffer_type = (enum enum_field_types)btype;
                        bind->buffer=&fres->buffer.timestamp;
                        bind->buffer_length = sizeof(fres->buffer.timestamp);
                        bind->length = NULL;
                        mdbJsToMyTime(r, &fres->buffer.timestamp, 1);
                        done = 1;
                        break;
                    default:
                        Jsi_LogBug("Unhandled bind type: %s = %d", tname, btype);
                }
                if (done)
                    continue;
                 if (cast == 0 && match == 0) 
errout:
                 {
                    int ltyp = (jdb->optPtr->typeCheck==mdbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);
                    Jsi_LogMsg(interp, ltyp, "bind param \"%s\" type is not \"%s\"", zVar, tname);
                    if (ltyp == JSI_LOG_ERROR)
                        return JSI_ERROR;
                }
            }
            
            if (Jsi_ValueIsBoolean(interp, pv)) {
                Jsi_GetBoolFromValue(interp, pv, &n);
                bind->buffer_type = MYSQL_TYPE_TINY;
                bind->buffer = &fres->buffer.vchar;
                bind->buffer_length = sizeof(fres->buffer.vchar);
                bind->length = &fres->len;
                //bind->is_null = &fres->isnull;
                fres->buffer.vchar = n;
                
            } else if (Jsi_ValueIsNumber(interp, pv)) {
                Jsi_Number r;
                Jsi_Wide wv;
                Jsi_GetNumberFromValue(interp, pv, &r);
                wv = (Jsi_Wide)r;
                bind->buffer_type = MYSQL_TYPE_DOUBLE;
                bind->buffer = &fres->buffer.vdouble;
                bind->buffer_length = sizeof(fres->buffer.vdouble);
                bind->length = &fres->len;
                fres->buffer.vdouble = (double)r;
                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0)) {
                    bind->buffer = &fres->buffer.vlonglong;
                    bind->buffer_type = MYSQL_TYPE_LONGLONG;
                    bind->buffer_length = sizeof(fres->buffer.vlonglong);
                    fres->buffer.vlonglong = wv;
                }
            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->optPtr->mapundef)) {
bindnull:
                bind->buffer_type = MYSQL_TYPE_NULL;
                bind->buffer = &fres->buffer.vchar;
                bind->buffer_length = sizeof(fres->buffer.vchar);
                bind->length = &fres->len;
                fres->buffer.vchar = 0;

            } else if (Jsi_ValueIsString(interp, pv)) {
                char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);
                bind->buffer_type = MYSQL_TYPE_STRING;
                bind->buffer=sstr;
                bind->buffer_length = n;
                bind->length = NULL;
                if (isBlob)
                    bind->buffer_type = MYSQL_TYPE_BLOB;
            } else {
                if (!jdb->bindWarn) {
                    Jsi_LogError("bind param must be string/number/bool/null: %s", zVar);
                    rc = JSI_ERROR;
                    break;
                } else {
                    Jsi_LogWarn("bind param must be string/number/bool/null: %s", zVar);
                    goto bindnull;
                }
            }
            if (decr)
                Jsi_DecrRefCount(interp, pv);
        }
    }
    if (mysql_stmt_bind_param(prep->myStmt, prep->bindParam)) {
        Jsi_LogError("bind failed: %s", mysql_error(jdb->db));
        rc = JSI_ERROR;
    }
    return rc;
}


static void mdbClose(MYSQL  *db) {
        mysql_close(db);
}

static int mysqlObjFree(Jsi_Interp *interp, void *data);
static int  mysqlObjEqual(void *data1, void *data2);
static int  mysqlObjIsTrue(void *data);

static Jsi_UserObjReg mysqlobject = {
    .name   = "MySql",
    .spec   = mysqlCmds,
    .freefun= mysqlObjFree,
    .istrue = mysqlObjIsTrue,
    .isequ  = mysqlObjEqual
};

static int mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value)
{
    if (!Jsi_ValueIsArray(interp, value)) {
        Jsi_LogError("expected array of numbers");
        return JSI_ERROR;
    }
    int i, argc = Jsi_ValueGetLength(interp, value);
    for (i=0; i<argc; i++) {
        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);
        if (!Jsi_ValueIsNumber(interp, v)) {
            Jsi_LogError("expected array of numbers");
            return JSI_ERROR;
        }
    }
    return JSI_OK;
}

/*
** JSI calls this procedure when an MYSQL  database command is
** deleted.
*/
static void mdbDeleteCmd(MySqlObj *jdb)
{
    Jsi_Interp *interp = jdb->interp;
    if (jdb->debug & mdbTMODE_DELETE)
        JSI_DBQUERY_PRINTF( "DEBUG: delete\n");
    mdbFlushStmtCache(jdb);
    if (jdb->stmtHash)
        Jsi_HashDelete(jdb->stmtHash);
    //closeIncrblobChannels(jdb);
    if (jdb->db) {
        mdbClose(jdb->db);
    }
    while( jdb->pFunc ) {
        SqlFunc *pFunc = jdb->pFunc;
        jdb->pFunc = pFunc->pNext;
        Jsi_DSFree(&pFunc->dScript);
        Jsi_DecrRefCount(interp, pFunc->tocall);
        Jsi_Free((char*)pFunc);
    }
    if( jdb->zNull ) {
        Jsi_Free(jdb->zNull);
    }
    if (jdb->typeNameHash)
        Jsi_HashDelete(jdb->typeNameHash);
    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);
    if (jdb->stmtCache)
        Jsi_ListDelete(jdb->stmtCache);
}

/*
** Return a JSON formatted value for the iCol'th column of the row currently pointed to by
** the MyDbEvalContext structure passed as the first argument.
*/
static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {
    Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];
    MysqlPrep *prep = p->prep;
    SqlFieldResults *field = prep->fieldResult+iCol;
    if (field->isnull) {
        Jsi_DSAppend(dStr, "null", NULL);
        return;
    }
    const char *zBlob = "";
    int bytes = 0;

    switch(field->jsiTypeMap) {
        case JSI_OPTION_BOOL: {
            sprintf(nbuf, "%s", field->buffer.vchar?"true":"false");
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_WIDE: {
            sprintf(nbuf, "%lld", field->buffer.vlonglong);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_DOUBLE: {
            Jsi_NumberToString(field->buffer.vdouble, nbuf);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_DATE:
        case JSI_OPTION_TIME:
        case JSI_OPTION_DATETIME: {
            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);
            Jsi_NumberToString(jtime, nbuf);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_STRING:
            zBlob = field->buffer.vstring;
        default:
        {
            if( !zBlob ) {
                Jsi_DSAppend(dStr, "null", NULL);
                return;
            }
            Jsi_JSONQuote(interp, zBlob, bytes, dStr);
            return;
        }
    }
}

static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {
    //Jsi_Interp *interp = p->jdb->interp;
    char nbuf[200];
    MysqlPrep *prep = p->prep;
    SqlFieldResults *field = prep->fieldResult+iCol;
    Jsi_Interp *interp = p->jdb->interp;
    if (field->isnull)
        return;
        
    switch(field->jsiTypeMap) {
        case JSI_OPTION_STRING: {
            int bytes = field->len;
            const char *zBlob = field->buffer.vstring;
    
            if( !zBlob ) {
                const char *nv = p->jdb->optPtr->nullvalue;
                Jsi_DSAppend(dStr, nv?nv:"null", NULL);
                return;
            }
            Jsi_DSAppendLen(dStr, zBlob, bytes);
            return;
        }
        case JSI_OPTION_BOOL: {
            sprintf(nbuf, "%s", field->buffer.vchar?"true":"false");
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_WIDE: {
            sprintf(nbuf, "%lld", field->buffer.vlonglong);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_DATE:
        case JSI_OPTION_TIME:
        case JSI_OPTION_DATETIME: {
            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);
            Jsi_NumberToString(jtime, nbuf);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        case JSI_OPTION_DOUBLE: {
            Jsi_NumberToString(field->buffer.vdouble, nbuf);
            Jsi_DSAppend(dStr, nbuf, NULL);
            return;
        }
        default:
            Jsi_LogWarn("unknown type: %d", field->jsiTypeMap);
    
    }
}


static Jsi_Value* mdbEvalSetColumnValue(MyDbEvalContext *p, int iCol, Jsi_Value **val) {
    Jsi_Interp *interp = p->jdb->interp;
    MysqlPrep *prep = p->prep;
    SqlFieldResults *field = prep->fieldResult+iCol;
    if (field->isnull)
        return Jsi_ValueMakeNull(interp, val);
        
    switch(field->jsiTypeMap) {
        case JSI_OPTION_STRING: {
            int bytes = field->len;
            char *zBlob = field->buffer.vstring;
            if( !zBlob ) {
                return Jsi_ValueMakeNull(interp, val);
            }
            zBlob = (char*)Jsi_Malloc(bytes+1);
            memcpy(zBlob, field->buffer.vstring, bytes+1);
            zBlob[bytes] = 0;
            return Jsi_ValueMakeBlob(interp, val, (unsigned char*)zBlob, bytes+1);
        }
        case JSI_OPTION_BOOL:
            return Jsi_ValueMakeBool(interp, val, field->buffer.vchar);
        case JSI_OPTION_WIDE:
             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vlonglong);
        case JSI_OPTION_DATE:
        case JSI_OPTION_TIME:
        case JSI_OPTION_DATETIME: {
            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);
            return Jsi_ValueMakeNumber(interp, val, jtime);
        }
        case JSI_OPTION_DOUBLE:
             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vdouble);
        default:
            Jsi_LogWarn("unknown type: %d", field->jsiTypeMap);
    }
    return Jsi_ValueNew1(interp);
}

static int mdbEvalCallCmd( MyDbEvalContext *p, Jsi_Interp *interp, int result)
{
    int cnt = 0, rc = result;
    Jsi_Value *varg1;
    Jsi_Obj *argso;
    char **apColName = NULL;
    Jsi_OptionTypes *apColType = NULL;
    if (p->jdb->debug & mdbTMODE_EVAL)
        JSI_DBQUERY_PRINTF( "DEBUG: eval\n");

    while( (rc==JSI_OK) && JSI_OK==(rc = mdbEvalStep(p)) ) {
        int i;
        int nCol;

        cnt++;
        mdbEvalRowInfo(p, &nCol, &apColName, &apColType);
        if (nCol<=0)
            continue;
        if (Jsi_ValueIsNull(interp,p->tocall))
            continue;
        /* Single object containing sql result members. */
        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));
        for(i=0; i<nCol; i++) {
            Jsi_Value *nnv = mdbEvalSetColumnValue(p, i, NULL);
            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);
        }
        Jsi_IncrRefCount(interp, varg1);
        rc = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);
        Jsi_DecrRefCount(interp, varg1);
        if (rc)
            break;
    }
    //mdbEvalFinalize(p);

    if( rc==JSI_OK || rc==JSI_BREAK ) {
        //Jsi_ResetResult(interp);
        rc = JSI_OK;
    }
    return rc;
}

static MySqlObj *_mysql_getDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)
{
    MySqlObj *jdb = (MySqlObj*)Jsi_UserObjGetData(interp, _this, funcPtr);
    if (!jdb) {
        Jsi_LogError("MySql call to a non-mysql object\n");
        return NULL;
    }
    if (!jdb->db)
    {
        Jsi_LogError("MySql db is closed");
        return NULL;
    }
    return jdb;
}

static void mysqlObjErase(MySqlObj *jdb)
{
    mdbDeleteCmd(jdb);
    jdb->db = NULL;
}

static int mysqlObjFree(Jsi_Interp *interp, void *data)
{
    MySqlObj *fo = (MySqlObj*)data;
    SQLSIGASSERT(fo,DB);
    mysqlObjErase(fo);
    MEMCLEAR(fo);
    Jsi_Free(fo);
    return JSI_OK;
}

static int mysqlObjIsTrue(void *data)
{
    MySqlObj *fo = (MySqlObj*)data;
    SQLSIGASSERT(fo,DB);
    if (!fo->db) return 0;
    else return 1;
}

static int mysqlObjEqual(void *data1, void *data2)
{
    //SQLSIGASSERT(data1,DB);
    //SQLSIGASSERT(data2,DB);
    return (data1 == data2);
}
static MYSQL* mdbConnect(Jsi_Interp *interp, MySqlObj* jdb)
{
    return mysql_real_connect(jdb->db,
        jdb->host?Jsi_ValueString(interp, jdb->host, NULL):NULL,
        jdb->user, jdb->password, jdb->database,
        jdb->port, 0, jdb->dbflags);
}

#define FN_MySql JSI_INFO("\
Create a mysql client.")
static int MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    jdb = (MySqlObj*)Jsi_Calloc(1, sizeof(*jdb));
    SQLSIGINIT(jdb, DB);
    const char *groupname = "mysqljsi";
    
    jdb->maxStmts = NUM_PREPARED_STMTS;
    jdb->forceInt = 1;
    jdb->interp = interp;
    jdb->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if (jdb->hasOpts && Jsi_OptionsProcess(interp, SqlOptions, arg, jdb, 0) < 0) {
        jdb->deleted = 1;
        mysqlObjFree(interp, jdb);
        return JSI_ERROR;
    }
    jdb->db = mysql_init(NULL);

#if (MYSQL_VERSION_ID>=32350)
    if (jdb->reconnect)
    {
      my_bool reconnect = 1;
      mysql_options(jdb->db, MYSQL_OPT_RECONNECT, &reconnect);
    }
    mysql_options(jdb->db, MYSQL_READ_DEFAULT_GROUP, groupname);
#endif

#if (MYSQL_VERSION_ID >= 40107)
    if (jdb->sslKey) {
        const char *sslcert = Jsi_ValueString(interp, jdb->sslCert, NULL),
            *sslca = Jsi_ValueString(interp, jdb->sslCA, NULL),
            *sslcapath = Jsi_ValueString(interp, jdb->sslCAPath, NULL),
            *sslcipher = Jsi_ValueString(interp, jdb->sslCipher, NULL),
            *sslkey = Jsi_ValueString(interp, jdb->sslKey, NULL);
        mysql_ssl_set(jdb->db, sslkey, sslcert, sslca, sslcapath, sslcipher);
        jdb->dbflags |= CLIENT_SSL;
    }
#endif

    if (!mdbConnect(interp, jdb)) {
        mysqlObjFree(interp, jdb);
        Jsi_LogError("connect failed %s", mysql_error(jdb->db));
        return JSI_ERROR;
    }

    if (jdb->enableMulti) {
        if (mysql_set_server_option(jdb->db, MYSQL_OPTION_MULTI_STATEMENTS_ON))
            Jsi_LogWarn("multi on failed %s", mysql_error(jdb->db));
    }
    //jdb->event = Jsi_EventNew(interp, mysqlUpdate, jdb); //TODO: events
    Jsi_Value *toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "MySql", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    if ((jdb->objId = Jsi_UserObjNew(interp, &mysqlobject, fobj, jdb))<0) {
        mysqlObjFree(interp, jdb);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    jdb->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);
    jdb->userObjPtr = fobj;
    jdb->optPtr = &jdb->queryOpts;
    Jsi_ListAttr attr = { .data=(void*)jdb, .freeProc=mdbStmtFreeProc };
    jdb->stmtCache = Jsi_ListNew(&attr);
    return JSI_OK;
}

static int MySqlReconnectCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);
    if (!jdb) return JSI_ERROR;
    int oldMax = jdb->maxStmts;
    jdb->maxStmts = 0;
    mdbStmtLimit(jdb);
    jdb->maxStmts = oldMax;
    mysql_close(jdb->db);
    jdb->db = mysql_init(NULL);
    if (!mdbConnect(interp, jdb)) {
        Jsi_LogError("reconnect failed: %s", mysql_error(jdb->db));
        return JSI_ERROR;
    }
    return JSI_OK;
}

#define FN_evaluate JSI_INFO("\
Variable binding is NOT performed.  \
Returns number of modified fields")
static int MySqlEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);
    if (!jdb) return JSI_ERROR;
    int zLen, rc = JSI_OK, cnt = 0;
    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, &zLen);

    if (mysql_real_query(jdb->db, zSql, zLen)) {
        Jsi_LogError("mysql error: %s", mysql_error(jdb->db));
        rc = JSI_ERROR;
    } else if (jdb->enableMulti) {
        MYSQL_RES *results;
        int sr = mysql_next_result(jdb->db);
        while (sr == 0 && (results = mysql_store_result(jdb->db)))
            mysql_free_result(results);
        cnt = mysql_field_count(jdb->db);
    }
        
    if (rc == JSI_OK)
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);
    return rc;
}

/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static const char needCsvQuote[] = {
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, 
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
};

/*
** Output a single term of CSV.  Actually, p->separator is used for
** the separator, which may or may not be a comma.  p->nullvalue is
** the null value.  Strings are quoted if necessary.
*/
static void mdbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)
{
    if( z==0 ) {
        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:"", NULL);
    } else {
        int i;
        int nSep = Jsi_Strlen(p->separator);
        for(i=0; z[i]; i++) {
            if( needCsvQuote[((unsigned char*)z)[i]] || 
                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {
                i = 0;
                break;
            }
        }
        if( i==0 ) {
            Jsi_DSAppend(dStr, "\"", NULL);
            for(i=0; z[i]; i++) {
                if( z[i]=='"' ) Jsi_DSAppend(dStr, "\"", NULL);
                Jsi_DSAppendLen(dStr, z+i, 1);
            }
            Jsi_DSAppend(dStr, "\"", NULL);
        } else {
            Jsi_DSAppend(dStr, z, NULL);
        }
    }
    if( bSep ) {
        Jsi_DSAppend(dStr, p->separator, NULL);
    }
}

static void mdbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)
{
    while( *z ) {
        switch (*z) {
        case '<':
            Jsi_DSAppend(dStr, "&lt;", NULL);
            break;
        case '>':
            Jsi_DSAppend(dStr, "&gt;", NULL);
            break;
        case '&':
            Jsi_DSAppend(dStr, "&amp;", NULL);
            break;
        case '\"':
            Jsi_DSAppend(dStr, "&quot;", NULL);
            break;
        case '\'':
            Jsi_DSAppend(dStr, "&#39;", NULL);
            break;
        default:
            Jsi_DSAppendLen(dStr, z, 1);
            break;
        }
        z++;
    }
}
/*
** Output the given string as a quoted string using SQL quoting conventions.
*/
static void mdbOutputQuotedString(Jsi_DString *dStr, const char *z) {
    int i;
    int nSingle = 0;
    for(i=0; z[i]; i++) {
        if( z[i]=='\'' ) nSingle++;
    }
    if( nSingle==0 ) {
        Jsi_DSAppend(dStr,"'", z, "'", NULL);
    } else {
        Jsi_DSAppend(dStr,"'", NULL);
        while( *z ) {
            for(i=0; z[i] && z[i]!='\''; i++) {}
            if( i==0 ) {
                Jsi_DSAppend(dStr,"''", NULL);
                z++;
            } else if( z[i]=='\'' ) {
                Jsi_DSAppendLen(dStr,z, i);
                Jsi_DSAppend(dStr,"''", NULL);
                z += i+1;
            } else {
                Jsi_DSAppend(dStr, z, NULL);
                break;
            }
        }
        Jsi_DSAppend(dStr,"'", NULL);
    }
}

static int MySqlQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc = JSI_OK;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString eStr = {};
    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);
    int cnt = 0;
    char **apColName = NULL;
    Jsi_OptionTypes *apColType = NULL;
    int isopts = 0;
    MyDbEvalContext sEval = {};
    QueryOpts opts, *oEopt;
    opts = jdb->queryOpts;
    opts.callback = NULL;
    opts.width = NULL;
    Jsi_Value *callback = NULL, *width = NULL;
            
    if (arg) {
        if (Jsi_ValueIsNull(interp,arg)) {
        } else if (Jsi_ValueIsFunction(interp,arg)) {
            callback = opts.callback = arg;
        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {
            isopts = 1;
        } else {
            Jsi_LogError("argument must be null, a function, or options");
            return JSI_ERROR;
        }
    }

    if (isopts) {
        if (Jsi_OptionsProcess(interp, QueryFmtOptions, arg, &opts, 0) < 0)
            return JSI_ERROR;
        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);
        width = (opts.width ? opts.width : jdb->queryOpts.width);
    }
/*    if (jdb->queryOpts.Cdata) {
        char *cdata = (char*)jdb->queryOpts.Cdata;
        MySqlObjMultipleBind* copts = Jsi_CDataLookup(interp, cdata);
        if (!copts) {
            Jsi_LogError("unknown Cdata option: %s", jdb->queryOpts.Cdata);
            return JSI_ERROR;
        }
        int n = MySqlObjQuery(jdb, copts->opts, copts->data, copts->numData, zSql, copts->flags);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
        return JSI_OK;
    } */
    if (!opts.separator) {
        switch (opts.mode) {
            case _mdb_EF_LIST: opts.separator = "|"; break;
            case _mdb_EF_COLUMN: opts.separator = " "; break;
            case _mdb_EF_TABS: opts.separator = "\t"; break;
            default: opts.separator = ",";
        }
    }
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = opts.nocache;
    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK) {
        rc = JSI_ERROR;
        goto bail;
    }
    sEval.namedParams = (opts.noNamedParams==0 && !opts.values);
    sEval.ret = *ret;
    oEopt = jdb->optPtr;
    jdb->optPtr = &opts;
    
    if (sEval.namedParams) {
        rc = mdbEvalPrep(&sEval);
        if (rc == JSI_ERROR)
            goto bail;
        if (rc == JSI_BREAK) {
            rc = JSI_OK;
            goto bail;
        }
    }
    if (callback) {
        sEval.tocall = callback;
        if (opts.mode != _mdb_EF_ROWS) {
            Jsi_LogError("'mode' must be 'rows' with 'callback'");
            rc = JSI_ERROR;
        } else 
            rc = mdbEvalCallCmd(&sEval, interp, JSI_OK);
        goto bail;
    }
    switch (opts.mode) {
        case _mdb_EF_NONE:
            while(JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            goto bail;
            break;
        case _mdb_EF_JSON:
            if (opts.headers) {
                Jsi_DSAppend(dStr, "[ ", NULL);
                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                    int i;
                    int nCol;
                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                    if (cnt == 0) {
                        Jsi_DSAppend(dStr, "[", NULL);
                        for(i=0; i<nCol; i++) {
                            if (i)
                                Jsi_DSAppend(dStr, ", ", NULL);
                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                        }
                        Jsi_DSAppend(dStr, "]", NULL);
                        cnt++;
                    }
                    if (cnt)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_DSAppend(dStr, "[", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        mdbEvalSetColumnJSON(&sEval, i, dStr);
                    }
                    Jsi_DSAppend(dStr, "]", NULL);
                    cnt++;
                    if (opts.limit && cnt>opts.limit) break;
                }
                Jsi_DSAppend(dStr, " ]", NULL);
                
            } else {
                Jsi_DSAppend(dStr, "[ ", NULL);
                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                    int i;
                    int nCol;
                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                    if (cnt)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_DSAppend(dStr, "{", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                        Jsi_DSAppend(dStr, ":", NULL);
                        mdbEvalSetColumnJSON(&sEval, i, dStr);
                    }
                    Jsi_DSAppend(dStr, "}", NULL);
                    cnt++;
                    if (opts.limit && cnt>=opts.limit) break;
                }
                Jsi_DSAppend(dStr, " ]", NULL);
            }
            break;
            
        case _mdb_EF_JSON2: {
                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                    int i;
                    int nCol;
                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                    if (cnt == 0 && 1) {
                        Jsi_DSAppend(dStr, "{ \"names\": [ ", NULL);
                        for(i=0; i<nCol; i++) {
                            if (i)
                                Jsi_DSAppend(dStr, ", ", NULL);
                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);
                        }
                        Jsi_DSAppend(dStr, " ], \"values\": [ ", NULL);
                    }
                    if (cnt)
                        Jsi_DSAppend(dStr, ", ", NULL);
                    Jsi_DSAppend(dStr, "[", NULL);
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, ", ", NULL);
                        mdbEvalSetColumnJSON(&sEval, i, dStr);
                    }
                    Jsi_DSAppend(dStr, " ]", NULL);
                    cnt++;
                    if (opts.limit && cnt>=opts.limit) break;
                }
                if (cnt)
                    Jsi_DSAppend(dStr, " ] } ", NULL);
            }
            break;
            
        case _mdb_EF_LIST:
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, opts.separator, NULL);
                        Jsi_DSAppend(dStr, apColName[i], NULL);
                    }
                }
    
                if (cnt || opts.headers)
                    Jsi_DSAppend(dStr, "\n", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    mdbEvalSetColumn(&sEval, i, dStr);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            break;
            
        case _mdb_EF_COLUMN: {
            int *wids = NULL;
            Jsi_DString vStr = {};
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i, w;
                int nCol;
                
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && nCol>0) {
                    Jsi_DString sStr;
                    wids = (int*)Jsi_Calloc(nCol, sizeof(int));
                    Jsi_DSInit(&sStr);
                    for(i=0; i<nCol; i++) {
                        int j = Jsi_Strlen(apColName[i]);
                        wids[i] = (j<10?10:j);
                        if (width) {
                            Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);
                            if (wv) {
                                Jsi_Number dv;
                                Jsi_ValueGetNumber(interp, wv, &dv);
                                if (dv>0)
                                    wids[i] = (int)dv;
                            }
                        }
                        w = (j<wids[i] ? j : wids[i]);
                        Jsi_DSAppendLen(dStr, apColName[i], w);
                        w = (j<wids[i] ? wids[i]-j+1 : 0);
                        while (w-- > 0)
                            Jsi_DSAppend(dStr, " ", NULL);
                    }
                    for(i=0; i<nCol && opts.headers; i++) {
                        w = wids[i];
                        w -= Jsi_Strlen(apColName[i]);
                        if (i) {
                            Jsi_DSAppend(dStr, opts.separator, NULL);
                            Jsi_DSAppend(&sStr, opts.separator, NULL);
                        }
                        w = wids[i];
                        while (w-- > 0)
                            Jsi_DSAppend(&sStr, "-", NULL);
                    }
                    if (opts.headers)
                        Jsi_DSAppend(dStr, "\n", Jsi_DSValue(&sStr), "\n", NULL);
                    Jsi_DSFree(&sStr);
                }
    
                if (cnt)
                    Jsi_DSAppend(dStr, "\n", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    int nl = Jsi_DSLength(&vStr);
                    if (nl > wids[i]) {
                        Jsi_DSSetLength(&vStr, wids[i]);
                        w = 0;
                    } else {
                        w = wids[i]-nl;
                    }
                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
                    while (w-- > 0)
                        Jsi_DSAppend(dStr, " ", NULL);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            if (wids)
                Jsi_Free(wids);
            break;
        }
        
        case _mdb_EF_INSERT: {
            Jsi_DString vStr = {};    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                const char *tbl = (opts.table ? opts.table : "table");
                if (cnt)
                    Jsi_DSAppend(dStr, "\n", NULL);
                Jsi_DSAppend(dStr, "INSERT INTO ", tbl, " VALUES(", NULL);
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                for(i=0; i<nCol; i++) {
                    Jsi_Number dv;
                    const char *azArg;
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    
                    MysqlPrep *prep = sEval.prep;
                    Jsi_OptionTypes ptype = prep->fieldResult[i].jsiTypeMap;
                    
                    azArg = Jsi_DSValue(&vStr);
                    const char *zSep = i>0 ? ",": "";
                    if( (azArg[i]==0) || ptype==JSI_OPTION_NONE ) {
                      Jsi_DSAppend(dStr, zSep, "NULL", NULL);
                    }else if( ptype ==JSI_OPTION_STRING) {
                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                      mdbOutputQuotedString(dStr, azArg);
                    }else if (ptype==JSI_OPTION_BOOL || ptype ==JSI_OPTION_DOUBLE) {
                      Jsi_DSAppend(dStr, zSep, azArg, NULL);
                    }else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ){
                      Jsi_DSAppend(dStr, zSep, azArg, NULL);
                    }else{
                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);
                      mdbOutputQuotedString(dStr, azArg);
                    }
                }
                Jsi_DSAppend(dStr, ");", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
        }
    
        case _mdb_EF_TABS:
        case _mdb_EF_CSV: {
            Jsi_DString vStr = {};  
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    for(i=0; i<nCol; i++) {
                        if (i)
                            Jsi_DSAppend(dStr, opts.separator, NULL);
                        Jsi_DSAppend(dStr, apColName[i], NULL);
                    }
                }
    
                if (cnt || opts.headers)
                    Jsi_DSAppend(dStr, "\n", NULL);
                for(i=0; i<nCol; i++) {
                    if (i)
                        Jsi_DSAppend(dStr, opts.separator, NULL);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    if (opts.mode == _mdb_EF_CSV)
                        mdbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);
                    else
                        Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            break;
        }
            
        case _mdb_EF_LINE: {
            int i, w = 5, ww;
            int nCol;
            Jsi_DString vStr = {};   
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0) {
                    for(i=0; i<nCol; i++) {
                        ww = Jsi_Strlen(apColName[i]);
                        if (ww>w)
                            w = ww;
                    }
                }
    
                for(i=0; i<nCol; i++) {
                    Jsi_DString eStr;
                    Jsi_DSInit(&eStr);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    Jsi_DSPrintf(&eStr, "%*s = %s", w, apColName[i], Jsi_DSValue(&vStr));
                    Jsi_DSAppend(dStr, (cnt?"\n":""), Jsi_DSValue(&eStr), NULL);
                    Jsi_DSFree(&eStr);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            break;
        }
            
        case _mdb_EF_HTML: {
            Jsi_DString vStr = {};   
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    Jsi_DSAppend(dStr, "<TR>", NULL);
                    for(i=0; i<nCol; i++) {
                        Jsi_DSAppend(dStr, "<TH>", NULL);
                        mdbOutputHtmlString(&opts, apColName[i], dStr);
                        Jsi_DSAppend(dStr, "</TH>", NULL);
                    }
                    Jsi_DSAppend(dStr, "</TR>", NULL);
                }
                if (cnt || opts.headers)
                    Jsi_DSAppend(dStr, "\n", NULL);
                Jsi_DSAppend(dStr, "<TR>", NULL);
                for(i=0; i<nCol; i++) {
                    Jsi_DSAppend(dStr, "<TD>", NULL);
                    Jsi_DSSetLength(&vStr, 0);
                    mdbEvalSetColumn(&sEval, i, &vStr);
                    mdbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);
                    Jsi_DSAppend(dStr, "</TD>", NULL);
                }
                Jsi_DSAppend(dStr, "</TR>", NULL);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            Jsi_DSFree(&vStr);
            break;
        }
            
        case _mdb_EF_ROWS:
        {
            Jsi_Value *vcur, *vrow;
            int cnt = 0;
            Jsi_Obj *oall, *ocur;
            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
                vrow = Jsi_ValueMakeObject(interp, NULL, ocur);
                for(i=0; i<nCol; i++) {
                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);
                    Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);
                }
                Jsi_ObjArrayAdd(interp, oall, vrow);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            mdbEvalFinalize(&sEval);
            if (rc != JSI_ERROR)
                rc = JSI_OK;
            goto bail;
            break;
        }
        case _mdb_EF_ARRAYS:
        {
            Jsi_Value *vcur, *vrow;
            int cnt = 0;
            Jsi_Obj *oall, *ocur;
            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
                    for(i=0; i<nCol; i++) {
                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                        Jsi_ObjArrayAdd(interp, ocur, vcur);
                    }
                    Jsi_ObjArrayAdd(interp, oall, vrow);
                }
                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
                for(i=0; i<nCol; i++) {
                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);
                    Jsi_ObjArrayAdd(interp, ocur, vcur);
                }
                Jsi_ObjArrayAdd(interp, oall, vrow);
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            mdbEvalFinalize(&sEval);
            if (rc != JSI_ERROR)
                rc = JSI_OK;
            goto bail;
            break;
        }
        case _mdb_EF_ARRAY1D:
        {
            Jsi_Value *vcur;
            int cnt = 0;
            Jsi_Obj *oall;
            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));
    
            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
                int i;
                int nCol;
                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);
                if (cnt == 0 && opts.headers) {
                    for(i=0; i<nCol; i++) {
                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);
                        Jsi_ObjArrayAdd(interp, oall, vcur);
                    }
                }
                for(i=0; i<nCol; i++) {
                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);
                    Jsi_ObjArrayAdd(interp, oall, vcur);
                }
                cnt++;
                if (opts.limit && cnt>=opts.limit) break;
            }
            mdbEvalFinalize(&sEval);
            if (rc != JSI_ERROR)
                rc = JSI_OK;
            goto bail;
            break;
        }
    }
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr));
bail:
    mdbEvalFinalize(&sEval);
    if (isopts) {
        Jsi_OptionsFree(interp, QueryFmtOptions, &opts, 0);
    }
    Jsi_DSFree(dStr);
    Jsi_DSFree(&eStr);
    jdb->optPtr = oEopt;

    return rc;
}

static int MySqlOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                          Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    MyDbEvalContext sEval = {};
    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    sEval.nocache = jdb->queryOpts.nocache;
    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)
        return JSI_ERROR;
    sEval.ret = *ret;
    sEval.tocall = NULL;
    int cnt = 0;


    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
        int nCol = sEval.prep->numCol;
        if (nCol>0)
            mdbEvalSetColumnValue(&sEval, 0, ret);
        cnt++;
    }
    mdbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    return rc;
}

static int MySqlExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                           Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int rc;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);
    const char *zSql;
    Jsi_DString dStr = {};
    MyDbEvalContext sEval = {};
    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);

    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    sEval.nocache = jdb->queryOpts.nocache;
    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)
        return JSI_ERROR;
    sEval.ret = *ret;
    int cnt = 0;


    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {
        int nCol = sEval.prep->numCol;
        if (nCol>0)
            cnt++;
    }
    mdbEvalFinalize(&sEval);
    if( rc==JSI_BREAK ) {
        rc = JSI_OK;
    }
    Jsi_DSFree(&dStr);
    Jsi_ValueMakeBool(interp, ret, cnt);
    return rc;
}

static int MySqlLastRowidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                                    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Wide rowid;
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    rowid = mdbLastInsertRowid(jdb);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rowid);
    return JSI_OK;
}

/*
static int MySqlInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    _SQL_LITE_N_(_interrupt)(jdb->db);
    return JSI_OK;
} */


static int MySqlCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                             Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);
    const char *str =  Jsi_ValueString(interp, s, NULL);
    int isComplete = 0;
    if (str)
        isComplete = 0; // sqlite3_complete( str );
    Jsi_ValueMakeBool(interp, ret, isComplete);
    return JSI_OK;
}

static int MySqlErrorNoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    int n = mysql_errno(jdb->db);
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);
    return JSI_OK;
}

static int MySqlErrorStateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    const char *str = mysql_sqlstate(jdb->db);
    if (str)
        Jsi_ValueMakeStringDup(interp, ret, str);
    return JSI_OK;
}

static int MySqlLastQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    const char *str = mysql_info(jdb->db);
    if (str)
        Jsi_ValueMakeStringDup(interp, ret, str);
    return JSI_OK;
}

static int MySqlResetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
#if (MYSQL_VERSION_ID >= 50703)
    int oldMax = jdb->maxStmts;
    jdb->maxStmts = 0;
    mdbStmtLimit(jdb);
    jdb->maxStmts = oldMax;
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_reset_connection(jdb->db));
#else
    Jsi_LogWarn("mysql reset requires version 5.7.3+");
#endif
    return JSI_OK;    
}


static int MySqlPingCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    int n = mysql_ping(jdb->db);
    Jsi_Bool noErr = 0;
    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);
    if (val)
        Jsi_ValueGetBoolean(interp, val, &noErr);
    if (n && noErr==0) {
        Jsi_LogError("ping failed: (%d) %s", n, mysql_error(jdb->db));
        return JSI_ERROR;
    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);

    return JSI_OK;    
}

static int MySqlAffectedRowsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_affected_rows(jdb->db));
    return JSI_OK;
}
static int MySqlInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                              Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    Jsi_Obj *nobj = Jsi_ObjNew(interp);
    Jsi_ValueMakeObject(interp, ret, nobj);
    const char *str, *svals[20];
    int i = 0;
    svals[i++] = "clientInfo";
    svals[i++] = mysql_get_client_info();
    svals[i++] = "hostInfo";
    svals[i++] = mysql_get_host_info(jdb->db);
    svals[i++] = "serverInfo";
    svals[i++] = mysql_get_server_info(jdb->db);
    svals[i++] = "stat";
    svals[i++] = mysql_stat(jdb->db);
    svals[i++] = 0;
    i = 0;
    while (svals[i]) {
        str = svals[i+1];
        Jsi_ObjInsert(interp, nobj, svals[i], str?Jsi_ValueNewStringDup(interp, str):Jsi_ValueNewNull(interp), 0);
    }
    Jsi_ObjInsert(interp, nobj, "threadId", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_thread_id(jdb->db)), 0);
    Jsi_ObjInsert(interp, nobj, "protocolVersion", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_proto_info(jdb->db)), 0);
    Jsi_ObjInsert(interp, nobj, "clientVersion", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_client_version()), 0);
    Jsi_ObjInsert(interp, nobj, "serverVersion", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_server_version(jdb->db)), 0);
    Jsi_ObjInsert(interp, nobj, "warningCount", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_warning_count(jdb->db)), 0);
    return JSI_OK;
}

static int MySqlConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
                         Jsi_Value **ret, Jsi_Func *funcPtr)
{
    MySqlObj *jdb;
    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;
    //jdb->hasOpts = 1;
    int oms = jdb->maxStmts;
    const char *oldu = jdb->user, *oldpw = jdb->password, *olddb = jdb->database;
    int rc = Jsi_OptionsConf(interp, SqlOptions, Jsi_ValueArrayIndex(interp, args, 0), jdb, ret, 0);
    if (jdb->maxStmts<0 || jdb->maxStmts>MAX_PREPARED_STMTS) {
        JSI_DBQUERY_PRINTF( "option maxStmts value %d is not in range 0..%d", jdb->maxStmts, MAX_PREPARED_STMTS);
        jdb->maxStmts = oms;
        rc = JSI_ERROR;
    }
    if (oldu != jdb->user || oldpw != jdb->password || olddb != jdb->database)
        if (!mysql_change_user(jdb->db, jdb->user, jdb->password, jdb->database)) {
            rc = JSI_ERROR;
            jdb->user = oldu;
            jdb->password = oldpw;
            jdb->database = olddb;
        }
    mdbStmtLimit(jdb);
    return rc;
}

static Jsi_CmdSpec mysqlCmds[] = {
    { "MySql",         MySqlConstructor,    0,  1,  "options:object=void", JSI_CMD_IS_CONSTRUCTOR, 
        .help="Create a new db connection to a MySql database:", .opts=SqlOptions, .retType=(uint)JSI_TT_USEROBJ},
    { "affectedRows",   MySqlAffectedRowsCmd,0, 0, "", .help="Return affected rows", .retType=(uint)JSI_TT_NUMBER },
    { "complete",       MySqlCompleteCmd,   1,  1, "sql:string", .help="Return true if sql is complete", .retType=(uint)JSI_TT_BOOL },
    { "conf",           MySqlConfCmd,       0,  1, "options:string|object=void", .help="Configure options", .opts=SqlOptions, .retType=(uint)JSI_TT_ANY },
    { "errorNo",        MySqlErrorNoCmd,    0,  0, "", .help = "Return error code returned by most recent call to mysql3_exec()", .retType=(uint)JSI_TT_NUMBER },
    { "errorState",     MySqlErrorStateCmd, 0,  0, "", .help = "Return the mysql error state str" , .retType=(uint)JSI_TT_STRING},
    { "eval",           MySqlEvalCmd,       1,  1, "sql:string", .help="Run sql commands without input/output", .retType=(uint)JSI_TT_NUMBER },
    { "exists",         MySqlExistsCmd,     1,  1, "sql:string", .help="Execute sql, and return true if there is at least one result value", .retType=(uint)JSI_TT_BOOL },
    { "info",           MySqlInfoCmd,       0,  0, "", .help="Return info about last query", .retType=(uint)JSI_TT_OBJECT },
    { "lastQuery",      MySqlLastQueryCmd,  0,  0, "", .help="Return info string about most recently executed statement", .retType=(uint)JSI_TT_STRING },
    { "lastRowid",      MySqlLastRowidCmd,  0,  0, "", .help="Return rowid of last insert", .retType=(uint)JSI_TT_NUMBER },
    { "onecolumn",      MySqlOnecolumnCmd,  1,  1, "sql:string", .help="Execute sql, and return a single value", .retType=(uint)JSI_TT_ANY },
    { "ping",           MySqlPingCmd,       0,  1, "noError:boolean=false", .help="Ping connection", .retType=(uint)JSI_TT_NUMBER },
    { "query",          MySqlQueryCmd,      1,  2, "sql:string, options:function|object=void", .help="Run sql query with input and/or outputs.", .opts=QueryFmtOptions, .retType=(uint)JSI_TT_ANY },
    { "reconnect",      MySqlReconnectCmd,  0,  0, "", .help="Reconnect with current settings", .retType=(uint)JSI_TT_VOID },
    { "reset",          MySqlResetCmd,      0,  0, "", .help="Reset connection", .retType=(uint)JSI_TT_NUMBER },
    { NULL, .help="Commands for accessing mysql databases" }
};


int Jsi_DoneMySql(Jsi_Interp *interp)
{
    Jsi_UserObjUnregister(interp, &mysqlobject);
    return JSI_OK;
}


static int _jsimysqlinit = 0; // TODO: use interp data to support unloading.

int Jsi_InitMySql(Jsi_Interp *interp)
{
    Jsi_Hash* dbSys;
#ifndef JSI_OMIT_THREADS
    if (_jsimysqlinit == 0 && mysql_library_init(0, NULL, NULL)) {
        fprintf(stderr, "failed to initialize MySQL library\n");
        exit(1);
    }
#endif
    _jsimysqlinit = 1;
#ifdef JSI_USE_STUBS
  if (Jsi_StubsInit(interp, 0) != JSI_OK)
    return JSI_ERROR;
#endif
    if (!(dbSys = Jsi_UserObjRegister(interp, &mysqlobject))) {
        Jsi_LogError("Failed to init mysql extension");
        return JSI_ERROR;
    }
    if (!Jsi_CommandCreateSpecs(interp, mysqlobject.name, mysqlCmds, dbSys, 0))
        return JSI_ERROR;
#ifdef JSI_DB_TEST
    if (getenv("RUN_DB_TEST"))
        TestMySql(interp);
#endif
    return JSI_OK;
}

#endif
#ifndef JSI_LITE_ONLY
/* A Bison parser, made by GNU Bison 2.5.  */

/* Bison implementation for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output.  */
#define YYBISON 1

/* Bison version.  */
#define YYBISON_VERSION "2.5"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 1

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1

/* Using locations.  */
#define YYLSP_NEEDED 1



/* Copy the first part of user declarations.  */

/* Line 268 of yacc.c  */

#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#include "jsiCode.c"
#endif

typedef struct ForinVar {
    jsi_Sig sig;
    char *varname;
    OpCodes *local;
    OpCodes *lval;
} ForinVar;

static ForinVar *forinvar_new(jsi_Pstate *pstate, char *varname, OpCodes *local, OpCodes *lval)
{
    ForinVar *r = (ForinVar*)Jsi_Calloc(1,sizeof(*r));
    r->sig = JSI_SIG_FORINVAR;
    r->varname = varname;
    r->local = local;
    r->lval = lval;
    return r;
}

static OpCodes *make_forin(OpCodes *lval, OpCodes *expr, OpCodes *stat, const char *label)
{
    OpCodes *init = codes_join(expr, code_key());
    OpCodes *cond = codes_join3(lval, code_next(),
                                   code_jfalse(stat->code_len + 2));
    OpCodes *stat_jmp = code_jmp(-(cond->code_len + stat->code_len));
    code_reserved_replace(stat, 1, 0, label, 2);
    return codes_join3(codes_join(init, cond), 
                          codes_join(stat, stat_jmp), code_pop(2));
}

typedef struct CaseExprStat {
    jsi_Sig sig;
    OpCodes *expr;
    OpCodes *stat;
    int isdefault;
} CaseExprStat;

static CaseExprStat *exprstat_new(jsi_Pstate *pstate, OpCodes *expr, OpCodes *stat, int isdef)
{
    CaseExprStat *r = (CaseExprStat*)Jsi_Calloc(1,sizeof(*r));
    r->sig = JSI_SIG_CASESTAT;
    r->expr = expr;
    r->stat = stat;
    r->isdefault = isdef;
    return r;
}

typedef struct CaseList {
    jsi_Sig sig;
    CaseExprStat *es;
    int off;
    struct CaseList *tail;
    struct CaseList *next;
} CaseList;

static CaseList *caselist_new(jsi_Pstate *pstate, CaseExprStat *es)
{
    CaseList *a = (CaseList*)Jsi_Calloc(1,sizeof(*a));
    a->sig = JSI_SIG_CASELIST;
    a->es = es;
    a->tail = a;
    return a;
}

static CaseList *caselist_insert(jsi_Pstate *pstate, CaseList *a, CaseExprStat *es)
{
    CaseList *b = (CaseList*)Jsi_Calloc(1,sizeof(*b));
    a->sig = JSI_SIG_CASELIST;
    b->es = es;
    a->tail->next = b;
    a->tail = b;
    return a;
}

static OpCodes *opassign(jsi_Pstate *pstate, jsi_Pline *line, OpCodes *lval, OpCodes *oprand, OpCodes *op)
{
    OpCodes *ret;
    if (((OpCodes *)lval)->lvalue_flag == 1) {
        ret = codes_join3(lval, 
                             codes_join3(code_push_top(), oprand, op),
                             code_assign(pstate, line, 1));
    } else {
        ret = codes_join3(lval,
                             codes_join4(code_push_top2(), code_subscript(pstate, line, 1), oprand, op),
                             code_assign(pstate, line, 2));
    }
    return ret;
}



/* Line 268 of yacc.c  */

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif

/* Enabling verbose error messages.  */
#ifdef YYERROR_VERBOSE
# undef YYERROR_VERBOSE
# define YYERROR_VERBOSE 1
#else
# define YYERROR_VERBOSE 1
#endif

/* Enabling the token table.  */
#ifndef YYTOKEN_TABLE
# define YYTOKEN_TABLE 0
#endif


/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     STRING = 258,
     IDENTIFIER = 259,
     IF = 260,
     ELSE = 261,
     FOR = 262,
     IN = 263,
     WHILE = 264,
     DO = 265,
     CONTINUE = 266,
     SWITCH = 267,
     CASE = 268,
     DEFAULT = 269,
     BREAK = 270,
     FUNC = 271,
     RETURN = 272,
     LOCAL = 273,
     NEW = 274,
     DELETE = 275,
     TRY = 276,
     CATCH = 277,
     FINALLY = 278,
     THROW = 279,
     WITH = 280,
     UNDEF = 281,
     _TRUE = 282,
     _FALSE = 283,
     _THIS = 284,
     ARGUMENTS = 285,
     FNUMBER = 286,
     REGEXP = 287,
     TYPESTRING = 288,
     TYPENUMBER = 289,
     TYPENULL = 290,
     TYPEOBJECT = 291,
     TYPEBOOLEAN = 292,
     TYPEUSEROBJ = 293,
     TYPEREGEXP = 294,
     TYPEANY = 295,
     TYPEARRAY = 296,
     ELLIPSIS = 297,
     __DEBUG = 298,
     MIN_PRI = 299,
     ARGCOMMA = 300,
     DIVAS = 301,
     BXORAS = 302,
     BORAS = 303,
     BANDAS = 304,
     URSHFAS = 305,
     RSHFAS = 306,
     LSHFAS = 307,
     MODAS = 308,
     MULAS = 309,
     MNSAS = 310,
     ADDAS = 311,
     OR = 312,
     AND = 313,
     NNEQ = 314,
     EEQU = 315,
     NEQ = 316,
     EQU = 317,
     INSTANCEOF = 318,
     GEQ = 319,
     LEQ = 320,
     URSHF = 321,
     RSHF = 322,
     LSHF = 323,
     VOID = 324,
     TYPEOF = 325,
     DEC = 326,
     INC = 327,
     NEG = 328,
     MAX_PRI = 329
   };
#endif



#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif

#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
} YYLTYPE;
# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif


/* Copy the second part of user declarations.  */


/* Line 343 of yacc.c  */

#ifdef short
# undef short
#endif

#ifdef YYTYPE_UINT8
typedef YYTYPE_UINT8 yytype_uint8;
#else
typedef unsigned char yytype_uint8;
#endif

#ifdef YYTYPE_INT8
typedef YYTYPE_INT8 yytype_int8;
#elif (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
typedef signed char yytype_int8;
#else
typedef short int yytype_int8;
#endif

#ifdef YYTYPE_UINT16
typedef YYTYPE_UINT16 yytype_uint16;
#else
typedef unsigned short int yytype_uint16;
#endif

#ifdef YYTYPE_INT16
typedef YYTYPE_INT16 yytype_int16;
#else
typedef short int yytype_int16;
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned int
# endif
#endif

#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(msgid) dgettext ("bison-runtime", msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(msgid) msgid
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YYUSE(e) ((void) (e))
#else
# define YYUSE(e) /* empty */
#endif

/* Identity function, used to suppress warnings about constant conditions.  */
#ifndef lint
# define YYID(n) (n)
#else
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static int
YYID (int yyi)
#else
static int
YYID (yyi)
    int yyi;
#endif
{
  return yyi;
}
#endif

#if ! defined yyoverflow || YYERROR_VERBOSE

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's `empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
	     && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* ! defined yyoverflow || YYERROR_VERBOSE */


#if (! defined yyoverflow \
     && (! defined __cplusplus \
	 || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
	     && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yytype_int16 yyss_alloc;
  YYSTYPE yyvs_alloc;
  YYLTYPE yyls_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
      + 2 * YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
    do									\
      {									\
	YYSIZE_T yynewbytes;						\
	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
	Stack = &yyptr->Stack_alloc;					\
	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
	yyptr += yynewbytes / sizeof (*yyptr);				\
      }									\
    while (YYID (0))

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from FROM to TO.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(To, From, Count) \
      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
#  else
#   define YYCOPY(To, From, Count)		\
      do					\
	{					\
	  YYSIZE_T yyi;				\
	  for (yyi = 0; yyi < (Count); yyi++)	\
	    (To)[yyi] = (From)[yyi];		\
	}					\
      while (YYID (0))
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  100
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   2409

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  99
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  43
/* YYNRULES -- Number of rules.  */
#define YYNRULES  194
/* YYNRULES -- Number of states.  */
#define YYNSTATES  384

/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
#define YYUNDEFTOK  2
#define YYMAXUTOK   329

#define YYTRANSLATE(YYX)						\
  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)

/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
static const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    83,     2,     2,     2,    82,    65,     2,
      92,    97,    80,    78,    45,    79,    90,    81,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,    60,    94,
      71,    47,    70,    59,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    91,     2,    98,    64,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    95,    63,    96,    84,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      46,    48,    49,    50,    51,    52,    53,    54,    55,    56,
      57,    58,    61,    62,    66,    67,    68,    69,    72,    73,
      74,    75,    76,    77,    85,    86,    87,    88,    89,    93
};

#if YYDEBUG
/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
   YYRHS.  */
static const yytype_uint16 yyprhs[] =
{
       0,     0,     3,     4,     6,     9,    11,    13,    16,    18,
      20,    24,    27,    29,    31,    35,    39,    43,    46,    50,
      54,    56,    58,    60,    64,    66,    74,    80,    83,    85,
      87,    89,    91,    92,    94,    95,    98,   100,   103,   109,
     117,   126,   128,   131,   136,   140,   144,   152,   157,   167,
     169,   173,   175,   179,   183,   189,   197,   207,   217,   226,
     228,   231,   235,   236,   238,   239,   241,   248,   256,   262,
     270,   277,   286,   287,   289,   295,   297,   299,   301,   303,
     305,   307,   309,   311,   313,   315,   317,   321,   323,   325,
     327,   329,   331,   333,   335,   339,   343,   349,   353,   359,
     365,   373,   377,   380,   382,   384,   386,   390,   395,   399,
     402,   405,   408,   411,   414,   418,   422,   426,   430,   434,
     438,   441,   444,   447,   450,   453,   457,   461,   465,   469,
     473,   477,   481,   485,   489,   493,   497,   501,   505,   509,
     513,   517,   521,   525,   529,   533,   537,   541,   545,   549,
     553,   557,   561,   565,   569,   573,   575,   578,   581,   586,
     589,   595,   601,   609,   615,   621,   626,   633,   641,   648,
     653,   655,   657,   659,   664,   668,   669,   671,   673,   677,
     679,   681,   683,   685,   687,   689,   691,   693,   697,   698,
     700,   704,   708,   712,   716
};

/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
static const yytype_int16 yyrhs[] =
{
     100,     0,    -1,    -1,   101,    -1,   101,   132,    -1,   132,
      -1,   102,    -1,   101,   102,    -1,   106,    -1,   103,    -1,
       4,    60,   103,    -1,   132,    94,    -1,   118,    -1,   117,
      -1,    15,   107,    94,    -1,    11,   107,    94,    -1,    17,
     132,    94,    -1,    17,    94,    -1,    18,   115,    94,    -1,
      24,   132,    94,    -1,   114,    -1,   110,    -1,    94,    -1,
      95,   101,    96,    -1,   104,    -1,   105,    92,   126,    97,
      60,   128,   131,    -1,   105,    92,   126,    97,   131,    -1,
      16,     4,    -1,   119,    -1,   123,    -1,   124,    -1,   111,
      -1,    -1,     4,    -1,    -1,     4,    60,    -1,   102,    -1,
      95,    96,    -1,    25,    92,   132,    97,   109,    -1,   108,
      12,    92,   132,    97,    95,    96,    -1,   108,    12,    92,
     132,    97,    95,   112,    96,    -1,   113,    -1,   112,   113,
      -1,    13,   132,    60,   101,    -1,    14,    60,   101,    -1,
      13,   132,    60,    -1,    21,   131,    22,    92,     4,    97,
     131,    -1,    21,   131,    23,   131,    -1,    21,   131,    22,
      92,     4,    97,   131,    23,   131,    -1,   116,    -1,   115,
      45,   116,    -1,     4,    -1,     4,    47,   132,    -1,    20,
     134,    94,    -1,     5,    92,   132,    97,   109,    -1,     5,
      92,   132,    97,   109,     6,   109,    -1,   108,     7,    92,
     120,   121,    94,   122,    97,   109,    -1,   108,     7,    92,
      18,     4,     8,   132,    97,   109,    -1,   108,     7,    92,
     134,     8,   132,    97,   109,    -1,    94,    -1,   132,    94,
      -1,    18,   115,    94,    -1,    -1,   132,    -1,    -1,   132,
      -1,   108,     9,    92,   132,    97,   109,    -1,   108,    10,
     109,     9,    92,   132,    97,    -1,    16,    92,   126,    97,
     131,    -1,    16,    92,   126,    97,    60,   128,   131,    -1,
      16,     4,    92,   126,    97,   131,    -1,    16,     4,    92,
     126,    97,    60,   128,   131,    -1,    -1,   130,    -1,   130,
      45,    90,    90,    90,    -1,    33,    -1,    34,    -1,    37,
      -1,    39,    -1,    36,    -1,    38,    -1,    40,    -1,    41,
      -1,    16,    -1,    85,    -1,   127,    -1,   128,    63,   127,
      -1,    85,    -1,    31,    -1,    27,    -1,    28,    -1,    35,
      -1,     3,    -1,     4,    -1,     4,    47,   129,    -1,     4,
      60,   128,    -1,     4,    60,   128,    47,   129,    -1,   130,
      45,     4,    -1,   130,    45,     4,    47,   129,    -1,   130,
      45,     4,    60,   128,    -1,   130,    45,     4,    60,   128,
      47,   129,    -1,    95,   101,    96,    -1,    95,    96,    -1,
     137,    -1,   125,    -1,   134,    -1,   132,    45,   132,    -1,
     132,    91,   132,    98,    -1,   132,    90,     4,    -1,    79,
     132,    -1,    78,   132,    -1,    84,   132,    -1,    83,   132,
      -1,    85,   132,    -1,   132,    80,   132,    -1,   132,    81,
     132,    -1,   132,    82,   132,    -1,   132,    78,   132,    -1,
     132,    79,   132,    -1,   132,     8,   132,    -1,   134,    88,
      -1,   134,    87,    -1,    88,   134,    -1,    86,   132,    -1,
      87,   134,    -1,    92,   132,    97,    -1,   132,    62,   132,
      -1,   132,    61,   132,    -1,   132,    71,   132,    -1,   132,
      70,   132,    -1,   132,    74,   132,    -1,   132,    73,   132,
      -1,   132,    69,   132,    -1,   132,    68,   132,    -1,   132,
      67,   132,    -1,   132,    66,   132,    -1,   132,    65,   132,
      -1,   132,    63,   132,    -1,   132,    64,   132,    -1,   132,
      77,   132,    -1,   132,    76,   132,    -1,   132,    75,   132,
      -1,   134,    47,   132,    -1,   134,    58,   132,    -1,   134,
      57,   132,    -1,   134,    56,   132,    -1,   134,    55,   132,
      -1,   134,    54,   132,    -1,   134,    53,   132,    -1,   134,
      52,   132,    -1,   134,    51,   132,    -1,   134,    50,   132,
      -1,   134,    49,   132,    -1,   134,    48,   132,    -1,   134,
      72,   132,    -1,   133,    -1,    19,   137,    -1,    19,   134,
      -1,    19,    92,   132,    97,    -1,    19,   125,    -1,    19,
     137,    92,   135,    97,    -1,    19,   134,    92,   135,    97,
      -1,    19,    92,   132,    97,    92,   135,    97,    -1,    19,
     125,    92,   135,    97,    -1,   132,    59,   132,    60,   132,
      -1,    43,    92,   132,    97,    -1,   132,    90,     4,    92,
     135,    97,    -1,   132,    91,   132,    98,    92,   135,    97,
      -1,    92,   132,    97,    92,   135,    97,    -1,   134,    92,
     135,    97,    -1,     4,    -1,    30,    -1,    29,    -1,   134,
      91,   132,    98,    -1,   134,    90,     4,    -1,    -1,   136,
      -1,   132,    -1,   136,    45,   132,    -1,     3,    -1,    26,
      -1,    27,    -1,    28,    -1,    31,    -1,    32,    -1,   138,
      -1,   141,    -1,    95,   139,    96,    -1,    -1,   140,    -1,
     139,    45,   140,    -1,     4,    60,   132,    -1,     3,    60,
     132,    -1,    91,   136,    98,    -1,    91,    98,    -1
};

/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
static const yytype_uint16 yyrline[] =
{
       0,   174,   174,   175,   178,   181,   186,   187,   192,   193,
     194,   198,   199,   200,   201,   202,   203,   204,   205,   206,
     207,   208,   209,   210,   211,   215,   223,   234,   243,   244,
     245,   246,   249,   250,   253,   254,   260,   261,   265,   271,
     272,   317,   318,   322,   323,   324,   328,   335,   342,   352,
     353,   357,   366,   378,   388,   392,   401,   412,   429,   462,
     463,   464,   467,   468,   471,   472,   476,   486,   496,   500,
     504,   508,   514,   515,   518,   526,   527,   528,   529,   530,
     531,   532,   533,   534,   535,   538,   539,   544,   545,   546,
     547,   548,   549,   552,   553,   554,   555,   556,   557,   558,
     559,   562,   563,   567,   568,   569,   573,   574,   575,   576,
     577,   578,   579,   580,   581,   582,   583,   584,   585,   586,
     587,   591,   595,   599,   603,   607,   608,   612,   616,   617,
     618,   619,   620,   621,   622,   623,   624,   625,   626,   627,
     628,   629,   630,   631,   632,   633,   634,   635,   636,   637,
     638,   639,   640,   641,   642,   643,   645,   646,   649,   650,
     651,   657,   665,   670,   675,   679,   683,   691,   697,   702,
     728,   734,   735,   736,   741,   748,   749,   753,   754,   761,
     762,   763,   764,   765,   766,   767,   768,   772,   776,   777,
     778,   786,   787,   791,   792
};
#endif

#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "$end", "error", "$undefined", "STRING", "IDENTIFIER", "IF", "ELSE",
  "FOR", "IN", "WHILE", "DO", "CONTINUE", "SWITCH", "CASE", "DEFAULT",
  "BREAK", "FUNC", "RETURN", "LOCAL", "NEW", "DELETE", "TRY", "CATCH",
  "FINALLY", "THROW", "WITH", "UNDEF", "_TRUE", "_FALSE", "_THIS",
  "ARGUMENTS", "FNUMBER", "REGEXP", "TYPESTRING", "TYPENUMBER", "TYPENULL",
  "TYPEOBJECT", "TYPEBOOLEAN", "TYPEUSEROBJ", "TYPEREGEXP", "TYPEANY",
  "TYPEARRAY", "ELLIPSIS", "__DEBUG", "MIN_PRI", "','", "ARGCOMMA", "'='",
  "DIVAS", "BXORAS", "BORAS", "BANDAS", "URSHFAS", "RSHFAS", "LSHFAS",
  "MODAS", "MULAS", "MNSAS", "ADDAS", "'?'", "':'", "OR", "AND", "'|'",
  "'^'", "'&'", "NNEQ", "EEQU", "NEQ", "EQU", "'>'", "'<'", "INSTANCEOF",
  "GEQ", "LEQ", "URSHF", "RSHF", "LSHF", "'+'", "'-'", "'*'", "'/'", "'%'",
  "'!'", "'~'", "VOID", "TYPEOF", "DEC", "INC", "NEG", "'.'", "'['", "'('",
  "MAX_PRI", "';'", "'{'", "'}'", "')'", "']'", "$accept", "file",
  "statements", "statement", "commonstatement", "func_statement",
  "func_prefix", "iterstatement", "identifier_opt", "label_opt",
  "statement_or_empty", "with_statement", "switch_statement", "cases",
  "case", "try_statement", "vardecs", "vardec", "delete_statement",
  "if_statement", "for_statement", "for_init", "for_cond", "expr_opt",
  "while_statement", "do_statement", "func_expr", "args_opt", "typeid",
  "argtype", "argdefault", "args", "func_statement_block", "expr",
  "fcall_exprs", "lvalue", "exprlist_opt", "exprlist", "value", "object",
  "items", "item", "array", 0
};
#endif

# ifdef YYPRINT
/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
   token YYLEX-NUM.  */
static const yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
     295,   296,   297,   298,   299,    44,   300,    61,   301,   302,
     303,   304,   305,   306,   307,   308,   309,   310,   311,    63,
      58,   312,   313,   124,    94,    38,   314,   315,   316,   317,
      62,    60,   318,   319,   320,   321,   322,   323,    43,    45,
      42,    47,    37,    33,   126,   324,   325,   326,   327,   328,
      46,    91,    40,   329,    59,   123,   125,    41,    93
};
# endif

/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
static const yytype_uint8 yyr1[] =
{
       0,    99,   100,   100,   100,   100,   101,   101,   102,   102,
     102,   103,   103,   103,   103,   103,   103,   103,   103,   103,
     103,   103,   103,   103,   103,   104,   104,   105,   106,   106,
     106,   106,   107,   107,   108,   108,   109,   109,   110,   111,
     111,   112,   112,   113,   113,   113,   114,   114,   114,   115,
     115,   116,   116,   117,   118,   118,   119,   119,   119,   120,
     120,   120,   121,   121,   122,   122,   123,   124,   125,   125,
     125,   125,   126,   126,   126,   127,   127,   127,   127,   127,
     127,   127,   127,   127,   127,   128,   128,   129,   129,   129,
     129,   129,   129,   130,   130,   130,   130,   130,   130,   130,
     130,   131,   131,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   133,   133,   133,   133,
     134,   134,   134,   134,   134,   135,   135,   136,   136,   137,
     137,   137,   137,   137,   137,   137,   137,   138,   139,   139,
     139,   140,   140,   141,   141
};

/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
static const yytype_uint8 yyr2[] =
{
       0,     2,     0,     1,     2,     1,     1,     2,     1,     1,
       3,     2,     1,     1,     3,     3,     3,     2,     3,     3,
       1,     1,     1,     3,     1,     7,     5,     2,     1,     1,
       1,     1,     0,     1,     0,     2,     1,     2,     5,     7,
       8,     1,     2,     4,     3,     3,     7,     4,     9,     1,
       3,     1,     3,     3,     5,     7,     9,     9,     8,     1,
       2,     3,     0,     1,     0,     1,     6,     7,     5,     7,
       6,     8,     0,     1,     5,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     3,     1,     1,     1,
       1,     1,     1,     1,     3,     3,     5,     3,     5,     5,
       7,     3,     2,     1,     1,     1,     3,     4,     3,     2,
       2,     2,     2,     2,     3,     3,     3,     3,     3,     3,
       2,     2,     2,     2,     2,     3,     3,     3,     3,     3,
       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       3,     3,     3,     3,     3,     1,     2,     2,     4,     2,
       5,     5,     7,     5,     5,     4,     6,     7,     6,     4,
       1,     1,     1,     4,     3,     0,     1,     1,     3,     1,
       1,     1,     1,     1,     1,     1,     1,     3,     0,     1,
       3,     3,     3,     3,     2
};

/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
   Performed when YYTABLE doesn't specify something else to do.  Zero
   means the default is an error.  */
static const yytype_uint8 yydefact[] =
{
      34,   179,   170,     0,    32,    32,     0,     0,     0,     0,
       0,     0,     0,     0,   180,   181,   182,   172,   171,   183,
     184,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    22,    34,     0,    34,     6,     9,    24,     0,
       8,     0,    21,    31,    20,    13,    12,    28,    29,    30,
     104,     5,   155,   105,   103,   185,   186,    35,     0,    33,
       0,     0,    27,    72,   170,     0,    17,   188,     0,    51,
       0,    49,     0,   159,   157,   156,     0,    34,     0,     0,
       0,     0,   110,   109,   112,   111,   113,   123,   124,   122,
     194,   177,     0,     0,   179,   170,    34,     0,     0,   189,
       1,     7,     4,    72,     0,     0,    34,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    11,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   121,   120,
       0,     0,   175,    10,     0,    15,    14,    72,    93,     0,
      73,     0,     0,     0,    16,     0,     0,    18,     0,   175,
     175,   175,    53,   102,    34,     0,     0,    19,     0,     0,
       0,   193,   125,     0,    35,    23,     0,   187,     0,     0,
       0,    34,    36,     0,     0,   119,   106,     0,   127,   126,
     137,   138,   136,   135,   134,   133,   132,   129,   128,   131,
     130,   141,   140,   139,   117,   118,   114,   115,   116,   108,
       0,   142,   153,   152,   151,   150,   149,   148,   147,   146,
     145,   144,   143,   154,   174,     0,     0,   176,    34,     0,
       0,     0,     0,     0,     0,    52,    50,   158,     0,     0,
       0,   101,     0,    47,    34,   165,   178,   175,   192,   191,
     190,     0,     0,    59,    62,     0,   105,     0,    37,     0,
       0,     0,   175,   107,   173,   169,    54,     0,    92,    89,
      90,    88,    91,    87,    94,    83,    75,    76,    79,    77,
      80,    78,    81,    82,    84,    85,    95,     0,    68,    97,
       0,   191,   175,   163,   161,   160,     0,    38,     0,     0,
      26,    51,     0,     0,    63,    60,     0,    34,     0,     0,
     164,     0,   175,    34,     0,    70,     0,     0,     0,     0,
       0,     0,     0,     0,   168,     0,     0,    61,    64,     0,
      66,     0,     0,   166,     0,    55,     0,    96,    86,    69,
      98,    99,    74,   162,    46,    25,     0,     0,    65,    34,
      67,     0,     0,    39,     0,    41,   167,    71,     0,     0,
      34,    34,    58,     0,    34,    40,    42,   100,    48,    57,
      56,    34,    34,    34
};

/* YYDEFGOTO[NTERM-NUM].  */
static const yytype_int16 yydefgoto[] =
{
      -1,    34,    96,   192,    37,    38,    39,    40,    60,    41,
     193,    42,    43,   364,   365,    44,    70,    71,    45,    46,
      47,   264,   313,   357,    48,    49,    50,   159,   295,   296,
     284,   160,    78,    97,    52,    53,   236,   237,    54,    55,
      98,    99,    56
};

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
#define YYPACT_NINF -296
static const yytype_int16 yypact[] =
{
     211,  -296,    46,   -27,    70,    70,    -3,  1158,   158,   330,
     171,    75,  1235,    80,  -296,  -296,  -296,  -296,  -296,  -296,
    -296,    84,  1235,  1235,  1235,  1235,  1235,  1235,   171,   171,
     404,  1235,  -296,   655,   178,   385,  -296,  -296,  -296,    95,
    -296,   260,  -296,  -296,  -296,  -296,  -296,  -296,  -296,  -296,
    -296,  1746,  -296,  2317,  -296,  -296,  -296,   998,  1235,  -296,
      92,    96,  -296,   185,  -296,    -2,  -296,   106,  1784,   146,
     -15,  -296,  1235,   104,    29,   107,   -43,   780,    94,  1822,
    1235,  1235,    10,    10,    10,    10,    10,    10,    90,    90,
    -296,  2058,   -39,  1356,   142,   147,   874,  1746,   -34,  -296,
    -296,  -296,  1746,   185,   114,   118,  1028,   120,  1235,  1235,
    1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,
    1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,
    1235,  1235,   209,  1235,  -296,  1235,  1235,  1235,  1235,  1235,
    1235,  1235,  1235,  1235,  1235,  1235,  1235,  1235,  -296,  -296,
     213,  1235,  1235,  -296,  1395,  -296,  -296,   185,    -4,   121,
     174,   131,   142,   164,  -296,  1235,   158,  -296,  1434,  1235,
    1235,  1235,  -296,  -296,   904,   133,    75,  -296,  1473,  1512,
    1235,  -296,   141,  1235,   998,  -296,   106,  -296,   137,  1140,
    1235,   749,  -296,   243,  1235,   245,  2058,  1225,  2133,  2170,
    2208,  2245,  2272,   247,   247,   247,   247,   169,   169,   169,
     169,   184,   184,   184,     2,     2,    10,    10,    10,   165,
    1272,  2058,  2058,  2058,  2058,  2058,  2058,  2058,  2058,  2058,
    2058,  2058,  2058,   169,  -296,  1316,   159,   216,  1028,   176,
      26,    30,   -53,     1,  1235,  2058,  -296,   187,   179,   180,
     183,  -296,   264,  -296,  1028,  -296,  2058,  1235,  2058,  1898,
    -296,   -40,   277,  -296,  1235,  1860,  1947,  1551,  -296,   190,
    1590,  1235,  1235,   191,  -296,  -296,   278,   -10,  -296,  -296,
    -296,  -296,  -296,  -296,  -296,  -296,  -296,  -296,  -296,  -296,
    -296,  -296,  -296,  -296,  -296,  -296,    13,    30,  -296,    52,
     197,  2058,  1235,  -296,  -296,  -296,   194,  -296,   195,    30,
    -296,     5,   -13,   199,  2020,  -296,  1235,  1028,  1235,   193,
    2095,   203,  1235,  1028,    30,  -296,    26,    30,   100,    26,
      30,   214,   204,    75,  -296,   100,  1235,  -296,  1235,  1629,
    -296,  1668,     9,  -296,   210,  -296,   100,  -296,  -296,  -296,
    -296,    51,  -296,  -296,   285,  -296,  1707,   212,  2020,  1028,
    -296,  1235,   250,  -296,    11,  -296,  -296,  -296,    26,    75,
    1028,  1028,  -296,  1982,  1121,  -296,  -296,  -296,  -296,  -296,
    -296,   500,   531,   625
};

/* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
    -296,  -296,     3,     0,   -38,  -296,  -296,  -296,   306,  -296,
    -150,  -296,  -296,  -296,   -52,  -296,    53,   148,  -296,  -296,
    -296,  -296,  -296,  -296,  -296,  -296,   304,   -99,    -8,  -222,
    -295,  -296,  -164,    14,  -296,    -1,  -154,   301,   326,  -296,
    -296,   153,  -296
};

/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule which
   number is the opposite.  If YYTABLE_NINF, syntax error.  */
#define YYTABLE_NINF -189
static const yytype_int16 yytable[] =
{
      36,    62,   161,    35,   188,   299,   180,   297,    74,    76,
     108,   186,   253,   336,    51,   248,   249,   250,   108,   153,
     309,    68,   361,   362,   361,   362,    79,    88,    89,   278,
     166,   347,   166,    36,   350,   101,    82,    83,    84,    85,
      86,    87,    77,   240,    91,    93,   285,   150,   151,   102,
     324,   172,   165,   279,   280,    77,   241,   281,   239,   181,
     326,   282,   187,   286,   287,    58,   288,   289,   290,   291,
     292,   293,   154,   377,    59,   328,   327,    36,   298,   167,
     174,   337,   129,   130,   131,    77,   168,   335,   276,    63,
      63,   300,   132,   133,   178,   179,   101,   310,   368,   329,
     132,   133,   346,   308,   307,   363,    57,   375,   351,   162,
     163,   283,   330,   325,   327,   294,   175,   176,   321,   150,
     151,   170,   195,   196,   197,   198,   199,   200,   201,   202,
     203,   204,   205,   206,   207,   208,   209,   210,   211,   212,
     213,   214,   215,   216,   217,   218,   153,   220,   332,   221,
     222,   223,   224,   225,   226,   227,   228,   229,   230,   231,
     232,   233,    69,   327,   349,   235,    91,   340,   344,   354,
      77,   355,    80,   345,   101,    64,    81,   108,   100,   245,
     150,   151,   367,    91,    91,    91,   155,   103,   266,   158,
     156,    36,   108,   165,   256,    77,   169,   258,   259,   171,
      17,    18,   183,   265,   267,   378,   189,   184,   270,   372,
     190,    -2,   194,   219,     1,     2,     3,   234,   242,   243,
     379,   380,     4,   157,   244,   252,     5,     6,     7,     8,
       9,    10,    11,   257,   261,    12,    13,    14,    15,    16,
      17,    18,    19,    20,   124,   125,   126,   127,   128,   129,
     130,   131,   269,   108,    21,   108,   275,   272,   301,   132,
     133,   180,   127,   128,   129,   130,   131,   104,   306,   105,
     106,    91,   107,   277,   132,   133,   303,   304,   314,   302,
     305,   311,   318,   322,   323,   320,    91,   331,   342,    22,
      23,   333,   334,   338,    24,    25,    26,    27,    28,    29,
     343,   353,    30,    31,   352,    32,    33,   366,   369,   371,
     374,    61,   376,    73,   246,   312,    91,   120,   121,   348,
     122,   123,   124,   125,   126,   127,   128,   129,   130,   131,
     339,    92,   341,     1,    64,    75,    91,   132,   133,   260,
       0,     0,     0,     0,     0,     0,    65,     0,     0,     0,
     356,     0,   358,     0,     0,     0,    14,    15,    16,    17,
      18,    19,    20,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    36,   373,     0,   382,     0,     0,
       0,    36,   101,   101,   383,    -3,     0,     0,     1,     2,
       3,     0,     0,     0,     0,     0,     4,     0,     0,     0,
       5,     6,     7,     8,     9,    10,    11,     1,    64,    12,
      13,    14,    15,    16,    17,    18,    19,    20,     0,     0,
      65,    30,    72,     9,     0,    67,     0,     0,    21,     0,
      14,    15,    16,    17,    18,    19,    20,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    21,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    22,    23,     0,     0,     0,    24,    25,
      26,    27,    28,    29,     0,     0,    30,    31,     0,    32,
      33,     0,    22,    23,     0,     0,     0,    24,    25,    26,
      27,    28,    29,     0,     0,    30,    31,     0,     0,    67,
       0,     0,    90,     1,     2,     3,     0,     0,     0,     0,
       0,     4,     0,   -45,   -45,     5,     6,     7,     8,     9,
      10,    11,     0,     0,    12,    13,    14,    15,    16,    17,
      18,    19,    20,     0,     1,     2,     3,     0,     0,     0,
       0,     0,     4,    21,   -44,   -44,     5,     6,     7,     8,
       9,    10,    11,     0,     0,    12,    13,    14,    15,    16,
      17,    18,    19,    20,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    21,     0,     0,     0,    22,    23,
       0,     0,     0,    24,    25,    26,    27,    28,    29,     0,
       0,    30,    31,     0,    32,    33,   -45,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    22,
      23,     0,     0,     0,    24,    25,    26,    27,    28,    29,
       0,     0,    30,    31,     0,    32,    33,   -44,     1,     2,
       3,     0,     0,     0,     0,     0,     4,     0,   -43,   -43,
       5,     6,     7,     8,     9,    10,    11,     0,     0,    12,
      13,    14,    15,    16,    17,    18,    19,    20,    94,    95,
       3,     0,     0,     0,     0,     0,     4,     0,    21,     0,
       5,     6,     7,     8,     9,    10,    11,     0,     0,    12,
      13,    14,    15,    16,    17,    18,    19,    20,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    21,     0,
    -188,     0,     0,    22,    23,     0,     0,     0,    24,    25,
      26,    27,    28,    29,     0,     0,    30,    31,     0,    32,
      33,   -43,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    22,    23,     0,     0,     0,    24,    25,
      26,    27,    28,    29,     0,     0,    30,    31,     0,    32,
      33,  -188,    94,    95,     3,     0,     0,     0,     0,     0,
       4,     0,     0,     0,     5,     6,     7,     8,     9,    10,
      11,     0,     0,    12,    13,    14,    15,    16,    17,    18,
      19,    20,     0,     1,     2,     3,     0,     0,     0,     0,
       0,     4,    21,     0,  -188,     5,     6,     7,     8,     9,
      10,    11,     0,     0,    12,    13,    14,    15,    16,    17,
      18,    19,    20,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    21,     0,     0,     0,    22,    23,     0,
       0,     0,    24,    25,    26,    27,    28,    29,     0,     0,
      30,    31,     0,    32,    33,   268,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    22,    23,
       0,     0,     0,    24,    25,    26,    27,    28,    29,     0,
       0,    30,    31,     0,    32,    33,   173,     1,     2,     3,
       0,     0,     0,     0,     0,     4,     0,     0,     0,     5,
       6,     7,     8,     9,    10,    11,     0,     0,    12,    13,
      14,    15,    16,    17,    18,    19,    20,     1,     2,     3,
       0,     0,     0,     0,     0,     4,     0,    21,     0,     5,
       6,     7,     8,     9,    10,    11,     0,     0,    12,    13,
      14,    15,    16,    17,    18,    19,    20,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    21,     0,     0,
       0,     0,    22,    23,     0,     0,     0,    24,    25,    26,
      27,    28,    29,     0,     0,    30,    31,     0,    32,    33,
     185,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    22,    23,     0,     0,     0,    24,    25,    26,
      27,    28,    29,     0,     0,    30,    31,     0,    32,    33,
     251,     1,    64,     3,     0,     0,     0,     0,     0,     4,
       0,     0,     0,     5,     6,     7,     8,     9,    10,    11,
       0,     0,    12,    13,    14,    15,    16,    17,    18,    19,
      20,     1,     2,     3,     0,     0,     0,     0,     0,     4,
       0,    21,     0,     5,     6,     7,     8,     9,    10,    11,
       0,     0,    12,    13,    14,    15,    16,    17,    18,    19,
      20,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    21,     0,     0,     0,     0,    22,    23,     0,     0,
       0,    24,    25,    26,    27,    28,    29,     0,     0,    30,
      31,     0,    32,    33,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    22,    23,     0,     0,
       0,    24,    25,    26,    27,    28,    29,     0,     0,    30,
      31,     0,    32,   191,     1,     2,     3,     0,     0,     0,
       0,     0,     4,     0,     0,     0,     5,     6,     7,     8,
       9,    10,    11,     1,    64,    12,    13,    14,    15,    16,
      17,    18,    19,    20,     0,     0,    65,     0,   262,     9,
       0,     1,    64,     0,    21,     0,    14,    15,    16,    17,
      18,    19,    20,     0,    65,     0,     0,     9,     0,     0,
       0,     0,     0,    21,    14,    15,    16,    17,    18,    19,
      20,     0,     0,     0,     0,     0,     0,     0,     0,    22,
      23,    21,     0,     0,    24,    25,    26,    27,    28,    29,
       0,     0,    30,    31,     0,    32,    33,     0,    22,    23,
       0,     0,     0,    24,    25,    26,    27,    28,    29,     0,
       0,    30,    31,   108,   263,    67,    22,    23,     1,    64,
       0,    24,    25,    26,    27,    28,    29,     0,     0,    30,
      31,    65,    66,    67,     9,     0,     0,     0,     0,     0,
       0,    14,    15,    16,    17,    18,    19,    20,     0,     0,
     109,     0,     0,     0,     0,     0,     0,     0,    21,     0,
     108,     0,     0,     0,   110,   271,   111,   112,   113,   114,
     115,   116,   117,   118,   119,   120,   121,     0,   122,   123,
     124,   125,   126,   127,   128,   129,   130,   131,     0,     0,
       0,     0,     0,    22,    23,   132,   133,   109,    24,    25,
      26,    27,    28,    29,   108,     0,    30,    31,     0,     0,
      67,   110,     0,   111,   112,   113,   114,   115,   116,   117,
     118,   119,   120,   121,     0,   122,   123,   124,   125,   126,
     127,   128,   129,   130,   131,     0,     0,     0,     0,     0,
       0,   109,   132,   133,   108,     0,     0,     0,     0,     0,
     273,     0,     0,     0,     0,   110,     0,   111,   112,   113,
     114,   115,   116,   117,   118,   119,   120,   121,     0,   122,
     123,   124,   125,   126,   127,   128,   129,   130,   131,     0,
       0,   109,     0,   108,     0,     0,   132,   133,     0,     0,
       0,     0,     0,     0,   274,   110,     0,   111,   112,   113,
     114,   115,   116,   117,   118,   119,   120,   121,     0,   122,
     123,   124,   125,   126,   127,   128,   129,   130,   131,     0,
     109,     0,   108,     0,     0,     0,   132,   133,     0,     0,
       0,     0,     0,   182,   110,     0,   111,   112,   113,   114,
     115,   116,   117,   118,   119,   120,   121,     0,   122,   123,
     124,   125,   126,   127,   128,   129,   130,   131,     0,   109,
       0,   108,     0,     0,     0,   132,   133,     0,     0,     0,
       0,     0,   238,   110,     0,   111,   112,   113,   114,   115,
     116,   117,   118,   119,   120,   121,     0,   122,   123,   124,
     125,   126,   127,   128,   129,   130,   131,     0,   109,     0,
     108,     0,     0,     0,   132,   133,     0,     0,     0,     0,
       0,   247,   110,     0,   111,   112,   113,   114,   115,   116,
     117,   118,   119,   120,   121,     0,   122,   123,   124,   125,
     126,   127,   128,   129,   130,   131,     0,   109,     0,   108,
       0,     0,     0,   132,   133,     0,     0,     0,     0,     0,
     254,   110,     0,   111,   112,   113,   114,   115,   116,   117,
     118,   119,   120,   121,     0,   122,   123,   124,   125,   126,
     127,   128,   129,   130,   131,     0,   109,     0,   108,     0,
       0,     0,   132,   133,     0,     0,     0,     0,     0,   255,
     110,     0,   111,   112,   113,   114,   115,   116,   117,   118,
     119,   120,   121,     0,   122,   123,   124,   125,   126,   127,
     128,   129,   130,   131,     0,   109,     0,   108,     0,     0,
       0,   132,   133,     0,     0,     0,     0,     0,   317,   110,
       0,   111,   112,   113,   114,   115,   116,   117,   118,   119,
     120,   121,     0,   122,   123,   124,   125,   126,   127,   128,
     129,   130,   131,     0,   109,     0,   108,     0,     0,     0,
     132,   133,     0,     0,     0,     0,     0,   319,   110,     0,
     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
     121,     0,   122,   123,   124,   125,   126,   127,   128,   129,
     130,   131,     0,   109,     0,   108,     0,     0,     0,   132,
     133,     0,     0,     0,     0,     0,   359,   110,     0,   111,
     112,   113,   114,   115,   116,   117,   118,   119,   120,   121,
       0,   122,   123,   124,   125,   126,   127,   128,   129,   130,
     131,     0,   109,     0,   108,     0,     0,     0,   132,   133,
       0,     0,     0,     0,     0,   360,   110,     0,   111,   112,
     113,   114,   115,   116,   117,   118,   119,   120,   121,     0,
     122,   123,   124,   125,   126,   127,   128,   129,   130,   131,
       0,   109,   108,     0,     0,     0,     0,   132,   133,     0,
       0,     0,     0,     0,   370,   110,     0,   111,   112,   113,
     114,   115,   116,   117,   118,   119,   120,   121,     0,   122,
     123,   124,   125,   126,   127,   128,   129,   130,   131,   109,
     108,     0,     0,     0,     0,     0,   132,   133,     0,     0,
     134,     0,     0,   110,     0,   111,   112,   113,   114,   115,
     116,   117,   118,   119,   120,   121,     0,   122,   123,   124,
     125,   126,   127,   128,   129,   130,   131,   109,   108,     0,
       0,     0,     0,     0,   132,   133,     0,     0,   164,     0,
       0,   110,     0,   111,   112,   113,   114,   115,   116,   117,
     118,   119,   120,   121,     0,   122,   123,   124,   125,   126,
     127,   128,   129,   130,   131,   109,   108,     0,     0,     0,
       0,     0,   132,   133,     0,     0,   177,     0,     0,   110,
       0,   111,   112,   113,   114,   115,   116,   117,   118,   119,
     120,   121,     0,   122,   123,   124,   125,   126,   127,   128,
     129,   130,   131,     0,     0,     0,     0,     0,     0,     0,
     132,   133,     0,     0,   315,   316,     0,   110,     0,   111,
     112,   113,   114,   115,   116,   117,   118,   119,   120,   121,
       0,   122,   123,   124,   125,   126,   127,   128,   129,   130,
     131,     0,     0,     0,     0,     0,     0,     0,   132,   133,
     108,     0,   134,     0,   135,   136,   137,   138,   139,   140,
     141,   142,   143,   144,   145,   146,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   147,
       0,     0,     0,     0,     0,     0,     0,   109,   108,     0,
       0,     0,     0,     0,   148,   149,     0,   150,   151,   152,
       0,   110,   381,   111,   112,   113,   114,   115,   116,   117,
     118,   119,   120,   121,     0,   122,   123,   124,   125,   126,
     127,   128,   129,   130,   131,   109,   108,     0,     0,     0,
       0,     0,   132,   133,     0,     0,     0,     0,     0,   110,
       0,   111,   112,   113,   114,   115,   116,   117,   118,   119,
     120,   121,     0,   122,   123,   124,   125,   126,   127,   128,
     129,   130,   131,   108,     0,     0,     0,     0,     0,     0,
     132,   133,     0,     0,     0,     0,     0,   110,     0,   111,
     112,   113,   114,   115,   116,   117,   118,   119,   120,   121,
       0,   122,   123,   124,   125,   126,   127,   128,   129,   130,
     131,   108,     0,     0,     0,     0,     0,     0,   132,   133,
       0,     0,     0,     0,     0,     0,   111,   112,   113,   114,
     115,   116,   117,   118,   119,   120,   121,     0,   122,   123,
     124,   125,   126,   127,   128,   129,   130,   131,   108,     0,
       0,     0,     0,     0,     0,   132,   133,     0,     0,     0,
       0,     0,     0,     0,     0,   112,   113,   114,   115,   116,
     117,   118,   119,   120,   121,     0,   122,   123,   124,   125,
     126,   127,   128,   129,   130,   131,   108,     0,     0,     0,
       0,     0,     0,   132,   133,     0,     0,     0,     0,     0,
       0,     0,     0,   113,   114,   115,   116,   117,   118,   119,
     120,   121,     0,   122,   123,   124,   125,   126,   127,   128,
     129,   130,   131,   108,     0,     0,     0,     0,     0,     0,
     132,   133,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   114,   115,   116,   117,   118,   119,   120,   121,
     108,   122,   123,   124,   125,   126,   127,   128,   129,   130,
     131,     0,     0,     0,     0,     0,     0,     0,   132,   133,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     115,   116,   117,   118,   119,   120,   121,     0,   122,   123,
     124,   125,   126,   127,   128,   129,   130,   131,     0,     0,
       0,     0,     0,     0,     0,   132,   133,     0,   116,   117,
     118,   119,   120,   121,     0,   122,   123,   124,   125,   126,
     127,   128,   129,   130,   131,     0,     0,     0,     0,     0,
       0,     0,   132,   133,   135,   136,   137,   138,   139,   140,
     141,   142,   143,   144,   145,   146,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   147,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   148,   149,     0,   150,   151,   152
};

#define yypact_value_is_default(yystate) \
  ((yystate) == (-296))

#define yytable_value_is_error(yytable_value) \
  YYID (0)

static const yytype_int16 yycheck[] =
{
       0,     4,     4,     0,   103,     4,    45,    60,     9,    10,
       8,    45,   176,     8,     0,   169,   170,   171,     8,    57,
      60,     7,    13,    14,    13,    14,    12,    28,    29,     3,
      45,   326,    45,    33,   329,    35,    22,    23,    24,    25,
      26,    27,    95,    47,    30,    31,    16,    90,    91,    35,
      60,    94,    47,    27,    28,    95,    60,    31,   157,    98,
      47,    35,    96,    33,    34,    92,    36,    37,    38,    39,
      40,    41,    58,   368,     4,   297,    63,    77,   242,    94,
      77,    94,    80,    81,    82,    95,    72,   309,   238,    92,
      92,    90,    90,    91,    80,    81,    96,   261,    47,    47,
      90,    91,   324,   257,   254,    96,    60,    96,   330,     3,
       4,    85,    60,   277,    63,    85,    22,    23,   272,    90,
      91,    92,   108,   109,   110,   111,   112,   113,   114,   115,
     116,   117,   118,   119,   120,   121,   122,   123,   124,   125,
     126,   127,   128,   129,   130,   131,   184,   133,   302,   135,
     136,   137,   138,   139,   140,   141,   142,   143,   144,   145,
     146,   147,     4,    63,   328,   151,   152,   317,   322,   333,
      95,   335,    92,   323,   174,     4,    92,     8,     0,   165,
      90,    91,   346,   169,   170,   171,    94,    92,   189,     4,
      94,   191,     8,    47,   180,    95,    92,   183,   184,    92,
      29,    30,    60,   189,   190,   369,    92,    60,   194,   359,
      92,     0,    92,     4,     3,     4,     5,     4,    97,    45,
     370,   371,    11,    92,    60,    92,    15,    16,    17,    18,
      19,    20,    21,    92,    97,    24,    25,    26,    27,    28,
      29,    30,    31,    32,    75,    76,    77,    78,    79,    80,
      81,    82,     9,     8,    43,     8,    97,    92,   244,    90,
      91,    45,    78,    79,    80,    81,    82,     7,     4,     9,
      10,   257,    12,    97,    90,    91,    97,    97,   264,    92,
      97,     4,    92,    92,     6,   271,   272,    90,    95,    78,
      79,    97,    97,    94,    83,    84,    85,    86,    87,    88,
      97,    97,    91,    92,    90,    94,    95,    97,    23,    97,
      60,     5,   364,     9,   166,   262,   302,    70,    71,   327,
      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,
     316,    30,   318,     3,     4,     9,   322,    90,    91,   186,
      -1,    -1,    -1,    -1,    -1,    -1,    16,    -1,    -1,    -1,
     336,    -1,   338,    -1,    -1,    -1,    26,    27,    28,    29,
      30,    31,    32,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   374,   361,    -1,   374,    -1,    -1,
      -1,   381,   382,   383,   381,     0,    -1,    -1,     3,     4,
       5,    -1,    -1,    -1,    -1,    -1,    11,    -1,    -1,    -1,
      15,    16,    17,    18,    19,    20,    21,     3,     4,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    -1,    -1,
      16,    91,    92,    19,    -1,    95,    -1,    -1,    43,    -1,
      26,    27,    28,    29,    30,    31,    32,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    43,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    78,    79,    -1,    -1,    -1,    83,    84,
      85,    86,    87,    88,    -1,    -1,    91,    92,    -1,    94,
      95,    -1,    78,    79,    -1,    -1,    -1,    83,    84,    85,
      86,    87,    88,    -1,    -1,    91,    92,    -1,    -1,    95,
      -1,    -1,    98,     3,     4,     5,    -1,    -1,    -1,    -1,
      -1,    11,    -1,    13,    14,    15,    16,    17,    18,    19,
      20,    21,    -1,    -1,    24,    25,    26,    27,    28,    29,
      30,    31,    32,    -1,     3,     4,     5,    -1,    -1,    -1,
      -1,    -1,    11,    43,    13,    14,    15,    16,    17,    18,
      19,    20,    21,    -1,    -1,    24,    25,    26,    27,    28,
      29,    30,    31,    32,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    43,    -1,    -1,    -1,    78,    79,
      -1,    -1,    -1,    83,    84,    85,    86,    87,    88,    -1,
      -1,    91,    92,    -1,    94,    95,    96,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,
      79,    -1,    -1,    -1,    83,    84,    85,    86,    87,    88,
      -1,    -1,    91,    92,    -1,    94,    95,    96,     3,     4,
       5,    -1,    -1,    -1,    -1,    -1,    11,    -1,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    -1,    -1,    24,
      25,    26,    27,    28,    29,    30,    31,    32,     3,     4,
       5,    -1,    -1,    -1,    -1,    -1,    11,    -1,    43,    -1,
      15,    16,    17,    18,    19,    20,    21,    -1,    -1,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    43,    -1,
      45,    -1,    -1,    78,    79,    -1,    -1,    -1,    83,    84,
      85,    86,    87,    88,    -1,    -1,    91,    92,    -1,    94,
      95,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    78,    79,    -1,    -1,    -1,    83,    84,
      85,    86,    87,    88,    -1,    -1,    91,    92,    -1,    94,
      95,    96,     3,     4,     5,    -1,    -1,    -1,    -1,    -1,
      11,    -1,    -1,    -1,    15,    16,    17,    18,    19,    20,
      21,    -1,    -1,    24,    25,    26,    27,    28,    29,    30,
      31,    32,    -1,     3,     4,     5,    -1,    -1,    -1,    -1,
      -1,    11,    43,    -1,    45,    15,    16,    17,    18,    19,
      20,    21,    -1,    -1,    24,    25,    26,    27,    28,    29,
      30,    31,    32,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    43,    -1,    -1,    -1,    78,    79,    -1,
      -1,    -1,    83,    84,    85,    86,    87,    88,    -1,    -1,
      91,    92,    -1,    94,    95,    96,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,    79,
      -1,    -1,    -1,    83,    84,    85,    86,    87,    88,    -1,
      -1,    91,    92,    -1,    94,    95,    96,     3,     4,     5,
      -1,    -1,    -1,    -1,    -1,    11,    -1,    -1,    -1,    15,
      16,    17,    18,    19,    20,    21,    -1,    -1,    24,    25,
      26,    27,    28,    29,    30,    31,    32,     3,     4,     5,
      -1,    -1,    -1,    -1,    -1,    11,    -1,    43,    -1,    15,
      16,    17,    18,    19,    20,    21,    -1,    -1,    24,    25,
      26,    27,    28,    29,    30,    31,    32,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    43,    -1,    -1,
      -1,    -1,    78,    79,    -1,    -1,    -1,    83,    84,    85,
      86,    87,    88,    -1,    -1,    91,    92,    -1,    94,    95,
      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    78,    79,    -1,    -1,    -1,    83,    84,    85,
      86,    87,    88,    -1,    -1,    91,    92,    -1,    94,    95,
      96,     3,     4,     5,    -1,    -1,    -1,    -1,    -1,    11,
      -1,    -1,    -1,    15,    16,    17,    18,    19,    20,    21,
      -1,    -1,    24,    25,    26,    27,    28,    29,    30,    31,
      32,     3,     4,     5,    -1,    -1,    -1,    -1,    -1,    11,
      -1,    43,    -1,    15,    16,    17,    18,    19,    20,    21,
      -1,    -1,    24,    25,    26,    27,    28,    29,    30,    31,
      32,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    43,    -1,    -1,    -1,    -1,    78,    79,    -1,    -1,
      -1,    83,    84,    85,    86,    87,    88,    -1,    -1,    91,
      92,    -1,    94,    95,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    78,    79,    -1,    -1,
      -1,    83,    84,    85,    86,    87,    88,    -1,    -1,    91,
      92,    -1,    94,    95,     3,     4,     5,    -1,    -1,    -1,
      -1,    -1,    11,    -1,    -1,    -1,    15,    16,    17,    18,
      19,    20,    21,     3,     4,    24,    25,    26,    27,    28,
      29,    30,    31,    32,    -1,    -1,    16,    -1,    18,    19,
      -1,     3,     4,    -1,    43,    -1,    26,    27,    28,    29,
      30,    31,    32,    -1,    16,    -1,    -1,    19,    -1,    -1,
      -1,    -1,    -1,    43,    26,    27,    28,    29,    30,    31,
      32,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    78,
      79,    43,    -1,    -1,    83,    84,    85,    86,    87,    88,
      -1,    -1,    91,    92,    -1,    94,    95,    -1,    78,    79,
      -1,    -1,    -1,    83,    84,    85,    86,    87,    88,    -1,
      -1,    91,    92,     8,    94,    95,    78,    79,     3,     4,
      -1,    83,    84,    85,    86,    87,    88,    -1,    -1,    91,
      92,    16,    94,    95,    19,    -1,    -1,    -1,    -1,    -1,
      -1,    26,    27,    28,    29,    30,    31,    32,    -1,    -1,
      45,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    43,    -1,
       8,    -1,    -1,    -1,    59,    60,    61,    62,    63,    64,
      65,    66,    67,    68,    69,    70,    71,    -1,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,    -1,    -1,
      -1,    -1,    -1,    78,    79,    90,    91,    45,    83,    84,
      85,    86,    87,    88,     8,    -1,    91,    92,    -1,    -1,
      95,    59,    -1,    61,    62,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    -1,    73,    74,    75,    76,    77,
      78,    79,    80,    81,    82,    -1,    -1,    -1,    -1,    -1,
      -1,    45,    90,    91,     8,    -1,    -1,    -1,    -1,    -1,
      98,    -1,    -1,    -1,    -1,    59,    -1,    61,    62,    63,
      64,    65,    66,    67,    68,    69,    70,    71,    -1,    73,
      74,    75,    76,    77,    78,    79,    80,    81,    82,    -1,
      -1,    45,    -1,     8,    -1,    -1,    90,    91,    -1,    -1,
      -1,    -1,    -1,    -1,    98,    59,    -1,    61,    62,    63,
      64,    65,    66,    67,    68,    69,    70,    71,    -1,    73,
      74,    75,    76,    77,    78,    79,    80,    81,    82,    -1,
      45,    -1,     8,    -1,    -1,    -1,    90,    91,    -1,    -1,
      -1,    -1,    -1,    97,    59,    -1,    61,    62,    63,    64,
      65,    66,    67,    68,    69,    70,    71,    -1,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,    -1,    45,
      -1,     8,    -1,    -1,    -1,    90,    91,    -1,    -1,    -1,
      -1,    -1,    97,    59,    -1,    61,    62,    63,    64,    65,
      66,    67,    68,    69,    70,    71,    -1,    73,    74,    75,
      76,    77,    78,    79,    80,    81,    82,    -1,    45,    -1,
       8,    -1,    -1,    -1,    90,    91,    -1,    -1,    -1,    -1,
      -1,    97,    59,    -1,    61,    62,    63,    64,    65,    66,
      67,    68,    69,    70,    71,    -1,    73,    74,    75,    76,
      77,    78,    79,    80,    81,    82,    -1,    45,    -1,     8,
      -1,    -1,    -1,    90,    91,    -1,    -1,    -1,    -1,    -1,
      97,    59,    -1,    61,    62,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    -1,    73,    74,    75,    76,    77,
      78,    79,    80,    81,    82,    -1,    45,    -1,     8,    -1,
      -1,    -1,    90,    91,    -1,    -1,    -1,    -1,    -1,    97,
      59,    -1,    61,    62,    63,    64,    65,    66,    67,    68,
      69,    70,    71,    -1,    73,    74,    75,    76,    77,    78,
      79,    80,    81,    82,    -1,    45,    -1,     8,    -1,    -1,
      -1,    90,    91,    -1,    -1,    -1,    -1,    -1,    97,    59,
      -1,    61,    62,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    -1,    73,    74,    75,    76,    77,    78,    79,
      80,    81,    82,    -1,    45,    -1,     8,    -1,    -1,    -1,
      90,    91,    -1,    -1,    -1,    -1,    -1,    97,    59,    -1,
      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
      71,    -1,    73,    74,    75,    76,    77,    78,    79,    80,
      81,    82,    -1,    45,    -1,     8,    -1,    -1,    -1,    90,
      91,    -1,    -1,    -1,    -1,    -1,    97,    59,    -1,    61,
      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      -1,    73,    74,    75,    76,    77,    78,    79,    80,    81,
      82,    -1,    45,    -1,     8,    -1,    -1,    -1,    90,    91,
      -1,    -1,    -1,    -1,    -1,    97,    59,    -1,    61,    62,
      63,    64,    65,    66,    67,    68,    69,    70,    71,    -1,
      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,
      -1,    45,     8,    -1,    -1,    -1,    -1,    90,    91,    -1,
      -1,    -1,    -1,    -1,    97,    59,    -1,    61,    62,    63,
      64,    65,    66,    67,    68,    69,    70,    71,    -1,    73,
      74,    75,    76,    77,    78,    79,    80,    81,    82,    45,
       8,    -1,    -1,    -1,    -1,    -1,    90,    91,    -1,    -1,
      94,    -1,    -1,    59,    -1,    61,    62,    63,    64,    65,
      66,    67,    68,    69,    70,    71,    -1,    73,    74,    75,
      76,    77,    78,    79,    80,    81,    82,    45,     8,    -1,
      -1,    -1,    -1,    -1,    90,    91,    -1,    -1,    94,    -1,
      -1,    59,    -1,    61,    62,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    -1,    73,    74,    75,    76,    77,
      78,    79,    80,    81,    82,    45,     8,    -1,    -1,    -1,
      -1,    -1,    90,    91,    -1,    -1,    94,    -1,    -1,    59,
      -1,    61,    62,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    -1,    73,    74,    75,    76,    77,    78,    79,
      80,    81,    82,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      90,    91,    -1,    -1,    94,     8,    -1,    59,    -1,    61,
      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      -1,    73,    74,    75,    76,    77,    78,    79,    80,    81,
      82,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    90,    91,
       8,    -1,    94,    -1,    47,    48,    49,    50,    51,    52,
      53,    54,    55,    56,    57,    58,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    45,     8,    -1,
      -1,    -1,    -1,    -1,    87,    88,    -1,    90,    91,    92,
      -1,    59,    60,    61,    62,    63,    64,    65,    66,    67,
      68,    69,    70,    71,    -1,    73,    74,    75,    76,    77,
      78,    79,    80,    81,    82,    45,     8,    -1,    -1,    -1,
      -1,    -1,    90,    91,    -1,    -1,    -1,    -1,    -1,    59,
      -1,    61,    62,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    -1,    73,    74,    75,    76,    77,    78,    79,
      80,    81,    82,     8,    -1,    -1,    -1,    -1,    -1,    -1,
      90,    91,    -1,    -1,    -1,    -1,    -1,    59,    -1,    61,
      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,
      -1,    73,    74,    75,    76,    77,    78,    79,    80,    81,
      82,     8,    -1,    -1,    -1,    -1,    -1,    -1,    90,    91,
      -1,    -1,    -1,    -1,    -1,    -1,    61,    62,    63,    64,
      65,    66,    67,    68,    69,    70,    71,    -1,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,     8,    -1,
      -1,    -1,    -1,    -1,    -1,    90,    91,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    62,    63,    64,    65,    66,
      67,    68,    69,    70,    71,    -1,    73,    74,    75,    76,
      77,    78,    79,    80,    81,    82,     8,    -1,    -1,    -1,
      -1,    -1,    -1,    90,    91,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    -1,    73,    74,    75,    76,    77,    78,    79,
      80,    81,    82,     8,    -1,    -1,    -1,    -1,    -1,    -1,
      90,    91,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    64,    65,    66,    67,    68,    69,    70,    71,
       8,    73,    74,    75,    76,    77,    78,    79,    80,    81,
      82,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    90,    91,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      65,    66,    67,    68,    69,    70,    71,    -1,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    90,    91,    -1,    66,    67,
      68,    69,    70,    71,    -1,    73,    74,    75,    76,    77,
      78,    79,    80,    81,    82,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    90,    91,    47,    48,    49,    50,    51,    52,
      53,    54,    55,    56,    57,    58,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    87,    88,    -1,    90,    91,    92
};

/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
   symbol of state STATE-NUM.  */
static const yytype_uint8 yystos[] =
{
       0,     3,     4,     5,    11,    15,    16,    17,    18,    19,
      20,    21,    24,    25,    26,    27,    28,    29,    30,    31,
      32,    43,    78,    79,    83,    84,    85,    86,    87,    88,
      91,    92,    94,    95,   100,   101,   102,   103,   104,   105,
     106,   108,   110,   111,   114,   117,   118,   119,   123,   124,
     125,   132,   133,   134,   137,   138,   141,    60,    92,     4,
     107,   107,     4,    92,     4,    16,    94,    95,   132,     4,
     115,   116,    92,   125,   134,   137,   134,    95,   131,   132,
      92,    92,   132,   132,   132,   132,   132,   132,   134,   134,
      98,   132,   136,   132,     3,     4,   101,   132,   139,   140,
       0,   102,   132,    92,     7,     9,    10,    12,     8,    45,
      59,    61,    62,    63,    64,    65,    66,    67,    68,    69,
      70,    71,    73,    74,    75,    76,    77,    78,    79,    80,
      81,    82,    90,    91,    94,    47,    48,    49,    50,    51,
      52,    53,    54,    55,    56,    57,    58,    72,    87,    88,
      90,    91,    92,   103,   132,    94,    94,    92,     4,   126,
     130,     4,     3,     4,    94,    47,    45,    94,   132,    92,
      92,    92,    94,    96,   101,    22,    23,    94,   132,   132,
      45,    98,    97,    60,    60,    96,    45,    96,   126,    92,
      92,    95,   102,   109,    92,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,   132,   132,   132,   132,   132,     4,
     132,   132,   132,   132,   132,   132,   132,   132,   132,   132,
     132,   132,   132,   132,     4,   132,   135,   136,    97,   126,
      47,    60,    97,    45,    60,   132,   116,    97,   135,   135,
     135,    96,    92,   131,    97,    97,   132,    92,   132,   132,
     140,    97,    18,    94,   120,   132,   134,   132,    96,     9,
     132,    60,    92,    98,    98,    97,   109,    97,     3,    27,
      28,    31,    35,    85,   129,    16,    33,    34,    36,    37,
      38,    39,    40,    41,    85,   127,   128,    60,   131,     4,
      90,   132,    92,    97,    97,    97,     4,   109,   135,    60,
     131,     4,   115,   121,   132,    94,     8,    97,    92,    97,
     132,   135,    92,     6,    60,   131,    47,    63,   128,    47,
      60,    90,   135,    97,    97,   128,     8,    94,    94,   132,
     109,   132,    95,    97,   135,   109,   128,   129,   127,   131,
     129,   128,    90,    97,   131,   131,   132,   122,   132,    97,
      97,    13,    14,    96,   112,   113,    97,   131,    47,    23,
      97,    97,   109,   132,    60,    96,   113,   129,   131,   109,
     109,    60,   101,   101
};

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		(-2)
#define YYEOF		0

#define YYACCEPT	goto yyacceptlab
#define YYABORT		goto yyabortlab
#define YYERROR		goto yyerrorlab


/* Like YYERROR except do call yyerror.  This remains here temporarily
   to ease the transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  However,
   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
   discussed.  */

#define YYFAIL		goto yyerrlab
#if defined YYFAIL
  /* This is here to suppress warnings from the GCC cpp's
     -Wunused-macros.  Normally we don't worry about that warning, but
     some users do, and we want to make it easy for users to remove
     YYFAIL uses, which will produce warnings from Bison 2.5.  */
#endif

#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)					\
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    {								\
      yychar = (Token);						\
      yylval = (Value);						\
      YYPOPSTACK (1);						\
      goto yybackup;						\
    }								\
  else								\
    {								\
      yyerror (&yylloc, pstate, YY_("syntax error: cannot back up")); \
      YYERROR;							\
    }								\
while (YYID (0))


#define YYTERROR	1
#define YYERRCODE	256


/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

#define YYRHSLOC(Rhs, K) ((Rhs)[K])
#ifndef YYLLOC_DEFAULT
# define YYLLOC_DEFAULT(Current, Rhs, N)				\
    do									\
      if (YYID (N))                                                    \
	{								\
	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
	}								\
      else								\
	{								\
	  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).last_column;				\
	}								\
    while (YYID (0))
#endif


/* YY_LOCATION_PRINT -- Print the location on the stream.
   This macro was not mandated originally: define only if we know
   we won't break user code: when these are the locations we know.  */

#ifndef YY_LOCATION_PRINT
# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
#  define YY_LOCATION_PRINT(File, Loc)			\
     fprintf (File, "%d.%d-%d.%d",			\
	      (Loc).first_line, (Loc).first_column,	\
	      (Loc).last_line,  (Loc).last_column)
# else
#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
# endif
#endif


/* YYLEX -- calling `yylex' with the right arguments.  */

#ifdef YYLEX_PARAM
# define YYLEX yylex (&yylval, &yylloc, YYLEX_PARAM)
#else
# define YYLEX yylex (&yylval, &yylloc, pstate)
#endif

/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)			\
do {						\
  if (yydebug)					\
    YYFPRINTF Args;				\
} while (YYID (0))

# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
do {									  \
  if (yydebug)								  \
    {									  \
      YYFPRINTF (stderr, "%s ", Title);					  \
      yy_symbol_print (stderr,						  \
		  Type, Value, Location, pstate); \
      YYFPRINTF (stderr, "\n");						  \
    }									  \
} while (YYID (0))


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, jsi_Pstate *pstate)
#else
static void
yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp, pstate)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
    YYLTYPE const * const yylocationp;
    jsi_Pstate *pstate;
#endif
{
  if (!yyvaluep)
    return;
  YYUSE (yylocationp);
  YYUSE (pstate);
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# else
  YYUSE (yyoutput);
# endif
  switch (yytype)
    {
      default:
	break;
    }
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, jsi_Pstate *pstate)
#else
static void
yy_symbol_print (yyoutput, yytype, yyvaluep, yylocationp, pstate)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
    YYLTYPE const * const yylocationp;
    jsi_Pstate *pstate;
#endif
{
  if (yytype < YYNTOKENS)
    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
  else
    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);

  YY_LOCATION_PRINT (yyoutput, *yylocationp);
  YYFPRINTF (yyoutput, ": ");
  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp, pstate);
  YYFPRINTF (yyoutput, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
#else
static void
yy_stack_print (yybottom, yytop)
    yytype_int16 *yybottom;
    yytype_int16 *yytop;
#endif
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)				\
do {								\
  if (yydebug)							\
    yy_stack_print ((Bottom), (Top));				\
} while (YYID (0))


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_reduce_print (YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, jsi_Pstate *pstate)
#else
static void
yy_reduce_print (yyvsp, yylsp, yyrule, pstate)
    YYSTYPE *yyvsp;
    YYLTYPE *yylsp;
    int yyrule;
    jsi_Pstate *pstate;
#endif
{
  int yynrhs = yyr2[yyrule];
  int yyi;
  unsigned long int yylno = yyrline[yyrule];
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
	     yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
		       &(yyvsp[(yyi + 1) - (yynrhs)])
		       , &(yylsp[(yyi + 1) - (yynrhs)])		       , pstate);
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)		\
do {					\
  if (yydebug)				\
    yy_reduce_print (yyvsp, yylsp, Rule, pstate); \
} while (YYID (0))

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef	YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static YYSIZE_T
yystrlen (const char *yystr)
#else
static YYSIZE_T
yystrlen (yystr)
    const char *yystr;
#endif
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static char *
yystpcpy (char *yydest, const char *yysrc)
#else
static char *
yystpcpy (yydest, yysrc)
    char *yydest;
    const char *yysrc;
#endif
{
  char *yyd = yydest;
  const char *yys = yysrc;

  while ((*yyd++ = *yys++) != '\0')
    continue;

  return yyd - 1;
}
#  endif
# endif

# ifndef yytnamerr
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */
static YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
	switch (*++yyp)
	  {
	  case '\'':
	  case ',':
	    goto do_not_strip_quotes;

	  case '\\':
	    if (*++yyp != '\\')
	      goto do_not_strip_quotes;
	    /* Fall through.  */
	  default:
	    if (yyres)
	      yyres[yyn] = *yyp;
	    yyn++;
	    break;

	  case '"':
	    if (yyres)
	      yyres[yyn] = '\0';
	    return yyn;
	  }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
# endif

/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
   about the unexpected token YYTOKEN for the state stack whose top is
   YYSSP.

   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
   not large enough to hold the message.  In that case, also set
   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
   required number of bytes is too large to store.  */
static int
yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                yytype_int16 *yyssp, int yytoken)
{
  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
  YYSIZE_T yysize = yysize0;
  YYSIZE_T yysize1;
  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
  /* Internationalized format string. */
  const char *yyformat = 0;
  /* Arguments of yyformat. */
  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
  /* Number of reported tokens (one for the "unexpected", one per
     "expected"). */
  int yycount = 0;

  /* There are many possibilities here to consider:
     - Assume YYFAIL is not used.  It's too flawed to consider.  See
       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
       for details.  YYERROR is fine as it does not invoke this
       function.
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple "syntax error".
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */
  if (yytoken != YYEMPTY)
    {
      int yyn = yypact[*yyssp];
      yyarg[yycount++] = yytname[yytoken];
      if (!yypact_value_is_default (yyn))
        {
          /* Start YYX at -YYN if negative to avoid negative indexes in
             YYCHECK.  In other words, skip the first -YYN actions for
             this state because they are default actions.  */
          int yyxbegin = yyn < 0 ? -yyn : 0;
          /* Stay within bounds of both yycheck and yytname.  */
          int yychecklim = YYLAST - yyn + 1;
          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
          int yyx;

          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
                && !yytable_value_is_error (yytable[yyx + yyn]))
              {
                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
                  {
                    yycount = 1;
                    yysize = yysize0;
                    break;
                  }
                yyarg[yycount++] = yytname[yyx];
                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
                if (! (yysize <= yysize1
                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
                  return 2;
                yysize = yysize1;
              }
        }
    }

  switch (yycount)
    {
# define YYCASE_(N, S)                      \
      case N:                               \
        yyformat = S;                       \
      break
      YYCASE_(0, YY_("syntax error"));
      YYCASE_(1, YY_("syntax error, unexpected %s"));
      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
# undef YYCASE_
    }

  yysize1 = yysize + yystrlen (yyformat);
  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    return 2;
  yysize = yysize1;

  if (*yymsg_alloc < yysize)
    {
      *yymsg_alloc = 2 * yysize;
      if (! (yysize <= *yymsg_alloc
             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
      return 1;
    }

  /* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of "%s"s.  */
  {
    char *yyp = *yymsg;
    int yyi = 0;
    while ((*yyp = *yyformat) != '\0')
      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        {
          yyp += yytnamerr (yyp, yyarg[yyi++]);
          yyformat += 2;
        }
      else
        {
          yyp++;
          yyformat++;
        }
  }
  return 0;
}
#endif /* YYERROR_VERBOSE */

/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, jsi_Pstate *pstate)
#else
static void
yydestruct (yymsg, yytype, yyvaluep, yylocationp, pstate)
    const char *yymsg;
    int yytype;
    YYSTYPE *yyvaluep;
    YYLTYPE *yylocationp;
    jsi_Pstate *pstate;
#endif
{
  YYUSE (yyvaluep);
  YYUSE (yylocationp);
  YYUSE (pstate);

  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  switch (yytype)
    {

      default:
	break;
    }
}


/* Prevent warnings from -Wmissing-prototypes.  */
#ifdef YYPARSE_PARAM
#if defined __STDC__ || defined __cplusplus
int yyparse (void *YYPARSE_PARAM);
#else
int yyparse ();
#endif
#else /* ! YYPARSE_PARAM */
#if defined __STDC__ || defined __cplusplus
int yyparse (jsi_Pstate *pstate);
#else
int yyparse ();
#endif
#endif /* ! YYPARSE_PARAM */


/*----------.
| yyparse.  |
`----------*/

#ifdef YYPARSE_PARAM
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void *YYPARSE_PARAM)
#else
int
yyparse (YYPARSE_PARAM)
    void *YYPARSE_PARAM;
#endif
#else /* ! YYPARSE_PARAM */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (jsi_Pstate *pstate)
#else
int
yyparse (pstate)
    jsi_Pstate *pstate;
#endif
#endif
{
/* The lookahead symbol.  */
int yychar;

/* The semantic value of the lookahead symbol.  */
YYSTYPE yylval;

/* Location data for the lookahead symbol.  */
YYLTYPE yylloc;

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       `yyss': related to states.
       `yyvs': related to semantic values.
       `yyls': related to locations.

       Refer to the stacks thru separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    /* The location stack.  */
    YYLTYPE yylsa[YYINITDEPTH];
    YYLTYPE *yyls;
    YYLTYPE *yylsp;

    /* The locations where the error started and ended.  */
    YYLTYPE yyerror_range[3];

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;
  YYLTYPE yyloc;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yytoken = 0;
  yyss = yyssa;
  yyvs = yyvsa;
  yyls = yylsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */
  yyssp = yyss;
  yyvsp = yyvs;
  yylsp = yyls;

#if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
  /* Initialize the default location before parsing starts.  */
  yylloc.first_line   = yylloc.last_line   = 1;
  yylloc.first_column = yylloc.last_column = 1;
#endif

  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
	/* Give user a chance to reallocate the stack.  Use copies of
	   these so that the &'s don't force the real ones into
	   memory.  */
	YYSTYPE *yyvs1 = yyvs;
	yytype_int16 *yyss1 = yyss;
	YYLTYPE *yyls1 = yyls;

	/* Each stack pointer address is followed by the size of the
	   data in use in that stack, in bytes.  This used to be a
	   conditional around just the two extra args, but that might
	   be undefined if yyoverflow is a macro.  */
	yyoverflow (YY_("memory exhausted"),
		    &yyss1, yysize * sizeof (*yyssp),
		    &yyvs1, yysize * sizeof (*yyvsp),
		    &yyls1, yysize * sizeof (*yylsp),
		    &yystacksize);

	yyls = yyls1;
	yyss = yyss1;
	yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
	goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
	yystacksize = YYMAXDEPTH;

      {
	yytype_int16 *yyss1 = yyss;
	union yyalloc *yyptr =
	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
	if (! yyptr)
	  goto yyexhaustedlab;
	YYSTACK_RELOCATE (yyss_alloc, yyss);
	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
	YYSTACK_RELOCATE (yyls_alloc, yyls);
#  undef YYSTACK_RELOCATE
	if (yyss1 != yyssa)
	  YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;
      yylsp = yyls + yysize - 1;

      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
		  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
	YYABORT;
    }

  YYDPRINTF ((stderr, "Entering state %d\n", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token: "));
      yychar = YYLEX;
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  *++yyvsp = yylval;
  *++yylsp = yylloc;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     `$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];

  /* Default location.  */
  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 2:

/* Line 1806 of yacc.c  */
    { pstate->opcodes = code_nop(); }
    break;

  case 3:

/* Line 1806 of yacc.c  */
    {
        pstate->opcodes = (OpCodes*)(yyvsp[(1) - (1)]);
    }
    break;

  case 4:

/* Line 1806 of yacc.c  */
    {
        pstate->opcodes = codes_join3((OpCodes*)(yyvsp[(1) - (2)]), (OpCodes*)(yyvsp[(2) - (2)]), code_ret(pstate, &(yylsp[(1) - (2)]), 1));
    }
    break;

  case 5:

/* Line 1806 of yacc.c  */
    {    /* for json */
        pstate->opcodes = codes_join((OpCodes*)(yyvsp[(1) - (1)]), code_ret(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), 1));
    }
    break;

  case 6:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 7:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (2)]), (OpCodes*)(yyvsp[(2) - (2)])); }
    break;

  case 8:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 9:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 10:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 11:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (2)]), code_pop(1)); }
    break;

  case 12:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 13:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 14:

/* Line 1806 of yacc.c  */
    { (yyval) = code_reserved(pstate, (jsi_Pline *)&(yylsp[(2) - (3)]), RES_BREAK, (char*)(yyvsp[(2) - (3)])); }
    break;

  case 15:

/* Line 1806 of yacc.c  */
    { (yyval) = code_reserved(pstate, (jsi_Pline *)&(yylsp[(2) - (3)]), RES_CONTINUE, (char*)(yyvsp[(2) - (3)])); }
    break;

  case 16:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (3)]), code_ret(pstate, (jsi_Pline *)&(yylsp[(2) - (3)]), 1)); }
    break;

  case 17:

/* Line 1806 of yacc.c  */
    { (yyval) = code_ret(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 0); }
    break;

  case 18:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(2) - (3)]); }
    break;

  case 19:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (3)]), code_throw(pstate, (jsi_Pline *)&(yylsp[(2) - (3)]))); }
    break;

  case 20:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 21:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 22:

/* Line 1806 of yacc.c  */
    { (yyval) = code_nop(); }
    break;

  case 23:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(2) - (3)]); }
    break;

  case 24:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 25:

/* Line 1806 of yacc.c  */
    {
        OpCodes *ret = codes_join4(code_push_index(pstate, (jsi_Pline *)&(yylsp[(1) - (7)]), (char*)(yyvsp[(1) - (7)])),
          code_push_func(pstate, &(yylsp[(3) - (7)]), jsi_FuncMake(pstate, (Jsi_ScopeStrs*)(yyvsp[(3) - (7)]), (OpCodes*)(yyvsp[(7) - (7)]), (jsi_Pline *)&(yylsp[(7) - (7)]), (char*)(yyvsp[(1) - (7)]))),
          code_assign(pstate, (jsi_Pline *)&(yylsp[(1) - (7)]), 1), code_pop(1));
        if (pstate->eval_flag) ret = codes_join(code_local(pstate, (jsi_Pline *)&(yylsp[(1) - (7)]), (const char*)(yyvsp[(1) - (7)])), ret);
        jsi_PstatePop(pstate);
        (yyval) = ret;
    }
    break;

  case 26:

/* Line 1806 of yacc.c  */
    {
        OpCodes *ret = codes_join4(code_push_index(pstate, (jsi_Pline *)&(yylsp[(1) - (5)]), (char*)(yyvsp[(1) - (5)])),
          code_push_func(pstate, (jsi_Pline *)&(yylsp[(3) - (5)]), jsi_FuncMake(pstate, (Jsi_ScopeStrs*)(yyvsp[(3) - (5)]), (OpCodes*)(yyvsp[(5) - (5)]), (jsi_Pline *)&(yylsp[(5) - (5)]), (char*)(yyvsp[(1) - (5)]))),
          code_assign(pstate, (jsi_Pline *)&(yylsp[(1) - (5)]), 1), code_pop(1));
        if (pstate->eval_flag) ret = codes_join(code_local(pstate, (jsi_Pline *)&(yylsp[(1) - (5)]), (char*)(yyvsp[(1) - (5)])), ret);
        jsi_PstatePop(pstate);
        (yyval) = ret;
    }
    break;

  case 27:

/* Line 1806 of yacc.c  */
    {
        if (!pstate->eval_flag) {
            jsi_PstateAddVar(pstate, (const char*)(yyvsp[(2) - (2)]));
        }
        (yyval) = (yyvsp[(2) - (2)]);
    }
    break;

  case 28:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 29:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 30:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 31:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 32:

/* Line 1806 of yacc.c  */
    { (yyval) = NULL; }
    break;

  case 33:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 34:

/* Line 1806 of yacc.c  */
    { (yyval) = NULL; }
    break;

  case 35:

/* Line 1806 of yacc.c  */
    {
        (yyval) = (yyvsp[(1) - (2)]);
    }
    break;

  case 36:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 37:

/* Line 1806 of yacc.c  */
    { (yyval) = code_nop(); }
    break;

  case 38:

/* Line 1806 of yacc.c  */
    { 
        (yyval) = codes_join4((OpCodes*)(yyvsp[(3) - (5)]), code_with(pstate, (jsi_Pline *)&(yylsp[(3) - (5)]), ((OpCodes *)(yyvsp[(5) - (5)]))->code_len + 1), (OpCodes*)(yyvsp[(5) - (5)]), code_ewith(pstate, (jsi_Pline *)&(yylsp[(5) - (5)])));
    }
    break;

  case 39:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(4) - (7)]), code_pop(1)); }
    break;

  case 40:

/* Line 1806 of yacc.c  */
    {
        CaseList *cl = (CaseList*)(yyvsp[(7) - (8)]);
        OpCodes *allstats = codes_new(3);
        CaseList *cldefault = NULL;
        CaseList *head = NULL;
        
        while (cl) {
            cl->off = allstats->code_len;
            allstats = codes_join(allstats, cl->es->stat);

            CaseList *t = cl;
            cl = cl->next;
            
            if (t->es->isdefault) {
                if (cldefault) yyerror((jsi_Pline *)&(yylsp[(8) - (8)]), pstate, "More then one switch default\n");
                cldefault = t;
            } else {
                t->next = head;
                head = t;
            }
        }
        code_reserved_replace(allstats, 0, 1, (const char*)(yyvsp[(1) - (8)]), 1);
        
        OpCodes *ophead = code_jmp(allstats->code_len + 1);
        if (cldefault) {
            ophead = codes_join(code_jmp(ophead->code_len + cldefault->off + 1), ophead);
            if (cldefault->es)
                Jsi_Free(cldefault->es);
            Jsi_Free(cldefault);
        }
        while (head) {
            OpCodes *e = codes_join4(code_push_top(), head->es->expr, 
                                        code_equal(), code_jtrue(ophead->code_len + head->off + 1));
            ophead = codes_join(e, ophead);
            CaseList *t = head;
            head = head->next;
            if (t->es)
                Jsi_Free(t->es);
            Jsi_Free(t);
        }
        (yyval) = codes_join4(codes_join((OpCodes*)(yyvsp[(4) - (8)]), code_unref()), ophead, allstats, code_pop(1));
    }
    break;

  case 41:

/* Line 1806 of yacc.c  */
    { (yyval) = caselist_new(pstate,(CaseExprStat*)(yyvsp[(1) - (1)])); }
    break;

  case 42:

/* Line 1806 of yacc.c  */
    { (yyval) = caselist_insert(pstate,(CaseList*)(yyvsp[(1) - (2)]), (CaseExprStat*)(yyvsp[(2) - (2)])); }
    break;

  case 43:

/* Line 1806 of yacc.c  */
    { (yyval) = exprstat_new(pstate, (OpCodes*)(yyvsp[(2) - (4)]), (OpCodes*)(yyvsp[(4) - (4)]), 0); }
    break;

  case 44:

/* Line 1806 of yacc.c  */
    { (yyval) = exprstat_new(pstate, NULL, (OpCodes*)(yyvsp[(3) - (3)]), 1); }
    break;

  case 45:

/* Line 1806 of yacc.c  */
    { (yyval) = exprstat_new(pstate, (OpCodes*)(yyvsp[(2) - (3)]), code_nop(), 0); }
    break;

  case 46:

/* Line 1806 of yacc.c  */
    {
        OpCodes *catchblock = codes_join3(code_scatch(pstate, (jsi_Pline *)&(yylsp[(5) - (7)]), (const char*)(yyvsp[(5) - (7)])), (OpCodes*)(yyvsp[(7) - (7)]), code_ecatch(pstate, (jsi_Pline *)&(yylsp[(7) - (7)])));
        OpCodes *finallyblock = codes_join(code_sfinal(pstate, (jsi_Pline *)&(yylsp[(5) - (7)])), code_efinal(pstate, (jsi_Pline *)&(yylsp[(5) - (7)])));
        OpCodes *tryblock = codes_join((OpCodes*)(yyvsp[(2) - (7)]), code_etry(pstate, (jsi_Pline *)&(yylsp[(5) - (7)])));
        (yyval) = codes_join4(code_stry(pstate, &(yylsp[(5) - (7)]), tryblock->code_len, catchblock->code_len, finallyblock->code_len),
                            tryblock, catchblock, finallyblock);
    }
    break;

  case 47:

/* Line 1806 of yacc.c  */
    {
        OpCodes *catchblock = codes_join(code_scatch(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), NULL), code_ecatch(pstate, (jsi_Pline *)&(yylsp[(1) - (4)])));
        OpCodes *finallyblock = codes_join3(code_sfinal(pstate, (jsi_Pline *)&(yylsp[(1) - (4)])), (OpCodes*)(yyvsp[(4) - (4)]), code_efinal(pstate, (jsi_Pline *)&(yylsp[(4) - (4)])));
        OpCodes *tryblock = codes_join((OpCodes*)(yyvsp[(2) - (4)]), code_etry(pstate, (jsi_Pline *)&(yylsp[(2) - (4)])));
        (yyval) = codes_join4(code_stry(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), tryblock->code_len, catchblock->code_len, finallyblock->code_len),
                            tryblock, catchblock, finallyblock);
    }
    break;

  case 48:

/* Line 1806 of yacc.c  */
    {
        OpCodes *catchblock = codes_join3(code_scatch(pstate, (jsi_Pline *)&(yylsp[(5) - (9)]), (const char*)(yyvsp[(5) - (9)])), (OpCodes*)(yyvsp[(7) - (9)]), code_ecatch(pstate, (jsi_Pline *)&(yylsp[(7) - (9)])));
        OpCodes *finallyblock = codes_join3(code_sfinal(pstate, (jsi_Pline *)&(yylsp[(1) - (9)])), (OpCodes*)(yyvsp[(9) - (9)]), code_efinal(pstate, (jsi_Pline *)&(yylsp[(1) - (9)])));
        OpCodes *tryblock = codes_join((OpCodes*)(yyvsp[(2) - (9)]), code_etry(pstate, (jsi_Pline *)&(yylsp[(2) - (9)])));
        (yyval) = codes_join4(code_stry(pstate, (jsi_Pline *)&(yylsp[(1) - (9)]), tryblock->code_len, catchblock->code_len, finallyblock->code_len),
                            tryblock, catchblock, finallyblock);
    }
    break;

  case 49:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 50:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)])); }
    break;

  case 51:

/* Line 1806 of yacc.c  */
    {
        OpCodes *ret = codes_join4(code_push_index(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), (char*)(yyvsp[(1) - (1)])),
                            code_push_undef(),
                            code_assign(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), 1),
                            code_pop(1));
        if (!pstate->eval_flag) jsi_PstateAddVar(pstate, (const char*)(yyvsp[(1) - (1)]));
        else ret = codes_join(code_local(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), (const char*)(yyvsp[(1) - (1)])), ret);
        (yyval) = ret;
    }
    break;

  case 52:

/* Line 1806 of yacc.c  */
    {
        OpCodes *ret = codes_join4(code_push_index(pstate, &(yylsp[(1) - (3)]), (char*)(yyvsp[(1) - (3)])),
                            (OpCodes*)(yyvsp[(3) - (3)]),
                            code_assign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), 1),
                            code_pop(1));
        if (!pstate->eval_flag) jsi_PstateAddVar(pstate, (const char*)(yyvsp[(1) - (3)]));
        else ret = codes_join(code_local(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (const char*)(yyvsp[(1) - (3)])), ret);
        (yyval) = ret;
    }
    break;

  case 53:

/* Line 1806 of yacc.c  */
    {
        if (((OpCodes *)(yyvsp[(2) - (3)]))->lvalue_flag == 2) {
            (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (3)]), code_delete(2));
        } else {
            (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (3)]), code_delete(1));
        }
    }
    break;

  case 54:

/* Line 1806 of yacc.c  */
    {
        int offset = ((OpCodes *)(yyvsp[(5) - (5)]))->code_len;
        (yyval) = codes_join3((OpCodes*)(yyvsp[(3) - (5)]), code_jfalse(offset + 1), (OpCodes*)(yyvsp[(5) - (5)]));
    }
    break;

  case 55:

/* Line 1806 of yacc.c  */
    {
        int len_block2 = ((OpCodes *)(yyvsp[(7) - (7)]))->code_len;
        OpCodes *block1 = codes_join((OpCodes*)(yyvsp[(5) - (7)]), code_jmp(len_block2 + 1));
        OpCodes *condi = codes_join((OpCodes*)(yyvsp[(3) - (7)]), code_jfalse(block1->code_len + 1));
        (yyval) = codes_join3(condi, block1, (OpCodes*)(yyvsp[(7) - (7)]));
    }
    break;

  case 56:

/* Line 1806 of yacc.c  */
    {
        OpCodes *init = (OpCodes*)(yyvsp[(4) - (9)]);
        OpCodes *cond = (OpCodes*)(yyvsp[(5) - (9)]);
        OpCodes *step = ((yyvsp[(7) - (9)]) ? codes_join((OpCodes*)(yyvsp[(7) - (9)]), code_pop(1)) : code_nop());
        OpCodes *stat = (OpCodes*)(yyvsp[(9) - (9)]);
        OpCodes *cont_jmp = code_jfalse(step->code_len + stat->code_len + 2);
        OpCodes *step_jmp = code_jmp(-(cond->code_len + step->code_len + stat->code_len + 1));
        code_reserved_replace(stat, step->code_len + 1, 0, (const char*)(yyvsp[(1) - (9)]), 0);
        (yyval) = codes_join(codes_join3(init, cond, cont_jmp),
                           codes_join3(stat, step, step_jmp));
    }
    break;

  case 57:

/* Line 1806 of yacc.c  */
    {
        ForinVar *fv;
        fv = forinvar_new(pstate, (char*)(yyvsp[(5) - (9)]), code_local(pstate, (jsi_Pline *)&(yylsp[(5) - (9)]), (const char*)(yyvsp[(5) - (9)])), NULL);
        OpCodes *lval;
        if (fv->varname) lval = code_push_index(pstate, (jsi_Pline *)&(yylsp[(1) - (9)]), fv->varname);
        else lval = fv->lval;
        
        OpCodes *ret = make_forin(lval, (OpCodes*)(yyvsp[(7) - (9)]), (OpCodes*)(yyvsp[(9) - (9)]), (const char*)(yyvsp[(1) - (9)]));
        if (fv->varname && fv->local) {
            if (!pstate->eval_flag) {
                jsi_PstateAddVar(pstate,fv->varname);
                jsi_FreeOpcodes(fv->local);
            } else ret = codes_join(fv->local, ret);
        }
        Jsi_Free(fv);
        (yyval) = ret;
    }
    break;

  case 58:

/* Line 1806 of yacc.c  */
    {
        ForinVar *fv;
        if (((OpCodes *)(yyvsp[(4) - (8)]))->lvalue_flag == 2) 
            fv = forinvar_new(pstate,NULL, NULL, codes_join((OpCodes*)(yyvsp[(4) - (8)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(4) - (8)]), 0)));
        else fv = forinvar_new(pstate, NULL, NULL, (OpCodes*)(yyvsp[(4) - (8)]));
        OpCodes *lval;
        if (fv->varname) lval = code_push_index(pstate, (jsi_Pline *)&(yylsp[(1) - (8)]), fv->varname);
        else lval = fv->lval;
        
        OpCodes *ret = make_forin(lval, (OpCodes*)(yyvsp[(6) - (8)]), (OpCodes*)(yyvsp[(8) - (8)]), (char*)(yyvsp[(1) - (8)]));
        if (fv->varname && fv->local) {
            if (!pstate->eval_flag) {
                jsi_PstateAddVar(pstate,fv->varname);
                jsi_FreeOpcodes(fv->local);
            } else ret = codes_join(fv->local, ret);
        }
        Jsi_Free(fv);
        (yyval) = ret;
    }
    break;

  case 59:

/* Line 1806 of yacc.c  */
    { (yyval) = code_nop(); }
    break;

  case 60:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (2)]), code_pop(1)); }
    break;

  case 61:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(2) - (3)]); }
    break;

  case 62:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_bool(1); }
    break;

  case 63:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 64:

/* Line 1806 of yacc.c  */
    { (yyval) = NULL; }
    break;

  case 65:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 66:

/* Line 1806 of yacc.c  */
    {
        OpCodes *cond = (OpCodes*)(yyvsp[(4) - (6)]);
        OpCodes *stat = (OpCodes*)(yyvsp[(6) - (6)]);
        code_reserved_replace(stat, 1, 0, (const char*)(yyvsp[(1) - (6)]), 0);
        (yyval) = codes_join4(cond, code_jfalse(stat->code_len + 2), stat,
                           code_jmp(-(stat->code_len + cond->code_len + 1)));
    }
    break;

  case 67:

/* Line 1806 of yacc.c  */
    {
        OpCodes *stat = (OpCodes*)(yyvsp[(3) - (7)]);
        OpCodes *cond = (OpCodes*)(yyvsp[(6) - (7)]);
        code_reserved_replace(stat, cond->code_len + 1, 0, (const char*)(yyvsp[(1) - (7)]), 0);
        (yyval) = codes_join3(stat, cond,
                            code_jtrue(-(stat->code_len + cond->code_len)));
    }
    break;

  case 68:

/* Line 1806 of yacc.c  */
    {
        (yyval) = code_push_func(pstate,  (jsi_Pline *)&(yylsp[(3) - (5)]), jsi_FuncMake(pstate, (Jsi_ScopeStrs*)(yyvsp[(3) - (5)]), (OpCodes*)(yyvsp[(5) - (5)]), (jsi_Pline *)&(yylsp[(5) - (5)]), NULL));
        jsi_PstatePop(pstate);
    }
    break;

  case 69:

/* Line 1806 of yacc.c  */
    {
        (yyval) = code_push_func(pstate,  (jsi_Pline *)&(yylsp[(3) - (7)]), jsi_FuncMake(pstate, (Jsi_ScopeStrs*)(yyvsp[(3) - (7)]), (OpCodes*)(yyvsp[(7) - (7)]), (jsi_Pline *)&(yylsp[(7) - (7)]), NULL));
        jsi_PstatePop(pstate);
    }
    break;

  case 70:

/* Line 1806 of yacc.c  */
    {
        (yyval) = code_push_func(pstate, (jsi_Pline *)&(yylsp[(3) - (6)]), jsi_FuncMake(pstate, (Jsi_ScopeStrs*)(yyvsp[(4) - (6)]), (OpCodes*)(yyvsp[(6) - (6)]), (jsi_Pline *)&(yylsp[(6) - (6)]), (char*)(yyvsp[(2) - (6)])));
        jsi_PstatePop(pstate);
    }
    break;

  case 71:

/* Line 1806 of yacc.c  */
    {
        (yyval) = code_push_func(pstate, (jsi_Pline *)&(yylsp[(3) - (8)]), jsi_FuncMake(pstate, (Jsi_ScopeStrs*)(yyvsp[(4) - (8)]), (OpCodes*)(yyvsp[(8) - (8)]), (jsi_Pline *)&(yylsp[(8) - (8)]), (char*)(yyvsp[(2) - (8)])));
        jsi_PstatePop(pstate);
    }
    break;

  case 72:

/* Line 1806 of yacc.c  */
    { jsi_PstatePush(pstate); (yyval) = jsi_ScopeStrsNew(pstate); }
    break;

  case 73:

/* Line 1806 of yacc.c  */
    {
        (yyval) = jsi_ArgsOptAdd(pstate, (Jsi_ScopeStrs*)(yyvsp[(1) - (1)]));
    }
    break;

  case 74:

/* Line 1806 of yacc.c  */
    {
        Jsi_ScopeStrs *s = jsi_ArgsOptAdd(pstate, (Jsi_ScopeStrs*)(yyvsp[(1) - (5)]));
        s->varargs = 1;
        (yyval) = s;
    }
    break;

  case 75:

/* Line 1806 of yacc.c  */
    {    (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_STRING; }
    break;

  case 76:

/* Line 1806 of yacc.c  */
    {  (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_NUMBER; }
    break;

  case 77:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_BOOL; }
    break;

  case 78:

/* Line 1806 of yacc.c  */
    {  (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_REGEXP; }
    break;

  case 79:

/* Line 1806 of yacc.c  */
    {  (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_OBJECT; }
    break;

  case 80:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_USEROBJ; }
    break;

  case 81:

/* Line 1806 of yacc.c  */
    {     (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_ANY; }
    break;

  case 82:

/* Line 1806 of yacc.c  */
    {   (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_ARRAY; }
    break;

  case 83:

/* Line 1806 of yacc.c  */
    {        (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_FUNCTION; }
    break;

  case 84:

/* Line 1806 of yacc.c  */
    {        (yyval) = (yyvsp[(1) - (1)]); pstate->argType |= JSI_TT_VOID; }
    break;

  case 85:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 86:

/* Line 1806 of yacc.c  */
    {
        (yyval) = (yyvsp[(1) - (3)]);
    }
    break;

  case 87:

/* Line 1806 of yacc.c  */
    {      (yyval) = Jsi_ValueNew(pstate->interp); }
    break;

  case 88:

/* Line 1806 of yacc.c  */
    { (yyval) = Jsi_ValueNewNumber(pstate->interp, *(Jsi_Number*)(yyvsp[(1) - (1)])); }
    break;

  case 89:

/* Line 1806 of yacc.c  */
    {   (yyval) = Jsi_ValueNewBoolean(pstate->interp, 1); }
    break;

  case 90:

/* Line 1806 of yacc.c  */
    {  (yyval) = Jsi_ValueNewBoolean(pstate->interp, 0); }
    break;

  case 91:

/* Line 1806 of yacc.c  */
    {(yyval) = Jsi_ValueNewNull(pstate->interp); }
    break;

  case 92:

/* Line 1806 of yacc.c  */
    {  (yyval) = Jsi_ValueNewStringKey(pstate->interp, (char*)(yyvsp[(1) - (1)])); }
    break;

  case 93:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, NULL, (const char*)(yyvsp[(1) - (1)]), NULL); }
    break;

  case 94:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, NULL, (const char*)(yyvsp[(1) - (3)]), (Jsi_Value*)(yyvsp[(3) - (3)])); }
    break;

  case 95:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, NULL, (const char*)(yyvsp[(1) - (3)]), NULL);}
    break;

  case 96:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, NULL, (const char*)(yyvsp[(1) - (5)]), (Jsi_Value*)(yyvsp[(5) - (5)]));}
    break;

  case 97:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, (Jsi_ScopeStrs*)(yyvsp[(1) - (3)]), (const char*)(yyvsp[(3) - (3)]), NULL); }
    break;

  case 98:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, (Jsi_ScopeStrs*)(yyvsp[(1) - (5)]), (const char*)(yyvsp[(3) - (5)]), (Jsi_Value*)(yyvsp[(5) - (5)])); }
    break;

  case 99:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, (Jsi_ScopeStrs*)(yyvsp[(1) - (5)]), (const char*)(yyvsp[(3) - (5)]), NULL);}
    break;

  case 100:

/* Line 1806 of yacc.c  */
    { (yyval) = jsi_argInsert(pstate, (Jsi_ScopeStrs*)(yyvsp[(1) - (7)]), (const char*)(yyvsp[(3) - (7)]), (Jsi_Value*)(yyvsp[(7) - (7)]));}
    break;

  case 101:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(2) - (3)]); }
    break;

  case 102:

/* Line 1806 of yacc.c  */
    { (yyval) = code_nop(); }
    break;

  case 103:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 104:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 105:

/* Line 1806 of yacc.c  */
    { 
        if (((OpCodes *)(yyvsp[(1) - (1)]))->lvalue_flag == 2) (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (1)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), 1)); 
        else (yyval) = (yyvsp[(1) - (1)]);
    }
    break;

  case 106:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), code_pop(1), (OpCodes*)(yyvsp[(3) - (3)])); }
    break;

  case 107:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (4)]), (OpCodes*)(yyvsp[(3) - (4)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), 1)); }
    break;

  case 108:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), code_push_string(pstate,(jsi_Pline *)&(yylsp[(3) - (3)]),(const char*)(yyvsp[(3) - (3)])), code_subscript(pstate, (jsi_Pline *)&(yylsp[(3) - (3)]), 1)); }
    break;

  case 109:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_neg()); }
    break;

  case 110:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_pos()); }
    break;

  case 111:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_bnot()); }
    break;

  case 112:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_not()); }
    break;

  case 113:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (2)]), code_pop(1), code_push_undef()); }
    break;

  case 114:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_mul()); }
    break;

  case 115:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_div()); }
    break;

  case 116:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_mod()); }
    break;

  case 117:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_add()); }
    break;

  case 118:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_sub()); }
    break;

  case 119:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_in()); }
    break;

  case 120:

/* Line 1806 of yacc.c  */
    {
        if (((OpCodes *)(yyvsp[(1) - (2)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (2)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 0), code_inc(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 1));
        else (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (2)]), code_inc(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 1));
    }
    break;

  case 121:

/* Line 1806 of yacc.c  */
    { 
        if (((OpCodes *)(yyvsp[(1) - (2)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (2)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 0), code_dec(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 1));
        else (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (2)]), code_dec(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 1)); 
    }
    break;

  case 122:

/* Line 1806 of yacc.c  */
    {
        if (((OpCodes *)(yyvsp[(2) - (2)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (2)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0), code_inc(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0));
        else (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_inc(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0));
    }
    break;

  case 123:

/* Line 1806 of yacc.c  */
    {
        if (((OpCodes *)(yyvsp[(2) - (2)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (2)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0), code_typeof(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0));
        else (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_typeof(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0));
    }
    break;

  case 124:

/* Line 1806 of yacc.c  */
    { 
        if (((OpCodes *)(yyvsp[(2) - (2)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (2)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0), code_dec(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0));
        else (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_dec(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0));
    }
    break;

  case 125:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(2) - (3)]); }
    break;

  case 126:

/* Line 1806 of yacc.c  */
    {
        OpCodes *expr2 = codes_join(code_pop(1), (OpCodes*)(yyvsp[(3) - (3)]));
        (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), code_jfalse_np(expr2->code_len + 1), expr2);
    }
    break;

  case 127:

/* Line 1806 of yacc.c  */
    {
        OpCodes *expr2 = codes_join(code_pop(1), (OpCodes*)(yyvsp[(3) - (3)]));
        (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), code_jtrue_np(expr2->code_len + 1), expr2);
    }
    break;

  case 128:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_less()); }
    break;

  case 129:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_greater()); }
    break;

  case 130:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_lessequ()); }
    break;

  case 131:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_greaterequ()); }
    break;

  case 132:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_equal()); }
    break;

  case 133:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_notequal()); }
    break;

  case 134:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_eequ());    }
    break;

  case 135:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_nneq()); }
    break;

  case 136:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_band()); }
    break;

  case 137:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_bor()); }
    break;

  case 138:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_bxor()); }
    break;

  case 139:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_shf(0)); }
    break;

  case 140:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_shf(1)); }
    break;

  case 141:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_shf(2)); }
    break;

  case 142:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_assign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), ((OpCodes *)(yyvsp[(1) - (3)]))->lvalue_flag)); }
    break;

  case 143:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_add()); }
    break;

  case 144:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_sub()); }
    break;

  case 145:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_mul()); }
    break;

  case 146:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_mod()); }
    break;

  case 147:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_shf(0)); }
    break;

  case 148:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_shf(1)); }
    break;

  case 149:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_shf(2)); }
    break;

  case 150:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_band()); }
    break;

  case 151:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_bor()); }
    break;

  case 152:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_bxor()); }
    break;

  case 153:

/* Line 1806 of yacc.c  */
    { (yyval) = opassign(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), (OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_div()); }
    break;

  case 154:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]), code_instanceof()); }
    break;

  case 155:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 156:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0, NULL)); }
    break;

  case 157:

/* Line 1806 of yacc.c  */
    { 
        if (((OpCodes *)(yyvsp[(2) - (2)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (2)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 1), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0, NULL));
        else (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]), 0, NULL));}
    break;

  case 158:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(3) - (4)]), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(3) - (4)]),0, NULL)); }
    break;

  case 159:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (2)]), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(2) - (2)]),0, NULL)); }
    break;

  case 160:

/* Line 1806 of yacc.c  */
    {
        OpCodes *lval = (OpCodes*)(yyvsp[(1) - (5)]);
        OpCodes *opl = (OpCodes*)(yyvsp[(4) - (5)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (5)]), (opl ? opl : code_nop()), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(2) - (5)]), expr_cnt, lval->lvalue_name));
    }
    break;

  case 161:

/* Line 1806 of yacc.c  */
    {
        OpCodes *opl = (OpCodes*)(yyvsp[(4) - (5)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        OpCodes *lv = NULL;
        if (((OpCodes *)(yyvsp[(2) - (5)]))->lvalue_flag == 2) lv = codes_join((OpCodes*)(yyvsp[(2) - (5)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(2) - (5)]), 1));
        else lv = (OpCodes *)(yyvsp[(2) - (5)]);
        (yyval) = codes_join3(lv, (opl ? opl : code_nop()), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(1) - (5)]),expr_cnt, lv?lv->lvalue_name:NULL));
    }
    break;

  case 162:

/* Line 1806 of yacc.c  */
    { 
        OpCodes *opl = (OpCodes *)(yyvsp[(6) - (7)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval) = codes_join3((OpCodes*)(yyvsp[(3) - (7)]), (opl ? opl : code_nop()), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(1) - (7)]),expr_cnt, NULL));
    }
    break;

  case 163:

/* Line 1806 of yacc.c  */
    {
        OpCodes *opl = (OpCodes*)(yyvsp[(4) - (5)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval) = codes_join3((OpCodes*)(yyvsp[(2) - (5)]), (opl ? opl : code_nop()), code_newfcall(pstate, (jsi_Pline *)&(yylsp[(2) - (5)]),expr_cnt, NULL));
    }
    break;

  case 164:

/* Line 1806 of yacc.c  */
    {
        OpCodes *expr2 = codes_join((OpCodes*)(yyvsp[(3) - (5)]), code_jmp(((OpCodes *)(yyvsp[(5) - (5)]))->code_len + 1));
        (yyval) = codes_join4((OpCodes*)(yyvsp[(1) - (5)]), code_jfalse(expr2->code_len + 1), expr2, (OpCodes*)(yyvsp[(5) - (5)]));
    }
    break;

  case 165:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(3) - (4)]), code_debug(pstate,(jsi_Pline *)&(yylsp[(3) - (4)]))); }
    break;

  case 166:

/* Line 1806 of yacc.c  */
    {
        OpCodes *lval = (OpCodes*)(yyvsp[(1) - (6)]);
        OpCodes *lval2 = (OpCodes*)(yyvsp[(3) - (6)]);
        OpCodes *ff = codes_join4((OpCodes*)(yyvsp[(1) - (6)]), code_push_string(pstate,(jsi_Pline *)&(yylsp[(3) - (6)]), (const char*)(yyvsp[(3) - (6)])), code_chthis(1), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (6)]), 1));
        OpCodes *opl = (OpCodes*)(yyvsp[(5) - (6)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval) = codes_join3(ff, (opl ? opl : code_nop()), code_fcall(pstate, (jsi_Pline *)&(yylsp[(3) - (6)]), expr_cnt, lval->lvalue_name, lval2->lvalue_name));
    }
    break;

  case 167:

/* Line 1806 of yacc.c  */
    {
        OpCodes *ff = codes_join4((OpCodes*)(yyvsp[(1) - (7)]), (OpCodes*)(yyvsp[(3) - (7)]), code_chthis(1), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (7)]), 1));
        OpCodes *opl = (OpCodes*)(yyvsp[(6) - (7)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval) = codes_join3(ff, (opl ? opl : code_nop()), code_fcall(pstate, (jsi_Pline *)&(yylsp[(3) - (7)]), expr_cnt, NULL, NULL));
    }
    break;

  case 168:

/* Line 1806 of yacc.c  */
    {
        OpCodes *opl = (OpCodes*)(yyvsp[(5) - (6)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        (yyval) = codes_join4((OpCodes*)(yyvsp[(2) - (6)]), code_chthis(0), (opl ? opl : code_nop()), code_fcall(pstate, (jsi_Pline *)&(yylsp[(3) - (6)]),expr_cnt, NULL, NULL));
    }
    break;

  case 169:

/* Line 1806 of yacc.c  */
    {
        OpCodes *opl = (OpCodes*)(yyvsp[(3) - (4)]);
        int expr_cnt = opl ? opl->expr_counter:0;
        OpCodes *pref;
        OpCodes *lval = (OpCodes*)(yyvsp[(1) - (4)]);
        if (lval->lvalue_flag == 2) {
            pref = codes_join3((OpCodes*)(yyvsp[(1) - (4)]), code_chthis(1), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), 1));
            const char *n1 = lval->lvalue_name, *n2 = NULL;
            if (pref->code_len>=2 && pref->codes[0].op == OP_PUSHVAR && pref->codes[1].op == OP_PUSHSTR && !n1) {
                FastVar *fv = (FastVar*)pref->codes[0].data;
                n2 = fv->var.varname;
                n1 = (char*)pref->codes[1].data;
            }
            (yyval) = codes_join3(pref, (opl ? opl : code_nop()), code_fcall(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), expr_cnt, n1, n2));
        } else {
            if (lval->lvalue_name && Jsi_Strcmp(lval->lvalue_name, "eval") == 0) {
                (yyval) = codes_join((opl ? opl : code_nop()), code_eval(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), expr_cnt, lval));
            } else {
                pref = codes_join((OpCodes*)(yyvsp[(1) - (4)]), code_chthis(0));
                (yyval) = codes_join3(pref, (opl ? opl : code_nop()), code_fcall(pstate, (jsi_Pline *)&(yylsp[(3) - (4)]), expr_cnt, lval->lvalue_name, NULL));
            }
        }
    }
    break;

  case 170:

/* Line 1806 of yacc.c  */
    {
        OpCodes *lval = code_push_index(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), (char*)(yyvsp[(1) - (1)])); 
        (yyval) = lval;
        lval->lvalue_flag = 1; 
        lval->lvalue_name = (char*)(yyvsp[(1) - (1)]); 
    }
    break;

  case 171:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_args(); ((OpCodes *)(yyval))->lvalue_flag = 1; }
    break;

  case 172:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_this(pstate,(jsi_Pline *)&(yylsp[(1) - (1)])); ((OpCodes *)(yyval))->lvalue_flag = 1; }
    break;

  case 173:

/* Line 1806 of yacc.c  */
    {
        if (((OpCodes *)(yyvsp[(1) - (4)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes*)(yyvsp[(1) - (4)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (4)]), 1), (OpCodes *)(yyvsp[(3) - (4)])); 
        else (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (4)]), (OpCodes*)(yyvsp[(3) - (4)])); 
        ((OpCodes *)(yyval))->lvalue_flag = 2;
    }
    break;

  case 174:

/* Line 1806 of yacc.c  */
    {
        if (((OpCodes *)(yyvsp[(1) - (3)]))->lvalue_flag == 2) (yyval) = codes_join3((OpCodes *)(yyvsp[(1) - (3)]), code_subscript(pstate, (jsi_Pline *)&(yylsp[(1) - (3)]), 1), code_push_string(pstate,(jsi_Pline *)&(yylsp[(3) - (3)]),(char *)(yyvsp[(3) - (3)]))); 
        else (yyval) = codes_join((OpCodes *)(yyvsp[(1) - (3)]), code_push_string(pstate,(jsi_Pline *)&(yylsp[(3) - (3)]),(char *)(yyvsp[(3) - (3)])));
        ((OpCodes *)(yyval))->lvalue_flag = 2;
    }
    break;

  case 175:

/* Line 1806 of yacc.c  */
    { (yyval) = NULL; }
    break;

  case 176:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 177:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); ((OpCodes *)(yyval))->expr_counter = 1; }
    break;

  case 178:

/* Line 1806 of yacc.c  */
    { 
        int exprcnt = ((OpCodes *)(yyvsp[(1) - (3)]))->expr_counter + 1;
        (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]));
        ((OpCodes *)(yyval))->expr_counter = exprcnt;
    }
    break;

  case 179:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_string(pstate,(jsi_Pline *)&(yylsp[(1) - (1)]), (char*)(yyvsp[(1) - (1)])); }
    break;

  case 180:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_undef(); }
    break;

  case 181:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_bool(1); }
    break;

  case 182:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_bool(0); }
    break;

  case 183:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_num((Jsi_Number*)(yyvsp[(1) - (1)])); }
    break;

  case 184:

/* Line 1806 of yacc.c  */
    { (yyval) = code_push_regex(pstate, (jsi_Pline *)&(yylsp[(1) - (1)]), (Jsi_Regex*)(yyvsp[(1) - (1)])); }
    break;

  case 185:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 186:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 187:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes *)(yyvsp[(2) - (3)]), code_object(pstate, (jsi_Pline *)&(yylsp[(2) - (3)]), ((OpCodes *)(yyvsp[(2) - (3)]))->expr_counter)); }
    break;

  case 188:

/* Line 1806 of yacc.c  */
    { (yyval) = code_nop(); ((OpCodes *)(yyval))->expr_counter = 0; }
    break;

  case 189:

/* Line 1806 of yacc.c  */
    { (yyval) = (yyvsp[(1) - (1)]); ((OpCodes *)(yyval))->expr_counter = 1; }
    break;

  case 190:

/* Line 1806 of yacc.c  */
    {
        int cnt = ((OpCodes *)(yyvsp[(1) - (3)]))->expr_counter + 1;
        (yyval) = codes_join((OpCodes*)(yyvsp[(1) - (3)]), (OpCodes*)(yyvsp[(3) - (3)]));
        ((OpCodes *)(yyval))->expr_counter = cnt;
    }
    break;

  case 191:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join(code_push_string(pstate,(jsi_Pline *)&(yylsp[(1) - (3)]), (const char*)(yyvsp[(1) - (3)])), (OpCodes*)(yyvsp[(3) - (3)])); }
    break;

  case 192:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join(code_push_string(pstate,(jsi_Pline *)&(yylsp[(1) - (3)]), (const char*)(yyvsp[(1) - (3)])), (OpCodes*)(yyvsp[(3) - (3)])); }
    break;

  case 193:

/* Line 1806 of yacc.c  */
    { (yyval) = codes_join((OpCodes*)(yyvsp[(2) - (3)]), code_array(pstate, (jsi_Pline *)&(yylsp[(2) - (3)]), ((OpCodes *)(yyvsp[(2) - (3)]))->expr_counter)); }
    break;

  case 194:

/* Line 1806 of yacc.c  */
    { (yyval) = code_array(pstate, (jsi_Pline *)&(yylsp[(1) - (2)]), 0); }
    break;



/* Line 1806 of yacc.c  */
      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;
  *++yylsp = yyloc;

  /* Now `shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*------------------------------------.
| yyerrlab -- here on detecting error |
`------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (&yylloc, pstate, YY_("syntax error"));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_("syntax error");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (&yylloc, pstate, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }

  yyerror_range[1] = yylloc;

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
	 error, discard it.  */

      if (yychar <= YYEOF)
	{
	  /* Return failure if at end of input.  */
	  if (yychar == YYEOF)
	    YYABORT;
	}
      else
	{
	  yydestruct ("Error: discarding",
		      yytoken, &yylval, &yylloc, pstate);
	  yychar = YYEMPTY;
	}
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  yyerror_range[1] = yylsp[1-yylen];
  /* Do not reclaim the symbols of the rule which action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;	/* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
	{
	  yyn += YYTERROR;
	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
	    {
	      yyn = yytable[yyn];
	      if (0 < yyn)
		break;
	    }
	}

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
	YYABORT;

      yyerror_range[1] = *yylsp;
      yydestruct ("Error: popping",
		  yystos[yystate], yyvsp, yylsp, pstate);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  *++yyvsp = yylval;

  yyerror_range[2] = yylloc;
  /* Using YYLLOC is tempting, but would change the location of
     the lookahead.  YYLOC is available though.  */
  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
  *++yylsp = yyloc;

  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined(yyoverflow) || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (&yylloc, pstate, YY_("memory exhausted"));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval, &yylloc, pstate);
    }
  /* Do not reclaim the symbols of the rule which action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
		  yystos[*yyssp], yyvsp, yylsp, pstate);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  /* Make sure YYID is used.  */
  return YYID (yyresult);
}



/* Line 2067 of yacc.c  */



#endif
#ifdef __WIN32
#ifndef JSI_AMALGAMATION
#include "../jsiInt.h"
#endif

#ifndef STRICT
#define STRICT
#endif
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

#define HAVE_DLOPEN_COMPAT
#if defined(HAVE_DLOPEN_COMPAT)
void *dlopen(const char *path, int mode)
{
    mode=mode;

    return (void *)LoadLibraryA(path);
}

int dlclose(void *handle)
{
    FreeLibrary((HANDLE)handle);
    return 0;
}

void *dlsym(void *handle, const char *symbol)
{
    return GetProcAddress((HMODULE)handle, symbol);
}

char *dlerror(void)
{
    static char msg[121];
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                   LANG_NEUTRAL, msg, sizeof(msg) - 1, NULL);
    return msg;
}
#endif

#ifdef _MSC_VER

#include <sys/timeb.h>

/* POSIX gettimeofday() compatibility for WIN32 */
int gettimeofday(struct timeval *tv, void *unused)
{
    struct _timeb tb;

    _ftime(&tb);
    tv->tv_sec = tb.time;
    tv->tv_usec = tb.millitm * 1000;

    return 0;
}

/* Posix dirent.h compatiblity layer for WIN32.
 * Copyright Kevlin Henney, 1997, 2003. All rights reserved.
 * Copyright Salvatore Sanfilippo ,2005.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose is hereby granted without fee, provided
 * that this copyright and permissions notice appear in all copies and
 * derivatives.
 *
 * This software is supplied "as is" without express or implied warranty.
 * This software was modified by Salvatore Sanfilippo for the Jsi Interpreter.
 */

DIR *opendir(const char *name)
{
    DIR *dir = 0;

    if (name && name[0]) {
        size_t base_length = strlen(name);
        const char *all =       /* search pattern must end with suitable wildcard */
            strchr("/\\", name[base_length - 1]) ? "*" : "/*";

        if ((dir = (DIR *) malloc(sizeof *dir)) != 0 &&
            (dir->name = (char *)malloc(base_length + strlen(all) + 1)) != 0) {
            strcat(strcpy(dir->name, name), all);

            if ((dir->handle = (long)_findfirst(dir->name, &dir->info)) != -1)
                dir->result.d_name = 0;
            else {              /* rollback */
                free(dir->name);
                free(dir);
                dir = 0;
            }
        }
        else {                  /* rollback */
            free(dir);
            dir = 0;
            errno = ENOMEM;
        }
    }
    else {
        errno = EINVAL;
    }
    return dir;
}

int closedir(DIR * dir)
{
    int result = -1;

    if (dir) {
        if (dir->handle != -1)
            result = _findclose(dir->handle);
        free(dir->name);
        free(dir);
    }
    if (result == -1)           /* map all errors to EBADF */
        errno = EBADF;
    return result;
}

struct dirent *readdir(DIR * dir)
{
    struct dirent *result = 0;

    if (dir && dir->handle != -1) {
        if (!dir->result.d_name || _findnext(dir->handle, &dir->info) != -1) {
            result = &dir->result;
            result->d_name = dir->info.name;
        }
    }
    else {
        errno = EBADF;
    }
    return result;
}

#endif

int scandir(const char *dirname,
            struct dirent ***namelist,
            int (*doselect)(const struct dirent *),
            int (*compar)(const struct dirent **,
                          const struct dirent **))
{
    WIN32_FIND_DATA wfd;
    HANDLE hf;
    struct dirent **plist, **newlist;
    struct dirent d;
    int numentries = 0;
    int allocentries = 255;
    int i;
    char path[FILENAME_MAX];
    i = strlen(dirname);
    if (i > sizeof path - 5)
        return -1;
    strcpy(path, dirname);
    if (i>0 && dirname[i-1]!='\\' && dirname[i-1]!='/')
        strcat(path, "\\");
    strcat(path, "*.*");
    hf = FindFirstFile(path, &wfd);
    if (hf == INVALID_HANDLE_VALUE)
        return -1;
    plist = malloc(sizeof *plist * allocentries);
    if (plist==NULL)
    {
        FindClose(hf);
        return -1;
    }
    do
    {
        if (numentries==allocentries)
        {
            allocentries *= 2;
            newlist = realloc(plist, sizeof *plist * allocentries);
            if (newlist==NULL)
            {
                for (i=0; i<numentries; i++)
                    free(plist[i]);
                free(plist);
                FindClose(hf);
                return -1;
            }
            plist = newlist;
        }
        strncpy(d.d_name, wfd.cFileName, sizeof d.d_name);
        /* HACK. if is directory, set inode to 1. */
        d.d_ino =( (wfd.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)?1:0);
        d.d_namlen = strlen(wfd.cFileName);
        d.d_reclen = sizeof d;
        if (doselect==NULL || doselect(&d))
        {
            plist[numentries] = malloc(sizeof d);
            if (plist[numentries]==NULL)
            {
                for (i=0; i<numentries; i++)
                    free(plist[i]);
                free(plist);
                FindClose(hf);
                return -1;
            };
            memcpy(plist[numentries], &d, sizeof d);
            numentries++;
        }
    }
    while (FindNextFile(hf, &wfd));
    FindClose(hf);
    if (numentries==0)
    {
        free(plist);
        *namelist = NULL;
    }
    else
    {
        newlist = realloc(plist, sizeof *plist * numentries);
        if (newlist!=NULL)
            plist = newlist;
        if (compar!=NULL)
            qsort(plist, numentries, sizeof *plist, (void*)compar);
        *namelist = plist;
    }
    return numentries;
}

int istrcmp(const char *s1, const char *s2)
{
    int d;
    for (;;)
    {
        d = tolower(*s1) - tolower(*s2);
        if (d!=0 || *s1=='\0' || *s2=='\0')
            return d;
        s1++;
        s2++;
    }
}

int alphasort(const struct dirent **d1,
              const struct dirent **d2)
{
    return istrcmp((*d1)->d_name, (*d2)->d_name);
}
#endif
/*
 * regcomp and regexec -- regsub and regerror are elsewhere
 *
 *  Copyright (c) 1986 by University of Toronto.
 *  Written by Henry Spencer.  Not derived from licensed software.
 *
 *  Permission is granted to anyone to use this software for any
 *  purpose on any computer system, and to redistribute it freely,
 *  subject to the following restrictions:
 *
 *  1. The author is not responsible for the consequences of use of
 *      this software, no matter how awful, even if they arise
 *      from defects in it.
 *
 *  2. The origin of this software must not be misrepresented, either
 *      by explicit claim or by omission.
 *
 *  3. Altered versions must be plainly marked as such, and must not
 *      be misrepresented as being the original software.
 *** THIS IS AN ALTERED VERSION.  It was altered by John Gilmore,
 *** hoptoad!gnu, on 27 Dec 1986, to add \n as an alternative to |
 *** to assist in implementing egrep.
 *** THIS IS AN ALTERED VERSION.  It was altered by John Gilmore,
 *** hoptoad!gnu, on 27 Dec 1986, to add \< and \> for word-matching
 *** as in BSD grep and ex.
 *** THIS IS AN ALTERED VERSION.  It was altered by John Gilmore,
 *** hoptoad!gnu, on 28 Dec 1986, to optimize characters quoted with \.
 *** THIS IS AN ALTERED VERSION.  It was altered by James A. Woods,
 *** ames!jaw, on 19 June 1987, to quash a regcomp() redundancy.
 *** THIS IS AN ALTERED VERSION.  It was altered by Christopher Seiwald
 *** seiwald@vix.com, on 28 August 1993, for use in jam.  Regmagic.h
 *** was moved into regexp.h, and the include of regexp.h now uses "'s
 *** to avoid conflicting with the system regexp.h.  Const, bless its
 *** soul, was removed so it can compile everywhere.  The declaration
 *** of strchr() was in conflict on AIX, so it was removed (as it is
 *** happily defined in string.h).
 *** THIS IS AN ALTERED VERSION.  It was altered by Christopher Seiwald
 *** seiwald@perforce.com, on 20 January 2000, to use function prototypes.
 *** THIS IS AN ALTERED VERSION.  It was altered by Christopher Seiwald
 *** seiwald@perforce.com, on 05 November 2002, to const string literals.
 *
 *   THIS IS AN ALTERED VERSION.  It was altered by Steve Bennett <steveb@workware.net.au>
 *   on 16 October 2010, to remove static state and add better Tcl ARE compatibility.
 *   This includes counted repetitions, UTF-8 support, character classes,
 *   shorthand character classes, increased number of parentheses to 100,
 *   backslash escape sequences. It also removes \n as an alternative to |.
 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 */
#ifdef __WIN32

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#ifndef JSI_AMALGAMATION
#include "../jsiInt.h"
#include "../jsiUtf8.h"
#include "regex.h"
#endif


#if !defined(HAVE_REGCOMP) || defined(JSI_REGEXP)

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are:
 */

/* This *MUST* be less than (255-20-1)/2=117 */
#define REG_MAX_PAREN 100

/* definition   number  opnd?   meaning */
#define END 0   /* no   End of program. */
#define BOL 1   /* no   Match "" at beginning of line. */
#define EOL 2   /* no   Match "" at end of line. */
#define ANY 3   /* no   Match any one character. */
#define ANYOF   4   /* str  Match any character in this string. */
#define ANYBUT  5   /* str  Match any character not in this string. */
#define BRANCH  6   /* node Match this alternative, or the next... */
#define BACK    7   /* no   Match "", "next" ptr points backward. */
#define EXACTLY 8   /* str  Match this string. */
#define NOTHING 9   /* no   Match empty string. */
#define REP     10  /* max,min  Match this (simple) thing [min,max] times. */
#define REPMIN  11  /* max,min  Match this (simple) thing [min,max] times, mininal match. */
#define REPX    12  /* max,min  Match this (complex) thing [min,max] times. */
#define REPXMIN 13  /* max,min  Match this (complex) thing [min,max] times, minimal match. */

#define WORDA   15  /* no   Match "" at wordchar, where prev is nonword */
#define WORDZ   16  /* no   Match "" at nonwordchar, where prev is word */
#define OPENNC  19  /* no   Non-capturing parentheses - must be OPEN-1 */
#define OPEN    20  /* no   Mark this point in input as start of #n. */
            /*  OPEN+1 is number 1, etc. */
#define CLOSE   (OPEN+REG_MAX_PAREN+1)  /* no   Analogous to OPEN. */
#define CLOSE_END   (CLOSE+REG_MAX_PAREN)
#define CLOSENC (CLOSE-1)   /* no   Non-capturing parentheses - must be CLOSE-1 */

/*
 * The first byte of the regexp internal "program" is actually this magic
 * number; the start node begins in the second byte.
 */
#define REG_MAGIC   0xFADED00D

/*
 * Opcode notes:
 *
 * BRANCH   The set of branches constituting a single choice are hooked
 *      together with their "next" pointers, since precedence prevents
 *      anything being concatenated to any individual branch.  The
 *      "next" pointer of the last BRANCH in a choice points to the
 *      thing following the whole choice.  This is also where the
 *      final "next" pointer of each individual branch points; each
 *      branch starts with the operand node of a BRANCH node.
 *
 * BACK     Normal "next" pointers all implicitly point forward; BACK
 *      exists to make loop structures possible.
 *
 * STAR,PLUS    '?', and complex '*' and '+', are implemented as circular
 *      BRANCH structures using BACK.  Simple cases (one character
 *      per match) are implemented with STAR and PLUS for speed
 *      and to minimize recursive plunges.
 *
 * OPEN,CLOSE   ...are numbered at compile time.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 */
#define OP(preg, p) (preg->program[p])
#define NEXT(preg, p)   (preg->program[p + 1])
#define OPERAND(p)  ((p) + 2)

/*
 * See regmagic.h for one further detail of program structure.
 */


/*
 * Utility definitions.
 */

#define FAIL(R,M)   { (R)->err = (M); return (M); }
#define ISMULT(c)   ((c) == '*' || (c) == '+' || (c) == '?' || (c) == '{')
#define META    "^$.[()|?{+*"

/*
 * Flags to be passed up and down.
 */
#define HASWIDTH    01  /* Known never to match null string. */
#define SIMPLE      02  /* Simple enough to be STAR/PLUS operand. */
#define SPSTART     04  /* Starts with * or +. */
#define WORST       0   /* Worst case. */

#define MAX_REP_COUNT 1000000

/*
 * Forward declarations for regcomp()'s friends.
 */
static int reg(regex_t *preg, int paren /* Parenthesized? */, int *flagp );
static int regpiece(regex_t *preg, int *flagp );
static int regbranch(regex_t *preg, int *flagp );
static int regatom(regex_t *preg, int *flagp );
static int regnode(regex_t *preg, int op );
static int regnext(regex_t *preg, int p );
static void regc(regex_t *preg, int b );
static int reginsert(regex_t *preg, int op, int size, int opnd );
static void regtail_(regex_t *preg, int p, int val, int line );
static void regoptail(regex_t *preg, int p, int val );
#define regtail(PREG, P, VAL) regtail_(PREG, P, VAL, __LINE__)

static int reg_range_find(const int *string, int c);
static const char *str_find(const char *string, int c, int nocase);
static int prefix_cmp(const int *prog, int proglen, const char *string, int nocase);

/*#define DEBUG*/
#ifdef DEBUG
static int regnarrate = 0;
static void regdump(regex_t *preg);
static const char *regprop( int op );
#endif


/**
 * Returns the length of the null-terminated integer sequence.
 */
static int str_int_len(const int *seq)
{
    int n = 0;
    while (*seq++) {
        n++;
    }
    return n;
}

/*
 - regcomp - compile a regular expression into internal code
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.)
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.
 */
int regcomp(regex_t *preg, const char *exp, int cflags)
{
    int scan;
    int longest;
    unsigned len;
    int flags;

#ifdef DEBUG
    fprintf(stderr, "Compiling: '%s'\n", exp);
#endif
    memset(preg, 0, sizeof(*preg));

    if (exp == NULL)
        FAIL(preg, REG_ERR_NULL_ARGUMENT);

    /* First pass: determine size, legality. */
    preg->cflags = cflags;
    preg->regparse = exp;
    /* XXX: For now, start unallocated */
    preg->program = NULL;
    preg->proglen = 0;

    /* Allocate space. */
    preg->proglen = (strlen(exp) + 1) * 5;
    preg->program = malloc(preg->proglen * sizeof(int));
    if (preg->program == NULL)
        FAIL(preg, REG_ERR_NOMEM);

    /* Note that since we store a magic value as the first item in the program,
     * program offsets will never be 0
     */
    regc(preg, REG_MAGIC);
    if (reg(preg, 0, &flags) == 0) {
        return preg->err;
    }

    /* Small enough for pointer-storage convention? */
    if (preg->re_nsub >= REG_MAX_PAREN)     /* Probably could be 65535L. */
        FAIL(preg,REG_ERR_TOO_BIG);

    /* Dig out information for optimizations. */
    preg->regstart = 0; /* Worst-case defaults. */
    preg->reganch = 0;
    preg->regmust = 0;
    preg->regmlen = 0;
    scan = 1;           /* First BRANCH. */
    if (OP(preg, regnext(preg, scan)) == END) {     /* Only one top-level choice. */
        scan = OPERAND(scan);

        /* Starting-point info. */
        if (OP(preg, scan) == EXACTLY) {
            preg->regstart = preg->program[OPERAND(scan)];
        }
        else if (OP(preg, scan) == BOL)
            preg->reganch++;

        /*
         * If there's something expensive in the r.e., find the
         * longest literal string that must appear and make it the
         * regmust.  Resolve ties in favor of later strings, since
         * the regstart check works with the beginning of the r.e.
         * and avoiding duplication strengthens checking.  Not a
         * strong reason, but sufficient in the absence of others.
         */
        if (flags&SPSTART) {
            longest = 0;
            len = 0;
            for (; scan != 0; scan = regnext(preg, scan)) {
                if (OP(preg, scan) == EXACTLY) {
                    int plen = str_int_len(preg->program + OPERAND(scan));
                    if (plen >= len) {
                        longest = OPERAND(scan);
                        len = plen;
                    }
                }
            }
            preg->regmust = longest;
            preg->regmlen = len;
        }
    }

#ifdef DEBUG
    regdump(preg);
#endif

    return 0;
}

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
static int reg(regex_t *preg, int paren /* Parenthesized? */, int *flagp )
{
    int ret;
    int br;
    int ender;
    int parno = 0;
    int flags;

    *flagp = HASWIDTH;  /* Tentatively. */

    /* Make an OPEN node, if parenthesized. */
    if (paren) {
        if (preg->regparse[0] == '?' && preg->regparse[1] == ':') {
            /* non-capturing paren */
            preg->regparse += 2;
            parno = -1;
        }
        else {
            parno = ++preg->re_nsub;
        }
        ret = regnode(preg, OPEN+parno);
    } else
        ret = 0;

    /* Pick up the branches, linking them together. */
    br = regbranch(preg, &flags);
    if (br == 0)
        return 0;
    if (ret != 0)
        regtail(preg, ret, br); /* OPEN -> first. */
    else
        ret = br;
    if (!(flags&HASWIDTH))
        *flagp &= ~HASWIDTH;
    *flagp |= flags&SPSTART;
    while (*preg->regparse == '|') {
        preg->regparse++;
        br = regbranch(preg, &flags);
        if (br == 0)
            return 0;
        regtail(preg, ret, br); /* BRANCH -> BRANCH. */
        if (!(flags&HASWIDTH))
            *flagp &= ~HASWIDTH;
        *flagp |= flags&SPSTART;
    }

    /* Make a closing node, and hook it on the end. */
    ender = regnode(preg, (paren) ? CLOSE+parno : END);
    regtail(preg, ret, ender);

    /* Hook the tails of the branches to the closing node. */
    for (br = ret; br != 0; br = regnext(preg, br))
        regoptail(preg, br, ender);

    /* Check for proper termination. */
    if (paren && *preg->regparse++ != ')') {
        preg->err = REG_ERR_UNMATCHED_PAREN;
        return 0;
    } else if (!paren && *preg->regparse != '\0') {
        if (*preg->regparse == ')') {
            preg->err = REG_ERR_UNMATCHED_PAREN;
            return 0;
        } else {
            preg->err = REG_ERR_JUNK_ON_END;
            return 0;
        }
    }

    return(ret);
}

/*
 - regbranch - one alternative of an | operator
 *
 * Implements the concatenation operator.
 */
static int regbranch(regex_t *preg, int *flagp )
{
    int ret;
    int chain;
    int latest;
    int flags;

    *flagp = WORST;     /* Tentatively. */

    ret = regnode(preg, BRANCH);
    chain = 0;
    while (*preg->regparse != '\0' && *preg->regparse != ')' &&
           *preg->regparse != '|') {
        latest = regpiece(preg, &flags);
        if (latest == 0)
            return 0;
        *flagp |= flags&HASWIDTH;
        if (chain == 0) {/* First piece. */
            *flagp |= flags&SPSTART;
        }
        else {
            regtail(preg, chain, latest);
        }
        chain = latest;
    }
    if (chain == 0) /* Loop ran zero times. */
        (void) regnode(preg, NOTHING);

    return(ret);
}

/*
 - regpiece - something followed by possible [*+?]
 *
 * Note that the branching code sequences used for ? and the general cases
 * of * and + are somewhat optimized:  they use the same NOTHING node as
 * both the endmarker for their branch list and the body of the last branch.
 * It might seem that this node could be dispensed with entirely, but the
 * endmarker role is not redundant.
 */
static int regpiece(regex_t *preg, int *flagp)
{
    int ret;
    char op;
    int next;
    int flags;
    int chain = 0;
    int min;
    int max;

    ret = regatom(preg, &flags);
    if (ret == 0)
        return 0;

    op = *preg->regparse;
    if (!ISMULT(op)) {
        *flagp = flags;
        return(ret);
    }

    if (!(flags&HASWIDTH) && op != '?') {
        preg->err = REG_ERR_OPERAND_COULD_BE_EMPTY;
        return 0;
    }

    /* Handle braces (counted repetition) by expansion */
    if (op == '{') {
        char *end;

        min = strtoul(preg->regparse + 1, &end, 10);
        if (end == preg->regparse + 1) {
            preg->err = REG_ERR_BAD_COUNT;
            return 0;
        }
        if (*end == '}') {
            max = min;
        }
        else {
            preg->regparse = end;
            max = strtoul(preg->regparse + 1, &end, 10);
            if (*end != '}') {
                preg->err = REG_ERR_UNMATCHED_BRACES;
                return 0;
            }
        }
        if (end == preg->regparse + 1) {
            max = MAX_REP_COUNT;
        }
        else if (max < min || max >= 100) {
            preg->err = REG_ERR_BAD_COUNT;
            return 0;
        }
        if (min >= 100) {
            preg->err = REG_ERR_BAD_COUNT;
            return 0;
        }

        preg->regparse = strchr(preg->regparse, '}');
    }
    else {
        min = (op == '+');
        max = (op == '?' ? 1 : MAX_REP_COUNT);
    }

    if (preg->regparse[1] == '?') {
        preg->regparse++;
        next = reginsert(preg, flags & SIMPLE ? REPMIN : REPXMIN, 5, ret);
    }
    else {
        next = reginsert(preg, flags & SIMPLE ? REP: REPX, 5, ret);
    }
    preg->program[ret + 2] = max;
    preg->program[ret + 3] = min;
    preg->program[ret + 4] = 0;

    *flagp = (min) ? (WORST|HASWIDTH) : (WORST|SPSTART);

    if (!(flags & SIMPLE)) {
        int back = regnode(preg, BACK);
        regtail(preg, back, ret);
        regtail(preg, next, back);
    }

    preg->regparse++;
    if (ISMULT(*preg->regparse)) {
        preg->err = REG_ERR_NESTED_COUNT;
        return 0;
    }

    return chain ? chain : ret;
}

/**
 * Add all characters in the inclusive range between lower and upper.
 *
 * Handles a swapped range (upper < lower).
 */
static void reg_addrange(regex_t *preg, int lower, int upper)
{
    if (lower > upper) {
        reg_addrange(preg, upper, lower);
    }
    /* Add a range as length, start */
    regc(preg, upper - lower + 1);
    regc(preg, lower);
}

/**
 * Add a null-terminated literal string as a set of ranges.
 */
static void reg_addrange_str(regex_t *preg, const char *str)
{
    while (*str) {
        reg_addrange(preg, *str, *str);
        str++;
    }
}

/**
 * Extracts the next unicode char from utf8.
 *
 * If 'upper' is set, converts the char to uppercase.
 */
static int reg_utf8_tounicode_case(const char *s, int *uc, int upper)
{
    int l = jsi_utf8_tounicode(s, uc);
    if (upper) {
        *uc = jsi_utf8_upper(*uc);
    }
    return l;
}

/**
 * Converts a hex digit to decimal.
 *
 * Returns -1 for an invalid hex digit.
 */
static int hexdigitval(int c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    return -1;
}

/**
 * Parses up to 'n' hex digits at 's' and stores the result in *uc.
 *
 * Returns the number of hex digits parsed.
 * If there are no hex digits, returns 0 and stores nothing.
 */
static int parse_hex(const char *s, int n, int *uc)
{
    int val = 0;
    int k;

    for (k = 0; k < n; k++) {
        int c = hexdigitval(*s++);
        if (c == -1) {
            break;
        }
        val = (val << 4) | c;
    }
    if (k) {
        *uc = val;
    }
    return k;
}

/**
 * Call for chars after a backlash to decode the escape sequence.
 *
 * Stores the result in *ch.
 *
 * Returns the number of bytes consumed.
 */
static int reg_decode_escape(const char *s, int *ch)
{
    int n;
    const char *s0 = s;

    *ch = *s++;

    switch (*ch) {
        case 'b': *ch = '\b'; break;
        case 'e': *ch = 27; break;
        case 'f': *ch = '\f'; break;
        case 'n': *ch = '\n'; break;
        case 'r': *ch = '\r'; break;
        case 't': *ch = '\t'; break;
        case 'v': *ch = '\v'; break;
        case 'u':
            if (*s == '{') {
                /* Expect \u{NNNN} */
                n = parse_hex(s + 1, 6, ch);
                if (n > 0 && s[n + 1] == '}' && *ch >= 0 && *ch <= 0x1fffff) {
                    s += n + 2;
                }
                else {
                    /* Invalid, so just treat as an escaped 'u' */
                    *ch = 'u';
                }
            }
            else if ((n = parse_hex(s, 4, ch)) > 0) {
                s += n;
            }
            break;
        case 'U':
            if ((n = parse_hex(s, 8, ch)) > 0) {
                s += n;
            }
        case 'x':
            if ((n = parse_hex(s, 2, ch)) > 0) {
                s += n;
            }
            break;
        case '\0':
            s--;
            *ch = '\\';
            break;
    }
    return s - s0;
}

/*
 - regatom - the lowest level
 *
 * Optimization:  gobbles an entire sequence of ordinary characters so that
 * it can turn them into a single node, which is smaller to store and
 * faster to run.  Backslashed characters are exceptions, each becoming a
 * separate node; the code is simpler that way and it's not worth fixing.
 */
static int regatom(regex_t *preg, int *flagp)
{
    int ret;
    int flags;
    int nocase = (preg->cflags & REG_ICASE);

    int ch;
    int n = reg_utf8_tounicode_case(preg->regparse, &ch, nocase);

    *flagp = WORST;     /* Tentatively. */

    preg->regparse += n;
    switch (ch) {
    /* FIXME: these chars only have meaning at beg/end of pat? */
    case '^':
        ret = regnode(preg, BOL);
        break;
    case '$':
        ret = regnode(preg, EOL);
        break;
    case '.':
        ret = regnode(preg, ANY);
        *flagp |= HASWIDTH|SIMPLE;
        break;
    case '[': {
            const char *pattern = preg->regparse;

            if (*pattern == '^') {  /* Complement of range. */
                ret = regnode(preg, ANYBUT);
                pattern++;
            } else
                ret = regnode(preg, ANYOF);

            /* Special case. If the first char is ']' or '-', it is part of the set */
            if (*pattern == ']' || *pattern == '-') {
                reg_addrange(preg, *pattern, *pattern);
                pattern++;
            }

            while (*pattern && *pattern != ']') {
                /* Is this a range? a-z */
                int start;
                int end;

                pattern += reg_utf8_tounicode_case(pattern, &start, nocase);
                if (start == '\\') {
                    pattern += reg_decode_escape(pattern, &start);
                    if (start == 0) {
                        preg->err = REG_ERR_NULL_CHAR;
                        return 0;
                    }
                }
                if (pattern[0] == '-' && pattern[1] && pattern[1] != ']') {
                    /* skip '-' */
                    pattern += jsi_utf8_tounicode(pattern, &end);
                    pattern += reg_utf8_tounicode_case(pattern, &end, nocase);
                    if (end == '\\') {
                        pattern += reg_decode_escape(pattern, &end);
                        if (end == 0) {
                            preg->err = REG_ERR_NULL_CHAR;
                            return 0;
                        }
                    }

                    reg_addrange(preg, start, end);
                    continue;
                }
                if (start == '[') {
                    if (strncmp(pattern, ":alpha:]", 8) == 0) {
                        if ((preg->cflags & REG_ICASE) == 0) {
                            reg_addrange(preg, 'a', 'z');
                        }
                        reg_addrange(preg, 'A', 'Z');
                        pattern += 8;
                        continue;
                    }
                    if (strncmp(pattern, ":alnum:]", 8) == 0) {
                        if ((preg->cflags & REG_ICASE) == 0) {
                            reg_addrange(preg, 'a', 'z');
                        }
                        reg_addrange(preg, 'A', 'Z');
                        reg_addrange(preg, '0', '9');
                        pattern += 8;
                        continue;
                    }
                    if (strncmp(pattern, ":space:]", 8) == 0) {
                        reg_addrange_str(preg, " \t\r\n\f\v");
                        pattern += 8;
                        continue;
                    }
                }
                /* Not a range, so just add the char */
                reg_addrange(preg, start, start);
            }
            regc(preg, '\0');

            if (*pattern) {
                pattern++;
            }
            preg->regparse = pattern;

            *flagp |= HASWIDTH|SIMPLE;
        }
        break;
    case '(':
        ret = reg(preg, 1, &flags);
        if (ret == 0)
            return 0;
        *flagp |= flags&(HASWIDTH|SPSTART);
        break;
    case '\0':
    case '|':
    case ')':
        preg->err = REG_ERR_INTERNAL;
        return 0;   /* Supposed to be caught earlier. */
    case '?':
    case '+':
    case '*':
    case '{':
        preg->err = REG_ERR_COUNT_FOLLOWS_NOTHING;
        return 0;
    case '\\':
        switch (*preg->regparse++) {
        case '\0':
            preg->err = REG_ERR_TRAILING_BACKSLASH;
            return 0;
        case '<':
        case 'm':
            ret = regnode(preg, WORDA);
            break;
        case '>':
        case 'M':
            ret = regnode(preg, WORDZ);
            break;
        case 'd':
            ret = regnode(preg, ANYOF);
            reg_addrange(preg, '0', '9');
            regc(preg, '\0');
            *flagp |= HASWIDTH|SIMPLE;
            break;
        case 'w':
            ret = regnode(preg, ANYOF);
            if ((preg->cflags & REG_ICASE) == 0) {
                reg_addrange(preg, 'a', 'z');
            }
            reg_addrange(preg, 'A', 'Z');
            reg_addrange(preg, '0', '9');
            reg_addrange(preg, '_', '_');
            regc(preg, '\0');
            *flagp |= HASWIDTH|SIMPLE;
            break;
        case 's':
            ret = regnode(preg, ANYOF);
            reg_addrange_str(preg," \t\r\n\f\v");
            regc(preg, '\0');
            *flagp |= HASWIDTH|SIMPLE;
            break;
        /* FIXME: Someday handle \1, \2, ... */
        default:
            /* Handle general quoted chars in exact-match routine */
            /* Back up to include the backslash */
            preg->regparse--;
            goto de_fault;
        }
        break;
    de_fault:
    default: {
            /*
             * Encode a string of characters to be matched exactly.
             */
            int added = 0;

            /* Back up to pick up the first char of interest */
            preg->regparse -= n;

            ret = regnode(preg, EXACTLY);

            /* Note that a META operator such as ? or * consumes the
             * preceding char.
             * Thus we must be careful to look ahead by 2 and add the
             * last char as it's own EXACTLY if necessary
             */

            /* Until end of string or a META char is reached */
            while (*preg->regparse && strchr(META, *preg->regparse) == NULL) {
                n = reg_utf8_tounicode_case(preg->regparse, &ch, (preg->cflags & REG_ICASE));
                if (ch == '\\' && preg->regparse[n]) {
                    /* Non-trailing backslash.
                     * Is this a special escape, or a regular escape?
                     */
                    if (strchr("<>mMwds", preg->regparse[n])) {
                        /* A special escape. All done with EXACTLY */
                        break;
                    }
                    /* Decode it. Note that we add the length for the escape
                     * sequence to the length for the backlash so we can skip
                     * the entire sequence, or not as required.
                     */
                    n += reg_decode_escape(preg->regparse + n, &ch);
                    if (ch == 0) {
                        preg->err = REG_ERR_NULL_CHAR;
                        return 0;
                    }
                }

                /* Now we have one char 'ch' of length 'n'.
                 * Check to see if the following char is a MULT
                 */

                if (ISMULT(preg->regparse[n])) {
                    /* Yes. But do we already have some EXACTLY chars? */
                    if (added) {
                        /* Yes, so return what we have and pick up the current char next time around */
                        break;
                    }
                    /* No, so add this single char and finish */
                    regc(preg, ch);
                    added++;
                    preg->regparse += n;
                    break;
                }

                /* No, so just add this char normally */
                regc(preg, ch);
                added++;
                preg->regparse += n;
            }
            regc(preg, '\0');

            *flagp |= HASWIDTH;
            if (added == 1)
                *flagp |= SIMPLE;
            break;
        }
        break;
    }

    return(ret);
}

static void reg_grow(regex_t *preg, int n)
{
    if (preg->p + n >= preg->proglen) {
        preg->proglen = (preg->p + n) * 2;
        preg->program = realloc(preg->program, preg->proglen * sizeof(int));
    }
}

/*
 - regnode - emit a node
 */
/* Location. */
static int regnode(regex_t *preg, int op)
{
    reg_grow(preg, 2);

    preg->program[preg->p++] = op;
    preg->program[preg->p++] = 0;

    /* Return the start of the node */
    return preg->p - 2;
}

/*
 - regc - emit (if appropriate) a byte of code
 */
static void regc(regex_t *preg, int b )
{
    reg_grow(preg, 1);
    preg->program[preg->p++] = b;
}

/*
 - reginsert - insert an operator in front of already-emitted operand
 *
 * Means relocating the operand.
 * Returns the new location of the original operand.
 */
static int reginsert(regex_t *preg, int op, int size, int opnd )
{
    reg_grow(preg, size);

    /* Move everything from opnd up */
    memmove(preg->program + opnd + size, preg->program + opnd, sizeof(int) * (preg->p - opnd));
    /* Zero out the new space */
    memset(preg->program + opnd, 0, sizeof(int) * size);

    preg->program[opnd] = op;

    preg->p += size;

    return opnd + size;
}

/*
 - regtail - set the next-pointer at the end of a node chain
 */
static void regtail_(regex_t *preg, int p, int val, int line )
{
    int scan;
    int temp;
    int offset;

    /* Find last node. */
    scan = p;
    for (;;) {
        temp = regnext(preg, scan);
        if (temp == 0)
            break;
        scan = temp;
    }

    if (OP(preg, scan) == BACK)
        offset = scan - val;
    else
        offset = val - scan;

    preg->program[scan + 1] = offset;
}

/*
 - regoptail - regtail on operand of first argument; nop if operandless
 */

static void regoptail(regex_t *preg, int p, int val )
{
    /* "Operandless" and "op != BRANCH" are synonymous in practice. */
    if (p != 0 && OP(preg, p) == BRANCH) {
        regtail(preg, OPERAND(p), val);
    }
}

/*
 * regexec and friends
 */

/*
 * Forwards.
 */
static int regtry(regex_t *preg, const char *string );
static int regmatch(regex_t *preg, int prog);
static int regrepeat(regex_t *preg, int p, int max);

/*
 - regexec - match a regexp against a string
 */
int regexec(regex_t  *preg,  const  char *string, size_t nmatch, regmatch_t pmatch[], int eflags)
{
    const char *s;
    int scan;

    /* Be paranoid... */
    if (preg == NULL || preg->program == NULL || string == NULL) {
        return REG_ERR_NULL_ARGUMENT;
    }

    /* Check validity of program. */
    if (*preg->program != REG_MAGIC) {
        return REG_ERR_CORRUPTED;
    }

#ifdef DEBUG
    fprintf(stderr, "regexec: %s\n", string);
    regdump(preg);
#endif

    preg->eflags = eflags;
    preg->pmatch = pmatch;
    preg->nmatch = nmatch;
    preg->start = string;   /* All offsets are computed from here */

    /* Must clear out the embedded repeat counts */
    for (scan = OPERAND(1); scan != 0; ) {
        switch (OP(preg, scan)) {
        case REP:
        case REPMIN:
        case REPX:
        case REPXMIN:
            preg->program[scan + 4] = 0;
            scan += 5;
            break;

        case ANYOF:
        case ANYBUT:
        case EXACTLY:
            scan += 2;
            while (preg->program[scan++]) {
            }
            break;

        case END:
            scan = 0;
            break;

        default:
            scan += 2;
            break;
        }
    }

    /* If there is a "must appear" string, look for it. */
    if (preg->regmust != 0) {
        s = string;
        while ((s = str_find(s, preg->program[preg->regmust], preg->cflags & REG_ICASE)) != NULL) {
            if (prefix_cmp(preg->program + preg->regmust, preg->regmlen, s, preg->cflags & REG_ICASE) >= 0) {
                break;
            }
            s++;
        }
        if (s == NULL)  /* Not present. */
            return REG_NOMATCH;
    }

    /* Mark beginning of line for ^ . */
    preg->regbol = string;

    /* Simplest case:  anchored match need be tried only once (maybe per line). */
    if (preg->reganch) {
        if (eflags & REG_NOTBOL) {
            /* This is an anchored search, but not an BOL, so possibly skip to the next line */
            goto nextline;
        }
        while (1) {
            if (regtry(preg, string)) {
                return REG_NOERROR;
            }
            if (*string) {
nextline:
                if (preg->cflags & REG_NEWLINE) {
                    /* Try the next anchor? */
                    string = strchr(string, '\n');
                    if (string) {
                        preg->regbol = ++string;
                        continue;
                    }
                }
            }
            return REG_NOMATCH;
        }
    }

    /* Messy cases:  unanchored match. */
    s = string;
    if (preg->regstart != '\0') {
        /* We know what char it must start with. */
        while ((s = str_find(s, preg->regstart, preg->cflags & REG_ICASE)) != NULL) {
            if (regtry(preg, s))
                return REG_NOERROR;
            s++;
        }
    }
    else
        /* We don't -- general case. */
        while (1) {
            if (regtry(preg, s))
                return REG_NOERROR;
            if (*s == '\0') {
                break;
            }
            else {
                int c;
                s += jsi_utf8_tounicode(s, &c);
            }
        }

    /* Failure. */
    return REG_NOMATCH;
}

/*
 - regtry - try match at specific point
 */
            /* 0 failure, 1 success */
static int regtry( regex_t *preg, const char *string )
{
    int i;

    preg->reginput = string;

    for (i = 0; i < preg->nmatch; i++) {
        preg->pmatch[i].rm_so = -1;
        preg->pmatch[i].rm_eo = -1;
    }
    if (regmatch(preg, 1)) {
        preg->pmatch[0].rm_so = string - preg->start;
        preg->pmatch[0].rm_eo = preg->reginput - preg->start;
        return(1);
    } else
        return(0);
}

/**
 * Returns bytes matched if 'pattern' is a prefix of 'string'.
 *
 * If 'nocase' is non-zero, does a case-insensitive match.
 *
 * Returns -1 on not found.
 */
static int prefix_cmp(const int *prog, int proglen, const char *string, int nocase)
{
    const char *s = string;
    while (proglen && *s) {
        int ch;
        int n = reg_utf8_tounicode_case(s, &ch, nocase);
        if (ch != *prog) {
            return -1;
        }
        prog++;
        s += n;
        proglen--;
    }
    if (proglen == 0) {
        return s - string;
    }
    return -1;
}

/**
 * Searchs for 'c' in the range 'range'.
 *
 * Returns 1 if found, or 0 if not.
 */
static int reg_range_find(const int *range, int c)
{
    while (*range) {
        /*printf("Checking %d in range [%d,%d]\n", c, range[1], (range[0] + range[1] - 1));*/
        if (c >= range[1] && c <= (range[0] + range[1] - 1)) {
            return 1;
        }
        range += 2;
    }
    return 0;
}

/**
 * Search for the character 'c' in the utf-8 string 'string'.
 *
 * If 'nocase' is set, the 'string' is assumed to be uppercase
 * and 'c' is converted to uppercase before matching.
 *
 * Returns the byte position in the string where the 'c' was found, or
 * NULL if not found.
 */
static const char *str_find(const char *string, int c, int nocase)
{
    if (nocase) {
        /* The "string" should already be converted to uppercase */
        c = jsi_utf8_upper(c);
    }
    while (*string) {
        int ch;
        int n = reg_utf8_tounicode_case(string, &ch, nocase);
        if (c == ch) {
            return string;
        }
        string += n;
    }
    return NULL;
}

/**
 * Returns true if 'ch' is an end-of-line char.
 *
 * In REG_NEWLINE mode, \n is considered EOL in
 * addition to \0
 */
static int reg_iseol(regex_t *preg, int ch)
{
    if (preg->cflags & REG_NEWLINE) {
        return ch == '\0' || ch == '\n';
    }
    else {
        return ch == '\0';
    }
}

static int regmatchsimplerepeat(regex_t *preg, int scan, int matchmin)
{
    int nextch = '\0';
    const char *save;
    int no;
    int c;

    int max = preg->program[scan + 2];
    int min = preg->program[scan + 3];
    int next = regnext(preg, scan);

    /*
     * Lookahead to avoid useless match attempts
     * when we know what character comes next.
     */
    if (OP(preg, next) == EXACTLY) {
        nextch = preg->program[OPERAND(next)];
    }
    save = preg->reginput;
    no = regrepeat(preg, scan + 5, max);
    if (no < min) {
        return 0;
    }
    if (matchmin) {
        /* from min up to no */
        max = no;
        no = min;
    }
    /* else from no down to min */
    while (1) {
        if (matchmin) {
            if (no > max) {
                break;
            }
        }
        else {
            if (no < min) {
                break;
            }
        }
        preg->reginput = save + jsi_utf8_index(save, no);
        reg_utf8_tounicode_case(preg->reginput, &c, (preg->cflags & REG_ICASE));
        /* If it could work, try it. */
        if (reg_iseol(preg, nextch) || c == nextch) {
            if (regmatch(preg, next)) {
                return(1);
            }
        }
        if (matchmin) {
            /* Couldn't or didn't, add one more */
            no++;
        }
        else {
            /* Couldn't or didn't -- back up. */
            no--;
        }
    }
    return(0);
}

static int regmatchrepeat(regex_t *preg, int scan, int matchmin)
{
    int *scanpt = preg->program + scan;

    int max = scanpt[2];
    int min = scanpt[3];

    /* Have we reached min? */
    if (scanpt[4] < min) {
        /* No, so get another one */
        scanpt[4]++;
        if (regmatch(preg, scan + 5)) {
            return 1;
        }
        scanpt[4]--;
        return 0;
    }
    if (scanpt[4] > max) {
        return 0;
    }

    if (matchmin) {
        /* minimal, so try other branch first */
        if (regmatch(preg, regnext(preg, scan))) {
            return 1;
        }
        /* No, so try one more */
        scanpt[4]++;
        if (regmatch(preg, scan + 5)) {
            return 1;
        }
        scanpt[4]--;
        return 0;
    }
    /* maximal, so try this branch again */
    if (scanpt[4] < max) {
        scanpt[4]++;
        if (regmatch(preg, scan + 5)) {
            return 1;
        }
        scanpt[4]--;
    }
    /* At this point we are at max with no match. Try the other branch */
    return regmatch(preg, regnext(preg, scan));
}

/*
 - regmatch - main matching routine
 *
 * Conceptually the strategy is simple:  check to see whether the current
 * node matches, call self recursively to see whether the rest matches,
 * and then act accordingly.  In practice we make some effort to avoid
 * recursion, in particular by going through "ordinary" nodes (that don't
 * need to know whether the rest of the match failed) by a loop instead of
 * by recursion.
 */
/* 0 failure, 1 success */
static int regmatch(regex_t *preg, int prog)
{
    int scan;   /* Current node. */
    int next;       /* Next node. */

    scan = prog;

#ifdef DEBUG
    if (scan != 0 && regnarrate)
        fprintf(stderr, "%s(\n", regprop(scan));
#endif
    while (scan != 0) {
        int n;
        int c;
#ifdef DEBUG
        if (regnarrate) {
            fprintf(stderr, "%3d: %s...\n", scan, regprop(OP(preg, scan))); /* Where, what. */
        }
#endif
        next = regnext(preg, scan);
        n = reg_utf8_tounicode_case(preg->reginput, &c, (preg->cflags & REG_ICASE));

        switch (OP(preg, scan)) {
        case BOL:
            if (preg->reginput != preg->regbol)
                return(0);
            break;
        case EOL:
            if (!reg_iseol(preg, c)) {
                return(0);
            }
            break;
        case WORDA:
            /* Must be looking at a letter, digit, or _ */
            if ((!isalnum(UCHAR(c))) && c != '_')
                return(0);
            /* Prev must be BOL or nonword */
            if (preg->reginput > preg->regbol &&
                (isalnum(UCHAR(preg->reginput[-1])) || preg->reginput[-1] == '_'))
                return(0);
            break;
        case WORDZ:
            /* Can't match at BOL */
            if (preg->reginput > preg->regbol) {
                /* Current must be EOL or nonword */
                if (reg_iseol(preg, c) || !isalnum(UCHAR(c)) || c != '_') {
                    c = preg->reginput[-1];
                    /* Previous must be word */
                    if (isalnum(UCHAR(c)) || c == '_') {
                        break;
                    }
                }
            }
            /* No */
            return(0);

        case ANY:
            if (reg_iseol(preg, c))
                return 0;
            preg->reginput += n;
            break;
        case EXACTLY: {
                int opnd;
                int len;
                int slen;

                opnd = OPERAND(scan);
                len = str_int_len(preg->program + opnd);

                slen = prefix_cmp(preg->program + opnd, len, preg->reginput, preg->cflags & REG_ICASE);
                if (slen < 0) {
                    return(0);
                }
                preg->reginput += slen;
            }
            break;
        case ANYOF:
            if (reg_iseol(preg, c) || reg_range_find(preg->program + OPERAND(scan), c) == 0) {
                return(0);
            }
            preg->reginput += n;
            break;
        case ANYBUT:
            if (reg_iseol(preg, c) || reg_range_find(preg->program + OPERAND(scan), c) != 0) {
                return(0);
            }
            preg->reginput += n;
            break;
        case NOTHING:
            break;
        case BACK:
            break;
        case BRANCH: {
                const char *save;

                if (OP(preg, next) != BRANCH)       /* No choice. */
                    next = OPERAND(scan);   /* Avoid recursion. */
                else {
                    do {
                        save = preg->reginput;
                        if (regmatch(preg, OPERAND(scan))) {
                            return(1);
                        }
                        preg->reginput = save;
                        scan = regnext(preg, scan);
                    } while (scan != 0 && OP(preg, scan) == BRANCH);
                    return(0);
                    /* NOTREACHED */
                }
            }
            break;
        case REP:
        case REPMIN:
            return regmatchsimplerepeat(preg, scan, OP(preg, scan) == REPMIN);

        case REPX:
        case REPXMIN:
            return regmatchrepeat(preg, scan, OP(preg, scan) == REPXMIN);

        case END:
            return(1);  /* Success! */
            break;

        case OPENNC:
        case CLOSENC:
            if (regmatch(preg, next)) {
                return 1;
            }
            return 0;

        default:
            if (OP(preg, scan) >= OPEN+1 && OP(preg, scan) < CLOSE_END) {
                const char *save;

                save = preg->reginput;

                if (regmatch(preg, next)) {
                    int no;
                    /*
                     * Don't set startp if some later
                     * invocation of the same parentheses
                     * already has.
                     */
                    if (OP(preg, scan) < CLOSE) {
                        no = OP(preg, scan) - OPEN;
                        if (no < preg->nmatch && preg->pmatch[no].rm_so == -1) {
                            preg->pmatch[no].rm_so = save - preg->start;
                        }
                    }
                    else {
                        no = OP(preg, scan) - CLOSE;
                        if (no < preg->nmatch && preg->pmatch[no].rm_eo == -1) {
                            preg->pmatch[no].rm_eo = save - preg->start;
                        }
                    }
                    return(1);
                } else
                    return(0);
            }
            return REG_ERR_INTERNAL;
        }

        scan = next;
    }

    /*
     * We get here only if there's trouble -- normally "case END" is
     * the terminating point.
     */
    return REG_ERR_INTERNAL;
}

/*
 - regrepeat - repeatedly match something simple, report how many
 */
static int regrepeat(regex_t *preg, int p, int max)
{
    int count = 0;
    const char *scan;
    int opnd;
    int ch;
    int n;

    scan = preg->reginput;
    opnd = OPERAND(p);
    switch (OP(preg, p)) {
    case ANY:
        /* No need to handle utf8 specially here */
        while (!reg_iseol(preg, *scan) && count < max) {
            count++;
            scan++;
        }
        break;
    case EXACTLY:
        while (count < max) {
            n = reg_utf8_tounicode_case(scan, &ch, preg->cflags & REG_ICASE);
            if (preg->program[opnd] != ch) {
                break;
            }
            count++;
            scan += n;
        }
        break;
    case ANYOF:
        while (count < max) {
            n = reg_utf8_tounicode_case(scan, &ch, preg->cflags & REG_ICASE);
            if (reg_iseol(preg, ch) || reg_range_find(preg->program + opnd, ch) == 0) {
                break;
            }
            count++;
            scan += n;
        }
        break;
    case ANYBUT:
        while (count < max) {
            n = reg_utf8_tounicode_case(scan, &ch, preg->cflags & REG_ICASE);
            if (reg_iseol(preg, ch) || reg_range_find(preg->program + opnd, ch) != 0) {
                break;
            }
            count++;
            scan += n;
        }
        break;
    default:        /* Oh dear.  Called inappropriately. */
        preg->err = REG_ERR_INTERNAL;
        count = 0;  /* Best compromise. */
        break;
    }
    preg->reginput = scan;

    return(count);
}

/*
 - regnext - dig the "next" pointer out of a node
 */
static int regnext(regex_t *preg, int p )
{
    int offset;

    offset = NEXT(preg, p);

    if (offset == 0)
        return 0;

    if (OP(preg, p) == BACK)
        return(p-offset);
    else
        return(p+offset);
}

#if defined(DEBUG) && !defined(JSI_BOOTSTRAP)

/*
 - regdump - dump a regexp onto stdout in vaguely comprehensible form
 */
static void regdump(regex_t *preg)
{
    int s;
    int op = EXACTLY;   /* Arbitrary non-END op. */
    int next;
    char buf[MAX_UTF8_LEN + 1];

    int i;
    for (i = 1; i < preg->p; i++) {
        printf("%02x ", (unsigned char)preg->program[i]);
        if (i % 16 == 0) {
            printf("\n");
        }
    }
    printf("\n");

    s = 1;
    while (op != END && s < preg->p) {  /* While that wasn't END last time... */
        op = OP(preg, s);
        printf("%3d: %s", s, regprop(op));  /* Where, what. */
        next = regnext(preg, s);
        if (next == 0)      /* Next ptr. */
            printf("(0)");
        else
            printf("(%d)", next);
        s += 2;
        if (op == REP || op == REPMIN || op == REPX || op == REPXMIN) {
            int max = preg->program[s];
            int min = preg->program[s + 1];
            if (max == 65535) {
                printf("{%d,*}", min);
            }
            else {
                printf("{%d,%d}", min, max);
            }
            printf(" %d", preg->program[s + 2]);
            s += 3;
        }
        else if (op == ANYOF || op == ANYBUT) {
            /* set of ranges */

            while (preg->program[s]) {
                int len = preg->program[s++];
                int first = preg->program[s++];
                buf[utf8_fromunicode(buf, first)] = 0;
                printf("%s", buf);
                if (len > 1) {
                    buf[utf8_fromunicode(buf, first + len - 1)] = 0;
                    printf("-%s", buf);
                }
            }
            s++;
        }
        else if (op == EXACTLY) {
            /* Literal string, where present. */

            while (preg->program[s]) {
                buf[utf8_fromunicode(buf, preg->program[s])] = 0;
                printf("%s", buf);
                s++;
            }
            s++;
        }
        putchar('\n');
    }

    if (op == END) {
        /* Header fields of interest. */
        if (preg->regstart) {
            buf[utf8_fromunicode(buf, preg->regstart)] = 0;
            printf("start '%s' ", buf);
        }
        if (preg->reganch)
            printf("anchored ");
        if (preg->regmust != 0) {
            int i;
            printf("must have:");
            for (i = 0; i < preg->regmlen; i++) {
                putchar(preg->program[preg->regmust + i]);
            }
            putchar('\n');
        }
    }
    printf("\n");
}

/*
 - regprop - printable representation of opcode
 */
static const char *regprop( int op )
{
    static char buf[50];

    switch (op) {
    case BOL:
        return "BOL";
    case EOL:
        return "EOL";
    case ANY:
        return "ANY";
    case ANYOF:
        return "ANYOF";
    case ANYBUT:
        return "ANYBUT";
    case BRANCH:
        return "BRANCH";
    case EXACTLY:
        return "EXACTLY";
    case NOTHING:
        return "NOTHING";
    case BACK:
        return "BACK";
    case END:
        return "END";
    case REP:
        return "REP";
    case REPMIN:
        return "REPMIN";
    case REPX:
        return "REPX";
    case REPXMIN:
        return "REPXMIN";
    case WORDA:
        return "WORDA";
    case WORDZ:
        return "WORDZ";
    case OPENNC:
        return "OPEN";
    case CLOSENC:
        return "CLOSE";
    default:
        if (op >= OPEN && op < CLOSE) {
            snprintf(buf, sizeof(buf), "OPEN%d", op-OPEN);
        }
        else if (op >= CLOSE && op < CLOSE_END) {
            snprintf(buf, sizeof(buf), "CLOSE%d", op-CLOSE);
        }
        else {
            snprintf(buf, sizeof(buf), "?%d?\n", op);
        }
        return(buf);
    }
}
#endif /* JSI_BOOTSTRAP */

size_t regerror(int errcode, const regex_t *preg, char *errbuf,  size_t errbuf_size)
{
    static const char *error_strings[] = {
        "success",
        "no match",
        "bad pattern",
        "null argument",
        "unknown error",
        "too big",
        "out of memory",
        "too many ()",
        "parentheses () not balanced",
        "braces {} not balanced",
        "invalid repetition count(s)",
        "extra characters",
        "*+ of empty atom",
        "nested count",
        "internal error",
        "count follows nothing",
        "trailing backslash",
        "corrupted program",
        "contains null char",
    };
    const char *err;

    if (errcode < 0 || errcode >= REG_ERR_NUM) {
        err = "Bad error code";
    }
    else {
        err = error_strings[errcode];
    }

    return snprintf(errbuf, errbuf_size, "%s", err);
}

void regfree(regex_t *preg)
{
    free(preg->program);
}

#endif
#endif
/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code was contributed to The NetBSD Foundation by Klaus Klein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifdef __WIN32
#ifndef JSI_AMALGAMATION
#include "../jsiInt.h"
#include "compat.h"
#endif

#define TM_YEAR_BASE 1970
#include "ctype.h"
#include "string.h"
#include "time.h"
#include "stdio.h"


/*
 * We do not implement alternate representations. However, we always
 * check whether a given modifier is allowed for a certain conversion.
 */
#define ALT_E           0x01
#define ALT_O           0x02
#define LEGAL_ALT(x)        { if (alt_format & ~(x)) return (0); }


static int conv_num(const char **, int *, int, int);

static const char *day[7] = {
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday"
};
static const char *abday[7] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
static const char *mon[12] = {
    "January", "February", "March", "April", "May", "June", "July",
    "August", "September", "October", "November", "December"
};
static const char *abmon[12] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
static const char *am_pm[2] = {
    "AM", "PM"
};


char *
strptime(const char *buf, const char *fmt, struct tm *tm)
{
    char c;
    const char *bp;
    size_t len = 0;
    int alt_format, i, split_year = 0;

    bp = buf;

    while ((c = *fmt) != '\0') {
    /* Clear `alternate' modifier prior to new conversion. */
    alt_format = 0;

    /* Eat up white-space. */
    if (isspace(c)) {
        while (isspace(*bp))
        bp++;

        fmt++;
        continue;
    }

    if ((c = *fmt++) != '%')
        goto literal;


      again:switch (c = *fmt++) {
    case '%':       /* "%%" is converted to "%". */
      literal:
        if (c != *bp++)
        return (0);
        break;

        /*
         *               * "Alternative" modifiers. Just set the appropriate flag
         *                               * and start over again.
         *                                               */
    case 'E':       /* "%E?" alternative conversion modifier. */
        LEGAL_ALT(0);
        alt_format |= ALT_E;
        goto again;

    case 'O':       /* "%O?" alternative conversion modifier. */
        LEGAL_ALT(0);
        alt_format |= ALT_O;
        goto again;

        /*
         *               * "Complex" conversion rules, implemented through recursion.
         *                               */
    case 'c':       /* Date and time, using the locale's format. */
        LEGAL_ALT(ALT_E);
        if (!(bp = strptime(bp, "%x %X", tm)))
        return (0);
        break;

    case 'D':       /* The date as "%m/%d/%y". */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%m/%d/%y", tm)))
        return (0);
        break;

    case 'R':       /* The time as "%H:%M". */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%H:%M", tm)))
        return (0);
        break;

    case 'r':       /* The time in 12-hour clock representation. */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%I:%M:%S %p", tm)))
        return (0);
        break;

    case 'T':       /* The time as "%H:%M:%S". */
        LEGAL_ALT(0);
        if (!(bp = strptime(bp, "%H:%M:%S", tm)))
        return (0);
        break;

    case 'X':       /* The time, using the locale's format. */
        LEGAL_ALT(ALT_E);
        if (!(bp = strptime(bp, "%H:%M:%S", tm)))
        return (0);
        break;

    case 'x':       /* The date, using the locale's format. */
        LEGAL_ALT(ALT_E);
        if (!(bp = strptime(bp, "%m/%d/%y", tm)))
        return (0);
        break;

        /*
         *           * "Elementary" conversion rules.
         *                           */
    case 'A':       /* The day of week, using the locale's form. */
    case 'a':
        LEGAL_ALT(0);
        for (i = 0; i < 7; i++) {
        /* Full name. */
        len = strlen(day[i]);
        if (strncasecmp(day[i], bp, len) == 0)
            break;

        /* Abbreviated name. */
        len = strlen(abday[i]);
        if (strncasecmp(abday[i], bp, len) == 0)
            break;
        }

        /* Nothing matched. */
        if (i == 7)
        return (0);

        tm->tm_wday = i;
        bp += len;
        break;

    case 'B':       /* The month, using the locale's form. */
    case 'b':
    case 'h':
        LEGAL_ALT(0);
        for (i = 0; i < 12; i++) {
        /* Full name. */
        len = strlen(mon[i]);
        if (strncasecmp(mon[i], bp, len) == 0)
            break;

        /* Abbreviated name. */
        len = strlen(abmon[i]);
        if (strncasecmp(abmon[i], bp, len) == 0)
            break;
        }

        /* Nothing matched. */
        if (i == 12)
        return (0);

        tm->tm_mon = i;
        bp += len;
        break;

    case 'C':       /* The century number. */
        LEGAL_ALT(ALT_E);
        if (!(conv_num(&bp, &i, 0, 99)))
        return (0);

        if (split_year) {
        tm->tm_year = (tm->tm_year % 100) + (i * 100);
        } else {
        tm->tm_year = i * 100;
        split_year = 1;
        }
        break;

    case 'd':       /* The day of month. */
    case 'e':
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_mday, 1, 31)))
        return (0);
        break;

    case 'k':       /* The hour (24-hour clock representation). */
        LEGAL_ALT(0);
        /* FALLTHROUGH */
    case 'H':
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_hour, 0, 23)))
        return (0);
        break;

    case 'l':       /* The hour (12-hour clock representation). */
        LEGAL_ALT(0);
        /* FALLTHROUGH */
    case 'I':
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_hour, 1, 12)))
        return (0);
        if (tm->tm_hour == 12)
        tm->tm_hour = 0;
        break;

    case 'j':       /* The day of year. */
        LEGAL_ALT(0);
        if (!(conv_num(&bp, &i, 1, 366)))
        return (0);
        tm->tm_yday = i - 1;
        break;

    case 'M':       /* The minute. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_min, 0, 59)))
        return (0);
        break;

    case 'm':       /* The month. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &i, 1, 12)))
        return (0);
        tm->tm_mon = i - 1;
        break;

    case 'p':       /* The locale's equivalent of AM/PM. */
        LEGAL_ALT(0);
        /* AM? */
        if (strcasecmp(am_pm[0], bp) == 0) {
        if (tm->tm_hour > 11)
            return (0);

        bp += strlen(am_pm[0]);
        break;
        }
        /* PM? */
        else if (strcasecmp(am_pm[1], bp) == 0) {
        if (tm->tm_hour > 11)
            return (0);

        tm->tm_hour += 12;
        bp += strlen(am_pm[1]);
        break;
        }

        /* Nothing matched. */
        return (0);

    case 'S':       /* The seconds. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_sec, 0, 61)))
        return (0);
        break;

    case 'U':       /* The week of year, beginning on sunday. */
    case 'W':       /* The week of year, beginning on monday. */
        LEGAL_ALT(ALT_O);
        /*
         *                   * XXX This is bogus, as we can not assume any valid
         *                                           * information present in the tm structure at this
         *                                                                   * point to calculate a real value, so just check the
         *                                                                                           * range for now.
         *                                                                                                                   */
        if (!(conv_num(&bp, &i, 0, 53)))
        return (0);
        break;

    case 'w':       /* The day of week, beginning on sunday. */
        LEGAL_ALT(ALT_O);
        if (!(conv_num(&bp, &tm->tm_wday, 0, 6)))
        return (0);
        break;

    case 'Y':       /* The year. */
        LEGAL_ALT(ALT_E);
        if (!(conv_num(&bp, &i, 0, 9999)))
        return (0);

        tm->tm_year = i - TM_YEAR_BASE;
        break;

    case 'y':       /* The year within 100 years of the epoch. */
        LEGAL_ALT(ALT_E | ALT_O);
        if (!(conv_num(&bp, &i, 0, 99)))
        return (0);

        if (split_year) {
        tm->tm_year = ((tm->tm_year / 100) * 100) + i;
        break;
        }
        split_year = 1;
        if (i <= 68)
        tm->tm_year = i + 2000 - TM_YEAR_BASE;
        else
        tm->tm_year = i + 1900 - TM_YEAR_BASE;
        break;

        /*
         *               * Miscellaneous conversions.
         *                               */
    case 'n':       /* Any kind of white-space. */
    case 't':
        LEGAL_ALT(0);
        while (isspace(*bp))
        bp++;
        break;


    default:        /* Unknown/unsupported conversion. */
        return (0);
    }


    }

    /* LINTED functional specification */
    return ((char *) bp);
}


static int
conv_num(const char **buf, int *dest, int llim, int ulim)
{
    int result = 0;

    /* The limit also determines the number of valid digits. */
    int rulim = ulim;

    if (**buf < '0' || **buf > '9')
    return (0);

    do {
    result *= 10;
    result += *(*buf)++ - '0';
    rulim /= 10;
    } while ((result * 10 <= ulim) && rulim && **buf >= '0' && **buf <= '9');

    if (result < llim || result > ulim)
    return (0);

    *dest = result;
    return (1);
}
#endif
/* The interpreter evaluation engine for jsi. */
#ifndef JSI_LITE_ONLY
#ifndef JSI_AMALGAMATION
#include "jsiInt.h"
#endif
#include <math.h>

/*#define USE_INLINE*/
#ifdef INLINE_ALL
#define INLINE inline
#else
#define INLINE
#endif

#define _jsi_STACK (interp->Stack)
#define _jsi_STACKIDX(s) interp->Stack[s]
#define _jsi_TOP (interp->Stack[interp->Sp-1])
#define _jsi_TOQ (interp->Stack[interp->Sp-2])
#define _jsi_THIS (interp->Obj_this)
#define _jsi_THISIDX(s) interp->Obj_this[s]

static Jsi_Value** ValuesAlloc(Jsi_Interp *interp, int cnt, Jsi_Value**old, int oldsz) {
    int i;
    Jsi_Value **v = (Jsi_Value **)Jsi_Realloc(old, cnt* sizeof(Jsi_Value*));
    for (i=oldsz; i<cnt; i++)
        v[i] = NULL;
    return v;
}

static void SetupStack(Jsi_Interp *interp)
{
    int oldsz = interp->maxStack;
    if (interp->maxStack)
        interp->maxStack += STACK_INCR_SIZE;
    else
        interp->maxStack = STACK_INIT_SIZE;
    _jsi_STACK = ValuesAlloc(interp, interp->maxStack, _jsi_STACK, oldsz);
    _jsi_THIS = ValuesAlloc(interp, interp->maxStack, _jsi_THIS, oldsz);
}

static void jsiPush(Jsi_Interp* interp, int n) {
    int i = 0;
    do {
        if (!_jsi_STACKIDX(interp->Sp))
            _jsi_STACKIDX(interp->Sp) = Jsi_ValueNew1(interp);
        if (!_jsi_THISIDX(interp->Sp))
            _jsi_THISIDX(interp->Sp) = Jsi_ValueNew1(interp);
        if (i++ >= n) break;
        interp->Sp++;
    } while (1);
}

/* Before setting a value in the _jsi_STACK/obj, unlink any reference to it. */

static void ClearStack(register Jsi_Interp *interp, int ofs) {
    Jsi_Value **vPtr = &_jsi_STACKIDX(interp->Sp-ofs), *v = *vPtr;
    if (!v) return;
#ifndef XX_NEWSTACK
    Jsi_ValueReset(interp, vPtr);
#else
    if (v->refCnt<=1)
        Jsi_ValueReset(interp, vPtr);
    else {
        Jsi_DecrRefCount(interp, v);
        _jsi_STACKIDX(interp->Sp-ofs) = Jsi_ValueNew1(interp);
    }
#endif
}

static void ClearThis(register Jsi_Interp *interp, int ofs) {
    Jsi_Value **vPtr = &_jsi_THISIDX(ofs), *v = *vPtr;
    if (!v) return;
#ifndef XX_NEWSTACK
    Jsi_ValueReset(interp, vPtr);
#else
    if (v->refCnt<=1)
        Jsi_ValueReset(interp, vPtr);
    else {
        Jsi_DecrRefCount(interp, v);
        _jsi_THISIDX(ofs) = Jsi_ValueNew1(interp);
    }
#endif
}


/* interp->Sp[-2] = interp->Sp[-1]->var */
static void inline ValueAssign(Jsi_Interp *interp, Jsi_Value *dst, Jsi_Value* src)
{
    Jsi_Value *v;
    if (dst->vt != JSI_VT_VARIABLE) {
        Jsi_LogError("operand not a left value");
    } else {
        v = dst->d.lval;
        SIGASSERT(v, VALUE);
        if (v == src)
            return;
        if (v->f.bits.readonly) {
            Jsi_LogWarn("ignore assign to readonly variable");
            return;
        }
        if (Jsi_ValueIsFunction(interp, src))
            Jsi_ValueMove(interp,v, src);
        else
            Jsi_ValueCopy(interp,v, src);
        SIGASSERT(v, VALUE);
#ifdef JSI_MEM_DEBUG
    if (!v->VD.label2)
        v->VD.label2 = "ValueAssign";
#endif
    }
}

/* pop n values from _jsi_STACK */
static INLINE void jsiPop(Jsi_Interp* interp, int n) {
    int t = n;
    while (t > 0) {
        Assert((interp->Sp-t)>=0);
/*        Jsi_Value *v = _jsi_STACKIDX(interp->Sp-t);
         if (v->refCnt>1) puts("OO");*/
        ClearStack(interp,t);
        --t;
    }
    interp->Sp -= n;
}

/* Convert preceding _jsi_STACK variable(s) into value(s). */
static INLINE void VarDeref(Jsi_Interp* interp, int n) {
    Assert(interp->Sp>=n);
    int i;
    for (i=1; i<=n; i++) {
        Jsi_Value *vb = _jsi_STACKIDX(interp->Sp - i);
        if (vb->vt == JSI_VT_VARIABLE) {
            SIGASSERT(vb->d.lval, VALUE);
            Jsi_ValueCopy(interp, vb, vb->d.lval);
        }
    }
}

#define common_math_opr(opr) {                      \
    VarDeref(interp,2);                                     \
    Jsi_ValueToNumber(interp, _jsi_TOP);     \
    Jsi_ValueToNumber(interp, _jsi_TOQ);     \
    _jsi_TOQ->d.num = _jsi_TOQ->d.num opr _jsi_TOP->d.num;            \
    jsiPop(interp, 1);                                          \
}

#define common_bitwise_opr(opr) {                       \
    int a, b;                                       \
    VarDeref(interp,2);                                     \
    Jsi_ValueToNumber(interp, _jsi_TOP);     \
    Jsi_ValueToNumber(interp, _jsi_TOQ);     \
    a = _jsi_TOQ->d.num; b = _jsi_TOP->d.num;                   \
    _jsi_TOQ->d.num = (Jsi_Number)(a opr b);                  \
    jsiPop(interp, 1);                                          \
}

static INLINE void logic_less(Jsi_Interp* interp, int i1, int i2) {
    Jsi_Value *v, *v1 = _jsi_STACK[interp->Sp-i1], *v2 = _jsi_STACK[interp->Sp-i2], *res = _jsi_TOQ;
    int val = 0, l1 = 0, l2 = 0; 
    char *s1 = Jsi_ValueString(interp, v1, &l1);
    char *s2 = Jsi_ValueString(interp, v2, &l2);
    Jsi_Number n1, n2;

    if (s1 || s2) {
        char *str;
        if (!(s1 && s2)) {
            v = (s1 ? v2 : v1);
            jsi_ValueToPrimitive(interp, &v);
            Jsi_ValueToString(interp, v, NULL);
            str = Jsi_ValueString(interp, v, (s1?&l2:&l1));
            if (s1) s2 = str; else s1 = str;
        }
        Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);
        Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);
        //int mlen = (l1>l2?l1:l2);
        val = Jsi_Strcmp(s1, s2);
  
        if (val > 0) val = 0;
        else if (val < 0) val = 1;
        else val = (l1 < l2);
        ClearStack(interp,2);
        Jsi_ValueMakeBool(interp, &res, val);
    } else {
        Jsi_ValueToNumber(interp, v1);
        Jsi_ValueToNumber(interp, v2);
        n1 = v1->d.num; n2 = v2->d.num;
        if (jsi_ieee_isnan(n1) || jsi_ieee_isnan(n2)) {
            ClearStack(interp,2);
            Jsi_ValueMakeUndef(interp, &res);
        } else {
            val = (n1 < n2);
            ClearStack(interp,2);
            Jsi_ValueMakeBool(interp, &res, val);
        }
    }
}

static const char *vprint(Jsi_Value *v)
{
    static char buf[100];
    if (v->vt == JSI_VT_NUMBER) {
        snprintf(buf, 100, "NUM:%" JSI_NUMGFMT " ", v->d.num);
    } else if (v->vt == JSI_VT_BOOL) {
        snprintf(buf, 100, "BOO:%d", v->d.val);
    } else if (v->vt == JSI_VT_STRING) {
        snprintf(buf, 100, "STR:'%s'", v->d.s.str);
    } else if (v->vt == JSI_VT_VARIABLE) {
        snprintf(buf, 100, "VAR:%p", v->d.lval);
    } else if (v->vt == JSI_VT_NULL) {
        snprintf(buf, 100, "NULL");
    } else if (v->vt == JSI_VT_OBJECT) {
        snprintf(buf, 100, "OBJ:%p", v->d.obj);
    } else if (v->vt == JSI_VT_UNDEF) {
        snprintf(buf, 100, "UNDEFINED");
    }
    return buf;
}

typedef enum {
        TL_TRY,
        TL_WITH,
} try_op_type;                            /* type of try */

typedef enum { LOP_NOOP, LOP_THROW, LOP_JMP } last_try_op_t; 

typedef struct TryList {
    try_op_type type;
    union {
        struct {                    /* try data */
            OpCode *tstart;         /* try start ip */
            OpCode *tend;           /* try end ip */
            OpCode *cstart;         /* ...*/
            OpCode *cend;
            OpCode *fstart;
            OpCode *fend;
            int tsp;
            last_try_op_t last_op;              /* what to do after finally block */
                                    /* depend on last jmp code in catch block */
            union {
                OpCode *tojmp;
            } ld;                   /* jmp out of catch (target)*/
        } td;
        struct {                    /* with data */
            OpCode *wstart;         /* with start */
            OpCode *wend;           /* with end */
        } wd;
    } d;
    
    jsi_ScopeChain *scope_save;         /* saved scope (used in catch block/with block)*/
    Jsi_Value *curscope_save;           /* saved current scope */
    struct TryList *next;
} TryList;

/* destroy top of trylist */
#define pop_try(head) _pop_try(interp, &head)
static INLINE void _pop_try(Jsi_Interp* interp, TryList **head)
{
    interp->tryDepth--;
    TryList *t = (*head)->next;
    Jsi_Free((*head));
    (*head) = t;
}

#define push_try(head, n) _push_try(interp, &head, n)
static INLINE void _push_try(Jsi_Interp* interp, TryList **head, TryList *n)
{
    interp->tryDepth++;
    (n)->next = (*head);
    (*head) = (n);
}

/* restore scope chain */
#define restore_scope() _restore_scope(interp, ps, trylist, \
    &scope, &currentScope, &context_id)
static INLINE void _restore_scope(Jsi_Interp* interp, jsi_Pstate *ps, TryList* trylist,
  jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id) {

/* restore_scope(scope_save, curscope_save)*/
    if (*scope != (trylist->scope_save)) {
        jsi_ScopeChainFree(interp, *scope);
        *scope = (trylist->scope_save);
        interp->ingsc = *scope;
    }
    if (*currentScope != (trylist->curscope_save)) {
        Jsi_DecrRefCount(interp, *currentScope);
        *currentScope = (trylist->curscope_save); 
        interp->incsc = *currentScope;
    }
    *context_id = ps->_context_id++; 
}

#define do_throw() if (_do_throw(interp, ps, &ip, &trylist,&scope, &currentScope, &context_id, (interp->Sp?_jsi_TOP:NULL)) != JSI_OK) { rc = JSI_ERROR; break; }

static int _do_throw(Jsi_Interp *interp, jsi_Pstate *ps, OpCode **ipp, TryList **tlp,
    jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id, Jsi_Value *top) {
    if (Jsi_InterpGone(interp))
        return JSI_ERROR;
    TryList *trylist = *tlp;
    while (1) {                      
        if (trylist == NULL) {
            const char *str = (top?Jsi_ValueString(interp, top, NULL):"");
            if (str)
                Jsi_LogError("%s", str);
            return JSI_ERROR;
        }             
        if (trylist->type == TL_TRY) {                  
            int n = interp->Sp - trylist->d.td.tsp;              
            jsiPop(interp, n);                                   
            if (*ipp >= trylist->d.td.tstart && *ipp < trylist->d.td.tend) {        
                *ipp = trylist->d.td.cstart - 1;                                  
                break;                                                          
            } else if (*ipp >= trylist->d.td.cstart && *ipp < trylist->d.td.cend) { 
                trylist->d.td.last_op = LOP_THROW;                              
                *ipp = trylist->d.td.fstart - 1;                                  
                break;                                                          
            } else if (*ipp >= trylist->d.td.fstart && *ipp < trylist->d.td.fend) { 
                _pop_try(interp, tlp);                                               
                trylist = *tlp;                                                
            } else Jsi_LogBug("Throw within a try, but not in its scope?");            
        } else {                                                                
            _restore_scope(interp, ps, trylist, scope, currentScope, context_id);         
            _pop_try(interp, tlp);   
            trylist = *tlp;                                                
        }                                                                       
    }
    return JSI_OK;
}

static TryList *trylist_new(try_op_type t, jsi_ScopeChain *scope_save, Jsi_Value *curscope_save)
{
    TryList *n = (TryList *)Jsi_Calloc(1,sizeof(*n));
    
    n->type = t;
    n->curscope_save = curscope_save;
    /*Jsi_IncrRefCount(interp, curscope_save);*/
    n->scope_save = scope_save;
    
    return n;
}

static void DumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,
    TryList *trylist, OpCode *ip, OpCodes *opcodes)
{
    int i;
/* if (0 && interp->debug <= 0xf) {
        return;
        if (ip->op != OP_FCALL) return;
        const char *s = interp->lastPushStr;
        const char *ff, *fname = ip->fname?ip->fname:"";
        if (interp->debug<0xf && ((ff=strrchr(fname,'/'))))
            fname = ff+1;
        fprintf(stderr, "CALL: %s() in %s:%d\n", s?s:"", fname, ip->line);
        return;
    }*/
    char buf[200];
    jsi_code_decode(ip, ip - opcodes->codes, buf, sizeof(buf));
    fprintf(stderr, "%-30.200s : THIS=%s, STACK=[", buf, vprint(_this));
    for (i = 0; i < interp->Sp; ++i) {
        fprintf(stderr, "%s%s", (i>0?", ":""), vprint(_jsi_STACKIDX(i)));
    }
    fprintf(stderr, "]\n");
    TryList *tlt = trylist;
    for (i = 0; tlt; tlt = tlt->next) i++;
    if (ps->last_exception)
        fprintf(stderr, "TL: %d, excpt: %s\n", i, vprint(ps->last_exception));
}

static int cmpstringp(const void *p1, const void *p2)
{
   return strcmp(* (char * const *) p1, * (char * const *) p2);
}

static  void SortDString(Jsi_Interp *interp, Jsi_DString *dStr) {
    int argc, i;
    char **argv;
    Jsi_DString sStr;
    Jsi_DSInit(&sStr);
    Jsi_SplitStr(Jsi_DSValue(dStr), &argc, &argv, " ", &sStr);
    qsort(argv, argc, sizeof(char*), cmpstringp);
    Jsi_DSFree(dStr);
    Jsi_DSInit(dStr);
    for (i=0; i<argc; i++) {
        Jsi_DSAppend(dStr, (i?" ":""), argv[i], NULL);
    }
    Jsi_DSFree(&sStr);
}

static void ValueObjDelete(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, int force)
{
    if (target->vt != JSI_VT_OBJECT) return;
    const char *kstr = Jsi_ValueToString(interp, key, NULL);
    Jsi_TreeEntry *hPtr;
    if (!Jsi_ValueIsStringKey(interp, key)) {
        Jsi_HashEntry *hePtr = Jsi_HashEntryFind(target->d.obj->tree->interp->strKeyTbl, kstr);
        if (hePtr)
            kstr = (char*)Jsi_HashKeyGet(hePtr);
    }
    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);
    if (hPtr == NULL || (hPtr->f.bits.dontdel && !force))
        return;
    Jsi_TreeEntryDelete(hPtr);
}

static void ObjGetNames(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_DString* dStr, int flags) {
    Jsi_TreeEntry *hPtr;
    Jsi_TreeSearch srch;
    Jsi_Value *v;
    int m = 0;
    Jsi_DSInit(dStr);
    if (obj->isarrlist)
        obj = interp->Array_prototype->d.obj;
    for (hPtr=Jsi_TreeEntryFirst(obj->tree, &srch,  JSI_TREE_INORDER); hPtr; hPtr=Jsi_TreeEntryNext(&srch)) {
        v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);
        if (!v) continue;
        if ((flags&JSI_NAME_FUNCTIONS) && !Jsi_ValueIsFunction(interp,v)) {
            continue;
        }
        if ((flags&JSI_NAME_DATA) && Jsi_ValueIsFunction(interp,v)) {
            continue;
        }

        Jsi_DSAppend(dStr, (m++?" ":""), Jsi_TreeKeyGet(hPtr), NULL);
    }
    Jsi_TreeSearchDone(&srch);
}

static void DumpFunctions(Jsi_Interp *interp) {
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_CmdSpecItem *csi = NULL;
    Jsi_CmdSpec *cs;
    Jsi_Value *lsf = interp->lastSubscriptFail;
    const char *spnam = "";
    int m = 0;
    if (interp->lastFuncIndex) {
        if (interp->lastFuncIndex->cmdSpec)
            spnam = interp->lastFuncIndex->cmdSpec->name;
    } else if (lsf && lsf->vt == JSI_VT_OBJECT) {
    
        spnam = interp->lastSubscriptFailStr;
        if (!spnam) spnam = interp->lastPushStr;
        if (lsf->d.obj->ot == JSI_OT_USEROBJ && lsf->d.obj->d.uobj->reg && lsf->d.obj->d.uobj->interp == interp) {
            cs = lsf->d.obj->d.uobj->reg->spec;
            if (cs)
                goto dumpspec;
        } else if (lsf->d.obj->ot == JSI_OT_OBJECT) {
            ObjGetNames(interp, lsf->d.obj, &dStr, JSI_NAME_FUNCTIONS);
            Jsi_LogError("'%s', functions are: %s.",
                spnam, Jsi_DSValue(&dStr));
            Jsi_DSFree(&dStr);
            return;
        } else {
            const char *sustr = NULL;
            switch (lsf->d.obj->ot) {
                case JSI_OT_STRING: sustr = "String"; break;
                case JSI_OT_NUMBER: sustr = "Number"; break;
                case JSI_OT_BOOL: sustr = "Boolean"; break;
            }
            if (sustr) {
                hPtr = Jsi_HashEntryFind(interp->cmdSpecTbl, sustr);
                csi = (Jsi_CmdSpecItem*)Jsi_HashValueGet(hPtr);
                cs = csi->spec;
                if (!spnam[0])
                    spnam = sustr;
                goto dumpspec;
            }
        }
    }
    if (!*spnam) {
        for (hPtr = Jsi_HashEntryFirst(interp->cmdSpecTbl, &search);
            hPtr; hPtr = Jsi_HashEntryNext(&search)) {
            csi = (Jsi_CmdSpecItem*)Jsi_HashValueGet(hPtr);
            if (csi->name && csi->name[0])
                Jsi_DSAppend(&dStr, (m++?" ":""), csi->name, NULL);
        }
    }
    
    if ((hPtr = Jsi_HashEntryFind(interp->cmdSpecTbl, spnam))) {
        csi = (Jsi_CmdSpecItem*)Jsi_HashValueGet(hPtr);
        while (csi) {
            int n;
            cs = csi->spec;
dumpspec:
            n = 0;
            while (cs->name) {
                if (n != 0 || !(cs->flags & JSI_CMD_IS_CONSTRUCTOR)) {
                    if (!*cs->name) continue;
                    Jsi_DSAppend(&dStr, (m?" ":""), cs->name, NULL);
                    n++; m++;
                }
                cs++;
            }
            csi = (csi?csi->next:NULL);
        }
        SortDString(interp, &dStr);
        if (interp->lastPushVar)
            spnam = interp->lastPushVar;
        else if (interp->lastPushStr)
            spnam = interp->lastPushStr;
        Jsi_LogError("'%s' is not one of: %s.",
            spnam, Jsi_DSValue(&dStr));
        Jsi_DSFree(&dStr);
    } else {
        Jsi_LogError("can not execute expression: '%s' not a function\n",
            interp->lastPushVar ? interp->lastPushVar : "");
    }
}

/* Attempt to dynamically load function XX by doing an eval of jsiIndex.XX */
/* TODO: prevent infinite loop/recursion. */
static Jsi_Value *LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret) {
    Jsi_DString dStr = {};
    Jsi_Value *v;
    int i;
    for (i=0; i<2; i++) {
        Jsi_DSAppend(&dStr, "jsiIndex.", str, NULL);
        Jsi_VarLookup(interp, Jsi_DSValue(&dStr));
        v = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));
        if (v)
            jsi_ValueDebugLabel(v, "LoadFunction","f1");
        Jsi_DSFree(&dStr);
        if (v) {
            const char *cp = Jsi_ValueGetDString(interp, v, &dStr, 0);
            /*printf("JSS: %s\n", cp);*/
            Jsi_DecrRefCount(interp, v);
            v = NULL;
            if (Jsi_EvalString(interp, cp, 0) == JSI_OK) {
                v = Jsi_NameLookup(interp, str);
                if (v)
                    jsi_ValueDebugLabel(v, "LoadFunction","f2");
            }
            Jsi_DSFree(&dStr);
            if (v) {
                tret = v;
                break;
            }
        }
        if (interp->indexLoaded++ || i>0)
            break;
        /*  Index not in memory, so try loading jsiIndex from the file jsiIndex.jsi */
        if (interp->indexFiles == NULL)
            return tret;
        Jsi_Value **ifs = &interp->indexFiles;
        int i, ifn = 1;
        if (Jsi_ValueIsArray(interp, interp->indexFiles)) {
            ifs = interp->indexFiles->d.obj->arr;
            ifn = interp->indexFiles->d.obj->arrCnt;
        }
        for (i=0; i<ifn; i++) {  
            if (Jsi_EvalFile(interp, ifs[i], 0) != JSI_OK)
                break;
            interp->indexLoaded++;
        }
    }
    interp->lastPushVar = (char*)str;
    return tret;
}

void jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *fstatic, OpCode *iPtr, Jsi_Value* args, Jsi_Value *scope)
{
    OpCode *ip = (iPtr ? iPtr : interp->curIp);
    if (!ip)
        return;
    const char *ff, *fname = ip->fname?ip->fname:"";
    if (interp->callTrace<=1 && ((ff=strrchr(fname,'/'))))
        fname = ff+1;
    if (interp->traceHook)
        (*interp->traceHook)(interp, fstatic->name, ip->fname, ip->line, fstatic->cmdSpec, args, scope);
    else
        fprintf(stderr, "%*s<#%d>: %s() in %s:%d\n", (interp->level-1)*2, "", interp->level, fstatic->name, fname, ip->line);
}

static INLINE int EvalFunction(register jsi_Pstate *ps, OpCode *ip, int discard) {
    int excpt_ret = JSI_OK;
    register Jsi_Interp *interp = ps->interp;
    int as_constructor = (ip->op == OP_NEWFCALL);
    int stackargc = (int)ip->data;
    VarDeref(interp, stackargc + 1);
    
    int tocall_index = interp->Sp - stackargc - 1, adds;
    Jsi_Value *tocall = _jsi_STACKIDX(tocall_index);
    char* failStr = interp->lastSubscriptFailStr;
    char *lpv = interp->lastPushStr;
    if (Jsi_ValueIsUndef(interp, tocall) && interp->lastPushVar && failStr == 0) {
        tocall = LoadFunction(interp, interp->lastPushVar, tocall);
        interp->lastPushStr = lpv;
        interp->curIp = ip;
    }
    if (!Jsi_ValueIsFunction(interp, tocall)) {
        DumpFunctions(interp);
        excpt_ret = JSI_ERROR;
        interp->lastSubscriptFailStr = NULL;
        goto empty_func;
    }
    interp->lastSubscriptFailStr = NULL;
    interp->lastFuncIndex = NULL;

    if (!tocall->d.obj->d.fobj) {   /* empty function */
empty_func:
        jsiPop(interp, stackargc);
        ClearStack(interp,1);
        Jsi_ValueMakeUndef(interp, &_jsi_TOP);
    } else {
        Jsi_Func *fstatic = tocall->d.obj->d.fobj->func;
        if (interp->nDebug && fstatic->callback == jsi_AssertCmd)
            goto empty_func;
        const char *onam = fstatic->name;
        if (!onam) // Override blank name with last index.
            fstatic->name = lpv;
        adds = fstatic->callflags.bits.addargs;
        if (adds && (fstatic->cmdSpec->flags&JSI_CMDSPEC_NONTHIS))
            adds = 0;
        /* create new scope, prepare arguments */
        /* here we shared scope and 'arguments' with the same object */
        /* so that arguments[0] is easier to shared space with first local variable */
        Jsi_Value *newscope = Jsi_ValueNew1(interp);
        Jsi_Obj *ao = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->Sp - stackargc), stackargc, 1);

        if (fstatic->bindArgs) {
            int nc, bargc = Jsi_ValueGetLength(interp, fstatic->bindArgs)-1;
            if (bargc > 0) {
                Jsi_ObjArraySizer(interp, ao, nc=(ao->arrCnt+bargc));
                memmove(ao->arr+bargc, ao->arr, sizeof(Jsi_Value*)*ao->arrCnt);
                memmove(ao->arr, fstatic->bindArgs->d.obj->arr+1, sizeof(Jsi_Value*)*bargc);
                ao->arrCnt = nc;
            }
        }
        Jsi_ValueMakeObject(interp, &newscope, ao);
        newscope->d.obj->__proto__ = interp->Object_prototype;          /* ecma */
        
        excpt_ret = jsi_SharedArgs(interp, newscope, fstatic, 1); /* make arg vars to shared arguments */
        fstatic->callflags.bits.addargs = 0;
        jsi_InitLocalVar(interp, newscope, fstatic);
        jsi_SetCallee(interp, newscope, tocall);
        
        jsiPop(interp, stackargc);
    
        Jsi_Value *ntPtr;
        if (fstatic->bindArgs && Jsi_ValueTypeGet(fstatic->bindArgs->d.obj->arr[0]) != JSI_VT_UNDEF) {
            ntPtr = Jsi_ValueDup(interp, Jsi_ValueArrayIndex(interp, fstatic->bindArgs, 0));
            
        } else if (_jsi_THISIDX(tocall_index)->vt == JSI_VT_OBJECT) {
            ntPtr = Jsi_ValueDup(interp, _jsi_THISIDX(tocall_index));
            ClearThis(interp, tocall_index);
        } else {
            ntPtr = Jsi_ValueDup(interp, interp->Top_object);
        }

        if (as_constructor) {                       /* new Constructor */
            Jsi_Obj *newobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);
            Jsi_Value *proto = Jsi_ValueObjLookup(interp, tocall, "prototype", 0);
            if (proto && proto->vt == JSI_VT_OBJECT)
                newobj->__proto__ = proto;
            Jsi_ValueReset(interp, &ntPtr);
            Jsi_ValueMakeObject(interp, &ntPtr, newobj);            
            /* TODO: constructor specifics??? */
        }
        
        if (interp->callTrace && fstatic->name)
            jsi_TraceFuncCall(interp, fstatic, ip, ntPtr, newscope);

        Jsi_Value *spretPtr = Jsi_ValueNew1(interp), *spretPtrOld = spretPtr;
        
        Jsi_Func *prevActive = interp->activeFunc;
        interp->activeFunc = fstatic;
        int docall = (excpt_ret==JSI_OK);
        if (fstatic->type == FC_NORMAL) {
            if (docall)
                excpt_ret = jsi_evalcode(ps, fstatic->opcodes, tocall->d.obj->d.fobj->scope, 
                    newscope, ntPtr, &spretPtr);
            interp->funcCallCnt++;
        } else if (!fstatic->callback) {
            Jsi_LogError("can not call:\"%s()\"", fstatic->name);
        } else {
            int oldcf = fstatic->callflags.i;
            fstatic->callflags.bits.iscons = (as_constructor?JSI_CALL_CONSTRUCTOR:0);
            if (fstatic->f.bits.hasattr)
            {
#define SPTR(s) (s?s:"")
                if ((fstatic->f.bits.isobj) && ntPtr->vt != JSI_VT_OBJECT) {
                    excpt_ret = JSI_ERROR;
                    docall = 0;
                    Jsi_LogError("'this' is not object: \"%s()\"", fstatic->name);
                } else if ((!(fstatic->f.bits.iscons)) && as_constructor) {
                    excpt_ret = JSI_ERROR;
                    docall = 0;
                    Jsi_LogError("can not call as constructor: \"%s()\"", fstatic->name);
                } else {
                    int aCnt = Jsi_ValueGetLength(interp, newscope);
                    if (aCnt<(fstatic->cmdSpec->minArgs+adds)) {
                        Jsi_LogError("missing args, expected \"%s(%s)\" ", fstatic->cmdSpec->name, SPTR(fstatic->cmdSpec->argStr));
                        excpt_ret = JSI_ERROR;
                        docall = 0;
                    } else if (fstatic->cmdSpec->maxArgs>=0 && (aCnt>fstatic->cmdSpec->maxArgs+adds)) {
                        Jsi_LogError("extra args, expected \"%s(%s)\" ", fstatic->cmdSpec->name, SPTR(fstatic->cmdSpec->argStr));
                        excpt_ret = JSI_ERROR;
                        docall = 0;
                    }
                }
            }
            if (docall) {
                fstatic->callflags.bits.isdiscard = discard;
                excpt_ret = fstatic->callback(interp, newscope, 
                    ntPtr, &spretPtr, fstatic);
                interp->cmdCallCnt++;
            }
            fstatic->callflags.i = oldcf;
        }
        if (!onam)
            fstatic->name = NULL;
        if (docall) {
            fstatic->callCnt++;
            if (excpt_ret == JSI_OK && fstatic->retType)
                excpt_ret = jsi_ArgTypeCheck(interp, fstatic->retType, spretPtr, "returned from", fstatic->name, 0, fstatic);
        }
        interp->activeFunc = prevActive;

        if (as_constructor) {
            if (ntPtr->vt == JSI_VT_OBJECT)
                ntPtr->d.obj->constructor = tocall->d.obj;
            if (spretPtr->vt != JSI_VT_OBJECT) {
                Jsi_ValueReset(interp,&spretPtr);
                Jsi_ValueCopy(interp, spretPtr, ntPtr);
            }
        }
        
        jsi_SharedArgs(interp, newscope, fstatic, 0); /* make arg vars to shared arguments */
        Jsi_DecrRefCount(interp, ntPtr);
        ClearStack(interp,1);
        if (spretPtr == spretPtrOld) {
            Jsi_ValueMove(interp, _jsi_TOP, spretPtr);
            Jsi_DecrRefCount(interp, spretPtr);
        } else {
            /*  returning a (non-copied) value reference */
            Jsi_DecrRefCount(interp, _jsi_TOP);
            _jsi_TOP = spretPtr;
        }
        Jsi_DecrRefCount(interp, newscope);
    }
    return excpt_ret;
}

static INLINE void PushVar(jsi_Pstate *ps, OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope, int context_id) {
    register Jsi_Interp *interp = ps->interp;
    FastVar *fvar = (FastVar *)ip->data;
    SIGASSERT(fvar,FASTVAR);
    Jsi_Value **dvPtr = &_jsi_STACKIDX(interp->Sp), *dv = *dvPtr, *v = NULL;
    if (fvar->context_id == context_id && fvar->ps == ps) {
        v = fvar->var.lval;
    } else {
        char *varname = fvar->var.varname;
        if (*varname == 'n' && Jsi_Strcmp(varname,"null") == 0)
            v = interp->NullValue;
        else {
            v = Jsi_ValueObjLookup(interp, currentScope, varname, 1);
        }
        if (!v)
            v = jsi_ScopeChainObjLookupUni(scope, varname);
        if (!v) {
            /* add to global scope.  TODO: do not define if a right_val??? */
            Jsi_Value *global_scope = scope->chains_cnt > 0 ? scope->chains[0]:currentScope;
            Jsi_Value key = VALINIT, *kPtr = &key; // Note: a string key so no reset needed.
            Jsi_ValueMakeStringKey(interp, &kPtr, varname);
            interp->lastPushVar = key.d.s.str; 
            v = jsi_ValueObjKeyAssign(interp, global_scope, &key, NULL, JSI_OM_DONTENUM);
            jsi_ValueDebugLabel(v, "var", varname);
            int isNew;
            Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);
            if (hPtr && isNew)
                Jsi_HashValueSet(hPtr, 0);
        }
        
        Jsi_IncrRefCount(interp, v);
        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT)
            v->f.bits.onstack = 1;  /* Indicate that a double free is required for object. */

    }
    if (dv != v && (dv->vt != JSI_VT_VARIABLE || dv->d.lval != v)) {
        if (dv->vt != JSI_VT_VARIABLE)
            Jsi_ValueReset(interp, dvPtr);
        dv->vt = JSI_VT_VARIABLE;
        SIGASSERT(v, VALUE);
        dv->d.lval = v;
        //Jsi_IncrRefCount(interp, v);
    }
    SIGASSERT(v, VALUE);
    jsiPush(interp,1);
}

static INLINE void PushFunc(jsi_Pstate *ps, OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope) {
    /* TODO: now that we're caching ps, may need to reference function ps for context_id??? */
    Jsi_Interp *interp = ps->interp;
    Jsi_FuncObj *fo = jsi_FuncObjNew(interp, (Jsi_Func *)ip->data);
    fo->scope = jsi_ScopeChainDupNext(interp, scope, currentScope);
    
    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_FUNCTION);
    obj->d.fobj = fo;
    
    Jsi_Value *v = _jsi_STACKIDX(interp->Sp), *fun_prototype = jsi_ObjValueNew(interp);
    fun_prototype->d.obj->__proto__ = interp->Object_prototype;                
    Jsi_ValueMakeObject(interp, &v, obj);
    Jsi_ValueInsert(interp, v, "prototype", fun_prototype, JSI_OM_DONTDEL|JSI_OM_DONTENUM);
    /* TODO: make own prototype and prototype.constructor */
    
    int isNew;
    Jsi_HashEntry *hPtr;
    if (interp->Sp == 1 && _jsi_STACKIDX(0)->vt == JSI_VT_VARIABLE) {
        if (interp->lastPushVar) {
            if (!fo->func->name)
                fo->func->name = interp->lastPushVar;
            hPtr = Jsi_HashEntryNew(interp->varTbl, interp->lastPushVar, &isNew);
            if (hPtr)
                Jsi_HashValueSet(hPtr, obj);
        }
    }
    hPtr = Jsi_HashEntryNew(interp->funcObjTbl, fo, &isNew);
    if (hPtr && isNew) {
        Jsi_ObjIncrRefCount(interp, obj);
        Jsi_HashValueSet(hPtr, obj);
    }
    jsiPush(interp,1);
}

static void evalSubscript(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *idx, OpCode *ip,  OpCode *end,
    Jsi_Value *currentScope) {

    VarDeref(interp,2);
    if (Jsi_ValueIsString(interp, src) && Jsi_ValueIsNumber(interp, idx)) {
        int sLen;
        char bbuf[10], *cp = Jsi_ValueString(interp, src, &sLen);
        int n = (int)idx->d.num;
        if (n<0 || n>=sLen) {
            Jsi_ValueMakeUndef(interp, &src);
        } else {
            bbuf[1] = 0;
            bbuf[0] = cp[n];
            Jsi_ValueMakeStringDup(interp, &src, bbuf);
        }
        jsiPop(interp, 1);
        return;
    }
    Jsi_ValueToObject(interp, src);
    if (interp->hasCallee && src->d.obj == currentScope->d.obj) {
        if (idx->vt == JSI_VT_STRING && Jsi_Strcmp(idx->d.s.str, "callee") == 0) {
            ClearStack(interp,1);
            Jsi_ValueMakeStringKey(interp, &idx, "\1callee\1");
        }
    }
    if (interp->lastSubscriptFail && interp->lastSubscriptFail->vt != JSI_VT_UNDEF) {
        Jsi_ValueReset(interp, &interp->lastSubscriptFail);
        interp->lastSubscriptFailStr = NULL;
    }
    if (src->vt != JSI_VT_UNDEF) {
        Jsi_Value res = VALINIT, *resPtr = &res;
        jsi_ValueSubscriptLen(interp, src, idx, &resPtr, (int)ip->data);
        int isfcall = ((ip+3)<end && ip[2].op == OP_FCALL);
        if (res.vt == JSI_VT_UNDEF && isfcall) {
            /* eg. so we can list available commands for  "db.xx()" */
            Jsi_ValueDup2(interp, &interp->lastSubscriptFail, src);
            if (Jsi_ValueIsString(interp, idx))
                interp->lastSubscriptFailStr = Jsi_ValueString(interp, idx, NULL);
        }
        ClearStack(interp,2);
        if (resPtr == &res) {
            Jsi_ValueCopy(interp, src, &res); /*TODO: need to rethink this. */
        } else
            Jsi_ValueMove(interp, src, resPtr); 
        if (res.vt == JSI_VT_OBJECT || res.vt == JSI_VT_STRING)  // TODO:*** Undo using ValueCopy twice. ***
            Jsi_ValueReset(interp, &resPtr);
    }
    jsiPop(interp, 1);
}


int _jsi_evalcode(register jsi_Pstate *ps, OpCodes *opcodes, 
     jsi_ScopeChain *scope, Jsi_Value *currentScope,
     Jsi_Value *_this, Jsi_Value *vret)
{
    register Jsi_Interp* interp = ps->interp;
    OpCode *ip = &opcodes->codes[0];
    int rc = JSI_OK, context_id = ps->_context_id++;
    OpCode *end = &opcodes->codes[opcodes->code_len];
    TryList  *trylist = NULL;
    
    if (currentScope->vt != JSI_VT_OBJECT) {
        Jsi_LogBug("Eval: current scope is not a object\n");
        return JSI_ERROR;
    }
    
    while(ip < end && rc == JSI_OK) {
        if (interp->exited) {
            rc = JSI_ERROR;
            break;
        }
        interp->opCnt++;
        if (interp->maxOpCnt && interp->maxOpCnt > interp->opCnt) {
            Jsi_LogError("Execution cap exceeded");
            rc = JSI_ERROR;
        }
        if (interp->level > interp->maxDepth) {
            Jsi_LogError("Infinite recursion detected?");
            rc = JSI_ERROR;
            break;
        }
        if (interp->opTrace) {
            DumpInstr(interp, ps, _this, trylist, ip, opcodes);
        }
        
#ifndef USE_STATIC_STACK
        if ((interp->maxStack-interp->Sp)<STACK_MIN_PAD)
            SetupStack(interp);
#endif
        jsiPush(interp,0);
        interp->curIp = ip;
        if (interp->evalHook && (*interp->evalHook)(interp, interp->curFile, interp->curIp->line) != JSI_OK) {
            rc = JSI_ERROR;
            break;
        }
        switch(ip->op) {
            case OP_NOP:
            case OP_LASTOP:
                break;
            case OP_PUSHUND:
                Jsi_ValueMakeUndef(interp, &_jsi_STACKIDX(interp->Sp));
                jsiPush(interp,1);
                break;
            case OP_PUSHBOO:
                Jsi_ValueMakeBool(interp, &_jsi_STACKIDX(interp->Sp), (int)ip->data);
                jsiPush(interp,1);
                break;
            case OP_PUSHNUM:
                Jsi_ValueMakeNumber(interp, &_jsi_STACKIDX(interp->Sp), (*((Jsi_Number *)ip->data)));
                jsiPush(interp,1);
                break;
            case OP_PUSHSTR: {
                interp->lastFuncIndex = NULL;
                Jsi_ValueMakeStringKey(interp,&_jsi_STACKIDX(interp->Sp), (char*)ip->data);
                interp->lastPushStr = Jsi_ValueString(interp, _jsi_STACKIDX(interp->Sp), NULL);
                jsiPush(interp,1);
                break;
            }
            case OP_PUSHVAR: {
                PushVar(ps, ip, scope, currentScope, context_id);
                break;
            }
            case OP_PUSHFUN: {
                PushFunc(ps, ip, scope, currentScope);
                break;
            }
            case OP_NEWFCALL:
                if (interp->maxUserObjs && interp->userObjCnt > interp->maxUserObjs) {
                    Jsi_LogError("Max 'new' count exceeded");
                    rc = JSI_ERROR;
                    break;
                }
            case OP_FCALL: {
                /* TODO: need reliable way to capture func string name to handle unknown functions.*/
                int discard = ((ip+2)<end && ip[1].op == OP_POP);
                if (EvalFunction(ps, ip, discard) != JSI_OK) {        /* throw an execption */
                    do_throw();

                }
                /* TODO: new Function return a function without scopechain, add here */
                break;
            }
            case OP_SUBSCRIPT: {
                evalSubscript(interp, _jsi_TOQ, _jsi_TOP, ip, end, currentScope);
                break;
            }
            case OP_ASSIGN: {
                if ((int)ip->data == 1) {
                    VarDeref(interp,1);
                    ValueAssign(interp, _jsi_TOQ, _jsi_TOP);                    
                    jsiPop(interp,1);
                } else {
                    VarDeref(interp, 3);
                    Jsi_Value *v3 = _jsi_STACKIDX(interp->Sp-3);
                    if (v3->vt == JSI_VT_OBJECT) {
                        jsi_ValueObjKeyAssign(interp, v3, _jsi_TOQ, _jsi_TOP, 0);
                        jsi_ValueDebugLabel(_jsi_TOP, "assign", NULL);
                    } else
                        Jsi_LogWarn("assign to a non-exist object\n");
                    ClearStack(interp,3);
                    Jsi_ValueCopy(interp,v3, _jsi_TOP);
                    jsiPop(interp, 2);
                }
                break;
            }
            case OP_PUSHREG: {
                Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_REGEXP);
                obj->d.robj = (Jsi_Regex *)ip->data;
                Jsi_ValueMakeObject(interp, &_jsi_STACKIDX(interp->Sp), obj);
                jsiPush(interp,1);
                break;
            }
            case OP_PUSHARG: //TODO: Value copy can cause memory leak!
                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->Sp), currentScope);
                jsiPush(interp,1);
                break;
            case OP_PUSHTHS: //TODO: Value copy can cause memory leak!
                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->Sp), _this);
                jsiPush(interp,1);
                break;
            case OP_PUSHTOP:
                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->Sp), _jsi_TOP);
                jsiPush(interp,1);
                break;
            case OP_UNREF:
                VarDeref(interp,1);
                break;
            case OP_PUSHTOP2:
                Jsi_ValueCopy(interp, _jsi_STACKIDX(interp->Sp), _jsi_TOQ);
                Jsi_ValueCopy(interp, _jsi_STACKIDX(interp->Sp+1), _jsi_TOP);
                jsiPush(interp, 2);
                break;
            case OP_CHTHIS: {
                if (ip->data) {
                    int t = interp->Sp - 2;
                    Assert(t>=0);
                    Jsi_Value *v = _jsi_THISIDX(t);
                    ClearThis(interp, t);
                    Jsi_ValueCopy(interp, v, _jsi_TOQ);
                    if (v->vt == JSI_VT_VARIABLE) {
                        Jsi_ValueCopy(interp, v, v->d.lval);
                    }
                    Jsi_ValueToObject(interp, v);
                }
                break;
            }
            case OP_LOCAL: {
                Jsi_Value key = VALINIT, *kPtr = &key; // Note: a string key so no reset needed.
                Jsi_ValueMakeStringKey(interp, &kPtr, (char*)ip->data);
                jsi_ValueObjKeyAssign(interp, currentScope, kPtr, NULL, JSI_OM_DONTENUM);
                
                /* make all FastVar to be relocated */
                context_id = ps->_context_id++;
                break;
            }
            case OP_POP:
                if ((interp->evalFlags&JSI_EVAL_RETURN) && (ip+1) >= end && 
                (Jsi_ValueIsObjType(interp, _jsi_TOP, JSI_OT_ITER)==0 &&
                Jsi_ValueIsObjType(interp, _jsi_TOP, JSI_OT_FUNCTION)==0)) {
                    /* Interactive and last instruction is a pop: save result. */
                    Jsi_ValueMove(interp, vret,_jsi_TOP); /*TODO***: correct ***/
                    _jsi_TOP->vt = JSI_VT_UNDEF;
                }
                jsiPop(interp, (int)ip->data);
                break;
            case OP_NEG:
                VarDeref(interp,1);
                Jsi_ValueToNumber(interp, _jsi_TOP);
                _jsi_TOP->d.num = -(_jsi_TOP->d.num);
                break;
            case OP_POS:
                VarDeref(interp,1);
                Jsi_ValueToNumber(interp, _jsi_TOP);
                break;
            case OP_NOT: {
                int val = 0;
                VarDeref(interp,1);
                
                val = Jsi_ValueIsTrue(interp, _jsi_TOP);
                
                ClearStack(interp,1);
                Jsi_ValueMakeBool(interp, &_jsi_TOP, !val);
                break;
            }
            case OP_BNOT: {
                VarDeref(interp,1);
                jsi_ValueToOInt32(interp, _jsi_TOP);
                _jsi_TOP->d.num = (Jsi_Number)(~((int)_jsi_TOP->d.num));
                break;
            }
            case OP_ADD: {
                VarDeref(interp,2);
                Jsi_Value *v, *v1 = _jsi_TOP, *v2 = _jsi_TOQ;
                int l1, l2;
                char *s1 = Jsi_ValueString(interp, v1, &l1);
                char *s2 = Jsi_ValueString(interp, v2, &l2);
                if (s1 || s2) {
                    char *str;
                    if (!(s1 && s2)) {
                        v = (s1 ? v2 : v1);
                        jsi_ValueToPrimitive(interp, &v);
                        Jsi_ValueToString(interp, v, NULL);
                        str = Jsi_ValueString(interp, v, (s1?&l2:&l1));
                        if (s1) s2 = str; else s1 = str;
                    }
                    Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);
                    Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);
                    str = (char*)Jsi_Malloc(l1+l2+1);
                    memcpy(str, s2, l2);
                    memcpy(str+l2, s1, l1);
                    str[l1+l2] = 0;
                    ClearStack(interp,2);
                    Jsi_ValueMakeString(interp, &v2, str);
                } else {
                    Jsi_ValueToNumber(interp, v1);
                    Jsi_ValueToNumber(interp, v2);
                    Jsi_Number n = v1->d.num + v2->d.num;
                    ClearStack(interp,2);
                    Jsi_ValueMakeNumber(interp, &v2, n);
                }
                jsiPop(interp,1);
                break;
            }
            case OP_IN: {
                Jsi_Value *v, *vl;
                const char *cp = NULL;
                Jsi_Number nval;
                VarDeref(interp,2);
                vl = _jsi_TOQ;
                v = _jsi_TOP;
                if (Jsi_ValueIsString(interp,vl))
                    cp = Jsi_ValueGetStringLen(interp, vl, NULL);
                else if (Jsi_ValueIsNumber(interp,vl))
                    Jsi_ValueGetNumber(interp, vl, &nval);
                else {
                    /*Jsi_LogError("expected string or number before IN");*/
                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);
                    jsiPop(interp,1);
                    break;
                }
                
                if (v->vt == JSI_VT_VARIABLE) {
                    v = v->d.lval;
                    SIGASSERT(v, VALUE);
                }
                if (v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_OBJECT) {
                    /*Jsi_LogError("expected object after IN");*/
                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);
                    jsiPop(interp,1);
                    break;
                }
                int bval = 0;
                char nbuf[100];
                Jsi_Value *vv;
                Jsi_Obj *obj = v->d.obj;
                if (!cp) {
                    sprintf(nbuf, "%d", (int)nval);
                    cp = nbuf;
                }
                if (obj->arr) {
                    vv = jsi_ObjArrayLookup(interp, obj, (char*)cp);
                } else {
                    vv = Jsi_TreeObjGetValue(obj, (char*)cp, 1);
                }
                bval = (vv != 0);
                Jsi_ValueMakeBool(interp, &_jsi_TOQ, bval);
                jsiPop(interp,1);
                break;
            }
            case OP_SUB: 
                common_math_opr(-); break;
            case OP_MUL:
                common_math_opr(*); break;
            case OP_DIV:
                common_math_opr(/); break;
            case OP_MOD: {
                VarDeref(interp,2);
                if (!Jsi_ValueIsType(interp,_jsi_TOP, JSI_VT_NUMBER))
                    Jsi_ValueToNumber(interp, _jsi_TOP);
                if (!Jsi_ValueIsType(interp,_jsi_TOQ, JSI_VT_NUMBER))
                    Jsi_ValueToNumber(interp, _jsi_TOQ);
                _jsi_TOQ->d.num = fmod(_jsi_TOQ->d.num, _jsi_TOP->d.num);
                jsiPop(interp,1);
                break;
            }
            case OP_LESS:
                VarDeref(interp,2);
                logic_less(interp,2,1);
                jsiPop(interp,1);
                break;
            case OP_GREATER:
                VarDeref(interp,2);
                logic_less(interp,1,2);
                jsiPop(interp,1);
                break;
            case OP_LESSEQU:
                VarDeref(interp,2);
                logic_less(interp,1,2);
                _jsi_TOQ->d.val = !_jsi_TOQ->d.val;
                jsiPop(interp,1);
                break;
            case OP_GREATEREQU:
                VarDeref(interp,2);
                logic_less(interp,2,1);
                _jsi_TOQ->d.val = !_jsi_TOQ->d.val;
                jsiPop(interp,1);
                break;
            case OP_EQUAL:
            case OP_NOTEQUAL: {
                VarDeref(interp,2);
                int r = Jsi_ValueCmp(interp, _jsi_TOP, _jsi_TOQ, 0);
                r = (ip->op == OP_EQUAL ? !r : r);
                ClearStack(interp,2);
                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);
                jsiPop(interp,1);
                break;
            }
            case OP_STRICTEQU:
            case OP_STRICTNEQ: {
                int r = 0;
                VarDeref(interp,2);
                r = !Jsi_ValueIsEqual(interp, _jsi_TOP, _jsi_TOQ);
                r = (ip->op == OP_STRICTEQU ? !r : r);
                ClearStack(interp,2);
                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);
                jsiPop(interp,1);
                break;
            }
            case OP_BAND: 
                common_bitwise_opr(&); break;
            case OP_BOR:
                common_bitwise_opr(|); break;
            case OP_BXOR:
                common_bitwise_opr(^); break;
            case OP_SHF: {
                VarDeref(interp,2);
                jsi_ValueToOInt32(interp, _jsi_TOQ);
                jsi_ValueToOInt32(interp, _jsi_TOP);
                int t1 = (int)_jsi_TOQ->d.num;
                int t2 = ((unsigned int)_jsi_TOP->d.num) & 0x1f;
                if (ip->data) {                 /* shift right */
                    if ((int)ip->data == 2) {   /* unsigned shift */
                        unsigned int t3 = (unsigned int)t1;
                        t3 >>= t2;
                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t3);
                    } else {
                        t1 >>= t2;
                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);
                    }
                } else {
                    t1 <<= t2;
                    Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);
                }
                jsiPop(interp,1);
                break;
            }
            case OP_KEY: {
                VarDeref(interp,1);
                if (_jsi_TOP->vt != JSI_VT_UNDEF && _jsi_TOP->vt != JSI_VT_NULL)
                    Jsi_ValueToObject(interp, _jsi_TOP);
                Jsi_Value *spret = Jsi_ValueNew1(interp);
                jsi_ValueObjGetKeys(interp, _jsi_TOP, spret);
                Jsi_ValueReplace(interp, _jsi_STACK+interp->Sp, spret);  
                Jsi_DecrRefCount(interp, spret);  
                jsiPush(interp,1);
                break;
            }
            case OP_NEXT: {
                if (_jsi_TOQ->vt != JSI_VT_OBJECT || _jsi_TOQ->d.obj->ot != JSI_OT_ITER) Jsi_LogBug("next: _jsi_TOQ not a iter\n");
                if (_jsi_TOP->vt != JSI_VT_VARIABLE) {
                    Jsi_LogError ("invalid for/in left hand-side\n");
                    break;
                }
                
                Jsi_IterObj *io = _jsi_TOQ->d.obj->d.iobj;
                if (io->iterCmd) {
                    io->iterCmd(io, _jsi_TOP, _jsi_STACKIDX(interp->Sp-3), io->iter++);
                } else {
                    while (io->iter < io->count) {
                        if (!io->isArrayList) {
                            if (Jsi_ValueKeyPresent(interp, _jsi_STACKIDX(interp->Sp-3), io->keys[io->iter],1)) 
                                break;
                        } else {
                            while (io->cur < io->obj->arrCnt) {
                                if (io->obj->arr[io->cur]) break;
                                io->cur++;
                            }
                            if (io->cur >= io->obj->arrCnt) {
                                /* TODO: Is this really a bug??? */
                                /* Jsi_LogBug("NOT FOUND LIST ARRAY\n");*/
                                io->iter = io->count;
                                break;
                            } else if (io->obj->arr[io->cur]) {
                                io->cur++;
                                break;
                            }
                        }
                        io->iter++;
                    }
                    if (io->iter >= io->count) {
                        ClearStack(interp,1);
                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 0);
                    } else {
                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;
                        SIGASSERT(v, VALUE);
                        Jsi_ValueReset(interp, vPtr);
                        if (io->isArrayList)
                            Jsi_ValueMakeNumber(interp, &v, io->cur-1);
                        else
                            Jsi_ValueMakeStringKey(interp, &v, io->keys[io->iter]);
                        io->iter++;
                        
                        ClearStack(interp,1);
                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 1);
                    }
                    break;
                }
            }
            case OP_INC:
            case OP_DEC: {
                int inc = ip->op == OP_INC ? 1 : -1;
                
                if (_jsi_TOP->vt != JSI_VT_VARIABLE) {
                    Jsi_LogError("operand not left value\n");
                    break;
                }
                Jsi_Value *v = _jsi_TOP->d.lval;
                SIGASSERT(v, VALUE);
                Jsi_ValueToNumber(interp, v);
                
                v->d.num += inc;
                    
                VarDeref(interp,1);
                if (ip->data) {
                    _jsi_TOP->d.num -= inc;
                }
                break;
            }
            case OP_TYPEOF: {
                const char *typ;
                Jsi_Value *v = _jsi_TOP;
                if (v->vt == JSI_VT_VARIABLE) {
                    v = v->d.lval;
                    SIGASSERT(v, VALUE);
                }
                typ = Jsi_ValueTypeStr(interp, v);
                VarDeref(interp,1);
                Jsi_ValueMakeStringKey(interp, &_jsi_TOP, (char*)typ);
                break;
            }
            case OP_INSTANCEOF: {

                VarDeref(interp,2);
                int bval = Jsi_ValueInstanceOf(interp, _jsi_TOQ, _jsi_TOP);
                jsiPop(interp,1);
                Jsi_ValueMakeBool(interp, &_jsi_TOP, bval);
                break;
            }
            case OP_JTRUE:
            case OP_JFALSE: 
            case OP_JTRUE_NP:
            case OP_JFALSE_NP: {
                VarDeref(interp,1);
                int off = (int)ip->data - 1; 
                int r = Jsi_ValueIsTrue(interp, _jsi_TOP);
                
                if (ip->op == OP_JTRUE || ip->op == OP_JFALSE) jsiPop(interp,1);
                ip += ((ip->op == OP_JTRUE || ip->op == OP_JTRUE_NP) ^ r) ? 0 : off;
                break;
            }
            case OP_JMPPOP: 
                jsiPop(interp, ((JmpPopInfo *)ip->data)->topop);
            case OP_JMP: {
                int off = ip->op == OP_JMP ? (int)ip->data - 1
                            : ((JmpPopInfo *)ip->data)->off - 1;

                while (1) {
                    if (trylist == NULL) break;
                    OpCode *tojmp = ip + off;

                    /* jmp out of a try block, should execute the finally block */
                    /* while jmp out a 'with' block, restore the scope */

                    if (trylist->type == TL_TRY) { 
                        if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) break;
                        
                        if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {
                            trylist->d.td.last_op = LOP_JMP;
                            trylist->d.td.ld.tojmp = tojmp;
                            
                            ip = trylist->d.td.fstart - 1;
                            off = 0;
                            break;
                        } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {
                            pop_try(trylist);
                        } else Jsi_LogBug("jmp within a try, but not in its scope?");
                    } else {
                        /* with block */
                        
                        if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) break;
                        
                        restore_scope();
                        pop_try(trylist);
                    }
                }
                
                ip += off;
                break;
            }
            case OP_EVAL: {
                int stackargc = (int)ip->data;
                VarDeref(interp, stackargc);

                int r = 0;
                Jsi_Value *spPtr = Jsi_ValueNew1(interp);
                if (stackargc > 0) {
                    if (_jsi_STACKIDX(interp->Sp - stackargc)->vt == JSI_VT_UNDEF) {
                        Jsi_LogError("eval undefined value\n");
                        goto undef_eval;
                    }
                    char *pro = Jsi_ValueString(interp, _jsi_STACKIDX(interp->Sp - stackargc), NULL);
                    if (pro) {
                        pro = Jsi_Strdup(pro);
                        r = jsi_global_eval(interp, ps, pro, scope, currentScope, _this, &spPtr);
                        Jsi_Free(pro);
                    } else {
                        Jsi_ValueCopy(interp, spPtr, _jsi_STACKIDX(interp->Sp - stackargc));
                    }
                }
undef_eval:
                jsiPop(interp, stackargc);
                Jsi_ValueCopy(interp, _jsi_STACK[interp->Sp], spPtr); /*TODO: is this correct?*/
                Jsi_DecrRefCount(interp, spPtr);
                jsiPush(interp,1);

                if (r) {
                    do_throw();
                }
                break;
            }
            case OP_RET: {
                if (interp->Sp>=1) {
                    VarDeref(interp,1);
                    Jsi_ValueMove(interp,vret, _jsi_TOP);
                }
                jsiPop(interp, (int)ip->data);
                interp->didReturn = 1;
                if (trylist) {
                    int isTry = 0;
                    while (trylist) {
                        if (trylist->type == TL_TRY)
                            isTry = 1;
                        pop_try(trylist);
                    }
                    if (isTry)
                        Jsi_LogWarn("return inside try/catch is unsupported");
                    goto done;
                }
                ip = end;
                break;
            }
            case OP_DELETE: {
                int count = (int)ip->data;
                if (count == 1) {
                    if (_jsi_TOP->vt != JSI_VT_VARIABLE) {
                        Jsi_LogError("delete a right value\n");
                    } else {
                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;
                        SIGASSERT(v, VALUE);
                       if (v != currentScope) {
                            Jsi_ValueReset(interp,vPtr);     /* not allow to delete arguments */
                        }
                        else Jsi_LogWarn("Delete arguments\n");
                    }
                    jsiPop(interp,1);
                } else if (count == 2) {
                    VarDeref(interp,2);
                    assert(interp->Sp>=2);
                    if (_jsi_TOQ->vt != JSI_VT_OBJECT) Jsi_LogWarn("delete non-object key, ignore\n");
                    if (_jsi_TOQ->d.obj == currentScope->d.obj) Jsi_LogWarn("Delete arguments\n");
                    
                    ValueObjDelete(interp, _jsi_TOQ, _jsi_TOP, 0);
                    
                    jsiPop(interp,2);
                } else Jsi_LogBug("delete");
                break;
            }
            case OP_OBJECT: {
                int itemcount = (int)ip->data;
                Assert(itemcount>=0);
                VarDeref(interp, itemcount * 2);
                Jsi_Obj *obj = Jsi_ObjNewObj(interp, _jsi_STACK+(interp->Sp-itemcount*2), itemcount*2);
                jsiPop(interp, itemcount * 2 - 1);       /* one left */
                ClearStack(interp,1);
                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);
                break;
            }
            case OP_ARRAY: {
                int itemcount = (int)ip->data;
                Assert(itemcount>=0);
                VarDeref(interp, itemcount);
                Jsi_Obj *obj = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->Sp-itemcount), itemcount, 1);
                jsiPop(interp, itemcount - 1);
                ClearStack(interp,1);
                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);
                break;
            }
            case OP_STRY: {
                TryInfo *ti = (TryInfo *)ip->data;
                TryList *n = trylist_new(TL_TRY, scope, currentScope);
                
                n->d.td.tstart = ip;                            /* make every thing pointed to right pos */
                n->d.td.tend = n->d.td.tstart + ti->trylen;
                n->d.td.cstart = n->d.td.tend + 1;
                n->d.td.cend = n->d.td.tend + ti->catchlen;
                n->d.td.fstart = n->d.td.cend + 1;
                n->d.td.fend = n->d.td.cend + ti->finallen;
                n->d.td.tsp = interp->Sp;

                push_try(trylist, n);
                break;
            }
            case OP_ETRY: {             /* means nothing happen go to final */
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected ETRY opcode??");

                ip = trylist->d.td.fstart - 1;
                break;
            }
            case OP_SCATCH: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected SCATCH opcode??");

                if (!ip->data) {
                    do_throw();
                } else {
                    /* new scope and make var */
                    scope = jsi_ScopeChainDupNext(interp, scope, currentScope);
                    currentScope = jsi_ObjValueNew(interp);
                    interp->ingsc = scope;
                    interp->incsc = currentScope;
                    Jsi_IncrRefCount(interp, currentScope);
                    Jsi_Value *excpt = Jsi_ValueNew1(interp);
                    if (ps->last_exception && ps->last_exception->vt != JSI_VT_UNDEF) {
                        Jsi_Value *ple = ps->last_exception;
                        Jsi_ValueCopy(interp, excpt, ple);
                        Jsi_ValueReset(interp, &ps->last_exception);
                    } else if (interp->errMsgBuf[0]) {
                        Jsi_ValueMakeStringDup(interp, &excpt, interp->errMsgBuf);
                        interp->errMsgBuf[0] = 0;
                    }
                    Jsi_ValueInsert(interp, currentScope, (char*)ip->data, excpt, JSI_OM_DONTENUM);
                    Jsi_DecrRefCount(interp, excpt);
                    context_id = ps->_context_id++;
                }
                break;
            }
            case OP_ECATCH: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected ECATCH opcode??");

                ip = trylist->d.td.fstart - 1;
                break;
            }
            case OP_SFINAL: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected SFINAL opcode??");

                /* restore scatch scope chain */
                restore_scope();
                break;
            }
            case OP_EFINAL: {
                if (trylist == NULL || trylist->type != TL_TRY)
                    Jsi_LogBug("Unexpected EFINAL opcode??");

                int last_op = trylist->d.td.last_op;
                OpCode *tojmp = (last_op == LOP_JMP ? trylist->d.td.ld.tojmp : 0);
                
                pop_try(trylist);

                if (last_op == LOP_THROW) {
                    do_throw();
                } else if (last_op == LOP_JMP) {
                    while (1) {
                        if (trylist == NULL) {
                            ip = tojmp;
                            break;
                        }
                        /* same as jmp opcode, see above */
                        if (trylist->type == TL_TRY) {
                            if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) {
                                ip = tojmp;
                                break;
                            }
                            
                            if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {
                                trylist->d.td.last_op = LOP_JMP;
                                trylist->d.td.ld.tojmp = tojmp;
                                
                                ip = trylist->d.td.fstart - 1;
                                break;
                            } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {
                                pop_try(trylist);
                            } else Jsi_LogBug("jmp within a try, but not in its scope?");
                        } else {        /* 'with' block */
                            if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) {
                                ip = tojmp;
                                break;
                            }
                            restore_scope();
                            pop_try(trylist);
                        }
                    }
                }
                break;
            }
            case OP_THROW: {
                VarDeref(interp,1);
                Jsi_ValueDup2(interp,&ps->last_exception, _jsi_TOP);
                interp->didReturn = 1; /* TODO: could possibly hide _jsi_STACK problem */
                do_throw();
                break;
            }
            case OP_WITH: {
                VarDeref(interp,1);
                Jsi_ValueToObject(interp, _jsi_TOP);
                
                TryList *n = trylist_new(TL_WITH, scope, currentScope);
                
                n->d.wd.wstart = ip;
                n->d.wd.wend = n->d.wd.wstart + (int)ip->data;

                push_try(trylist, n);
                interp->withDepth++;
                
                /* make expr to top of scope chain */
                scope = jsi_ScopeChainDupNext(interp, scope, currentScope);
                currentScope = Jsi_ValueNew1(interp);
                interp->ingsc = scope;
                interp->incsc = currentScope;
                Jsi_ValueCopy(interp, currentScope, _jsi_TOP);
                jsiPop(interp,1);
                
                context_id = ps->_context_id++;
                break;
            }
            case OP_EWITH: {
                if (trylist == NULL || trylist->type != TL_WITH)
                    Jsi_LogBug("Unexpected EWITH opcode??");

                restore_scope();
                
                pop_try(trylist);
                interp->withDepth--;
                break;
            }
            case OP_DEBUG: {
                VarDeref(interp,1);
                if (_jsi_TOP->vt == JSI_VT_OBJECT) {
                    fprintf(stderr, "R%d:", _jsi_TOP->refCnt);
                }
                fprintf(stderr, "%s\n", Jsi_ValueToString(interp, _jsi_TOP, NULL));
                break;
            }
            case OP_RESERVED: {
                ReservedInfo *ri = (ReservedInfo *)ip->data;
                const char *cmd = ri->type == RES_CONTINUE ? "continue" : "break";
                /* TODO: continue/break out of labeled scope not working. */
                if (ri->label) {
                    Jsi_LogError("%s: label(%s) not found\n", cmd, ri->label);
                } else {
                    Jsi_LogError("%s must be inside loop(or switch)\n", cmd);
                }
                break;
            }
        }
        ip++;
    }
done:
    while (trylist) {
        pop_try(trylist);
    }
    return rc;
}


int jsi_evalcode(jsi_Pstate *ps, OpCodes *opcodes, 
         jsi_ScopeChain *scope, Jsi_Value *currentScope,    /* scope chain */
         Jsi_Value *_this,
         Jsi_Value **vret)
{
    Jsi_Interp *interp = ps->interp;
    int rc, oldTry = interp->tryDepth;
    jsi_ScopeChain *oldscope = interp->ingsc;
    Jsi_Value *oldcurrentScope = interp->incsc;
    Jsi_Value *oldthis = interp->inthis;
    int oldSp = interp->Sp;
    if (interp->exited)
        return JSI_ERROR;
    interp->ingsc = scope;
    interp->incsc = currentScope;
    interp->inthis = _this;
    interp->level++;
    interp->refCount++;
    Jsi_IncrRefCount(interp, currentScope);
    rc = _jsi_evalcode(ps, opcodes, scope, currentScope, _this, *vret);
    Jsi_DecrRefCount(interp, currentScope);
    if (interp->didReturn == 0 && !interp->exited) {
        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)
            Jsi_ValueMakeUndef(interp, vret);
        /*if (interp->Sp != oldSp) //TODO: at some point after memory refs???
            Jsi_LogBug("Stack not balance after execute script\n");*/
    }
    interp->didReturn = 0;
    interp->Sp = oldSp;
    interp->refCount--;
    interp->level--;
    interp->ingsc = oldscope;
    interp->incsc = oldcurrentScope;
    interp->inthis = oldthis;
    interp->tryDepth = oldTry;
    if (interp->exited)
        rc = JSI_ERROR;
    return rc;
}



static jsi_Pstate* NewParser(Jsi_Interp* interp, char *codeStr, Jsi_Channel fp, int iseval)
{
    int isNew, cache = 1; //(interp->nocacheOpCodes==0);
    Jsi_HashEntry *hPtr = NULL;
    hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)codeStr, &isNew);
    if (!hPtr) return NULL;
    jsi_Pstate *ps;

    if (cache && isNew==0 && ((ps = (jsi_Pstate *)Jsi_HashValueGet(hPtr)))) {
        interp->codeCacheHit++;
        return ps;
    }
    ps = jsi_PstateNew(interp);
    ps->eval_flag = iseval;
    if (codeStr)
        jsi_PstateSetString(ps, codeStr);
    else
        jsi_PstateSetFile(ps, fp, 1);
        
    interp->inParse++;
    yyparse(ps);
    interp->inParse--;
    
    if (ps->err_count) {
        if (cache) Jsi_HashEntryDelete(hPtr);
        jsi_PstateFree(ps);
        return NULL;
    }
    if (isNew) {
        if (cache) {
            Jsi_HashValueSet(hPtr, ps);
            ps->hPtr = hPtr;
        } else {
            /* only using caching now. */
            assert(0);
        }
    }
    return ps;
}

/* eval here is diff from Jsi_CmdProc, current scope Jsi_LogWarn should be past to eval */
/* make evaling script execute in the same context */
int jsi_global_eval(Jsi_Interp* interp, jsi_Pstate *ps, char *program,
                       jsi_ScopeChain *scope, Jsi_Value *currentScope, Jsi_Value *_this, Jsi_Value **ret)
{
    int r = JSI_OK;
    jsi_Pstate *newps = NewParser(interp, program, NULL, 1);
    if (newps) {
        int oef = newps->eval_flag;
        newps->eval_flag = 1;
        interp->ps = newps;
        r = jsi_evalcode(newps, newps->opcodes, scope, currentScope, _this, ret);
        if (r) {
            Jsi_ValueDup2(interp, &ps->last_exception, newps->last_exception);
        }
        newps->eval_flag = oef;
        interp->ps = ps;
    } else  {
        Jsi_ValueMakeString(interp, &ps->last_exception, Jsi_Strdup("Syntax Error"));
        r = JSI_ERROR;
    }
    return r;
}

static int jsi_eval(Jsi_Interp* interp, char *str, Jsi_Channel fp, int flags)
{
    int rc = JSI_OK, oldef = interp->evalFlags;
    jsi_Pstate *oldps = interp->ps, *ps = NewParser(interp, str, fp, 0);
    interp->evalFlags = flags;
    if (!ps)
        return JSI_ERROR;
    Jsi_ValueMakeUndef(interp, &interp->retPtr);
    interp->ps = ps;
    Jsi_Value *retPtr = interp->retPtr;
    if (jsi_evalcode(ps, ps->opcodes, interp->gsc, interp->csc, interp->csc, &retPtr)) {
        rc = JSI_ERROR;
    } else {
        //TODO: dup even if null?
        Jsi_ValueDup2(interp, &oldps->last_exception, ps->last_exception);
    }
    interp->ps = oldps;
    interp->evalFlags = oldef;
    return rc;
}

static int jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, char *str, int flags)
{
    Jsi_Channel input = Jsi_GetStdChannel(interp, 0);
    Jsi_Value *npath = path;
    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)
        return JSI_OK;
    int rc, oldSp;
    const char *oldFile = interp->curFile;
    char *origFile = Jsi_ValueString(interp, path, NULL);
    const char *fname = origFile;
    char *oldDir = interp->curDir;
    char dirBuf[1024];

    oldSp = interp->Sp;
    dirBuf[0] = 0;
    Jsi_DString dStr = {};
    Jsi_DSInit(&dStr);
    if (str == NULL) {
        if (fname != NULL) {
            char *cp;
            if (!Jsi_Strcmp(fname,"-"))
                input = Jsi_GetStdChannel(interp, 0);
            else {
    
                /* Use translated FileName. */
                if (interp->curDir && fname[0] != '/' && fname[0] != '~') {
                    char dirBuf2[1024], *np;
                    snprintf(dirBuf, sizeof(dirBuf), "%s/%s", interp->curDir, fname);
                    if ((np=Jsi_FileRealpathStr(interp, dirBuf, dirBuf2)) == NULL) {
                        Jsi_LogError("Can not open '%s'\n", fname);
                        rc = -1;
                        goto bail;
                    }
                    npath = Jsi_ValueNewStringDup(interp, np);
                    Jsi_IncrRefCount(interp, npath);
                    fname = Jsi_ValueString(interp, npath, NULL);
                    if (flags&JSI_EVAL_ARGV0) {
                        interp->argv0 = Jsi_ValueNewStringDup(interp, np);
                        Jsi_IncrRefCount(interp, interp->argv0);
                    }
                } else {
                    if (flags&JSI_EVAL_ARGV0) {
                        interp->argv0 = Jsi_ValueNewStringDup(interp, fname);
                        Jsi_IncrRefCount(interp, interp->argv0);
                    }
                }
                
                input = Jsi_Open(interp, npath, "r");
                if (!input) {
                    Jsi_LogError("Can not open '%s'\n", fname);
                    rc = -1;
                    goto bail;
                }
            }
            int isNew;
            Jsi_HashEntry *hPtr;
            jsi_FileInfo *fi = NULL;
            hPtr = Jsi_HashEntryNew(interp->fileTbl, fname, &isNew);
            if (isNew == 0 && hPtr) {
                fi = (jsi_FileInfo *)Jsi_HashValueGet(hPtr);
                interp->curFile = fi->fileName;
                interp->curDir = fi->dirName;
                
            } else {
                fi = (jsi_FileInfo *)Jsi_Calloc(1,sizeof(*fi));
                Jsi_HashValueSet(hPtr, fi);
                fi->origFile = (char*)Jsi_KeyAdd(interp, origFile);
                interp->curFile = fi->fileName = (char*)Jsi_KeyAdd(interp, fname);
                char *dfname = Jsi_Strdup(fname);
                if ((cp = strrchr(dfname,'/')))
                    *cp = 0;
                interp->curDir = fi->dirName = (char*)Jsi_KeyAdd(interp, dfname);
                Jsi_Free(dfname);
            }
            if (!input->fname)
                input->fname = interp->curFile;
            if (1 /*|| input->isNative==0 || interp->nocacheOpCodes==0*/) {
                /* We use in-memory parse always now. */
                int cnt = 0;
                char buf[BUFSIZ];
                while (cnt<MAX_LOOP_COUNT) {
                    if (!Jsi_Gets(input, buf, sizeof(buf)))
                        break;
                    if (++cnt==1 && (!(flags&JSI_EVAL_NOSKIPBANG)) && (buf[0] == '#' && buf[1] == '!')) {
                        Jsi_DSAppend(&dStr, "\n", NULL);
                        continue;
                    }
                    Jsi_DSAppend(&dStr, buf,  NULL);
                }
                if (cnt>=MAX_LOOP_COUNT)
                    Jsi_LogError("source file too large");
                Jsi_Close(input);
                str = Jsi_DSValue(&dStr);
            }
        }
        if (interp->curDir && (flags&JSI_EVAL_INDEX))
            Jsi_AddIndexFiles(interp, interp->curDir);
    }

    /* TODO: cleanup interp->Sp stuff. */
    oldSp = interp->Sp;

    rc = jsi_eval(interp, str, input, flags);
    
bail:
    interp->curFile = oldFile;
    interp->curDir = oldDir;
    interp->Sp = oldSp;
    if (path != npath)
        Jsi_DecrRefCount(interp, npath);
    Jsi_DSFree(&dStr);
    Jsi_MutexUnlock(interp, interp->Mutex);
    if (interp->exited && interp->level <= 0)
    {
        rc = interp->exitCode;
        Jsi_InterpDelete(interp);
    }

    return rc;
}

int Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags)
{
    return jsi_evalStrFile(interp, fname, NULL, flags);
}

int Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags)
{
    return jsi_evalStrFile(interp, NULL, (char*)str, flags);
}

#undef _jsi_THIS
#undef _jsi_STACK
#undef _jsi_STACKIDX
#undef _jsi_THISIDX
#undef _jsi_TOP
#undef _jsi_TOQ

#endif
